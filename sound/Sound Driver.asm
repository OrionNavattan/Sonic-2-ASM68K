; ===========================================================================
; Sonic the Hedgehog 2 Z80 sound driver
; Z80 port of Sonic 1's variant of SMPS 68k Type 1

; Disassembled by Xenowhirl for AS 2007
; Additional disassembly work by RAS Oct 2008
; RAS' work merged into SVN by Flamewing
; Ported to AXM68K by OrionNavattan October 2022
; Labels and styling overhauled by OrionNavattan May 2023

; This code is compressed in the ROM, but you can edit it here as uncompressed
; and it will automatically be assembled and compressed into the correct place
; during the build process. It can use labels and equates defined in the 68k code,
; and the 68k code can likewise use the labels and equates defined in here.
; This is essential, as they contain references to each other's addresses.
;
; if you want to add significant amounts of extra code to this driver,
; try putting your code as far down as possible, after the function zSaxDec_End.
; That will make you less likely to run into space shortages from dislocated data alignment.

; Note that the Z80 syntax used here is slightly non-standard as of result of how AXM68k works:
; * is used to invoke the current program counter rather than $ in jump instructions,
; offset(*) must be used to invoke the program counter in macro parameters due to the use 
; of ASM68K's section and group functionality, and shadow registers are not indicated 
; with an apostrophe; e.g., ex af,af' is simply written as ex af,af.


; ---------------------------------------------------------------------------
; Perform a bank switch; after using this, the start of z_rom_window points 
; to the start of the given 68k address, rounded down to the nearest $8000 
; byte boundary.

; The version of this macro in the AS disassembly generates ld (hl),a or ld (hl),e
; instructions based on the address given as input to the macro. However,
; said macro cannot be directly ported to ASM68K, as it relies on a behavior of AS' 
; comparison operators that is completely different in ASM68K (specifically, true returns 1, 
; false 0; ASM68K returns -1 and 0 for these), nor can we use conditional expressions to 
; generate them, as conditional expressions in ASM68K must evaluate on the first pass.

; Basically, we can't generate them in situ. Instead, the instructions are generated
; and equated to constants by the startbank and bnkswtch_vals macros, and
; this macro simply inserts said constants on the second pass.
; ---------------------------------------------------------------------------

bankswitch:	macro addr68k
		
		cnt: = 0
		ptr_num: = 1

	if OptimizeSoundDriver
		; Because why use a and e when you can use h and l?
		ld	hl,z_bank_select_mirror			; 6001h, mirror of bankswitch register
		rept 9					
		db	bnkswtch_\addr68k\_\$ptr_num\		; include the constants generated by startbank and bnkswtch_vals
		cnt: = cnt+1
		ptr_num: = ptr_num+1
		endr
	else
		xor	a					; a = 0
		ld	e,1					; e = 1
		ld	hl,z_bank_select
		rept 9					
		db	bnkswtch_\addr68k\_\$ptr_num\		; include the constants generated by startbank and bnkswtch_vals
		cnt: = cnt+1
		ptr_num: = ptr_num+1
		endr
	endc	
	endm
	
; ---------------------------------------------------------------------------		
; Ensure that rst functions are correctly aligned to the rst vectors
; ---------------------------------------------------------------------------

rsttarget: macro * 
\* equ *
		if (offset(*)&7)|(offset(*)>38h)   
			inform 3, "Function \* is at %hh, but it must be at a multiple of 8 bytes at or lower than 38h to be used with the rst instruction.",offset(*)
		endc
		endm
		
; ---------------------------------------------------------------------------
; Make sure that arrays used with an 8-bit index don't cross a 100h byte
; boundary, and pad them automatically if they do
; ---------------------------------------------------------------------------

ensure1byteoffset: macro maxsize
		if ((offset(*)&0FFh)>(100h-\maxsize))
startpad: = offset(*)
			align 100h
endpad:	= offset(*)
			if endpad-startpad>=1h
				inform 1,"The array at %hh is not at a address safe for use with an 8-bit index. %hh bytes of padding have been inserted to rectify this, but it is recommended to rearrange your code to eliminate this issue.",startpad,endpad-startpad
			endc
		endc
		endm
; ===========================================================================

; Z80 'ROM' start:
 zEntryPoint:
		if offset(*)<>0
			inform 3,"zEntryPoint is at %hh, but it must be 0. Make sure you haven't accidentally defined code in the macros.",offset(zEntryPoint) 
		endc
   
		di						; disable interrupts
		ld	sp,z_stack_pointer			; set initial stack pointer
		jp	InitDriver				; continue to driver init
; ===========================================================================

f_pal:
		db	0					; set by SoundDriverLoad to signal that we are on a PAL console

; ---------------------------------------------------------------------------
; Subroutine to wait for YM2612/3438 to not be busy.
; This is redundant: the Z80 is slow enough to not need to worry about this.
; ---------------------------------------------------------------------------

    if OptimizeSoundDriver=0
		align	8
WaitForYM:    rsttarget
		ld	a,(ym_reg_a0)	
		add	a,a
		jr	c,WaitForYM
		ret
    endc

; ---------------------------------------------------------------------------
; Subroutines to write to the YM2612/3438

; input:
;	a = destination register ID
;	c = data to write
; ---------------------------------------------------------------------------

		align	8
WriteFMIorII:    rsttarget
		bit t_fmii_bit,(ix+ch_type)			; is this track playing on channels 0-2?
		jr	z,WriteFMI				; if so, it's bound for a0/d0
		jr	WriteFMII				; otherwise, it's bound for a1/d1
; ===========================================================================

		align	8
WriteFMI:    rsttarget
    if OptimizeSoundDriver=0
    	; Unnecessary.
		push	af
		rst	WaitForYM	
		pop	af
    endc
		ld	(ym_reg_a0),a				; set destination register
		push	af
    if OptimizeSoundDriver=0
        ; Unnecessary.
		rst	WaitForYM
    endc
		ld	a,c					; a = data
		ld	(ym_reg_d0),a				; write data to register
		pop	af
		ret
; ===========================================================================

		align	8
WriteFMII:    rsttarget
    if OptimizeSoundDriver=0
    	; Unnecessary.
		push	af
		rst	WaitForYM
		pop	af
    endc
		ld	(ym_reg_a1),a				; set destination register
		push	af
    if OptimizeSoundDriver=0
       	; Unnecessary. 
		rst	WaitForYM
    endc
		ld	a,c					; a = data
		ld	(ym_reg_d1),a				; write data to register
		pop	af
		ret

; ---------------------------------------------------------------------------
; Subroutine to update all sound. Triggered on every VBlank.
; ---------------------------------------------------------------------------

		align 38h
UpdateSound:    rsttarget
		push	af					; save 'af'
		exx						; swap 'bc', 'de', and 'hl' with their shadows
		call	BankSwitchToMusic			; bank switch to the music
		xor	a					; clear 'a'
		ld	(f_sfx),a				; clear updating SFX flag (updating music)
		ld	ix,z_abs_vars				; ix = start of the global variables
		ld	a,(z_abs_vars+f_pause_sound)		; get pause/unpause flag
		or	a					; is music paused?
		jr	z,.driverinput				; if not, update all tracks
		call	PauseMusic				; if music is paused, run the pause handler,
		jp	UpdateDAC				; then update the DAC
; ===========================================================================

.driverinput:
		ld	a,(z_abs_vars+v_fadeout_counter)	; are we fading out?
		or	a
		call	nz,DoFadeOut				; if so, update that

	;.skipfadeout:
		ld	a,(z_abs_vars+f_fadein)			; are we fading in?
		or	a
		call	nz,DoFadeIn				; if so, update that

	;.skipfadein:
		ld	a,(z_abs_vars+z_queue_0)
		or	a,(ix+z_queue_1)
		or	a,(ix+z_queue_2)			; (this was missing in Sonic 1's driver, breaking the third queue slot)
		call	nz,CycleSoundQueue			; if there is anything in the sound queue, cycle queue

	;.nosndinput:
		ld	a,(z_abs_vars+v_sound_id)
		cp	com_Null				; is song queue set for silence (empty)?
		call	nz,PlaySoundID				; if not 80h, call; we need to play something new

	;.update_spindash_cntr:
		ld	a,(v_spindash_counter)			; get spindash counter
		or	a
		jr	z,.pal_timer				; if it's zero, branch
		dec	a					; decrement counter
		ld	(v_spindash_counter),a			; store

	.pal_timer:
		; Perform timing adjustment on PAL systems.
		; (Update 1.2x faster to maintain the same rate as NTSC systems.)
		ld	hl,f_pal				; hl = pointer to PAL flag
		ld	a,(z_abs_vars+f_adjust_pal)		; f_adjust_pal indicates current song needs PAL adjustment
		and	a,(hl)					; and them together
		jr	z,.not_pal				; if zero, branch
		ld	hl,v_pal_update_counter			; get update counter
		dec	(hl)					; decrement
		jr	nz,.not_pal				; branch if time remains
		ld	(hl),6-1				; reset PAL update coutner
		call	UpdateMusic				; every 6 frames, run UpdateMusic twice to keep pace with NTSC consoles

	.not_pal:
		call	UpdateMusic  

	;.update_SFX:		
		bankswitch SoundIndex				; bank switch to sound effects

		ld	a,80h
		ld	(f_sfx),a				; set f_sfx flag to busy

    if FixBugs
		; Moving the TempoWait call in UpdateMusic prevents it from returning ix set to a 
		; convenient value, so we need to set it explicitly here.
		ld	ix,z_tracks_sfx_start-sizeof_trackvars
    endc

		ld	b,countof_sfx_fm_tracks			; Only 3 FM channels for SFX (FM3, FM4, FM5)
		
	.sfxfmloop:
		push	bc
		ld	de,sizeof_trackvars			; spacing between tracks
		add	ix,de					; advance to next track
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		call	nz,FMUpdateTrack			; if it is, update it
		pop	bc
		djnz	.sfxfmloop				; repeat until all have been updated

		; PSG SFX channels
		ld	b,countof_sfx_psg_tracks		; all PSG channels available

	.sfxpsgloop:
		push	bc
		ld	de,sizeof_trackvars			; spacing between tracks
		add	ix,de					; advance to next track
		bit	chf_enable_bit,(ix+ch_flags)		; is it playing?
		call	nz,PSGUpdateTrack			; if it is, update it
		pop	bc
		djnz	.sfxpsgloop				; repeat until all have been updated

; ---------------------------------------------------------------------------
; Subroutine to update the DAC sample
; ---------------------------------------------------------------------------

UpdateDAC:
		bankswitch DAC_Start				; bankswitch to the DAC data

		ld	a,(v_current_dac)			; get currently playing DAC sound
		or	a
		jp	m,.dacqueued				; if a new one is queued, branch
		exx						; otherwise, restore registers from shadow regs
		ld	b,1					; force the DAc to update immediately
		pop	af
		ei						; enable interrupts
		ret						; return to DAC loop
; ===========================================================================

	.dacqueued:
		ld	a,80h
		ex	af,af					; swap af with their shadows
		ld	a,(v_current_dac)			; get current DAC sound
		sub	a,_firstSample				; subtract 81h 
		ld	(v_current_dac),a			; store difference as current DAC sound
		; The following two instructions are dangerous: they discard the upper
		; two bits of v_current_dac, meaning you can only have 40h DAC samples.
		add	a,a
		add	a,a					; a *= 4 (each DAC entry is a pointer and length, 2+2)
		add	a,DACPtrTbl&0FFh			; get low byte into table -> 'a'
		ld	(DACStartAddress+1),a			; store into the instruction after DACStartAddress (self-modifying code)
		add	a,2					; offset to length versus pointer
		ld	(DACStoreLength+2),a			; store into the instruction after DACStoreLength (self-modifying code)
		pop	af
		ld	hl,WriteToDAC
		ex	(sp),hl					; make the ret at end of this function jump to WriteToDAC

	DACStartAddress:
		ld	hl,(DACPtrTbl)				; self-modified code: sets start address of DAC sample for WriteToDAC

	DACStoreLength:
		ld	de,(DACPtrTbl+2)			; self-modified code: sets length of DAC sample for WriteToDAC

	DACStoreDelay:
		ld	bc,100h					; self-modified code: from .DAC_data_store; sets b=1 (the 100h part of it) UPDATE RIGHT AWAY and c="data rate delay" for this DAC sample, the future 'b' setting
		ei						; enable interrupts
		ret						

; ---------------------------------------------------------------------------
; Subroutine to update music tracks
; ---------------------------------------------------------------------------

UpdateMusic:
    if FixBugs=0
		; Calling this function here is bad, because it can cause the
		; first note of a newly-started song to be delayed for a frame.
		; The vanilla driver resorts to a workaround to prevent such a
		; delay from having side-effects (namely, by setting every track
		; at rest) but it's better to just fix the problem directly, 
		; and move this call to the proper place.
		call	TempoWait
    endc

		ld	a,0FFh
		ld	(z_abs_vars+f_updating_dac),a		; set dac update flag
		ld	ix,z_tracks_start			; ix = start of track RAM
		bit	chf_enable_bit,(ix+ch_flags)		; is the DAC channel playing?
		call	nz,DACUpdateTrack			; if so, update it
		
	;.dacdone:	
		xor	a					; clear a
		ld	(z_abs_vars+f_updating_dac),a		; clear f_updating_dac
 		ld	b,countof_music_fm_tracks		; loop 6 times for FM tracks
 		
	.fmloop:
		push	bc
		ld	de,sizeof_trackvars			; space between tracks
		add	ix,de					; go to next track
		bit	chf_enable_bit,(ix+ch_flags)		; is this track playing?
		call	nz,FMUpdateTrack			; if so, update it
		pop	bc
		djnz	.fmloop					; loop until all FM tracks have been updated

		ld	b,countof_music_psg_tracks		; loop 3 times for PSG tracks
		
	.psgloop:
		push	bc
		ld	de,sizeof_trackvars			; space between tracks
		add	ix,de					; go to next track
		bit	chf_enable_bit,(ix+ch_flags)		; is this track playing?
		call	nz,PSGUpdateTrack			; if so, update it
		pop	bc
		djnz	.psgloop				; loop until all PSG tracks have been updated

    if FixBugs=0
		; See above. Removing this instruction will cause this
		; subroutine to fall through to TempoWait.
		ret
    endc

; ---------------------------------------------------------------------------
; Subroutine to set tempo update timer
; ---------------------------------------------------------------------------

TempoWait:
		ld	ix,z_abs_vars				; ix = start of global variables
		ld	a,(ix+v_current_tempo)			; get current tempo value
		add	a,(ix+v_tempo_counter)			; add the previous value
		ld	(ix+v_tempo_counter),a			; store it
		ret	c					; if the previous add overflowed, exit

		; if adding tempo value did NOT overflow, then add 1 to all durations.
		ld	hl,z_tracks_start+ch_delay		; hl = first track's note timeout
		ld	de,sizeof_trackvars			; offset between tracks
		ld	b,countof_music_tracks			; 1 DAC + 6 FM + 3 PSG tracks

	.tempoloop:
		inc	(hl)					; delay note by 1 frame
		add	hl,de					; advance to next track
		djnz	.tempoloop
		
		ret
; ===========================================================================

InitDriver:
		im	1					; set interrupt mode 1
		call	ClearTrackMemory			; clear the track RAM
		ei						; enable interrupts
		ld	iy,DACDecodeTbl				; load the DAC decode table
		ld	de,0					; de = 0, no sample to play
		; continue into DACWaitLoop

DACWaitLoop:
		ld	a,d
		or	a,e
		jr	z,DACWaitLoop				; as long as 'de' (length of sample) = 0, wait...

WriteToDAC:
		djnz	*					; busy wait for specific amount of time in 'b'

		di						; disable interrupts (while updating DAC)
		ld	a,ym_dac_output				; DAC port
		ld	(ym_reg_a0),a				; set DAC port register
		ld	a,(hl)					; get next DAC byte
		rept 4
		rlca						; shift upper nybble to lower nybble
		endr
		and	a,0Fh					; a = 4-bit offset into DACDecodeTbl
		ld	(.highnybble+2),a			; store into the instruction after .highnybble (self-modifying code)
		ex	af,af					; shadow register 'a' is the 'd' value for 'jman2050' encoding

	.highnybble:
		add	a,(iy)					; get byte from DACDecodeTbl (self-modified to proper displacement)
		ld	(ym_reg_d0),a				; write this byte to the DAC
		ex	af,af					; back to regular registers
		ld	b,c					; reload 'b' with wait value
		ei						; enable interrupts (done updating DAC, busy waiting for next update)
	
		djnz	*					; busy wait for specific amount of time in 'b'

		di						; disable interrupts (while updating DAC)
		push	af
		pop	af
		ld	a,ym_dac_output				
		ld	(ym_reg_a0),a				; set DAC port register
		ld	b,c					; reload 'b' with wait value
		ld	a,(hl)					; get next DAC byte
		inc	hl					; next byte in DAC stream...
		dec	de					; one less byte
		and	a,0Fh					; lower 4-bit offset into DACDecodeTbl
		ld	(.lownybble+2),a			; store into the instruction after .lownybble (self-modifying code)
		ex	af,af					; shadow register 'a' is the 'd' value for 'jman2050' encoding

	.lownybble:
		add	a,(iy)					; get byte from DACDecodeTbl (self-modified to proper displacement)
		ld	(ym_reg_d0),a				; write this byte to the DAC
		ex	af,af					; back to regular registers
		ei						; enable interrupts (done updating DAC, busy waiting for next update)
		jp	DACWaitLoop				; back to the wait loop; if there's more DAC to write, we come back down again!
; ===========================================================================

DACDecodeTbl:
		db	   0,    1,   2,   4,   8,  10h,  20h,  40h
		db	 80h,   -1,  -2,  -4,  -8, -10h, -20h, -40h

; ---------------------------------------------------------------------------
; RAM addresses for FM and PSG channel variables used by the SFX

; Used when an SFX ends so it can restore the music track it took over.
; The zeroes appear after FM 3 because it calculates the offsets into
; these tables by their channel assignment, where between Channel 3
; and Channel 4 there is a gap numerically
; ---------------------------------------------------------------------------.

		ensure1byteoffset 10h
SFX_BGMChannelRAM:
		dw	z_song_fm3
		dw	0
		dw	z_song_fm4  
		dw	z_song_fm5
		dw	z_song_psg1
		dw	z_song_psg2
		dw	z_song_psg3				; PSG3 square wave
		dw	z_song_psg3				; PSG3 noise

		ensure1byteoffset 10h
SFX_SFXChannelRAM:
		dw	z_sfx_fm3
		dw	0
		dw	z_sfx_fm4
		dw	z_sfx_fm5
		dw	z_sfx_psg1
		dw	z_sfx_psg2
		dw	z_sfx_psg3				; PSG3 square wave
		dw	z_sfx_psg3				; PSG3 noise

; ---------------------------------------------------------------------------
; Subroutine to update the DAC track
; ---------------------------------------------------------------------------

DACUpdateTrack:
		dec	(ix+ch_delay)				; has DAC sample timeout expired?
		ret	nz					; return if not
		ld	l,(ix+ch_dataptr_low)			; low byte of DAC track current address
		ld	h,(ix+ch_dataptr_high)			; high byte of DAC track current address

	.sampleloop:
		ld	a,(hl)					; get next byte
		inc	hl
		cp	_firstCom				; is it a coordination flag?
		jr	c,.notcoord				; if not, branch
		call	SongCommand				; handle coordination flag
		jp	.sampleloop				; loop back around for another byte
; ===========================================================================

	.notcoord:
		or	a					; is it a duration?
		jp	p,.gotduration				; if so, branch
		ld	(ix+ch_sample),a			; else, this is a note
		ld	a,(hl)					; get next byte
		or	a					; is it a note duration?
		jp	p,.nextbyte				; if so, branch
		ld	a,(ix+ch_saved_delay)			
		ld	(ix+ch_delay),a				; use last duration
		jr	.gotsampleduration			; jump to after duration subroutine...
; ===========================================================================

	.nextbyte:
		inc	hl					; Goes to next byte (after duration byte)

	.gotduration:
		call	SetDuration

	.gotsampleduration:
		ld	(ix+ch_dataptr_low),l			; save pointer
		ld	(ix+ch_dataptr_high),h
		bit chf_mask_bit,(ix+ch_flags)			; is track being overridden?
		ret	nz					; if so, return
		ld	a,(ix+ch_sample)			; get sample
		cp	nRst					; is it a rest?
		ret	z					; if so, return
		sub	a,_firstSample				
		add	a,a					; convert to index 
		add	a,DACMasterPlaylist&0FFh
		ld	(.DAC_data_store+2),a			; store into the following instruction (self-modifying code)

	.DAC_data_store:
		ld	bc,(DACMasterPlaylist)			; load sample info; b = DAC sample number, c = data rate delay
		ld	a,c	
		ld	(v_current_dac),a			; store current DAC sound to play
		ld	a,b
		ld	(DACStoreDelay+1),a			; store delay into the instruction after DACStoreDelay (self-modifying code)
		ret
		
; ---------------------------------------------------------------------------
; Subroutine to update FM tracks
; ---------------------------------------------------------------------------

FMUpdateTrack:
		dec	(ix+ch_delay)				; decrement duration timeout
		jr	nz,.notegoing				; branch if time remains
		res	chf_tie_bit,(ix+ch_flags)		; clear "do not attack next note" bit
		call	FMDoNext				; handle coordination flags, get next note and duration
		call	FMPrepareNote				; prepare to play next note
		call	FMNoteOn				; key it on (if allowed)
		call	DoModulation				; update modulation (if modulation doesn't change, we do not return here)
		jp	FMUpdateFreq				; apply frequency update from modulation
; ===========================================================================

	.notegoing:
		call	NoteTimeoutUpdate			; apply "note fill" (time until cut-off); Will not return here if "note fill" expires
		call	DoModulation				; Update modulation (if modulation doesn't change, we do not return here)
		jp	FMUpdateFreq				; apply frequency update from modulation
; ===========================================================================

FMDoNext:
		ld	l,(ix+ch_dataptr_low)			; get track data pointer
		ld	h,(ix+ch_dataptr_high)
		res	chf_rest_bit,(ix+ch_flags)		; clear "track at rest" bit

	.noteloop:
		ld	a,(hl)					; get next byte
		inc	hl					
		cp	_firstCom				; is it a coordination flag?
		jr	c,.gotnote				; if not, branch
		call	SongCommand				; handle coordination flag
		jr	.noteloop				; loop back around for another byte

	.gotnote:
		push	af
		call	FMNoteOff				; send key off
		pop	af
		or	a					; is it a duration?
		jp	p,.gotduration				; if so, branch
		call	FMSetFreq				; otherwise, this is a note; get its frequency
		ld	a,(hl)					; get next byte
		or	a					; is it a note?
		jp	m,FinishTrackUpdate			; if so, branch; track update is finished
		inc	hl					; otherwise, it's a duration; advance data pointer to next byte

	.gotduration:
		call	SetDuration				; set the duration
		jp	FinishTrackUpdate			; track update is finished

; ---------------------------------------------------------------------------
; Subroutine to get the FM frequency for a given note

; input:
;	a = note to get frequency for
; ---------------------------------------------------------------------------

FMSetFreq:
		sub	a,nRst					; is it a rest?
		jr	z,.restfm				; if so, branch
		add	a,(ix+ch_transpose)			; add track transposition
		add	a,a					; index into frequency table
    if OptimizeSoundDriver
    	; Save space by only including one octave in the frequency table,
    	; and calculating all other octaves.
		ld	d,12*2					; 12 notes per octave
		ld	c,0					; clear c (will hold octave bits)

	.loop:
		sub	a,d					; subtract 1 octave from the note
		jr	c,.gotoctave				; if this is less than zero, we are done
		inc	c					; one octave up
		jr	.loop
; ===========================================================================

	.gotoctave:
		add	a,d					; add 1 octave back (so note index is positive)
		sla	c
		sla	c
		sla	c					; multiply octave value by 8, to get final octave bits
    endc
		add	a,FMFrequencies&0FFh
		ld	(.storefreq+2),a			; store into the instruction after .storefreq (self-modifying code)
;		ld	d,a
;		adc	a,(FMFrequencies&0FF00h)>>8
;		sub	a,d
;		ld	(.storefreq+3),a		; this is how you could store the high byte of the pointer too (unnecessary if it's in the right range)

	.storefreq:
		ld	de,(FMFrequencies)			; get new frequency
		ld	(ix+ch_freq_low),e			; store frequency low byte
    if OptimizeSoundDriver
		ld	a,d
		or	a,c
		ld	(ix+ch_freq_high),a			; store frequency high byte
    else
		ld	(ix+ch_freq_high),d			; store frequency high byte
    endc
		ret
; ===========================================================================

.restfm:
		set	chf_rest_bit,(ix+ch_flags)		; set rest bit
		xor	a
		ld	(ix+ch_freq_low),a			; clear frequency
		ld	(ix+ch_freq_high),a	
		ret

; ---------------------------------------------------------------------------
; Subroutine to set the duration of a note

; input:
;	a = new duration value
; ---------------------------------------------------------------------------

SetDuration:
		ld	c,a					; c = new duration value
		ld	b,(ix+ch_tick)				; b = tempo divisor
		
	.multloop:
		djnz	.multloop_outer
		ld	(ix+ch_saved_delay),a			; store new duration (reused if a note follows a note without a new duration)
		ld	(ix+ch_delay),a				; set new duration
		ret
; ===========================================================================

.multloop_outer:
		add	a,c					; multiply duration by the tempo divisor
		jp	.multloop

; ---------------------------------------------------------------------------
; Subroutine to finish a track update
; ---------------------------------------------------------------------------

FinishTrackUpdate:
		ld	(ix+ch_dataptr_low),l			; store new track position
		ld	(ix+ch_dataptr_high),h
		ld	a,(ix+ch_saved_delay)			
		ld	(ix+ch_delay),a				; reset note timeout
		bit	chf_tie_bit,(ix+ch_flags)		; is track set to not attack note?
		ret	nz					; if so, exit
		ld	a,(ix+ch_savedgate)			
		ld	(ix+ch_gate),a				; reset note fill timeout
		ld	(ix+ch_flutter),0			; reset PSG flutter byte (even on FM tracks)
		bit	chf_vib_bit,(ix+ch_flags)		; is modulation  on?
		ret	z					; if not, exit
		ld	l,(ix+ch_vibptr_low)			; get address of modulation setting
		ld	h,(ix+ch_vibptr_high)
		jp	SetModulation				; apply modulation
		
; ---------------------------------------------------------------------------
; Subroutine to apply note fill (aka, staccato)
; ---------------------------------------------------------------------------

NoteTimeoutUpdate:
		ld	a,(ix+ch_gate)				; is note fill on?
		or	a
		ret	z					; if not, exit
		dec	(ix+ch_gate)				; decrement note fill timeout
		ret	nz					; if not zero, exit
		set	chf_rest_bit,(ix+ch_flags)		; set rest bit
		pop	de					; do not return to caller
		bit	chf_enable_bit,(ix+ch_type)		; is this a PSG track?
		jp	nz,PSGNoteOff				; if so, branch
		jp	FMNoteOff					

; ---------------------------------------------------------------------------
; Subroutine to apply vibrato
; ---------------------------------------------------------------------------

DoModulation:
		pop	de					; do not return to caller

		bit	chf_rest_bit,(ix+ch_flags)		; is track at rest?
		ret	nz					; if so, quit (does NOT return to UpdateTrack)
		bit	chf_vib_bit,(ix+ch_flags)		; is modulation active?
		ret	z					; if not, quit (does NOT return to UpdateTrack)
		ld	a,(ix+ch_vib_delay)			; has modulation wait expired?
		or	a
		jr	z,.waitdone				; if so, branch
		dec	(ix+ch_vib_delay)			; decrement wait timer
		ret						; return (does NOT return to UpdateTrack)
; ===========================================================================

	.waitdone:
		dec	(ix+ch_vib_speed)			; decrement modulation speed counter
		ret	nz					; return if not zero
		
	;.updatemodulation:	
		ld	l,(ix+ch_vibptr_low)
		ld	h,(ix+ch_vibptr_high)			; hl = modulation setting
		inc	hl					
		ld	a,(hl)					; get modulation data
		ld	(ix+ch_vib_speed),a			; restore speed counter
		ld	a,(ix+ch_vib_steps)			; get number of steps
		or	a
		jr	nz,.calcfreq				; branch if not zero
		inc	hl					
		inc	hl					
		ld	a,(hl)					; get number of steps in modulation
		ld	(ix+ch_vib_steps),a			; restore from modulation data
		ld	a,(ix+ch_vib_delta)			; get modulation delta
		neg						; negate it
		ld	(ix+ch_vib_delta),a			; store negated value
		ret
; ===========================================================================

	.calcfreq:
		dec	(ix+ch_vib_steps)			; update modulation steps
		ld	l,(ix+ch_vibfreq_low)
		ld	h,(ix+ch_vibfreq_high)			; get 16-bit modulation delta

		; Sign extend the modulation delta.
    if OptimizeSoundDriver
		ld	a,(ix+ch_vib_delta)			; get current modulation change per step -> 'a'
		ld	c,a
		rla						; carry contains sign of delta
		sbc	a,a					; a = 0 or -1 if carry is 0 or 1
		ld	b,a					; bc = sign extension of delta
    else
		ld	b,0
		ld	c,(ix+ch_vib_delta)			; get current modulation change per step -> 'c'
		bit	7,c
		jp	z,.nosignextend
		ld	b,0FFh					; sign extend if negative

.nosignextend:
    endc
		add	hl,bc					; add to current modulation value
		ld	(ix+ch_vibfreq_low),l
		ld	(ix+ch_vibfreq_high),h			; Store new 16-bit modulation value
		ld	c,(ix+ch_freq_low)			; frequency low byte -> c
		ld	b,(ix+ch_freq_high)			; frequency high byte -> b
		add	hl,bc					; add modulation value
		ex	de,hl
		jp	(hl)					; WILL return to zUpdateTrack
; ===========================================================================

		ensure1byteoffset 8Ch

GenNotePSG:	macro	const,psgfq,fmfq
		ifarg \psgfq
			dw \psgfq				; add PSG note value into ROM
		endc
		endm		
		
PSGFrequencies:
		DefineNotes		GenNotePSG		; generate PSG note constants

; ===========================================================================

FMPrepareNote:
		bit	chf_rest_bit,(ix+ch_flags)		; is track in rest?
		ret	nz					; if so, quit
		ld	e,(ix+ch_freq_low)			; get frequency low
		ld	d,(ix+ch_freq_high)			; get frequency high
		ld	a,d
		or	a,e
		jp	z,SetRest				; if de = 0, set track as resting

FMUpdateFreq:
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding this track?
		ret	nz					; if so, exit

		; Sign extend the detune value.
    if OptimizeSoundDriver
		ld	a,(ix+ch_detune)			; get detune value
		ld	l,a
		rla						; carry contains sign of ch_detune
		sbc	a,a					; a = 0 or -1 if carry is 0 or 1
		ld	h,a					; hl = sign extension of ch_detune
    else
		ld	h,0					; h = 0
		ld	l,(ix+ch_detune)			; get detune value
		bit	7,l					
		jr	z,.nosignextend				
		ld	h,0FFh					; sign extend if negative

	.nosignextend:
    endc
		add	hl,de					; alter frequency just a tad
		ld	c,h					; upper 6 bits of frequency
		ld	a,(ix+ch_type)				; get channel assignment
		and	a,t_fm_assignment			; only need assignment bits
		add	a,ym_frequency_high			; register for upper 6 bits (channel assignment bits will adjust to correct register)
		rst	WriteFMIorII				; write it!
		ld	c,l					; lower 8 bits of frequency
		sub	a,ym_frequency_high-ym_frequency_low	; register for lower 8 bits
		rst	WriteFMIorII				; write it!
		ret

; ---------------------------------------------------------------------------
; Subroutine to update PSG tracks
; ---------------------------------------------------------------------------

PSGUpdateTrack:
		dec	(ix+ch_delay)				; decrement duration timeout
		jr	nz,.notegoing				; branch if time remains
		res	chf_tie_bit,(ix+ch_flags)		; clear "do not attack next note" bit
		call	PSGDoNext				; handle coordination flags, get next note and duration
		call	PSGNoteOn				; key the note if allowed
		call	PSGDoVolFX				; apply PSG volume and flutter
		call	DoModulation				; update modulation (no return if modulation doesn't change)
		jp	PSGUpdateFreq
; ===========================================================================

	.notegoing:
		call	NoteTimeoutUpdate			; apply note fill (will not return here if note fill expires)
		call	PSGUpdateVolFX				; update volume and flutter
		call	DoModulation				; update modulation (no return if modulation doesn't change)
		jp	PSGUpdateFreq
; ===========================================================================

PSGDoNext:
		ld	l,(ix+ch_dataptr_low)			; get track data pointer
		ld	h,(ix+ch_dataptr_high)			
		res	chf_rest_bit,(ix+ch_flags)		; clear "track is rest" bit

	.noteloop:
		ld	a,(hl)					; get next byte
		inc	hl					
		cp	_firstCom				; is it a coordination flag?
		jr	c,.gotnote				; if not, branch
		call	SongCommand				; handle coordination flag
		jr	.noteloop				; loop back around for another byte
; ===========================================================================

	.gotnote:
		or	a					; is it a duration?
		jp	p,.gotduration				; if so, branch
		call	PSGSetFreq				; otherwise, this is a note; get its frequency
		ld	a,(hl)					; get next byte
		or	a					; is it a note?
		jp	m,FinishTrackUpdate			; if so, branch; track update is finished
		inc	hl					; otherwise, it's a duration; advance data pointer to next byte

	.gotduration:
		call	SetDuration				; set the duration
		jp	FinishTrackUpdate			; track update is finished

; ---------------------------------------------------------------------------
; Subroutine to get the PSG frequency for a given note

; input:
;	a = note to get frequency for
; ---------------------------------------------------------------------------

PSGSetFreq:
		sub	a,_firstNote				; is it a rest?
		jr	c,.restpsg				; if so, branch
		add	a,(ix+ch_transpose)			; add track transposition
		add	a,a					; index into frequency table
		add	a,PSGFrequencies&0FFh			; Point to proper place in table
		ld	(.storefreq+2),a			; store into the following instruction (self-modifying code)

	.storefreq:
		ld	de,(PSGFrequencies)			; get new frequency
		ld	(ix+ch_freq_low),e			; store low byte
		ld	(ix+ch_freq_high),d			; store high byte
		ret
; ===========================================================================

.restpsg:
		set	chf_rest_bit,(ix+ch_flags)		; Set "track in rest" bit
		ld	a,0FFh
		ld	(ix+ch_freq_low),a			; Frequency low byte = FFh
		ld	(ix+ch_freq_high),a			; Frequency hight byte = FFh
		jp	PSGNoteOff				; send PSG Note Off
; ===========================================================================

PSGNoteOn:
		bit	7,(ix+ch_freq_high)			; is track at rest?
		jr	nz,SetRest				; if so, branch
		ld	e,(ix+ch_freq_low)			; get frequency
		ld	d,(ix+ch_freq_high)

PSGUpdateFreq:
		ld	a,(ix+ch_flags)				; get playback control byte
		and	a,chf_rest|chf_mask			; is track resting or overridden by SFX?
		ret	nz					; if so, exit
		
		; Sign extend the detune value.
    if OptimizeSoundDriver
		ld	a,(ix+ch_detune)			; get detune value
		ld	l,a
		rla						; carry contains sign of ch_detune
		sbc	a,a					; a = 0 or -1 if carry is 0 or 1
		ld	h,a					; hl = sign extension of ch_detune
    else
		ld	h,0
		ld	l,(ix+ch_detune)			; get detune value
		bit	7,l
		jr	z,.nosignextend	
		ld	h,0FFh					; sign extend if negative

.nosignextend:
    endc
		add	hl,de					; alter frequency just a tad
		ld	a,(ix+ch_type)				; get channel assignment
		cp	tPSG4					; is it the noise channel?
		jr	nz,.notnoise				; if not, branch
		ld	a,tPSG3					; use PSG 3 channel bits

	.notnoise:
		ld	b,a					; b = register bits
		ld	a,l					; a = frequency low byte
		and	a,0Fh					; lower 4 bits frequency
		or	a,b					; latch frequency data to channel
		ld	(zPSG),a				; write to PSG
		ld	a,l					; a = frequency low byte
		srl	h					; next six instruction perform a right shift by 4 bits
		rra
		srl	h
		rra
		rra
		rra		
		and	a,3Fh					; keep only lower 6 bits (PSG d4-d9)
		ld	(zPSG),a				; write to PSG
		ret
; ===========================================================================

SetRest:
		set	chf_rest_bit,(ix+ch_flags)		; Set "track at rest" bit
		ret
; ===========================================================================

PSGUpdateVolFX:
		ld	a,(ix+ch_vol_env_id)			; get current PSG envelope
		or	a
		ret	z					; return if it's zero
		; otherwise, continue into PSGDoVolFX...

PSGDoVolFX:
		ld	b,(ix+ch_volume)			; b = channel volume
		ld	a,(ix+ch_vol_env_id)			; a = current PSG envelope
		or	a				
		jr	z,SetPSGVolume				; branch if envelope is zero
		ld	hl,Envelopes				; hl = pointer to PSG envelope table
		dec	a					; decrement a
		add	a,a					; double it
		ld	e,a
		ld	d,0					; de = a
		add	hl,de					; offset into envelope table...
		ld	a,(hl)					; get low byte -> 'a'
		inc	hl					; Next byte
		ld	h,(hl)					; get high byte into 'h'
		add	a,(ix+ch_flutter)			; add PSG flutter
		ld	l,a
		adc	a,h
		sub	a,l
		ld	h,a					; hl = (hl+(ix+ch_flutter))
		ld	a,(hl)					; get flutter value
		inc	(ix+ch_flutter)				; increment PSG flutter value
		or	a					; is flutter valeu negative?
		jp	p,.gotflutter				; branch if not
		cp	evcHold					; is it the terminator?
		jr	z,VolEnvCmd_Hold			; if so, branch (we hold at this flutter value, i.e. no more changes in ch_volume)

	.gotflutter:
		add	a,b					; Apply this "flutter" to channel ch_volume -> 'a'
		ld	b,a					; a -> 'b'

SetPSGVolume:
		ld	a,(ix+ch_flags)				; get playback control byte
		and	a,chf_rest|chf_mask			; is track resting or being overridden by SFX?
		ret	nz					; if so, exit
		bit	chf_tie_bit,(ix+ch_flags)		; if track set to not attack next note?
		jr	nz,PSGCheckNoteTimeout			; if so, branch

PSGSendVolume:
		ld	a,b					; 'b' -> 'a'
		cp	10h					; Did the level get pushed below silence level? (i.e. a > 0Fh)
		jr	c,.abovesilence
		ld	a,0Fh					; if so, fix it!

	.abovesilence:
		or	a,(ix+ch_type)				; add in track selector bits
		or	a,psg_set_vol				; mark it as a volume command
		ld	(zPSG),a				; write to PSG
		ret
; ===========================================================================

PSGCheckNoteTimeout:						; if you get here, then "do not attack next note" was set...
		ld	a,(ix+ch_savedgate)
		or	a					; is note timeout on?
		jr	z,PSGSendVolume				; branch if not
		ld	a,(ix+ch_gate)				
		or	a					; has note timeout expired?
		jr	nz,PSGSendVolume			; branch if not
		ret
; ===========================================================================

VolEnvCmd_Hold:
    if FixBugs
		dec	(ix+ch_flutter)				; decrement flutter to keep in place
		dec	(ix+ch_flutter)				; put index back (before final ch_volume value)
		jr	PSGDoVolFX				; update ch_volume
    else
		; This effectively halts all future ch_volume updates, breaking fades!
		dec	(ix+ch_flutter)				; put index back (before evcHold flag)
		ret						; return and don't update ch_volume on this frame (!!!)
    endc
; ===========================================================================

PSGNoteOff:
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding?
		ret	nz					; if so, exit
		ld	a,(ix+ch_type)				; get channel to silence
		or	a,psg_silence				; maximum attenuation
		ld	(zPSG),a
    if FixBugs
		; Without InitMusicPlayback forcefully muting all channels, there's the
		; risk of music accidentally playing noise because it can't detect if
		; the PSG4/noise channel needs muting, on track initialisation.
		; This bug can be heard be playing the End of Level music in CNZ, whose
		; music uses the noise channel. S&K's driver contains a fix just like this.
		cp	tPSG3|psg_silence			; are we stopping PSG3?
		ret	nz					; return if not
		ld	a,tPSG4|psg_silence			; if we are, stop noise channel while we're at it
		ld	(zPSG),a				
    endc
		ret
; ===========================================================================

    if OptimizeSoundDriver
		ensure1byteoffset 18h
    else
		ensure1byteoffset 0C0h
    endc

GenNoteFM:	macro	const,psgfq,fmfq,firstoctave
		if OptimizeSoundDriver
			if strlen("\fmfq")>0&strlen("\firstoctave")>0 ; only include values for the first octave; the rest will be calculated on the fly to save space
			dw \fmfq				; add FM note value into ROM
			endc
		else
			ifarg \fmfq
			dw \fmfq				; add FM note value into ROM
			endc
		endc	
		endm
		
FMFrequencies:
		DefineNotes	GenNoteFM			; generate the FM frequency table

; ===========================================================================

PSGSilenceAll:
		ld	hl,zPSG					; PSG input
		ld	(hl),tPSG1|psg_silence			; silence PSG 1
		ld	(hl),tPSG2|psg_silence			; silence PSG 2
		ld	(hl),tPSG3|psg_silence			; silence PSG 3
		ld	(hl),tPSG4|psg_silence			; silence noise channel
		ret

; ---------------------------------------------------------------------------
; Subroutine to pause/unpause music
; ---------------------------------------------------------------------------

PauseMusic:
		jp	m,.unpausemusic				; branch if music is being unpaused
		ld	a,(f_paused)
		or	a
		ret	nz					; branch if we are already paused
		ld	a,0FFh					; a = 0FFh
		ld	(f_paused),a				; set driver's pause flag
		call	FMSilenceAll				; silence all FM tracks
		jp	PSGSilenceAll				; silence all PSG tracks
; ===========================================================================

.unpausemusic:
    if OptimizeSoundDriver
		xor	a					; clear a
		ld	(z_abs_vars+f_pause_sound),a		; clear pause flag set by 68k
    else
		push	ix					; save ix (pointless, as nothing uses it beyond this point...)
		ld	(ix+f_pause_sound),0			; clear pause flag set by 68k
		xor	a					; clear a
    endc
		ld	(f_paused),a				; clear driver's pause flag
		ld	ix,z_song_dac_fm_start			; ix = start of music track RAM
		ld	b,countof_music_dac_fm_tracks		; 1 DAC + 6 FM
		call	.resume_track				; resume all music tracks

		bankswitch SoundIndex				; bankswitch to SFX

		ld	a,0FFh
		ld	(f_sfx),a				; set SFX update flag
		ld	ix,z_sfx_fm_start			; ix = start of SFX track RAM
		ld	b,countof_sfx_fm_tracks			; 3 FM

	if OptimizeSoundDriver=0
		; None of this is necessary; we can just fall through to .resume_track instead	
		call	.resume_track				; resume SFX tracks
		xor	a					; a = 0
		ld	(f_sfx),a				; clear SFX updating flag
		call	BankSwitchToMusic			; bankswitch to music (pointless, as music isn't updated until the next frame)
		pop	ix					; restore ix (unnecessary, as nothing uses it beyond this point...)
    endc
		ret
; ===========================================================================

.resume_track:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nexttrack				; branch if not
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding track?
		jr	nz,.nexttrack				; branch if not
   
    if OptimizeSoundDriver=0
		; SetNewVoice already does this.
		ld	c,(ix+ch_ams_fms_pan)			; AMS/FMS/panning flags
		ld	a,(ix+ch_type)				; get voice control byte
		and	a,t_fm_assignment			; only need assignment bits
		add	a,ym_ams_fms_pan			; select AMS/FMS/panning register
		rst	WriteFMIorII
    endc
		push	bc					; back up bc
		ld	c,(ix+ch_voice)				; get current track FM instrument
		call	SetNewVoice				; set voice
		pop	bc					; restore bc

	.nexttrack:
		ld	de,sizeof_trackvars	
		add	ix,de					; advance to next track
		djnz	.resume_track				; repeat until all tracks are restored
		ret

; ---------------------------------------------------------------------------
; Subroutine to	cycle the SFX queue
; ---------------------------------------------------------------------------

CycleSoundQueue:
		ld	a,(z_abs_vars+v_sound_id) 
		cp	com_Null				; is driver processing a previous sound, or has music been queued?
		ret	nz					; if so, exit
		ld	hl,z_abs_vars+z_queue_0			; hl = first queue slot
		ld	a,(z_abs_vars+v_priority)
		ld	c,a					; c = priority of currently playing SFX
		ld	b,sizeof_z_queue			; 3, for z_queue_0, z_queue_1, and z_queue_2

	.inputloop:
		ld	a,(hl)					; get id of sound
		ld	e,a	
		ld	(hl),0					; clear queue slot
		inc	hl					; advance hl to next queue slot
		cp	_firstMusic				; is it before first music (invalid)?
		jr	c,.nextinput				; if so, branch
		cp	_firstCmd				; is it a command?
		jr	nc,.queuesound				; if so, branch
		sub	a,_firstSfx				; subtract first SFX index
		jr	c,.queuesound				; branch if it is a music track
		add	a,SFXPriorities&0FFh			
		ld	l,a					; l = low byte of pointer to SFX priority
		adc	a,(SFXPriorities&0FF00h)>>8		; a = low byte of pointer to SFX priority + high byte of same pointer
		sub	a,l					; a = high byte of pointer to SFX priority
		ld	h,a					; hl = pointer to SFX priority
		ld	a,(hl)					; get SFX priority
		cp	c					; is the new SFX of a higher priority?
		jr	c,.setpriority				; if not, branch
		ld	c,a					; save new priority
		call	.queuesound				; queue the new SFX

	.setpriority:
		ld	a,c					; get back SFX priority
		or	a					; is it negative (jumping sound)?
		ret	m					; Return if so
		ld	(z_abs_vars+v_priority),a		; set new sound priority
		ret	
; ===========================================================================

.nextinput:
		djnz	.inputloop				; loop for all queue slots
		ret
; ===========================================================================

.queuesound:
		ld	a,e					; restore a to be the last queue item read
		ld	(z_abs_vars+v_sound_id),a		; set it it as the next item to play
		ret
	
; ---------------------------------------------------------------------------
; Subroutine to begin playing a sound
; ---------------------------------------------------------------------------

PlaySoundID:
		or	a					; is it sound 00?
		jp	z,ClearTrackMemory			; if so, branch (RESET EVERYTHING!)
    if _firstMusic-1 = 80h
		ret	p					; return if it was (invalidates 00h-7Fh; maybe we don't want that someday?)
    else
		cp	_firstMusic
		ret	c					; return if id is less than the first music id
    endc

		ld	(ix+v_sound_id),com_Null		; no new sound is coming in
		cp	_lastMusic				; is it music (less than index 20)?
		jp	c,Sound_PlayBGM				; if yes, play it
		cp	_firstSfx				; is it not a sound effect? (this check is redundant if _lastMusic == _firstSfx...)
		ret	c					; if not, return (do nothing)
		cp	_lastSfx				; is it a sound effect (less than index 71)?
		jp	c,Sound_PlaySFX				; if yes, play it
		cp	_firstCmd				; is it after the last regular sound but before the first special sound command (between 71 and 78)?
		ret	c					; if yes, return (do nothing)
		cp	cmd_Pause				; is it sound 7E or 7F (pause all or resume all)
		ret	nc					; if yes, return (those get handled elsewhere)

	;.is_command:
		sub	a,_firstCmd				; convert index 78-7D to a lookup into the following jump table
	if OptimizeSoundDriver
		ld  c,a
		add a,a
  	  	add a,c
	else
		add a,a
		add a,a
	endc		
		ld	(.commandjump+1),a			; store into the following instruction (self-modifying code)

.commandjump:
		jr	*
; ===========================================================================

GenSoundCmds:	macro	name,realcmd
		ifarg \realcmd
		jp	SoundCmd_\name				; generate a jump for every real command
		
		if OptimizeSoundDriver=0	
		db 0 ; Pad each table entry to 4 bytes; this is a leftover from Sonic 1,
  		; where this table consisted of bra.w instructions that were four
  		; bytes each. 
  		endc
  		endc
		endm

SoundCmd_Index:
		DriverCmds	GenSoundCmds			; generate jumps for all driver commands
		
; ---------------------------------------------------------------------------
; Subroutine to play the Sega sound
; ---------------------------------------------------------------------------

SoundCmd_Sega:
    if FixBugs
		; Reset panning (we don't want the Sega sound playing on only one speaker).
		ld	a,ym_ams_fms_pan_3_6			; FM6/DAC AMS/FMS/panning
		ld	c,pan_right|pan_left			; default AMS/FMS/panning settings (only stereo L/R enabled)
		rst	WriteFMII
    endc

		ld	a,ym_dac_enable				; DAC enable/disable register
		ld	c,dac_enable				; command to enable DAC
		rst	WriteFMI

		bankswitch SegaPCM				; bankswitch to the SEGA sound

		ld	hl,z_rom_window+(SegaPCM&7FFFh)		; start of SEGA PCM
		ld	de,sizeof_SegaPCM/2			; 
		ld	a,ym_dac_output				; DAC data register
		ld	(ym_reg_a0),a
		ld	c,com_Null				; if v_sound_id is not this, Sega PCM will stop

	.loop:
		ld	a,(hl)					; get next PCM byte
		ld	(ym_reg_d0),a				; send to DAC
		inc	hl					; advance pointer
		nop
		ld	b,0Ch					; Sega PCM pitch
		
		djnz	*					; delay loop

		nop
		ld	a,(z_abs_vars+v_sound_id)		; get v_sound_id
		cp	c					; is it com_Null?
		jr	nz,.stop				; if not, stop Sega PCM
		ld	a,(hl)					; get next PCM byte
		ld	(ym_reg_d0),a				; send to DAC
		inc	hl					; Advance pointer
		nop
		ld	b,0Ch					; Sega PCM pitch
	
		djnz	*					; delay loop

		nop
		dec	de					; decrement byte counter
		ld	a,d					; a = d
		or	a,e					; is de zero?
		jp	nz,.loop				; if not, loop

	.stop:
		call	BankSwitchToMusic			; bankswitch back to music
		ld	a,(z_abs_vars+f_dac_enabled)		; DAC status
		ld	c,a					; c = DAC status
		ld	a,ym_dac_enable				; restore previous DAC setting
		rst	WriteFMI
		ret

; ---------------------------------------------------------------------------
; Subroutine to play a music track

; input:
;	a = sound ID
; ---------------------------------------------------------------------------

Sound_PlayBGM:
    if FixBugs=0
		; This is a workaround for a bug where playing a new song will distort any SFX that were already playing.
		push	af
		call	SoundCmd_StopSFX			; stop all sounds before starting BGM
		pop	af
    endc
		ld	(v_current_song),a			; get current BGM
		cp	mus_ExtraLife				; is it the Extra Life jingle?
		jr	nz,.bgmnot1up				; if not, branch
		
		; Disable all SFX for duration of 1-up music.
		ld	a,(z_abs_vars+f_has_backup)	
		or	a					; is 1-up sound already playing?
		jr	nz,.bgm_loadmusic			; if it is, branch (we don't need to back up the track or silene SFX again)
		ld	ix,z_tracks_start			; ix = start of music track ram
		ld	de,sizeof_trackvars			; de = size of track ram
		ld	b,countof_music_tracks			; 1 DAC + 6 FM + 3 PSG tracks

	.clearsfxloop:
		res chf_mask_bit,(ix+ch_flags)			; clear 'SFX is overriding' bit (ch_Flags)
		add	ix,de					; advance to next track
		djnz	.clearsfxloop				; repeat for all tracks

		ld	ix,z_tracks_sfx_start			; ix = start of SFX track ram
		ld	b,countof_sfx_tracks			; 6 SFX tracks total (3 FM + 3 PSG)

	.cleartrackplayloop:
		res	chf_enable_bit,(ix+ch_flags)		; clear 'track is playing' bit (ch_Flags)
		add	ix,de					; advance to next track
		djnz	.cleartrackplayloop			; repeat for all tracks
	
	if FixBugs
		; This was in Sonic 1's driver, but this driver foolishly removed it.
		xor	a
		(z_abs_vars+v_priority),a			; clear SFX priority
	endc

		; Back up all global variables and music track memory so the music can resume after the 1-up music
		; completes.
		ld	de,v_backup_ram				; copy to backup ram
		ld	hl,z_abs_vars				; start copying at the start of the global variables
		ld	bc,z_tracks_end-z_abs_vars		; 1BCh bytes total
		ldir
	
		ld	a,80h
		ld	(z_abs_vars+f_has_backup),a		; set 1-up playing flag
		
	if FixBugs=0
		; This is done in the wrong place: it should have been done before
		; the variables are backed-up. Because of this, SFXPriorityVal will
		; be set back to a non-zero value when the 1-up jingle is over,
		; preventing lower-priority sounds from being able to play until a
		; high-priority sound is played.	
		xor	a
		ld	(z_abs_vars+v_priority),a		; clear SFX priority
	endc	
		jr	.bgm_loadmusic	
; ===========================================================================

.bgmnot1up:
		xor	a
		ld	(z_abs_vars+f_has_backup),a		; clear 1-up playing flag
		ld	(z_abs_vars+v_fadein_counter),a		; clear fade-in frame count
		ld	(z_abs_vars+v_fadeout_counter),a	; clear fade-out frame count


.bgm_loadmusic:
		call	InitMusicPlayback			; clear track memory and silence all channels
		ld	a,(v_current_song)			; a = ID of song we are about to play
		sub	a,_firstMusic				; make zero-based index
		ld	e,a	
		ld	d,0					; de = index of song
		ld	hl,SpeedUpIndex				; hl = speed shoes tempo list
		add	hl,de					; add song index to get pointer to speed shoes tempo
		ld	a,(hl)					; get speed shoes tempo
		ld	(z_abs_vars+v_tempo_speed),a		; store for later use
		ld	hl,MusicIndex				; load music playlist
		add	hl,de					; add song index to get pointer to list entry
		ld	a,(hl)					; get playlist value
		ld	b,a					; back up in b, as it'll get wiped out by the next step
		
		; The following instructions enable a bankswitch routine
		and	a,mus_bank				; only need 'bank' bit
		ld	(z_abs_vars+v_bank_number),a		; store for later bankswitch
		ld	a,b					; restore a
		add	a,a					; multiply by 4, shifting disable_pal_bit into highest bit
		add	a,a
		ld	c,a
		ccf						; invert carry flag
		sbc	a,a					; subtract with carry; results in FFh if disable_pal_bit was clear (allow PAL double-update), zero otherwise (do not allow PAL double-update)
		ld	(z_abs_vars+f_adjust_pal),a		; set PAL adjust flag
		ld	a,c					; put prior multiply result back in
		add	a,a					; shift uncompressed_mus_bit into highest bit
		sbc	a,a					; subtract with carry; results in FFh if uncompressed_mus_bit was set (uncompressed song), zero otherwise (compressed song)
		push	af					; back up result for later
		ld	a,b					; restore a
		and	a,~mus_flags&0FFh			; strip the flag bits, leaving the pointer
		add	a,a					; multiply by 2 to make index into ROM window
		ld	e,a
		ld	d,0					; de = a
		ld	hl,z_rom_window				; hl = start of ROM window
		add	hl,de					; add index to make address to pointer
		push	hl					; back up hl
		call	BankSwitchToMusic			; bank switch to the appropriate music bank
		pop	hl					; restore hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)					; de = address of music within the ROM window


		pop	af					; restore af (contains result of compressed vs uncompressed)
		or	a					; is this song uncompressed?
		jr	nz,.nodecomp				; if so, branch (bytecode will be parsed directly from ROM)

		ex	de,hl					; swap de and hl
		exx						; swap bc, de, and hl for their shadows and back them up to the stack
		push	hl
		push	de
		push	bc
    if OptimizeSoundDriver=0
		exx						; swap shadows again (unnecessary)
    endc
		call	SaxDec_Z80				; decompress the music bytecode
		exx						; restore all registers
		pop	bc
		pop	de
		pop	hl
		exx
		ld	de,z_music_data				; de = start of decompressed bytecode

.nodecomp:
		; Common track init code. If uncompressed, assumes de is pointing to start of bytecode.
		push	de
		pop	ix					; ix = de (BGM's starting address)
		ld	e,(ix+smps_voiceptr_hi)			; get voice pointer low byte -> 'e'
		ld	d,(ix+smps_voiceptr_lo)			; get voice pointer high byte -> 'd'
		ld	(z_abs_vars+v_music_voice_table),de	; set in main variables
		ld	a,(ix+smps_tempo)			; get main tempo value
		ld	(z_abs_vars+v_tempo_main),a		; set in main variables
		ld	b,a					; b = tempo
		ld	a,(z_abs_vars+f_speedup)		; get speed shoe flag
		or	a
		ld	a,b					; restore normal tempo value
		jr	z,.nospeedshoes				; branch if speed shoes are not active
		ld	a,(z_abs_vars+v_tempo_speed)		; use the speed shoe tempo for this song instead

	.nospeedshoes:
		ld	(z_abs_vars+v_current_tempo),a		; set current tempo
		ld	(z_abs_vars+v_tempo_counter),a		; set tempo delay counter
		ld	a,6-1
		ld	(v_pal_update_counter),a		; reset PAL update counter
		push	ix
		pop	hl					; hl = ix (BGM's starting address)
		ld	de,smps_trackinitdata	
		add	hl,de					; hl = start of track init info
		ld	a,(ix+smps_fmch_cnt)			; get number of FM+DAC channels
		or	a	
		jp	z,.bgm_psgload				; branch if there are none to load
		ld	b,a					; b = number of FM+DAC channels (will be used as loop counter)
		push	iy					; back up iy
		ld	iy,z_tracks_start			; iy = start of track memory
		ld	c,(ix+smps_tick)			; get tempo divisor
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		ld	de,FMDACInitBytes			; de = FMDACInitBytes
    endc

.bgm_fmloadloop:
    if FixBugs
		ld	(iy+ch_flags),chf_enable		; initial playback control; set "track playing" bit
    else
    	; Setting chf_rest is a workaround to mask the symptoms of the misplaced TempoWait
    	; call in UpdateMusic. With that bug fixed, this is no longer necessary.
		ld	(iy+ch_flags),chf_rest|chf_enable	; initial playback control; set "track playing" and "track at rest" bits
    endc
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		ld	a,(de)					; get current byte from FMDACInitBytes
		inc	de					; increment to next byte in FMDACInitBytes
		ld	(iy+ch_type),a				; set channel ID in voice control byte
    endc
		ld	(iy+ch_tick),c				; store tempo divisor from header
		ld	(iy+ch_stackptr),ch_stack		; set "gosub" stack init value (starts at end of this track's memory)
		ld	(iy+ch_ams_fms_pan),pan_right|pan_left	; default panning / AMS / FMS settings (only stereo L/R enabled)
		ld	(iy+ch_delay),1				; set duration of first "note: (should expire next update, play first note, etc.)
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		push	de					; back up FMDACInitBytes pointer
    endc
		push	bc					; back up channel count and tempo divider (bc is used by the ld or ldir instructions coming up)
		ld	a,iyl					; a = current track pointer low byte
		add	a,ch_dataptr_low			; we are copying data to track memory starting with the track address
		ld	e,a
		adc	a,iyh
		sub	a,e
		ld	d,a					; de = iy+ch_dataptr_low
    if OptimizeSoundDriver
    	; Sacrifice a bit of speed to save space by using ldir.
		ld	bc,4					; 4 bytes to copy
		ldir						; copy initial track address, default transposition, and default volume
    else
		ldi						; copy track address low byte
		ldi						; copy track address high byte
		ldi						; copy default transposition
		ldi						; copy default volume
    endc
		ld	de,sizeof_trackvars
		add	iy,de					; advance to next track
		pop	bc					; restore 'bc' (number of channels and tempo divider)
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		pop	de					; restore 'de' (FMDACInitBytes current pointer)
    endc
		djnz	.bgm_fmloadloop				; repeat for all FM tracks to be loaded

		pop	iy					; restore 'iy'
		ld	a,(ix+smps_fmch_cnt)			; get number of FM+DAC channels
		cp	countof_music_dac_fm_tracks		; are there six FM channels? (count includes a dummy entry for the DAC) 
		jr	nz,.silencefm6				; if not, branch
		xor	a
    if OptimizeSoundDriver=0
		ld	c,a					; c = 0, will disable dac
    endc
		jr	.set_dac				; jump to .set_dac
; ===========================================================================

	.silencefm6:
	; Silence FM Channel 6 specifically if it's not in use.
    if OptimizeSoundDriver=0
		; Unnecessary, as a later call to FMNoteOff will take care of this,
		ld	a,ym_keyonoff				; key on/off register
		ld	c,tFM6					; note off on all operators of channel 6
		rst	WriteFMI				
    endc
    if FixBugs=0
		; The added FMSilenceChannel does this, already
		ld	a,ym_total_level+ym_3_6_op1		; starting with FM6 operator 1
		ld	c,tl_silence+80h			; silence value (that +80h is unnecessary)
		ld	b,countof_operators			; write to all four FM6 operators

	.silencefm6loop:
		rst	WriteFMII				; silence operator
		add	a,next_operator				; next operator
		djnz	.silencefm6loop				; repeat for all operators
    endc

		; Panning isn't normally set until SetVoice.
		; This is a problem for the DAC track since it never uses SetVoice
		; (or at least it shouldn't), so we reset the panning here.
		ld	a,ym_ams_fms_pan_3_6			; AMS/FMS/panning of FM6
		ld	c,pan_right|pan_left			; default panning / AMS / FMS settings (only stereo L/R enabled)
		rst	WriteFMII
		ld	a,dac_enable				; FM Channel 6 is NOT in use (will enable DAC)
    if OptimizeSoundDriver=0
		ld	c,a					; Set this as value to be used in FM register write coming up...
    endc

	.set_dac:
		; Enable or disable DAC depending on whether FM6 is in use or not.
    if OptimizeSoundDriver
		ld	c,a					; if we silenced FM6, enable DAc; otherwise disable
    endc
		ld	(z_abs_vars+f_dac_enabled),a		; set or clear DAC enable flag
		ld	a,ym_dac_enable				; enable or disable DAC
		rst	WriteFMI

.bgm_psgload:
		ld	a,(ix+smps_psgch_cnt)			; get number of PSG tracks
		or	a
		jp	z,.bgm_psgdone				; branch if there are none to load
		ld	b,a					; b = number of PSG channels (will be used as loop counter)
		push	iy					; back up iy
		ld	iy,z_song_psg_start			; iy = start of PSG track memory 
		ld	c,(ix+smps_tick)			; get tempo divisor
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		ld	de,PSGInitBytes				; de = PSGInitBytes
    endc

	.bgm_psgloadloop:
    if FixBugs
		ld	(iy+ch_flags),chf_enable		; set "track is playing" bit
    else
    	; Setting chf_rest is a workaround to mask the symptoms of the misplaced TempoWait
    	; call in UpdateMusic. With that bug fixed, this is no longer necessary.
		ld	(iy+ch_flags),chf_rest|chf_enable	; set "track is playing" and "track at rest" bits
    endc
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		ld	a,(de)					; get current byte from PSGInitBytes
		inc	de					; increment to next byte in PSGInitBytes
		ld	(iy+ch_type),a				; set channel ID in voice control byte
    endc
		ld	(iy+ch_tick),c				; store tempo divisor from header
		ld	(iy+ch_stackptr),ch_stack		; set "gosub" stack init value (starts at end of this track's memory)
		ld	(iy+ch_delay),1				; set duration of first "note" (should expire next update, play first note, etc.)
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		push	de					; back up PSGInitBytes pointer
    endc
		push	bc					; back up channel count and tempo divider (bc is used by the ld' or ldir instructions coming up)
		ld	a,iyl					; a = current track pointer low byte
		add	a,ch_dataptr_low			; we are copying data to track memory starting with the track address
		ld	e,a
		adc	a,iyh
		sub	a,e
		ld	d,a					; de = iy+ch_dataptr_low
    if OptimizeSoundDriver
    	; Sacrifice a bit of speed to save space by using ldir.    
		ld	bc,4					; 4 bytes to copy
		ldir						; copy initial track address, default transposition, and default volume
    else
		ldi						; copy track address low byte
		ldi						; copy track address high byte
		ldi						; copy default transposition
		ldi						; copy default volume
    endc
		inc	hl
		ld	a,(hl)					; get initial envelope
		inc	hl					; this byte is usually the same as the prior, unused
		ld	(iy+ch_vol_env_id),a			; store envelope
		ld	de,sizeof_trackvars	
		add	iy,de					; advance to next track
		pop	bc					; restore 'bc' (number of channels and tempo divider)
    if FixBugs=0
		; Unnecessary if the bugfix in InitMusicPlayback is applied.
		pop	de					; restore 'de' (PSGInitBytes current pointer)
    endc
		djnz	.bgm_psgloadloop			; repeat for all PSG tracks yo be loaded

		pop	iy					; restore 'iy'

.bgm_psgdone:
		ld	ix,z_tracks_sfx_start			; ix = start of SFX track memory 
		ld	b,countof_sfx_tracks			; 6 SFX tracks total (3FM, 3PSG)
		ld	de,sizeof_trackvars			; size between tracks

	.sfxstoploop:
		bit	chf_enable_bit,(ix+ch_flags)		; is this track currently playing?
		jr	z,.sfxnext				; if not, branch (no work to do)
		ld	a,(ix+ch_type)				; get voice control byte
		or	a
		jp	m,.sfxpsgchannel			; branch if it's a PSG track
		sub	a,2					; otherwise, subtract 2
		add	a,a					; multiply by 2 (preparing to index starting from FM 3 only)
		jr	.gotchannelindex
; ===========================================================================

	.sfxpsgchannel:
		rept 4
		rra	
		endr
		and	a,0Fh					; shift right by 4 to get PSG index

	.gotchannelindex:
		add	a,SFX_BGMChannelRAM&0FFh		; get offset of music track that is SFX track is overriding
		ld	(.trackstore+1),a			; store into the following instruction (self-modifying code)

	; zloc_8F6
	.trackstore:
		ld	hl,(SFX_BGMChannelRAM+0)		; +0 replaced with offset to music track
    if FixBugs
		set chf_mask_bit,(hl)				; set "SFX override" bit
    else
		res chf_mask_bit,(hl)				; clear "SFX override" bit (but Why? According to S1's driver, this should be a 'set')
    endc

	.sfxnext:
		add	ix,de					; advance to next track
		djnz	.sfxstoploop				; repeat for all tracks

;.sendfmnoteoff:
		ld	ix,z_song_fm1				; 'ix' = first FM music track
		ld	b,countof_music_fm_tracks		; all 6 FM tracks

.fmnoteoffloop:
    if FixBugs
		; FMNoteOff isn't enough to silence the entire channel:
		; For added measure, we need to set the total level and release rate, too.
		push	bc
		bit chf_mask_bit,(ix+ch_flags)			; is this track being overridden by SFX?
		call	z,FMSilenceChannel			; if not, call FMSilenceChannel
		add	ix,de					; advance to next track
		pop	bc
    else
		call	FMNoteOff				; send key off
		add	ix,de					; advance to next track
    endc
		djnz	.fmnoteoffloop				; repeat for all FM channels
		
		ld	b,countof_music_psg_tracks		; all 3 PSG tracks

	.psgnoteoffloop:
		call	PSGNoteOff				; send note off
		add	ix,de					; next track
		djnz	.psgnoteoffloop
		ret
; ===========================================================================

    if FixBugs
FMSilenceChannel:
		call	.set_max_rel
		ld	a,(ix+ch_type)				; get voice control byte
		and	a,t_fm_assignment			; only need assignment bits
		add	a,ym_total_level			; YM TL registers
		ld	c,tl_silence				; set to minimum envelope amplitude
		call	.fm_op_writeloop
		jp	FMNoteOff
; ===========================================================================

.set_max_rel:
		ld	a,(ix+ch_type)				; get voice control byte
		and	a,t_fm_assignment			; only need assignment bits
		add	a,ym_releaserate_sustainlevel		; release rate and sustain level registers
		ld	c,0FFh					; set sustain level to minimum and release rate to maximum

.fm_op_writeloop:
		ld	b,countof_operators			; do all four operators

	.loop:
		rst	WriteFMIorII				; write to part I or II, as appropriate
		add	a,next_operator				; next operator
		djnz	.loop					; repeat for all operators
		ret
    endc
; ===========================================================================

FMDACInitBytes:
		db 	tDAC,tFM1,tFM2,tFM3			; port 1 
		db	tFM4,tFM5,tFM6				; port 2

PSGInitBytes:
		db  tPSG1,tPSG2,tPSG3				; specifically, these configure writes to the PSG port for each channel

; ---------------------------------------------------------------------------
; Subroutine to play a sound effect

; input:
;	a = sound ID
; ---------------------------------------------------------------------------

Sound_PlaySFX:
		ld	c,a					; c = sound index
		ld	a,(ix+f_has_backup)			; "1-up playing" flag
		or	a,(ix+f_fadein)				; or with fade-in flag
		jp	nz,.clear_sndprio			; branch if either is set (SFX cannot be played)
		xor	a
		ld	(f_spindash),a				; clear spindash sound flag
		ld	a,c					; a = sound index
		cp	sfx_Ring				; is this the ring sound?
		jr	nz,.checkgloop				; if not, branch

	; Alternate the ring SFX between speakers
	;.chkringspeaker:
		ld	a,(f_stereo_alt)			; get ring speaker flag
		or	a							
		jr	nz,.gotringspeaker			; branch if set (play sound on right speaker)
		ld	c,sfx_RingLeft				; play sound on left speaker

	.gotringspeaker:
		cpl						; invert speaker flag
		ld	(f_stereo_alt),a			; store new ring speaker value (other side)
		jp	.playsound				; play the ring sound
; ===========================================================================

	; Only play the gloop SFX every other frame
	.checkgloop:
    if OptimizeSoundDriver=0
    	; Reduntant.
		ld	a,c
    endc
		cp	sfx_Gloop				; is this the bloop/gloop noise?
		jr	nz,.checkspindash			; if not, branch
		ld	a,(f_gloop)				; get gloop flag
		cpl						; invert
		ld	(f_gloop),a				; store
		or	a
		ret	z					; don't play the sound if flag was clear
		jp	.playsound				; play the gloop sound
; ===========================================================================

	.checkspindash:
    if OptimizeSoundDriver=0
    	; Reduntant.
		ld	a,c
    endc
		cp	sfx_SpinDashCharge			; is this the spindash rev sound?
		jr	nz,.playsound				; if not, branch

		ld	a,(v_spindash_counter)			; get spindash counter
		or	a
		ld	a,(v_spindash_freq_index)		; get spindash frequency
		jr	nz,.incfreq				; branch if the counter hasn't reached zero
		ld	a,-1					; reset the extra frequency (becomes 0 on the next line)

	.incfreq:
		inc	a					; increase the frequency
		cp	0Ch
		jr	nc,.maxfreq				; branch if we've reached the maximum frequency
		ld	(v_spindash_freq_index),a		; store new frequency

	.maxfreq:
		ld	a,3Ch					
		ld	(v_spindash_counter),a			; set spindash counter
		ld	a,-1
		ld	(f_spindash),a				; set spindash flag

.playsound:
		bankswitch SoundIndex				; switch to SFX bank

		ld	hl,z_rom_window+(SoundIndex&7FFFh)	; hl = start of SFX pointers in ROM
		ld	a,c					; a = SFX ID
		sub	a,_firstSfx
		add	a,a					; convert ID into zero-based index
		ld	e,a
		ld	d,0					; de = a
		add	hl,de					; add de to hl to get pointer for SFX
		ld	a,(hl)					; a = low byte of pointer 
		inc	hl
		ld	h,(hl)					; h = high byte of pointer
		ld	l,a					; hl - pointer to SFX bytecode
		ld	e,(hl)
		inc	hl
		ld	d,(hl)					; get voice pointer
		inc	hl
		ld	(.voiceptr+1),de			; store into the instruction after .voiceptr (self-modifying code)
		ld	c,(hl)					; c = tempo divisor
		inc	hl
		ld	b,(hl)					; b = count of channels
		inc	hl

	.sfx_loadloop:
		push	bc					; back up divisor/channel count
		xor	a					; a = 0 (will end up being NO CUSTOM VOICE TABLE!)
		ld	(.chk_psg+1),a				; Store into the instruction after .chk_psg (self-modifying code)
		push	hl					; save current position within sound
		inc	hl

		ld	a,(hl)					; get channel assignment
		or	a
		jp	m,.sfxinitpsg				; branch if it's a PSG track
		sub	a,2					; SFX can only use FM3, FM4 or FM5
		add	a,a					; multiply by 2
		jp	.sfxinitfm
; ===========================================================================

	.sfxinitpsg:
		; This is a PSG track!
		; Always ends up writing zero to voice table pointer?
		ld	(.chk_psg+1),a				; store into the instruction after .chk_psg (self-modifying code)
		cp	tPSG3					; is this PSG3?
		jr	nz,.getindex				; branch if not
		push	af
		or	a,psg_silence				
		ld	(zPSG),a				; silence PSG3
		xor	a,1<<psg_channel_bit1			; 20h
		ld	(zPSG),a				; silence noise channel
		pop	af

	.getindex:
		rept 4
		rra
		endr
		and	a,0Fh					; shift right by 4 to get PSG index

	.sfxinitfm:
		add	a,SFX_BGMChannelRAM&0FFh		; a = offset to corresponding music track
		ld	(.bgm_to_override+1),a			; store into the instruction after .bgm_to_override (self-modifying code)

	.bgm_to_override:
		ld	hl,(SFX_BGMChannelRAM)			; self-modified code: hl = start of music track that this SFX track will override
		set chf_mask_bit,(hl)				; mark music track as being overridden
		add	a,SFX_SFXChannelRAM-SFX_BGMChannelRAM	; a = offset to corresponding SFX track
		ld	(.clearsfxtrackram+2),a			; store into the instruction after .clearsfxtrackram (self-modifying code)

	.clearsfxtrackram:
		ld	ix,(SFX_SFXChannelRAM)			; ix = start of SFX track
		ld	e,ixl
		ld	d,ixh					; de = ix
		push	de					; back up de
		ld	l,e					; hl = de (start of SFX track)
		ld	h,d
		ld	(hl),0					; clear first byte of track
		inc	de					; start on next byte
		ld	bc,sizeof_trackvars-1			; clear all bytes in the track, minus 1 (since we're copying 00h from first byte)
		ldir						; clear track memory
		
		pop	de					; restore de (start of SFX track)
		pop	hl					; restore hl (offset of sound bytecode in ROM + 4)

	; if ch_flags<>0
	;	ld	a,e					
	;	add	a,ch_flags
	;	ld	e,a
	;	adc	a,d
	;	sub	a,e
	;	ld	d,a
	
		ldi						; copy playback control byte
		ldi						; copy voice control byte
		pop	bc					; restore bc to get tempo divisor... 
		push	bc					; and back it up again
		ld	(ix+ch_tick),c				; set tempo divisor of SFX track
		ld	(ix+ch_delay),1				; set duration of first "note" (should expire next update, play first note, etc.)
		ld	(ix+ch_stackptr),ch_stack		; set "gosub" stack init value (starts at end of this track's memory)
		ld	a,e
		add	a,ch_dataptr_low-ch_tick
		ld	e,a
		adc	a,d
		sub	a,e
		ld	d,a					; skip over ch_tick; de = ch_dataptr_low
    if OptimizeSoundDriver
    	; Sacrifice a bit of speed to save space by using ldir. 	
		ld	bc,3
		ldir						; copy initial track address and default transposition
    else
		ldi						; copy track address low byte
		ldi						; copy track address high byte
		ldi						; copy default transposition
    endc

		; if spindash active, the following block updates its frequency specially:
		ld	a,(f_spindash)
		or	a
		jr	z,.notspindash				; if spindash not active branch
		ld	a,(v_spindash_freq_index)		; get current frequency index
		dec	de					; de = track transposition
		ex	de,hl					; swap hl and de
		add	a,(hl)					; add default transposition
		ex	de,hl					; restore de and hl
		ld	(de),a					; store new frequency
		inc	de					; de = ch_volume

	.notspindash:
		ldi						; copy default volume

	.chk_psg:						; modified way back within .sfx_loadloop
		ld	a,0					; self-modified code, not zero if this is a PSG track
		or	a
		jr	nz,.sfxinitdone				; branch if this is a PSG track
	
		; Do one additional FM-related initialization step.
		ld	(ix+ch_ams_fms_pan),pan_right|pan_left	; default panning / AMS / FMS settings (only stereo L/R enabled)

	.voiceptr:
		ld	de,0					; self-modified code: modified to custom voice table address (possibly still 0000h)
		ld	(ix+ch_voice_ptr_low),e			; set low byte of custom voice table
		ld	(ix+ch_voice_ptr_high),d		; set high byte of custom voice table

	.sfxinitdone:
		pop	bc					; restore bc to get channel count
		dec	b					; one less channel
		jp	nz,.sfx_loadloop			; repeat for all channels

		jp	BankSwitchToMusic			; if done, prepare to do music...
; ===========================================================================

	.clear_sndprio:
		xor	a
		ld	(z_abs_vars+v_priority),a		; clear priority
		ret

; ---------------------------------------------------------------------------
; Subroutine to stop SFX
; ---------------------------------------------------------------------------

SoundCmd_StopSFX:
		xor	a
		ld	(z_abs_vars+v_priority),a		; clear priority
		ld	ix,z_tracks_sfx_start			; ix = start of SFX track memory
		ld	b,countof_sfx_tracks			; 3 FM + 3 PSG tracks (SFX)


	.trackloop:
		push	bc					; back up loop counter
		bit	chf_enable_bit,(ix+ch_flags)		; was this track playing?
		jp	z,.nexttrack				; branch if not
		res	chf_enable_bit,(ix+ch_flags)		; stop track
		res	chf_tie_bit,(ix+ch_flags)		; not attacking, either
		ld	a,(ix+ch_type)				; get voice control byte
		or	a
		jp	m,.trackpsg				; branch if this is a PSG track
		push	af
		call	FMNoteOff				; FM key off
		pop	af
		push	ix					; back up ix
		sub	a,tFM3					; determine corresponding music track (starting on FM3, so subtract 2 from channel assignment)
		add	a,a					; multiply by 2 (each index 2 bytes)
		add	a,SFX_BGMChannelRAM&0FFh		; a = offset to music track
		ld	(.fmpointer+2),a			; store into the instruction after .fmpointer (self-modifying code)

	.fmpointer:
		ld	ix,(SFX_BGMChannelRAM)			; self-modified code: will load appropriate corresponding music track address
		bit chf_mask_bit,(ix+ch_flags)			; was this music track overridden by SFX?
		jr	z,.notoverridden			; if not, branch
		res chf_mask_bit,(ix+ch_flags)			; clear SFX overriding bit
		set	chf_rest_bit,(ix+ch_flags)		; set track rest bit
		ld	a,(ix+ch_voice)				; get current voice
		call	SetVoiceMusic				; reset FM voice

.notoverridden:
	if OptimizeSoundDriver
		; Optimize branch and eliminate a redundant 'pop ix'.
		jr	.nexttrack
	else
		pop	ix					; restore ix
		jp	.nexttrack
	endc	 
; ===========================================================================

.trackpsg:
		push	af
		call	PSGNoteOff				; PSG Note off
		pop	af
		push	ix					; back up ix
		
		rept 4
		rra
		endr
		and	a,0Fh					; shift right by 4 to get PSG index
		add	a,SFX_BGMChannelRAM&0FFh		; a = offset to music track
		ld	(.psgpointer+2),a			; store into the instruction after .psgpointer (self-modifying code)

.psgpointer:
		ld	ix,(SFX_BGMChannelRAM)			; self-modified code from just above; ix = corresponding Music PSG track
		res chf_mask_bit,(ix+ch_flags)			; clear SFX overriding bit
		set	chf_rest_bit,(ix+ch_flags)		; set track rest bit
		ld	a,(ix+ch_type)				; get voice control byte
		cp	tPSG4
	if OptimizeSoundDriver
		jr	nz,.nexttrack				; branch if this is a noise track
	else		
		jr	nz,.nexttrackpop			; branch if this is a noise track
	endc
		ld	a,(ix+ch_noisemode)			; get PSG noise setting
		ld	(zPSG),a				; write to PSG

	if OptimizeSoundDriver
		; Eliminate a redundant 'pop ix'.
	.nexttrack:
		pop ix
	else
.nexttrackpop:
		pop	ix

.nexttrack:
	endc
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next track
		pop	bc					; restore loop counter
		djnz	.trackloop				; repeat for all tracks
		ret

; ---------------------------------------------------------------------------
; Subroutine to initialize music fade out
; ---------------------------------------------------------------------------

SoundCmd_Fade:
		ld	a,3
		ld	(z_abs_vars+v_fadeout_delay),a		; set fadeout delay to 3
		ld	a,28h
		ld	(z_abs_vars+v_fadeout_counter),a	; set fadeout counter
		xor	a
		ld	(z_song_dac+ch_flags),a			; stop DAC track (can't fade it)
		ld	(z_abs_vars+f_speedup),a		; disable speed shoe tempo
		ret

; ---------------------------------------------------------------------------
; Subroutine to fade out music
; ---------------------------------------------------------------------------

DoFadeOut:
		ld	a,(z_abs_vars+v_fadeout_delay)		; get current tick count before next ch_volume decrease
		or	a					; has fadeout delay expired?
		jr	z,.continuefade				; branch if so
		dec	(ix+v_fadeout_delay)			; decrement delay count
		ret

.continuefade:
		dec	(ix+v_fadeout_counter)			; decrement fade counter 
		jp	z,ClearTrackMemory			; branch if fade is done
		ld	(ix+v_fadeout_delay),3			; reset fade delay
		push	ix
		ld	ix,z_song_fm1				; ix = first FM music track
		ld	b,countof_music_fm_tracks		; 6 FM tracks

.fmloop:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nextfm				; branch if not
		inc	(ix+ch_volume)				; increase volume attenuation
		jp	p,.sendfmtl				; branch if still positive
		res	chf_enable_bit,(ix+ch_flags)		; stop track
		jr	.nextfm
; ===========================================================================

	.sendfmtl:
		push	bc
		call	SendVoiceTL				; update channel volume
		pop	bc

	.nextfm:
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next track
		djnz	.fmloop					; repeat for all FM tracks
	
		ld	b,countof_music_psg_tracks		; 3 PSG tracks

.psgloop:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nextpsg				; if not, branch
		inc	(ix+ch_volume)				; increase volume attenuation
		ld	a,0Fh+1
		cp	(ix+ch_volume)				; is it greater than 0Fh?
		jp	nc,.sendpsgvol				; branch if not
		res	chf_enable_bit,(ix+ch_flags)		; stop track
		jr	.nextpsg
; ===========================================================================

	.sendpsgvol:
		push	bc
		ld	b,(ix+ch_volume)			; b = ch_volume
    if FixBugs
		ld	a,(ix+ch_vol_env_id)
		or	a					; is this track using envelope 0 (no envelope)?
		call	z,SetPSGVolume				; if so, update ch_volume (this code is normally only run on envelope 1+, so we need to do it here for envelope 0)
    else
		; This code ignores envelopes, breaking fade on envelope-using tracks!
		; (It's also a part of the envelope-processing code, so calling it here is redundant)
		; This is only useful for envelope 0 (no envelope).
		call	SetPSGVolume				; Update ch_volume (ignores current envelope!!!)
    endc
		pop	bc

	.nextpsg:
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next track
		djnz	.psgloop				; repeat for all PSG tracks
		pop	ix
		ret

; ---------------------------------------------------------------------------
; Subroutine to stop FM channels
; ---------------------------------------------------------------------------

FMSilenceAll:
		ld	a,ym_keyonoff				; FM key on/off register
		ld	b,3					; 3 FM channels for each YM2612 part

	.noteoffloop:
		ld	c,b					; c = current key off
		dec	c					; decrement to make channel ID
		rst	WriteFMI				; write key off for part I 
		set t_fmii_bit,c				; set part II select
		rst	WriteFMI				; write key off for part II
		djnz	.noteoffloop				; repeat until all channels are off

		; Write kill-all value to all per-operator registers.
		ld	a,ym_mult_detune			; first per-operator register
		ld	c,0FFh					; dummy kill-all value
		ld	b,countof_peroperatorregs		; write to all per-operator registers

	.channelloop:
		rst	WriteFMI				; write to channels 1-3
		rst	WriteFMII				; write to channels 4-6
		inc	a					; advance to next register
		djnz	.channelloop				; repeat for all registers

		ret

; ---------------------------------------------------------------------------
; Subroutine to stop music
; ---------------------------------------------------------------------------

SoundCmd_Stop:
		xor	a
		ld	(z_abs_vars+f_pause_sound),a		; clear pause flag
		; continue straight into ClearTrackMemory

; ---------------------------------------------------------------------------
; Subroutine to clear all track memory and reset sound hardware
; ---------------------------------------------------------------------------

ClearTrackMemory:
		; Reset YM2612/3438 settings. 
		ld	a,ym_dac_enable				; enable/disable DAC
		ld	c,dac_enable				; enable DAC
		rst	WriteFMI				
		ld	a,c
		ld	(z_abs_vars+f_dac_enabled),a		; set DAC enabled flag
		ld	a,ym_timerctrl_ch3_mode			; timers/FM3 mode register
		ld	c,0					; FM3/FM6 normal mode, timers disabled
		rst	WriteFMI
		
		; Clear all global playback variables and track memory.
		ld	hl,z_abs_vars				; start of global playback variables
		ld	de,z_abs_vars+1				; copy from previous byte to next
		ld	(hl),0					; clear first byte
		ld	bc,(z_tracks_sfx_end-z_abs_vars)-1	; 2B8h bytes total
		ldir						; do it!
	
		; Silence all sound.
		ld	a,com_Null
		ld	(z_abs_vars+v_sound_id),a		; set music to $80 (silence)
		call	FMSilenceAll				; silence FM
		jp	PSGSilenceAll				; silence PSG

; ---------------------------------------------------------------------------
; Subroutine to initialise music
; ---------------------------------------------------------------------------

InitMusicPlayback:
		; This function saves some of the queue/flag items and
		; otherwise resets all music-related playback memory and
		; silences the hardware.  Used prior to playing a new song.
		; Very similar to ClearTrackMemory except that it is
		; specific to the music tracks.

		; Save several values.
		ld	ix,z_abs_vars
		ld	b,(ix+v_priority)			
		ld	c,(ix+f_has_backup)
		push	bc
		ld	b,(ix+f_speedup)
		ld	c,(ix+v_fadein_counter)
		push	bc
		ld	b,(ix+z_queue_0)
		ld	c,(ix+z_queue_1)
		push	bc
    if FixBugs
		; z_queue_2 isn't backed up! This was a bug in Sonic 1's driver as well.
		ld	b,(ix+z_queue_2)
		push	bc
    endc
		; Clear all global playback variables and music tracks.
		ld	hl,z_abs_vars				; start of global playback variables
		ld	de,z_abs_vars+1				; copy from previous byte to next
		ld	(hl),0					; clear first byte
		ld	bc,(z_tracks_end-z_abs_vars)-1		; 1BBh bytes total
		ldir						; do it!

		; Restore the values saved above.
		pop	bc
		ld	(ix+z_queue_0),b
		ld	(ix+z_queue_1),c
    if FixBugs
		; See the fix above.
		pop	bc
		ld	(ix+z_queue_2),b
    endc
		pop	bc
		ld	(ix+f_speedup),b
		ld	(ix+v_fadein_counter),c
		pop	bc
		ld	(ix+v_priority),b
		ld	(ix+f_has_backup),c
		ld	a,com_Null
		ld	(z_abs_vars+v_sound_id),a		; set music to $80 (silence)

    if FixBugs
		; If a music file's header doesn't define each and every channel, they
		; won't be silenced by Sound_PlayBGM.sfxnext, because their tracks aren't
		; properly initialised. This can cause hanging notes. So, we'll set them up
		; properly here.
		ld	ix,z_tracks_start			; start at the first music track
		ld	b,countof_music_tracks			; 7 DAC/FM tracks & 3 PSG tracks
		ld	de,sizeof_trackvars
		ld	hl,FMDACInitBytes			; this will continue into PSGInitBytes

	.loop:
		ld	a,(hl)					; write track's channel byte
		inc	hl
		ld	(ix+ch_type),a				; set channel type while we're at it, so subroutines understand what the track is
		add	ix,de					; advance to next track
		djnz	.loop					; repeat for all tracks

		ret
    else
		; This silences all channels, even those being used by SFX!
		; .sfxnext does the same thing, only better (it doesn't affect SFX channels).
		call	FMSilenceAll
		jp	PSGSilenceAll
    endc

; ---------------------------------------------------------------------------
; Speed	up music
; ---------------------------------------------------------------------------

SoundCmd_Speedup:
		ld	b,80h
		ld	a,(z_abs_vars+f_has_backup)
		or	a					; is 1-up music playing?
		ld	a,(z_abs_vars+v_tempo_speed)
		jr	z,SetTempo				; branch if not
		jr	SetTempo_1Up				; set speed shoes in backed-up vars instead

; ---------------------------------------------------------------------------
; Change music back to normal speed
; ---------------------------------------------------------------------------

SoundCmd_Slowdown:
		ld	b,0
		ld	a,(z_abs_vars+f_has_backup)
		or	a					; is 1-up music playing?
		ld	a,(z_abs_vars+v_tempo_main)
		jr	z,SetTempo				; branch if not
		jr	SetTempo_1Up				; set speed shoes in backed-up vars instead	
; ===========================================================================

SetTempo:
		ld	(z_abs_vars+v_current_tempo),a		; store new tempo value
		ld	a,b
		ld	(z_abs_vars+f_speedup),a		; set or clear speed-up flag
		ret
; ===========================================================================

SetTempo_1Up:
		ld	(z_savevar+v_current_tempo),a		; store new tempo value in backed-up variables (will apply once 1-up music finishes)
		ld	a,b
		ld	(z_savevar+f_speedup),a			; set or clear speed-up flag in backed-up variables
		ret

; ---------------------------------------------------------------------------
; Subroutine to fade in music
; ---------------------------------------------------------------------------

DoFadeIn:
		ld	a,(z_abs_vars+v_fadein_delay)		; get current tick count before next ch_volume increase
		or	a					;has fadein delay expired?
		jr	z,.continuefade				; branch if so
		dec	(ix+v_fadein_delay)			; decrement delay count
		ret
; ===========================================================================

.continuefade:
		ld	a,(z_abs_vars+v_fadein_counter)		; get fade counter
		or	a
		jr	nz,.fadenotdone				; branch if fade isn't done
		ld	a,(z_song_dac+ch_flags)			; get DAC's playback control byte
		and	a,~chf_mask				; clear SFX overriding bit
		ld	(z_song_dac+ch_flags),a			; set it
		xor	a
		ld	(z_abs_vars+f_fadein),a			; clear fade-in flag, allowing SFX to play again
		ret
; ===========================================================================

.fadenotdone:
		dec	(ix+v_fadein_counter)			; decrement fade counter
		ld	(ix+v_fadein_delay),2			; reset fade delay (a bit faster than fading in)
		push	ix
		ld	ix,z_song_fm1				; ix = first FM music track
		ld	b,countof_music_fm_tracks		; 6 FM tracks

.fmloop:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nextfm				; branch if not
		dec	(ix+ch_volume)				; reduce volume attenuation
		push	bc
		call	SendVoiceTL				; update channel volume
		pop	bc

	.nextfm:
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next track
		djnz	.fmloop					; repeat for all FM tracks

		ld	b,countof_music_psg_tracks		; 3 PSG tracks

.psgloop:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nextpsg				; branch if not
		dec	(ix+ch_volume)				; reduce volume attenuation
		push	bc
		ld	b,(ix+ch_volume)			; b = ch_volume
    if FixBugs
		ld	a,(ix+ch_vol_env_id)
		or	a					; is this track using ch_volume envelope 0 (no envelope)?
		call	z,SetPSGVolume				; if so, update ch_volume (this code is only run on envelope 1+, so we need to do it here for envelope 0)
    else
		; This code ignores envelopes, breaking fade on envelope-using tracks!
		; (It's also a part of the envelope-processing code, so calling it here is redundant)
		; This is only useful for envelope 0 (no envelope).
		call	SetPSGVolume				; Update ch_volume (ignores current envelope!)
    endc
		pop	bc

.nextpsg:
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next track
		djnz	.psgloop				; repeat for all PSG tracks

		pop	ix
		ret

; ---------------------------------------------------------------------------
; Subroutine to play FM note
; ---------------------------------------------------------------------------

FMNoteOn:
		ld	a,(ix+ch_flags)				; get playback control byte
		and	a,chf_rest|chf_mask
		ret	nz					; exit if track is at rest or if SFX is overriding
		ld	a,(ix+ch_type)				; get voice control byte
		or	a,all_opers				; note on on all operators
		ld	c,a	
		ld	a,ym_keyonoff				; FM key on/off register
		rst	WriteFMI
		ret

; ---------------------------------------------------------------------------
; Subroutine to stop FM note
; ---------------------------------------------------------------------------

FMNoteOff:
		ld	a,(ix+ch_flags)				; get playback control byte
		and	a,chf_mask|chf_tie
		ret	nz					; exit if track is at rest or if SFX is overriding
		ld	a,ym_keyonoff				; FM key on/off register
		ld	c,(ix+ch_type)				; voice control byte used as input (upper four bits clear will key all operators off)
		rst	WriteFMI
		ret
		
; ---------------------------------------------------------------------------
; Subroutine bankswitch to the music banks 
; ---------------------------------------------------------------------------

BankSwitchToMusic:
		ld	a,(z_abs_vars+v_bank_number)		; get bank number
		or	a
		jr	nz,.bank_2				; branch if we're switching to bank 2

		bankswitch MusicPoint1
		ret

	.bank_2:
		bankswitch MusicPoint2
		ret

; ---------------------------------------------------------------------------
; Subroutine to handle track commands

; input: 
;	a = command ID
; ---------------------------------------------------------------------------

SongCommand:
		sub	a,_firstCom
    if OptimizeSoundDriver
		ld	c,a					; multiply by 3 to allow removal of padding
		add	a,a
		add	a,c	
    else
		add	a,a					; multiply by 4, skipping past padding
		add	a,a
    endc
		ld	(SongCommandTable+1),a			; store into the instruction after SongCommandTable (self-modifying code)
		ld	a,(hl)					; get input value if command requires it
		inc	hl					; next byte in bytecode (the command handler will undo this if command takes no input)

SongCommandTable:
		jr	*					; jump to the command pointer (self-modified from above)
		
GenComJump:	macro	name1,name2
		jp	SongCom_\name1				; jump to the command code
		
  		if OptimizeSoundDriver=0
  		; Pad each table entry to 4 bytes; this is a leftover from Sonic 1,
  		; where this table consisted of bra.w instructions that were four
  		; bytes each. 
		db	0 
  		endc
		endm
				
		TrackCommand	GenComJump			; generate jumps for all commands	

; ---------------------------------------------------------------------------
; Track command: panning

; input: 
;	a = new pan value
; ---------------------------------------------------------------------------

SongCom_Pan:
		; Note that the AMS and FMS bits are saved; this command was only meant to
		; change the panning of a given channel.
		bit	t_psgtrk_bit,(ix+ch_type)		; is this a PSG track?
		ret	m					; if so, exit
    if FixBugs=0
		; This check is in the wrong place. If this command is triggered by a music track 
		; while it's being overridden by SFX, it will use the old panning when the SFX ends.
		; This is because ch_ams_fms_pan doesn't get updated.
		bit chf_mask_bit,(ix+ch_flags)			; is this track being overridden by SFX?
		ret	nz					; if so, exit
    endc
		ld	c,a					; c = new pan value
		ld	a,(ix+ch_ams_fms_pan)			; get current AMS/FMS/panning
		and	a,ams_settings|fms_settings		; retain AMS and FMS bits
		or	a,c					; mask in new pan value
		ld	(ix+ch_ams_fms_pan),a			; store value
    if FixBugs
		; The check should only stop hardware access, like this.
		; This keeps the panning value updated.
		bit chf_mask_bit,(ix+ch_flags)			; is this track being overridden by SFX?
		ret	nz					; if so, exit
    endc
		ld	c,a					; a -> c (YM2612 data write)
		ld	a,(ix+ch_type)				; get voice control byte
		and	a,t_fm_assignment			; only need channel assignment
		add	a,ym_ams_fms_pan			; add AMS/FMS/pan register value
		rst	WriteFMIorII
		ret

; ---------------------------------------------------------------------------
; Track command: detune

; More or less a pitch bend; applied to the frequency as a signed value.

; input: 
;	a = new detune value
; ---------------------------------------------------------------------------

SongCom_DetuneSet:
		ld	(ix+ch_detune),a			; set detune value
		ret

; ---------------------------------------------------------------------------
; Track command: timing/coordination (unused)

; Used for coordinating music with gameplay (not used in any of 
; the Sonic games.)

; input: 
;	a = new timing value
; ---------------------------------------------------------------------------

SongCom_Timing:
		ld	(z_abs_vars+v_timing),a			; set communication byte to parameter
		ret

; ---------------------------------------------------------------------------
; Track command: return from jump
; ---------------------------------------------------------------------------

SongCom_Ret:
		ld	c,(ix+ch_stackptr)			; c = track stack pointer
		ld	b,0					; b = 0
		push	ix
		pop	hl					; hl = start of track ram
		add	hl,bc					; hl = location of return address on track's stack
		ld	a,(hl)					; a = low byte of address 
		inc	hl
		ld	h,(hl)					; h = high byte of pointer
		ld	l,a					; hl = address popped from track stack
		inc	c
		inc	c
		ld	(ix+ch_stackptr),c			; free up space on stack
		ret

; ---------------------------------------------------------------------------
; Track command: fade-in to previous song

; Undoes the backup of variables and track RAM done by Sound_PlayBGM; and 
; sets up the previous song to fade back in.
; ---------------------------------------------------------------------------

SongCom_RestoreSong:
		ld	hl,v_backup_ram				; copy from backup ram
		ld	de,z_abs_vars				; copy to the global playback variables and music track RAM
		ld	bc,z_tracks_save_end-v_backup_ram	; 1BCh bytes total
		ldir

		call	BankSwitchToMusic			; bankswitch to the music
		ld	a,(z_song_dac+ch_flags)			; get DAC's playback control byte
		or	a,chf_mask
		ld	(z_song_dac+ch_flags),a			; set SFX override bit (not exactly the intended use, but will work to keep the DAC silenced while fading in)
		ld	a,(z_abs_vars+v_fadein_counter)		; get fade counter
		ld	c,a
		ld	a,28h
		sub	a,c					; if a fade is already in progress, adjust the initial track volume so fade-ins don't overlap
		ld	c,a					
		ld	b,countof_music_fm_tracks		; 6 FM tracks 
		ld	ix,z_song_fm1				; ix = first FM music track

.fmloop:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nextfm				; if not, branch
		set	chf_rest_bit,(ix+ch_flags)		; set track at rest bit
		ld	a,(ix+ch_volume)			; get channel volume
		add	a,c					; apply current volume fade-in
		ld	(ix+ch_volume),a	
    if OptimizeSoundDriver=0
		; This bit is always cleared (see Sound_PlayBGM).
		bit chf_mask_bit,(ix+ch_flags)			; is track being overridden by SFX?
		jr	nz,.nextfm				; if so, branch
    endc
		push	bc
		ld	a,(ix+ch_voice)				; get voice
		call	SetVoiceMusic				; update voice and set volume
		pop	bc

	.nextfm:
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next track
		djnz	.fmloop					; repeat for all FM tracks

		ld	b,countof_music_psg_tracks		; 3 PSG tracks

.psgloop:
		bit	chf_enable_bit,(ix+ch_flags)		; is track playing?
		jr	z,.nextpsg				; if not, branch
		set	chf_rest_bit,(ix+ch_flags)		; set track at rest
		call	PSGNoteOff				; silence PSG channel
		ld	a,(ix+ch_volume)			; get channel volume
		add	a,c					; apply current volume fade-in
		ld	(ix+ch_volume),a

    if FixBugs
		; Restore PSG noise type.
		ld	a,(ix+ch_type)
		cp	tPSG4					; is this the noise channel?
		jr	nz,.nextpsg				; if not, branch
		ld	a,(ix+ch_noisemode)
		ld	(zPSG),a				; restore Noise setting
    endc

	.nextpsg:
		ld	de,sizeof_trackvars
		add	ix,de					; advance to next tracz
		djnz	.psgloop				; repeat for all FM tracks...

		ld	a,80h
		ld	(z_abs_vars+f_fadein),a			; set fade-in flag
		ld	a,28h
		ld	(z_abs_vars+v_fadein_counter),a		; 28h increments total for fade-in
		xor	a
		ld	(z_abs_vars+f_has_backup),a		; clear 1-up playing flag
		ld	a,(z_abs_vars+f_dac_enabled)		; clear DAc enabled flag
		ld	c,a
		ld	a,ym_dac_enable
		rst	WriteFMI				; disable DAC on 
		pop	bc
		pop	bc
		pop	bc					; tamper with return value so we do not return to caller
		jp	UpdateDAC

; ---------------------------------------------------------------------------
; Track command: change tempo divisor of one track

; input: 
;	a = new tempo divisor
; ---------------------------------------------------------------------------

SongCom_ChannelTick:
		ld	(ix+ch_tick),a				; set tempo divider on this track only
		ret
		
; ---------------------------------------------------------------------------
; Track command: change FM channel volume

; input: 
;	a = delta to new volume
; ---------------------------------------------------------------------------

SongCom_VolAddFM:
		add	a,(ix+ch_volume)			; add current volume to get new volume
		ld	(ix+ch_volume),a			; store
		jp	SendVoiceTL				; set new volume
		
; ---------------------------------------------------------------------------
; Track command: do not attack next note
; ---------------------------------------------------------------------------

SongCom_Tie:
		set	chf_tie_bit,(ix+ch_flags)		; set 'do not attack next note' bit
		dec	hl					; put byte read back (no input for this command)
		ret

; ---------------------------------------------------------------------------
; Track command: set note fill value

; input: 
;	a = new note fill value
; ---------------------------------------------------------------------------

SongCom_Gate:
		ld	(ix+ch_gate),a				; note fill value (modifiable)
		ld	(ix+ch_savedgate),a			; note fill value (master copy, rewrites ch_gate when necessary)
		ret

; ---------------------------------------------------------------------------
; Track command: change transposition

; input: 
;	a = delta to new transposition
; ---------------------------------------------------------------------------

SongCom_TransAdd:
		add	a,(ix+ch_transpose)			; add to current transpose value to get new value
		ld	(ix+ch_transpose),a			; store
		ret
		
; ---------------------------------------------------------------------------
; Track command: set tempo

; input: 
;	a = new tempo value
; ---------------------------------------------------------------------------

SongCom_TempoSet:
		ld	(z_abs_vars+v_current_tempo),a		; set tempo
		ret
		
; ---------------------------------------------------------------------------
; Track command: change tempo divisor of all tracks

; input: 
;	a = new tempo divisor
; ---------------------------------------------------------------------------

SongCom_SongTick:
		push	ix					; back up ix
		ld	ix,z_tracks_start			; ix = start of music tracks
		ld	de,sizeof_trackvars			; track size
		ld	b,countof_music_tracks			; all 10 music tracks

.trackloop:
		ld	(ix+ch_tick),a				; set timing divisor on ALL tracks; this can result in total half-speed, quarter-speed, etc.
		add	ix,de
		djnz	.trackloop

		pop	ix					; restore ix
		ret
		
; ---------------------------------------------------------------------------
; This controls which TL registers are set for a particular algorithm; 
; it actually makes more sense to look at a FMSlotMask entry as a bitfield.
; Bits 0-4 set which TL operators are actually affected for setting a channel 
; volume.
; ---------------------------------------------------------------------------
		ensure1byteoffset 8
FMSlotMask:
		db	  8, 8, 8, 8, 0Ch, 0Eh, 0Eh ,0Fh
		
; ---------------------------------------------------------------------------
; Track command: change PSG channel volume

; input: 
;	a = delta to new volume
; ---------------------------------------------------------------------------

SongCom_VolAddPSG:
		add	a,(ix+ch_volume)			; add to channel ch_volume
		ld	(ix+ch_volume),a			; store updated ch_volume
		ret

; ---------------------------------------------------------------------------
; This used to be Sonic 1's SongCom_ClearPush. The push SFX feature (used 
; when pushing blocks in MZ) was initially retained when the driver was 
; ported to Z80, but eventually removed in Beta 5. This broken code is all 
; that's left of it.
; ---------------------------------------------------------------------------

SongCom_ClearPush:
    if (OptimizeSoundDriver=0)&(FixBugs=0)
		; Dangerous!  It doesn't put back the byte read, meaning one gets skipped!
		ret
    endc

; ---------------------------------------------------------------------------
; This used to be Sonic 1's SongCom_EndBack. But the Special SFX function 
; wasn't ported.
; ---------------------------------------------------------------------------

SongCom_EndBack:
		dec	hl					; put back byte; does nothing
		ret

; ---------------------------------------------------------------------------
; Track command: set FM voice

; input: 
;	a = new voice
; ---------------------------------------------------------------------------

SongCom_Voice:
		ld	(ix+ch_voice),a				; set new voice in track variables
		ld	c,a					; back it up in c 
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding?	
		ret	nz					; if so, exit
		push	hl					; back up hl
		call	SetNewVoice				; set the new voice
		pop	hl					; restore hl
		ret
; ===========================================================================

SetNewVoice:
		ld	a,(f_sfx)				; get SFX flag
		or	a
		ld	a,c					; restore a
		jr	z,SetVoiceMusic				; branch if SFX flag was not set (set 'hl' to v_music_voice_table)
		ld	l,(ix+ch_voice_ptr_low)			; get low byte of custom voice table
		ld	h,(ix+ch_voice_ptr_high)		; get high byte of custom voice table
		jr	SetVoice
; ===========================================================================

SetVoiceMusic:
		ld	hl,(z_abs_vars+v_music_voice_table)	; hl = music voice table pointer
		; Continue into SetVoice.

; ---------------------------------------------------------------------------
; Subroutine to set a new FM voice (aka, FM patch)

; input: 
;	a = voice index to set
;	hl = voice table pointer
; ---------------------------------------------------------------------------
SetVoice:
    if OptimizeSoundDriver
    	; This is a slower but much more compact way to multiply by 25.
		ld	e,a
		ld	d,0					; de = a

		ld	b,25

	.voicemultiply:
		add	hl,de					; add de to hl
		djnz	.voicemultiply				; repeat 25 times
    else
    	; The following is a crazy block designed to 'multiply' the target voice value by 25,
		; the length of a single voice.
		push	hl					; push 'hl' for the end of the following block...
		ld	c,a					; a = c
		ld	b,0					; b = 0 (so only low byte of 'bc' is set, basically voice to set)
		add	a,a					; multiply a by 2
		ld	l,a					; l = a
		ld	h,b					; h = 0
		add	hl,hl					; multiply hl by 4
		add	hl,hl
		ld	e,l
		ld	d,h					; de = hl
		add	hl,hl					; multiply hl by 2
		add	hl,de					; add de to hl
		add	hl,bc					; add bc to hl, making final index
		pop	de					; pop table pointer address into de
		add	hl,de					; add to index to get pointer to voice
    endc

		; Set up a value for setting the total level.
		ld	a,(hl)					; a = feedback/algorithm
		inc	hl					; next byte of voice
		ld	(.a_backup+1),a				; self-modified code: enables 'a' to be restored later
		ld	c,a
		ld	a,(ix+ch_type)				; get voice control byte
		and	a,t_fm_assignment			; only need assignment bits
		add	a,ym_algorithm_feedback			; add register base to get appropriate feedback/algorithm register
		rst	WriteFMIorII				; write new value

		; ch_detune/coarse freq, all channels
		sub	a,ym_algorithm_feedback-ym_mult_detune	; subtract 80h to get frequency multiplier and detune register
		ld	b,countof_operators			; set all four operators 

	.detuneloop:
		ld	c,(hl)					; get ch_detune/coarse freq for this operator
		inc	hl					; next voice byte
		rst	WriteFMIorII				; write to YM2612/3438
		add	a,next_operator				; next ch_detune/coarse freq register
		djnz	.detuneloop				; repeat for all operators

		push	af					; back up a for much later (will be restored when time to set TL)

		add	a,ym_attack_scaling-ym_total_level	; skip over the TL registers for now
		ld	b,(ym_ssg_eg-ym_attack_scaling)/countof_operators ; 16 writes total (all per-operator registers up to but not including ym_ssg_eg)

	.registerloop:
		ld	c,(hl)					; get next reg data value
		inc	hl					; next voice byte
		rst	WriteFMIorII				; write to FM
		add	a,4					; advance to next register
		djnz	.registerloop				; repeat for all registers

		; Now going to set "stereo output control and LFO sensitivity."
		add	a,ym_ams_fms_pan-ym_ssg_eg		; set to AMS/FMS/pan register
		ld	c,(ix+ch_ams_fms_pan)			; get AMS/FMS/pan settings
		rst	WriteFMIorII				; write to FM
		ld	(ix+ch_tl_ptr_low),l			; save current position
		ld	(ix+ch_tl_ptr_high),h

	.a_backup:
		ld	a,0					; self-modified code: 'a' will actually be set to the feedback/algorithm byte
		and	a,ym_algo				; only need algorithm bits
		add	a,FMSlotMask&0FFh			; add offset to FMSlotMask table (low byte only)
		ld	e,a					; get low byte
		ld	d,(FMSlotMask&0FF00h)>>8		; get high byte 
		ld	a,(de)					; get appropriate FMSlotMask value
		ld	(ix+ch_vol_tl_mask),a			; store in track ram
		ld	e,a					; also place it in e
		ld	d,(ix+ch_volume)			; d = channel volume
		pop	af					; restore a; a = first TL register
		; Continue into SetFMTLs.

; ---------------------------------------------------------------------------
; Subroutine to write TLs for all operators of a given channel

; input: 
;	hl = pointer to TL bytes
; ---------------------------------------------------------------------------

SetFMTLs:
		ld	b,countof_operators			; set all four operators

	.loop:
		ld	c,(hl)					; get next TL byte -> c
		inc	hl					; next voice byte
		rr	e					; rotate FMSlotMask right
		jr	nc,.write				; branch if bit 0 was clear prior to the rotate (write the TL value directly without modifying it)

		; Otherwise, apply channel volume to TL here.
		; It's not appropriate to alter ALL TL values, only
		; the ones which are "slots" (output operators).
		push	af					; save 'a'
    if FixBugs
		res	7,c
    endc
		ld	a,d					; d = channel volume
		add	a,c					; add it to the TL value
    if FixBugs
		; Prevent attenuation overflow (otherwise known as volume underflow)
		jp	p,.belowmax				; branch if attenuation overflowed
		ld	a,tl_silence				; limit attenuation to 7Fh

	.belowmax:
    endc
		ld	c,a					; c = modified TL value
		pop	af					; restore 'a'

	.write:
		rst	WriteFMIorII				; write TL value
		add	a,next_operator				; advance to next TL reg
		djnz	.loop					; repeat for all operators

		ret

; ---------------------------------------------------------------------------
; Subroutine to prepare setting TLs. Used by fade out, fade in, and FM volume
; add commands.
; ---------------------------------------------------------------------------

SendVoiceTL:
		bit	t_psgtrk_bit,(ix+ch_type)		; is this a PSG track?
		ret	nz					; if so, exit
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding?
		ret	nz					; if so, exit
		ld	e,(ix+ch_vol_tl_mask)			; get slot mask
		ld	a,(ix+ch_type)				; get voice control byte
		and	a,t_fm_assignment			; only need channel assignment
		add	a,ym_total_level			; add 40h to get TL register for channel
		ld	d,(ix+ch_volume)			; get track volume
		bit	7,d	
		ret	nz					; exit if it's negative
		push	hl					; back up hl
		ld	l,(ix+ch_tl_ptr_low)			; low byte of TL bytes pointer
		ld	h,(ix+ch_tl_ptr_high)			; low byte of TL bytes pointer
		call	SetFMTLs				; set the TLs
		pop	hl					; restore hl
		ret
		
; ---------------------------------------------------------------------------
; Track command: set up vibrato/modulation
; ---------------------------------------------------------------------------

SongCom_Vib:
		set	chf_vib_bit,(ix+ch_flags)		; enable modulation
		dec	hl					; put byte read back (no input for this command)
		ld	(ix+ch_vibptr_low),l			; save pointer to modulation data
		ld	(ix+ch_vibptr_high),h
		; Continue into SetModulation

; ---------------------------------------------------------------------------
; Subroutine to set vibrato/modulation

; input: 
;	hl = pointer to configuration data
; ---------------------------------------------------------------------------
	
SetModulation:
		; Set de to point to the track's modulation variables.
		ld	a,ixl					; get low byte of current track's RAM base
		add	a,ch_vib_delay				; add 13h
		ld	e,a					; store in e
		adc	a,ixh					; if carry occurred, add that to the upper byte
		sub	a,e					; subtract e
		ld	d,a					; de = ix+ch_vib_delay

    if OptimizeSoundDriver
		ld	bc,3					; three bytes total
		ldir						; copy modulation delay, speed, and delta to their respective variables
    else
		ldi						; copy modulation delay
		ldi						; copy modulation speed
		ldi						; copy modulation delta
    endc
		ld	a,(hl)					; get modulation steps
		inc	hl					; next byte
		srl	a					; divide number of steps by 2
		ld	(ix+ch_vib_steps),a			; store
		bit	chf_tie_bit,(ix+ch_flags)		; is 'do not attack next note' set?
		ret	nz					; if so, exit
		xor	a
		ld	(ix+ch_vibfreq_low),a			; clear modulation value
		ld	(ix+ch_vibfreq_high),a
		ret

; ---------------------------------------------------------------------------
; Track command: enable vibrato/modulation
; ---------------------------------------------------------------------------

SongCom_VibOn:
		dec	hl					; put byte read back (no input for this command)
		set	chf_vib_bit,(ix+ch_flags)		; set "modulation on" bit
		ret

; ---------------------------------------------------------------------------
; Track command: end of track
; ---------------------------------------------------------------------------

SongCom_End:
		res	chf_enable_bit,(ix+ch_flags)		; track is no longer playing
		res	chf_tie_bit,(ix+ch_flags)		; clear 'do not attack next note' bit
		bit	t_psgtrk_bit,(ix+ch_type)		; is this a PSG track?
		jr	nz,.stoppsg				; if so, branch
		ld	a,(z_abs_vars+f_updating_dac)		
		or	a					; is this the DAC track?
		jp	m,.stopdac				; if so, branch
		call	FMNoteOff				; if we're here, this is an FM track
		jr	.stoppedchannel
; ===========================================================================

.stoppsg:
		call	PSGNoteOff

.stoppedchannel:			
		ld	a,(f_sfx)
		or	a					; is this an SFX that's stopping?
		jp	p,.stopmusic				; branch if not
		
	;.stop_sfx:	
		xor	a
		ld	(z_abs_vars+v_priority),a		; clear SFX priority
		ld	a,(ix+ch_type)				; get voice control byte
		or	a
		jp	m,.getpsgptr				; branch if this is a PSG SFX track
		
	;stop_sfxfm:	
		push	ix					; save ix
		sub	a,2					; SFX can only use FM3 and up
		add	a,a					; multiply by 2 to get index
		add	a,SFX_BGMChannelRAM&0FFh		; add low byte of SFX_BGMChannelRAM start address
		ld	(.gotpointer+2),a			; store into the instruction after .gotpointer (self-modifying code)


	.gotpointer:
		ld	ix,(SFX_BGMChannelRAM)			; self-modified code from just above: ix = corresponding music FM track
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding?
		jp	z,.novoiceupd				; branch if not
		call	BankSwitchToMusic			; bank switch to the music tracks
		res chf_mask_bit,(ix+ch_flags)			; clear 'SFX overriding' bit 
		set	chf_rest_bit,(ix+ch_flags)		; set track rest bit
		ld	a,(ix+ch_voice)				; get current voice
		call	SetVoiceMusic				; restore it and set volume

		bankswitch SoundIndex				; bankswitch to sound effects

	.novoiceupd:
		pop	ix					; restore ix
		pop	bc					; do not return to coord flag loop
		pop	bc					; do not return to FMUpdateTrack
		ret
; ===========================================================================

.getpsgptr:
		push	ix					; save ix
		rra						; shift right by 4 to get PSG index
		rra
		rra
		rra	
		and	a,0Fh
		add	a,SFX_BGMChannelRAM&0FFh		; add low byte of SFX_BGMChannelRAM start address
		ld	(.gotchannelptr+2),a			; store into the instruction after .gotchannelptr (self-modifying code)

	.gotchannelptr:
		ld	ix,(SFX_BGMChannelRAM)			; self-modified code from just above: 'ix' points to corresponding music PSG track
		res chf_mask_bit,(ix+ch_flags)			; clear 'SFX overriding' bit 
		set	chf_rest_bit,(ix+ch_flags)		; set track rest bit
		ld	a,(ix+ch_type)				; get voice control byte
		cp	tPSG4					; is this the noise channel?
		jr	nz,.exit				; branch if not
		ld	a,(ix+ch_noisemode)			; get noise mode
		ld	(zPSG),a				; set it

.exit:
		pop	ix					; restore 'ix'

.stopmusic:
		pop	bc					; do not return to coord flag loop

; zloc_F76
.stopdac:
		pop	bc					; do not return to FMUpdateTrack, PSGUpdateTrack (anything other than DAC) or to coord flag loop (if DAC)
		ret

; ---------------------------------------------------------------------------
; Track command: set PSG noise mode
; ---------------------------------------------------------------------------

SongCom_NoiseSet:
		ld	(ix+ch_type),tPSG4			; turn into noise channel
		ld	(ix+ch_noisemode),a			; save noise mode for restoration if SFX overrides it
		bit chf_mask_bit,(ix+ch_flags)			; is SFX overriding?
		ret	nz					; if so, exit
		ld	(zPSG),a				; otherwise, set it
		ret

; ---------------------------------------------------------------------------
; Track command: disable vibrato/modulation
; ---------------------------------------------------------------------------

SongCom_VibOff:
		dec	hl					; put byte read back (no input for this command)
		res	chf_vib_bit,(ix+ch_flags)		; clear "modulation on" bit
		ret
		
; ---------------------------------------------------------------------------
; Track command: set PSG envelope

; input: 
;	a = new envelope ID
; ---------------------------------------------------------------------------

SongCom_Env:
		ld	(ix+ch_vol_env_id),a			; set current envelope
		ret

; ---------------------------------------------------------------------------
; Track command: jump

; input: 
;	a = low byte of destination
; ---------------------------------------------------------------------------

SongCom_Jump:
		ld	h,(hl)					; get high byte of jump destination (since pointer advanced to it)
		ld	l,a					; put low byte
		ret

; ---------------------------------------------------------------------------
; Track command: loop

; input: 
;	a = loop index (see below)
;	hl = pointer to rest of loop data 

; data format: $F7XXYYZZZZ
;	xx = loop index (offset within ch_loopcounters, allowing nested loops)
;	yy = number of times to repeat (including the first run)
;	zzzz = position to loop back to
; ---------------------------------------------------------------------------

SongCom_Loop:
		ld	c,(hl)					; c = number of repeats
		inc	hl					; next byte
		push	hl					; back up hl
		add	a,ch_loopcounters			; add to make loop counter offset (starts at 20h in track memory)
		ld	l,a
		ld	h,0					; hl = loop counter offset
		ld	e,ixl					; de = beginning of track memory
		ld	d,ixh
		add	hl,de					; hl = track memory offset for this loop
		ld	a,(hl)
		or	a					; has this loop already started?
		jr	nz,.loopexists				; branch if so
		ld	(hl),c					; initialize repeat count

.loopexists:
		dec	(hl)					; decrement loop counter
		pop	hl					; restore hl
		jr	z,.noloop				; branch if we've reached zero
		
		; If not zero, branch back to start of loop
		ld	a,(hl)					; get low byte of jump destination
		inc	hl
		ld	h,(hl)					; get high byte of jump destination
		ld	l,a					; put low byte
		ret
; ===========================================================================

.noloop:
		inc	hl					; skip over the target address
		inc	hl
		ret
		
; ---------------------------------------------------------------------------
; Track command: jump, saving position for return

; input: 
;	a = low byte of destination
; ---------------------------------------------------------------------------

SongCom_Call:
		ld	c,a					; c = low byte of destination
		ld	a,(ix+ch_stackptr)			; get current stack pointer
		sub	a,2					; add space for another target
		ld	(ix+ch_stackptr),a
		ld	b,(hl)					; bc = destination of jump
		inc	hl					; hl = return address
		ex	de,hl					; swap hl and de
		add	a,ixl					; add low byte of current track pointer to stack offset (low byte of stack location)
		ld	l,a
		adc	a,ixh
		sub	a,l
		ld	h,a					; hl = current stack pointer
		ld	(hl),e					; store return address low byte
		inc	hl
		ld	(hl),d					; Store return address high byte
		ld	h,b
		ld	l,c					; hl = destination of jump
		ret

; ---------------------------------------------------------------------------
; Unused Sonic 1 leftover. This was used in Spring Yard Zone's music to 
; quickly release operators 3 and 4.
; ---------------------------------------------------------------------------

SongCom_Release34:
		ld	a,ym_releaserate_sustainlevel+ym_1_4_op3 ; D1L/RR of operator 3
		ld	c,0Fh					; loaded with fixed value (max RR, 1TL)
		rst	WriteFMI				; written to part I
		ld	a,ym_releaserate_sustainlevel+ym_1_4_op4 ; D1L/RR of Operator 4
		ld	c,0Fh					; loaded with fixed value (max RR, 1TL)
		rst	WriteFMI				; written to part I
		dec	hl					; put byte read back (no input for this command)
		ret

; ---------------------------------------------------------------------------
; Priority table
; ---------------------------------------------------------------------------

GenPriority:	macro	name,priority
		db \priority
		endm
		
SFXPriorities:		
		SFXFiles	GenPriority			; generate the SFX priority list

; ---------------------------------------------------------------------------
; Envelope pointer list
; ---------------------------------------------------------------------------
		
GenEnvTable:	macro	name
		numstr: substr 1,2,"\name"			; get digits for constant
		dw EnvData_\numstr\				; create a pointer for every envelope
		endm		

Envelopes:
		VolumeEnv	GenEnvTable			; generate the envelope pointers

; ---------------------------------------------------------------------------
; Envelope includes
; ---------------------------------------------------------------------------

EnvData_01:
		db	0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5
		db	5,5,6,6,6,7,80h

EnvData_02:
		db	0,2,4,6,8,10h,80h

EnvData_03:
		db	0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,80h

EnvData_04:
		db	0,0,2,3,4,4,5,5,5,6,80h

EnvData_06:
		db	3,3,3,2,2,2,2,1,1,1,0,0,0,0,80h

EnvData_05:
		db	0,0,0,0,0,0,0,0,0,0,1,1
		db	1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2
		db	2,2,2,2,3,3,3,3,3,3,3,3,4,80h

EnvData_07:
		db	0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2
		db	3,3,3,4,4,4,5,5,5,6,7,80h

EnvData_08:
		db	0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2
		db	3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6
		db	6,6,6,6,7,7,7,80h

EnvData_09:
		db	0,1,2,3,4,5,6,7,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh,80h

EnvData_0A:
		db	0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
		db	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		db	1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2
		db	2,2,3,3,3,3,3,3,3,3,3,3,4,80h

EnvData_0B:
		db	4,4,4,3,3,3,2,2,2,1,1,1,1,1,1,1
		db	2,2,2,2,2,3,3,3,3,3,4,80h

EnvData_0C:
		db	4,4,3,3,2,2,1,1,1,1,1,1,1,1,1,1
		db	1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2
		db	2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3
		db	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
		db	3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4
		db	4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5
		db	5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6
		db	6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,80h

EnvData_0D:
		db	0Eh,0Dh,0Ch,0Bh,0Ah,9,8,7,6,5,4,3,2,1,0,80h

; ---------------------------------------------------------------------------
; Master playlist
; ---------------------------------------------------------------------------

MasterPlaylist: macro  name,tempo,flag
		
		if ~def(zptr_id)
			zptr_id: = 80h
		endc
		
		db	ptr_musfile_\1\+\flag			; generate playlist entry with value generated by sndbnk_ptr macro plus flag value if applicable
		zptr_mus_\1\: equ zptr_id			; generate signed byte constant for use in sound driver
		
		zptr_id: = zptr_id+1				; increment pointer value
	endm	

MusicIndex:		
		MusicFiles	MasterPlaylist			; generate playlist entries and Z80 constants

; ---------------------------------------------------------------------------
; Speed shoes tempo table
; ---------------------------------------------------------------------------

GenSpeedup:	macro	name,tempo,flag
		db \tempo
		endm
		
SpeedUpIndex:
		MusicFiles	GenSpeedup			; generate the speed shoes tempo list	

; ---------------------------------------------------------------------------
; DAC sample metadata
; ---------------------------------------------------------------------------
		
		ensure1byteoffset 1Ch

zsample:	macro	sample
		dw	zbankptr_\sample
		dw	sizeof_\sample
		endm

DACPtrTbl:
		zsample	DAC_Kick
		zsample	DAC_Snare
		zsample	DAC_Clap
		zsample	DAC_RecordScratch
		zsample	DAC_Timpani			
		zsample DAC_Tom			
		zsample	DAC_VLowClap			

; ---------------------------------------------------------------------------
; DAC sample playlist
; ---------------------------------------------------------------------------

		ensure1byteoffset 22h
		
GenDacPlaylist:	macro	name,src,pitch
	
	ifarg \src						; if this is a duplicate with a different pitch
		db	d\src,\pitch
	else
		db	d\name,\pitch	
	endc	
	endm					
		
DACMasterPlaylist:
		DefineSamples	GenDacPlaylist			; generate the DAC playlist

; ---------------------------------------------------------------------------
; Saxman Decompression algorithm 

; input:
;	hl = source address (in this case, compressed bytecode in the ROM window)
; ---------------------------------------------------------------------------

SaxDec_Z80:
    if OptimizeSoundDriver
		xor	a
		ld	b,a
		ld	d,a
		ld	e,a
    else
		exx
		ld	bc,0
		ld	de,0
    endc
		exx
		ld	de,z_music_data				; destination address
		ld	c,(hl)
		inc	hl
		ld	b,(hl)					; bc = size of compressed data
		inc	hl
		ld	(zSaxDec_GetByte+1),hl			; self-modified code: set to beginning of decompression stream
    if OptimizeSoundDriver=0
    	; An optimization in zSaxDec_CheckNextByte renders this unnecessary.
		inc	bc
    endc
		ld	(zSaxDec_CheckNextByte+1),bc		; self-modified code: set to length of song (plus 1 if optimizations are disabled)

SaxReadLoop:
		exx						; swap to shadow registers
    if OptimizeSoundDriver
    	; Slightly rework the read loop so that the shift of the descriptor bits is used 
    	; to determine compressed vs uncompressed.
		srl	b					; shift descriptor bit flags
		jr	c,.skip_fetching_descriptor		; branch if we still have bits left

		call	zSaxDec_CheckNextByte			; get next byte of descriptor bits
		ld	c,a					; put it in c
		ld	b,7Fh					; 7 new bits in c (first one will be used below)

	.skip_fetching_descriptor:
		srl	c					; shift to next descriptor bit (carry flags set)
		exx						; normal reg set
		jr	nc,zSaxDec_ReadCompressed		; branch if it's a compressed byte	
    else
		srl	c					; shift to next descriptor bit
		srl	b					; shift descriptor bit flags
		bit	0,b					; have we run out of bits?
		jr	nz,.skip_fetching_descriptor		; branch if not

		call	zSaxDec_CheckNextByte			; get next byte of descriptor bits
		ld	c,a					; put it in c
		ld	b,0FFh					; 8 new bits in c

.skip_fetching_descriptor:
		bit	0,c					; test current descriptor bit
		exx						; swap to normal registers 
		jr	z,zSaxDec_ReadCompressed		; branch if this is a compressed byte
    endc
    
;read_uncompressed:
		call	zSaxDec_CheckNextByte			; get uncompressed byte
		ld	(de),a					; write to destination
		inc	de					; increment destination pointer
		exx						; shadow reg set
		inc	de					; also increment relative pointer to destination (used for calculating dictionary match sources)
		exx						; normal reg set
		jr	SaxReadLoop
; ===========================================================================

zSaxDec_ReadCompressed:
		call	zSaxDec_CheckNextByte			; get low byte of target address of match
		ld	c,a					; store in c
		call	zSaxDec_CheckNextByte			; get high byte of target address and length of match
		ld	b,a					; store in b
		and	a,0Fh
		add	a,3					; a = length of match
		push	af					; back up a
		ld	a,b					; a = low byte of target address
		rept 4
		rlca						; shift to lower nybble
		endr	
		and	a,0Fh
		ld	b,a					; b = adjusted low byte of target (only upper four bits of value make up part of the address)
		ld	a,c					; a = high byte of target address
		add	a,12h				
		ld	c,a
		adc	a,b
		sub	a,c
		and	a,0Fh
		ld	b,a					; bc = offset into the decompressed data
		pop	af					; restore a
		exx						; shadow reg set
		push	de					; back up de (relative pointer to destination)
		ld	l,a					; hl = length of match
		ld	h,0
		add	hl,de					; update relative pointer by adding length of match
		ex	de,hl					; de = updated relative pointer
		exx						; normal reg set
		pop	hl					; hl = previous relative pointer to destination
		or	a					; clear carry flag
		sbc	hl,bc					; subtract offset from relative pointer
		jr	nc,zSaxDec_IsMatch			; branch if positive (dictionary match)

;is_zeros:		
		ex	de,hl					; hl = absolute pointer to destination
		ld	b,a					; b = length of zero-fill match

	.fillzeros:
		ld	(hl),0					; write zeros for length of match
		inc	hl
		djnz	.fillzeros

		ex	de,hl					; update absolute pointer to destination
		jr	SaxReadLoop	
; ===========================================================================

zSaxDec_IsMatch:
		ld	hl,z_music_data				; hl = start of decompressed data
		add	hl,bc					; add offset to get source of match
		ld	c,a					; (de already contains start of destination)
		ld	b,0					; bc = length of match	
		ldir						; copy match to destination
		jr	SaxReadLoop
; ===========================================================================

zSaxDec_CheckNextByte:
		ld	hl,0					; self-modified code: set to number of bytes in compressed data (+1 if unoptimized), counts down to 1 (or zero if optimized)
    if OptimizeSoundDriver
    	; Move this check up here to make exiting decompressor slightly faster, also eliminating the need to add +1
    	; to the size of the compressed data.
		ld	a,h
		or	a,l
		jr	z,zSaxDec_End				; if hl = 0, we are done; exit the decompressor
    endc
		dec	hl					; decrement remaining number of bytes
		ld	(zSaxDec_CheckNextByte+1),hl		; update the count
    if OptimizeSoundDriver=0
		ld	a,h
		or	a,l
		jr	z,zSaxDec_End				; if hl = 0, we are done; exit the decompressor
    endc
; ===========================================================================

zSaxDec_GetByte:
		ld	hl,0					; self-modified code: get address of next byte in compressed data
		ld	a,(hl)					; load it
		inc	hl					; advance to next byte
		ld	(zSaxDec_GetByte+1),hl			; store in above instruction 
		ret
; ===========================================================================

zSaxDec_End:
		pop	hl					; throw away return address from call to zSaxDec_CheckNextByte
		ret						; exit decompressor
; ===========================================================================

		include_global_vars				; include some global driver variables

; End of Z80 'ROM'

		if offset(*)>z_music_data
			inform 3,"Your Z80 code won't fit before the music RAM. It's %hh bytes past the start of music data at %hh",\offset(*)-z_music_data,z_music_data
		endc
