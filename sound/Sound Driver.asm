; Sonic the Hedgehog 2 disassembled Z80 sound driver

; Disassembled by Xenowhirl for AS
; Additional disassembly work by RAS Oct 2008
; RAS' work merged into SVN by Flamewing
; Ported to AXM68K by OrionNavattan October 2022

; This code is compressed in the ROM, but you can edit it here as uncompressed
; and it will automatically be assembled and compressed into the correct place
; during the build process.
;
; This Z80 code can use labels and equates defined in the 68k code,
; and the 68k code can use the labels and equates defined in here.
; This is fortunate, as they contain references to each other's addresses.
;
; If you want to add significant amounts of extra code to this driver,
; try putting your code as far down as possible, after the function zDecEnd.
; That will make you less likely to run into space shortages from dislocated data alignment.

; Note that the Z80 syntax used here is slightly non-standard as of result of how AXM68k works:
; * is used to invoke the current program counter rather than $ in jump instructions,
; offset(*) must be used to invoke the program counter in macro parameters due to the use 
; of ASM68K's section and group functionality, and shadow registers are not indicated 
; with an apostrophe; e.g., ex af,af' is simply written as ex af,af.

; ===========================================================================
; ---------------------------------------------------------------------------
; Macro to perform a bank switch; after using this,
; the start of zROMWindow points to the start of the given 68k address,
; rounded down to the nearest $8000 byte boundary.

; The version of this macro in the AS disassembly generates ld (hl),a or ld (hl),e
; instructions based on the address given as input to the macro. However,
; said macro cannot be directly ported to ASM68K, as it relies on a behavior of AS' 
; comparison operators that is completely different in ASM68K (specifically, true returns 1, 
; false 0; ASM68K returns -1 and 0 for these), nor can we use conditional expressions to 
; generate them, as conditional expressions in ASM68K must evaluate on the first pass.

; Basically, we can't generate them in situ. Instead, the instructions are generated
; and equated to constants by the startbank and bnkswtch_vals macros, and
; this macro simply inserts said constants on the second pass.
; ---------------------------------------------------------------------------

bankswitch:	macro addr68k
		
		cnt: = 0
		ptr_num: = 1

	if OptimizeSoundDriver
		; Because why use a and e when you can use h and l?
		ld	hl,z_bank_select_mirror			; 6001h, mirror of bankswitch register
		rept 9					
		db	bnkswtch_\addr68k\_\$ptr_num\		; include the constants generated by startbank and bnkswtch_vals
		cnt: = cnt+1
		ptr_num: = ptr_num+1
		endr
	else
		xor	a					; a = 0
		ld	e,1					; e = 1
		ld	hl,z_bank_select
		rept 9					
		db	bnkswtch_\addr68k\_\$ptr_num\		; include the constants generated by startbank and bnkswtch_vals
		cnt: = cnt+1
		ptr_num: = ptr_num+1
		endr
	endc	
	endm
	
; ---------------------------------------------------------------------------		
; Ensure that rst-targeted functions are aligned correctly  
; ---------------------------------------------------------------------------

rsttarget: macro * 
\* equ *
		if (offset(*)&7)|(offset(*)>38h)   
			inform 3, "Function \* is at %hh, but it must be at a multiple of 8 bytes at or lower than 38h to be used with the rst instruction.",offset(*)
		endc
		endm
		
; ---------------------------------------------------------------------------
; Make sure that arrays used with an 8-bit index don't cross a $100 byte boundary,
; and pad them automatically if they do
; ---------------------------------------------------------------------------

ensure1byteoffset: macro maxsize
		if ((offset(*)&0FFh)>(100h-\maxsize))
startpad: = offset(*)
			align 100h
endpad:	= offset(*)
			if endpad-startpad>=1h
				inform 1,"Z80 array at %hh is not at a address safe for use with an 8-bit index. %hh bytes of padding have been inserted to rectify this.",startpad,endpad-startpad
			endc
		endc
		endm

; ===========================================================================
; Z80 'ROM' start:
 zEntryPoint:
		if offset(*)<>0
			inform 3,"zEntryPoint is at %hh, but it must be 0. Make sure you haven't accidentally defined code in the macros.",offset(zEntryPoint) 
		endc
   
		di						; disable interrupts
		ld	sp,z_stack_pointer			; load initial stack pointer
		jp	zStartDAC
; ===========================================================================
; zbyte_7:
f_pal:
		db	0					; set by SoundDriverLoad to signal that we are on a PAL console

    if OptimizeSoundDriver=0
    	; This is redundant: the Z80 is slow enough to not need to worry about this
		align	8
; zsub_8
zFMBusyWait:    rsttarget
		; Performs the annoying task of waiting for the FM to not be busy
		ld	a,(ym_reg_a0)
		add	a,a
		jr	c,zFMBusyWait
		ret
    endc

		align	8
; zsub_10
zWriteFMIorII:    rsttarget
		bit chf_mask_bit,(ix+ch_type)
		jr	z,zWriteFMI
		jr	zWriteFMII

		align	8
; zsub_18
zWriteFMI:    rsttarget
	; Write reg/data pair to part I; 'a' is register, 'c' is data
    if OptimizeSoundDriver=0
		push	af
		rst	zFMBusyWait				; 'rst' is like 'call' but only works for 8-byte aligned addresses <= 38h
		pop	af
    endc
		ld	(ym_reg_a0),a
		push	af
    if OptimizeSoundDriver=0
		rst	zFMBusyWait
    endc
		ld	a,c
		ld	(ym_reg_d0),a
		pop	af
		ret

		align	8
; zsub_28
zWriteFMII:    rsttarget
; Write reg/data pair to part II; 'a' is register, 'c' is data
    if OptimizeSoundDriver=0
		push	af
		rst	zFMBusyWait
		pop	af
    endc
		ld	(ym_reg_a1),a
		push	af
    if OptimizeSoundDriver=0
		rst	zFMBusyWait
    endc
		ld	a,c
		ld	(ym_reg_d1),a
		pop	af
		ret

		align 38h
zVBlank:    rsttarget
		; This is called every VBLANK (38h is the interrupt entry point,
		; and VBLANK is the only one Z80 is hooked up to.)
		push	af					; save 'af'
		exx						; swap 'bc', 'de', and 'hl' with their shadows
		call	zBankSwitchToMusic			; bank switch to the music
		xor	a					; clear 'a'
		ld	(f_dosfx),a				; clear updating SFX flag (updating music)
		ld	ix,z_abs_vars				; ix points to the start of the global variables
		ld	a,(z_abs_vars+f_pause_sound)		; get pause/unpause flag
		or	a					; is music paused?
		jr	z,zUpdateEverything			; if not, branch
		call	zPauseMusic
		jp	zUpdateDAC				; now update the DAC
; ===========================================================================

; zloc_51
zUpdateEverything:
		ld	a,(z_abs_vars+v_fadeout_counter)	; are we fading out?
		or	a
		call	nz,zUpdateFadeout			; if so, update that

		ld	a,(z_abs_vars+f_fadein)			; are we fading in?
		or	a
		call	nz,zUpdateFadeIn			; if so, update that

		ld	a,(z_abs_vars+z_queue_0)
		or	a,(ix+z_queue_1)
		or	a,(ix+z_queue_2)			; this was missing in Sonic 1's driver, breaking the third queue slot.
		call	nz,zCycleQueue				; if any of those are non-zero, cycle queue

		; If this is 80h, nothing new will be played
		; otherwise it cues up the next play (flag from 68K for new item)
		ld	a,(z_abs_vars+z_soundqueue)
		cp	80h
		call	nz,zPlaySoundByIndex			; if not 80h, call; we need to play something new

		; Spindash update
		ld	a,(v_spindash_counter)
		or	a
		jr	z,.pal_timer				; if the spindash counter is already 0, branch
		dec	a					; 0ecrease the spindash sound playing counter
		ld	(v_spindash_counter),a

	.pal_timer:
		; If the system is PAL, then this performs some timing adjustments
		; (i.e. you need to update 1.2x as much to keep up the same rate)
		ld	hl,f_pal				; Get address of f_pal
		ld	a,(z_abs_vars+f_adjust_pal)		; load f_adjust_pal into 'a'
		and	a,(hl)					; and them together
		jr	z,.not_pal				; if zero, branch
		ld	hl,v_pal_update_counter
		dec	(hl)
		jr	nz,.not_pal
		ld	(hl),5					; every 6 frames (0-5) you need to "double update" to sort of keep up
		call	zUpdateMusic

	.not_pal:
		call	zUpdateMusic  

		; Now all of the SFX tracks are updated in a similar manner to "zUpdateMusic"...
		bankswitch SoundIndex				; Bank switch to sound effects

		ld	a,80h
		ld	(f_dosfx),a				; set f_dosfx = 80h (updating sound effects)

    if FixBugs
	; A bugfix in zUpdateMusic prevents it from returning ix set to a convenient value, so set it explicitly here
		ld	ix,z_tracks_sfx_start-sizeof_trackvars
    endc

		; FM SFX channels
		ld	b,countof_sfx_fm_tracks			; Only 3 FM channels for SFX (FM3, FM4, FM5)

	.fmloop:
		push	bc
		ld	de,sizeof_trackvars			; spacing between tracks
		add	ix,de					; next track
		bit	chf_enable_bit,(ix+ch_flags)		; is it playing?
		call	nz,zFMUpdateTrack			; if it is, call
		pop	bc
		djnz	.fmloop					; repeat until all have been updated

		; PSG SFX channels
		ld	b,countof_sfx_psg_tracks		; all PSG channels available

	.psgloop:
		push	bc
		ld	de,sizeof_trackvars			; spacing between tracks
		add	ix,de					; next track
		bit	chf_enable_bit,(ix+ch_flags)		; is it playing?
		call	nz,zPSGUpdateTrack			; if it is, call
		pop	bc
		djnz	.psgloop				; repeat until all have been updated

; Now we update the DAC... this only does anything if there's a new DAC
; sound to be played.  This is called after updating the DAC track.
; Otherwise it just mucks with the timing loop, forcing an update.
zUpdateDAC:
		bankswitch DAC_Start				; bankswitch to the DAC data

		ld	a,(v_current_dac)			; get currently playing DAC sound
		or	a
		jp	m,.dacqueued				; if one is queued (80h+), branch
		exx						; otherwise restore registers from mirror regs
		ld	b,1					; b=1 (initial feed to the DAC "djnz" loops, i.e. UPDATE RIGHT AWAY)
		pop	af
		ei						; enable interrupts
		ret

	.dacqueued:
	; If you get here, it's time to start a new DAC sound...
		ld	a,80h
		ex	af,af					; swap af with their shadows
		ld	a,(v_current_dac)			; get current DAC sound
		sub	a,_firstSample				; subtract 81h 
		ld	(v_current_dac),a			; store difference as current DAC sound
		; The following two instructions are dangerous: they discard the upper
		; two bits of v_current_dac, meaning you can only have 40h DAC samples.
		add	a,a
		add	a,a					; a *= 4 (each DAC entry is a pointer and length, 2+2)
		add	a,zDACPtrTbl&0FFh			; get low byte into table -> 'a'
		ld	(zDACStartAddress+1),a			; store into the instruction after zDACStartAddress (self-modifying code)
		add	a,2					; offset to length versus pointer
		ld	(zDACStoreLength+2),a			; store into the instruction after zDACStoreLength (self-modifying code)
		pop	af
		ld	hl,zWriteToDAC
		ex	(sp),hl					; jump to zWriteToDAC

; zloc_104
zDACStartAddress:
		ld	hl,(zDACPtrTbl)				; self-modified code: sets start address of DAC sample for zWriteToDAC

; zloc_107
zDACStoreLength:
		ld	de,(zDACPtrTbl+2)			; self-modified code: sets length of DAC sample for zWriteToDAC

;zloc_10B
zDACStoreDelay:
		ld	bc,100h					; self-modified code: From zDACDataStore; sets b=1 (the 100h part of it) UPDATE RIGHT AWAY and c="data rate delay" for this DAC sample, the future 'b' setting
		ei						; enable interrupts
		ret


; Updates all tracks; queues notes and durations!

; zsub_110
zUpdateMusic:
    if FixBugs=0
		; Calling this function here is bad, because it can cause the
		; first note of a newly-started song to be delayed for a frame.
		; The vanilla driver resorts to a workaround to prevent such a
		; delay from having side-effects, but it's better to just fix
		; the problem directly, and move this call to the proper place.
		call	TempoWait
    endc

; DAC updates
		ld	a,0FFh
		ld	(z_abs_vars+f_updating_dac),a		; set f_updating_dac
		ld	ix,z_tracks_start			; point "ix" to z_tracks_start
		bit	chf_enable_bit,(ix+ch_flags)		; is the DAC channel playing?
		call	nz,zDACUpdateTrack			; if so, call zDACUpdateTrack
		xor	a					; clear a
		ld	(z_abs_vars+f_updating_dac),a		; clear f_updating_dac
 
 		ld	b,countof_music_fm_tracks		; loop 6 times for FM tracks...
	.fmloop:
		push	bc
		ld	de,sizeof_trackvars			; space between tracks
		add	ix,de					; go to next track
		bit	chf_enable_bit,(ix+ch_flags)		; is this track playing?
		call	nz,zFMUpdateTrack			; if so, call
		pop	bc
		djnz	.fmloop					; loop until all FM tracks have been updated

		ld	b,countof_music_psg_tracks		; loop 3 times for PSG tracks...
	.psgloop:
		push	bc
		ld	de,sizeof_trackvars			; space between tracks
		add	ix,de					; go to next track
		bit	chf_enable_bit,(ix+ch_flags)		; is this track playing?
		call	nz,zPSGUpdateTrack			; if so, call
		pop	bc
		djnz	.psgloop				; loop until all PSG tracks have been updated

    if FixBugs=0
		; See above. Removing this instruction will cause this
		; subroutine to fall-through to TempoWait.
		ret
    endc

; zsub_14C
TempoWait:
; Tempo works as divisions of the 60Hz clock (there is a fix supplied for
; PAL that "kind of" keeps it on track.)  Every time the internal music clock
; overflows, it will update.  So a tempo of 80h will update every other
; frame, or 30 times a second.

		ld	ix,z_abs_vars				; ix points to global variables
		ld	a,(ix+f_current_tempo)			; get current tempo value
		add	a,(ix+f_tempo_counter)			; add the previous value
		ld	(ix+f_tempo_counter),a			; store this
		ret	c					; if the previous add overflowed (answer greater than FFh), return

		; if adding tempo value did NOT overflow, then we add 1 to all durations
		ld	hl,z_tracks_start+ch_delay		; start at first track's delay counter (counting up to delay)
		ld	de,sizeof_trackvars			; offset between tracks
		ld	b,countof_music_tracks			; loop for all tracks

.tempoloop:
		inc	(hl)					; increase delay tick counter to target
		add	hl,de					; next track...
		djnz	.tempoloop

		ret
; End of function TempoWait

; ===========================================================================

; zloc_167
zStartDAC:
		im	1					; set interrupt mode 1
		call	zClearTrackPlaybackMem			; clear the track RAM
		ei						; enable interrupts
		ld	iy,zDACDecodeTbl
		ld	de,0
; This controls the update rate for the DAC...
; My speculation for the rate at which the DAC updates:
;	Z80 clock = 3.57954MHz = 3579540Hz (not sure?)
;	zWaitLoop (immediately below) is waiting for someone to set
;		'de' (length of DAC sample) to non-zero

; The DAC code is sync'ed with VBLANK somehow, but I haven't quite got that
; one figure out yet ... tests on emulator seem to confirm it though.
; Next, there are "djnz" loops which do busy-waits.  (Two of them, which is
; where the '2' comes from in my guess equation.)  The DACMasterPlaylist
; appears to use '1' as the lowest input value to these functions.  (Which,
; given the djnz, would be the fastest possible value.)
; The rate seems to be calculated by 3579540Hz / (60Hz + (speed * 4)) / 2

; This "waitLoop" waits if the DAC has no data, or else it drops out!

; zloc_174:
zWaitLoop:
		ld	a,d
		or	a,e
		jr	z,zWaitLoop				; As long as 'de' (length of sample) = 0, wait...

; 'hl' is the pointer to the sample, 'de' is the length of the sample,
; and 'iy' points to the translation table; let's go...

; The "djnz $" loops control the playback rate of the DAC
; (the higher the 'b' value, the slower it will play)


; As for the actual encoding of the data, it is described by jman2050:
; "As for how the data is compressed, lemme explain that real quick:
; First, it is a lossy compression. So if you recompress a PCM sample this way,
; you will lose precision in data. Anyway, what happens is that each compressed data
; is separated into nybbles (1 4-bit section of a byte). This first nybble of data is
; read, and used as an index to a table containing the following data:
; 0,1,2,4,8,$10,$20,$40,$80,$FF,$FE,$FC,$F8,$F0,$E0,$C0."   [zDACDecodeTbl / zbyte_1B3]
; "So if the nybble were equal to F, it'd extract $C0 from the table. If it were 8,
; it would extract $80 from the table. ... Anyway, there is also another byte of data
; that we'll call 'd'. At the start of decompression, d is $80. What happens is that d
; is then added to the data extracted from the table using the nybble. So if the nybble
; were 4, the 8 would be extracted from the table, then added to d, which is $80,
; resulting in $88. This result is then put back into d, then fed into the YM2612 for
; processing. Then the next nybble is read, the data is extracted from the table, then
; is added to d (remember, d is now changed because of the previous operation), then is
; put back into d, then is fed into the YM2612. This process is repeated until the number
; of bytes as defined in the table above are read and decompressed."

; In our case, the so-called 'd' value is shadow register 'a'

zWriteToDAC:
		djnz	*					; Busy wait for specific amount of time in 'b'

		di						; disable interrupts (while updating DAC)
		ld	a,2Ah					; DAC port
		ld	(ym_reg_a0),a				; Set DAC port register
		ld	a,(hl)					; Get next DAC byte
		rlca
		rlca
		rlca
		rlca
		and	a,0Fh					; UPPER 4-bit offset into zDACDecodeTbl
		ld	(.highnybble+2),a			; store into the instruction after .highnybble (self-modifying code)
		ex	af,af					; shadow register 'a' is the 'd' value for 'jman2050' encoding

; zloc_18B
.highnybble:
		add	a,(iy)					; Get byte from zDACDecodeTbl (self-modified to proper displacement)
		ld	(ym_reg_d0),a				; Write this byte to the DAC
		ex	af,af					; back to regular registers
		ld	b,c					; reload 'b' with wait value
		ei						; enable interrupts (done updating DAC, busy waiting for next update)
	
		djnz	*					; Busy wait for specific amount of time in 'b'

		di						; disable interrupts (while updating DAC)
		push	af
		pop	af
		ld	a,2Ah					; DAC port
		ld	(ym_reg_a0),a				; Set DAC port register
		ld	b,c					; reload 'b' with wait value
		ld	a,(hl)					; Get next DAC byte
		inc	hl					; Next byte in DAC stream...
		dec	de					; One less byte
		and	a,0Fh					; LOWER 4-bit offset into zDACDecodeTbl
		ld	(.lownybble+2),a			; store into the instruction after .lownybble (self-modifying code)
		ex	af,af					; shadow register 'a' is the 'd' value for 'jman2050' encoding

; zloc_1A8
.lownybble:
		add	a,(iy)					; Get byte from zDACDecodeTbl (self-modified to proper displacement)
		ld	(ym_reg_d0),a				; Write this byte to the DAC
		ex	af,af					; back to regular registers
		ei						; enable interrupts (done updating DAC, busy waiting for next update)
		jp	zWaitLoop				; Back to the wait loop; if there's more DAC to write, we come back down again!

; ===========================================================================
; 'jman2050' DAC decode lookup table
; zbyte_1B3
zDACDecodeTbl:
		db	   0,    1,   2,   4,   8,  10h,  20h,  40h
		db	 80h,   -1,  -2,  -4,  -8, -10h, -20h, -40h

; The following two tables are used for when an SFX terminates
; its track to properly restore the music track it temporarily took
; over.  Note that an important rule here is that no SFX may use
; DAC, FM Channel 1, FM Channel 2, or FM Channel 6, period.
; Thus there's also only SFX tracks starting at FM Channel 3.

; The zeroes appear after FM 3 because it calculates the offsets into
; these tables by their channel assignment, where between Channel 3
; and Channel 4 there is a gap numerically.

		ensure1byteoffset 10h
; zbyte_1C3
zMusicTrackOffs:
; These are offsets to different music tracks starting with FM3
		dw	z_song_fm3,      0000h,  z_song_fm4,  z_song_fm5 ; FM3, 0, FM4, FM5
		dw	z_song_psg1, z_song_psg2, z_song_psg3, z_song_psg3 ; PSG1, PSG2, PSG3, PSG3 (noise alternate)

		ensure1byteoffset 10h
; zbyte_1D3
zSFXTrackOffs:
; These are offsets to different sound effect tracks starting with FM3
		dw	z_sfx_fm3,      0000h,  z_sfx_fm4,  z_sfx_fm5 ; FM3, 0, FM4, FM5
		dw	z_sfx_psg1, z_sfx_psg2, z_sfx_psg3, z_sfx_psg3 ; PSG1, PSG2, PSG3, PSG3 (noise alternate)


; ---------------------------------------------------------------------------
; Subroutine to update DAC sample
; ---------------------------------------------------------------------------

zDACUpdateTrack:
		dec	(ix+ch_delay)				; subtract 1 from ch_delay (Track 1's delay start)
		ret	nz					; return if not zero
		ld	l,(ix+ch_dataptr_low)			; low byte of DAC track current address
		ld	h,(ix+ch_dataptr_high)			; high byte of DAC track current address

	.sampleloop:
		ld	a,(hl)					; get next byte from DAC Track
		inc	hl					; move to next position
		cp	_firstCom				; is it a coordination flag?
		jr	c,.notcoord				; if not, branch
		call	zCoordFlag				; handle coordination flag
		jp	.sampleloop				; loop back around...

	.notcoord:
		or	a					; Test 'a' for 80h not set, which is a note duration
		jp	p,.gotduration				; If note duration, jump ahead (note that "hl" is already incremented)
		ld	(ix+ch_sample),a			; This is a note; store it here
		ld	a,(hl)					; Get next byte...
		or	a					; Test 'a' for 80h not set, which is a note duration
		jp	p,.repeatduration			; Is this a duration this time??  If so, jump ahead (only difference is to increment "hl")
		; Note followed by a note... apparently recycles the previous duration
		ld	a,(ix+ch_saved_delay)			; Current DAC note ticker goal value -> 'a'
		ld	(ix+ch_delay),a				; Use it again
		jr	zDACAfterDur				; Jump to after duration subroutine...
; ===========================================================================

; zloc_20D
.repeatduration:
		inc	hl					; Goes to next byte (after duration byte)

; zloc_20E
.gotduration:
		call	zSetDuration

; zloc_211
zDACAfterDur:
		ld	(ix+ch_dataptr_low),l			; Stores "hl" to the DAC track pointer memory
		ld	(ix+ch_dataptr_high),h
		bit chf_mask_bit,(ix+ch_flags)			; Is SFX overriding this track?
		ret	nz					; If so, we're done
		ld	a,(ix+ch_sample)			; Check next note to play
		cp	nRst					; Is it a rest?
		ret	z					; If so, quit
		sub	a,_firstSample				; Otherwise, transform note into an index... (we're selecting which drum to play!)
		add	a,a					; Multiply by 2...
		add	a,zDACMasterPlaylist&0FFh		; Offset into list
		ld	(zDACDataStore+2),a			; store into the following instruction (self-modifying code)

; zloc_22A
zDACDataStore:
		ld	bc,(zDACMasterPlaylist)			; Load appropriate drum info -> bc
		ld	a,c					; DAC sample number (81h base) -> 'a'
		ld	(v_current_dac),a			; Store current DAC sound to play
		ld	a,b					; Data rate delay -> 'b'
		ld	(zDACStoreDelay+1),a			; store into the instruction after zDACStoreDelay (self-modifying code)
		ret




; zsub_237
zFMUpdateTrack:
		dec	(ix+ch_delay)				; Decrement duration
		jr	nz,.notegoing				; If not time-out yet, go do updates only
		res	chf_tie_bit,(ix+ch_flags)		; When duration over, clear "do not attack" bit 4 (0x10) of track's play control
		call	zFMDoNext				; Handle coordination flags, get next note and duration
		call	zFMPrepareNote				; Prepares to play next note
		call	zFMNoteOn				; Actually key it (if allowed)
		call	zDoModulation				; Update modulation (if modulation doesn't change, we do not return here)
		jp	zFMUpdateFreq				; Applies frequency update from modulation

.notegoing:
		call	zNoteFillUpdate				; Applies "note fill" (time until cut-off); NOTE: Will not return here if "note fill" expires
		call	zDoModulation				; Update modulation (if modulation doesn't change, we do not return here)
		jp	zFMUpdateFreq				; Applies frequency update from modulation





; zsub_258
zFMDoNext:
		ld	l,(ix+ch_dataptr_low)			; Load track position low byte
		ld	h,(ix+ch_dataptr_high)			; Load track position high byte
		res	chf_rest_bit,(ix+ch_flags)		; Clear bit 1 (02h) "track is rest" from track

	.noteloop:
		ld	a,(hl)
		inc	hl					; Increment track to next byte
		cp	_firstCom				; Is it a control byte / "coordination flag"?
		jr	c,.gotnote				; If not, jump over
		call	zCoordFlag				; Handle coordination flag
		jr	.noteloop				; Go around, get next byte

	.gotnote:
		push	af
		call	zFMNoteOff				; Send key off
		pop	af
		or	a					; Test 'a' for 80h not set, which is a note duration
		jp	p,.gotduration				; If duration, jump to .gotduration
		call	zFMSetFreq				; Otherwise, this is a note; call zFMSetFreq
		ld	a,(hl)					; Get next byte
		or	a					; Test 'a' for 80h set, which is a note
		jp	m,zFinishTrackUpdate			; If this is a note, jump to zFinishTrackUpdate
		inc	hl					; Otherwise, go to next byte; a duration

	.gotduration:
		call	zSetDuration
		jp	zFinishTrackUpdate			; Either way, jumping to zFinishTrackUpdate...
; End of function zFMDoNext

; ===========================================================================
; zloc_285 zGetFrequency
zFMSetFreq:
; 'a' holds a note to get frequency for
		sub	a,nRst
		jr	z,zFMDoRest				; If this is a rest, jump to zFMDoRest
		add	a,(ix+ch_transpose)			; Add current channel ch_transpose (coord flag E9)
		add	a,a					; Offset into Frequency table...
    if OptimizeSoundDriver
		ld	d,12*2					; 12 notes per octave
		ld	c,0					; Clear c (will hold octave bits)

	.loop:
		sub	a,d					; Subtract 1 octave from the note
		jr	c,.getoctave				; If this is less than zero, we are done
		inc	c					; One octave up
		jr	.loop

	.getoctave:
		add	a,d					; Add 1 octave back (so note index is positive)
		sla	c
		sla	c
		sla	c					; Multiply octave value by 8, to get final octave bits
    endc
		add	a,FMFrequencies&0FFh
		ld	(.storefreq+2),a			; Store into the instruction after .storefreq (self-modifying code)
;		ld	d,a
;		adc	a,(FMFrequencies&0FF00h)>>8
;		sub	a,d
;		ld	(.storefreq+3),a		; This is how you could store the high byte of the pointer too (unnecessary if it's in the right range)

	; zloc_292
	.storefreq:
		ld	de,(FMFrequencies)			; Stores frequency into "de" (self-modified to proper index)
		ld	(ix+ch_freq_low),e			; Frequency low byte   -> trackPtr + 0Dh
    if OptimizeSoundDriver
		ld	a,d
		or	a,c
		ld	(ix+ch_freq_high),a			; Frequency high byte  -> trackPtr + 0Eh
    else
		ld	(ix+ch_freq_high),d			; Frequency high byte  -> trackPtr + 0Eh
    endc
		ret
; ===========================================================================

; zloc_29D
zFMDoRest:
		set	chf_rest_bit,(ix+ch_flags)		; Set bit 1 (track is at rest)
		xor	a					; Clear 'a'
		ld	(ix+ch_freq_low),a			; Zero out FM Frequency
		ld	(ix+ch_freq_high),a			; Zero out FM Frequency
		ret

; zsub_2A9
zSetDuration:
		ld	c,a					; 'a' = current duration
		ld	b,(ix+ch_tick)				; Divisor; causes multiplication of duration for every number higher than 1

.multloop:
		djnz	.multloop_outer
		ld	(ix+ch_saved_delay),a			; Store new duration into ticker goal of this track (this is reused if a note follows a note without a new duration)
		ld	(ix+ch_delay),a				; Sets it on ticker (counts to zero)
		ret

.multloop_outer:
		add	a,c					; Will multiply duration based on 'b'
		jp	.multloop
; End of function zSetDuration

; ===========================================================================

; zloc_2BA
zFinishTrackUpdate:
; Common finish-up routine used by FM or PSG
		ld	(ix+ch_dataptr_low),l			; Stores "hl" to the track pointer memory
		ld	(ix+ch_dataptr_high),h
		ld	a,(ix+ch_saved_delay)			; Last set duration
		ld	(ix+ch_delay),a				; ... put into ticker
		bit	chf_tie_bit,(ix+ch_flags)		; Is bit 4 (10h) "do not attack next note" set on playback?
		ret	nz					; If so, quit
		ld	a,(ix+ch_savedgate)			; Master "note fill" value -> a
		ld	(ix+ch_gate),a				; Reset 0Fh "note fill" value to master
		ld	(ix+ch_flutter),0			; Reset PSG flutter byte
		bit	chf_vib_bit,(ix+ch_flags)		; is modulation turned on?
		ret	z					; if not, quit
		ld	l,(ix+ch_vibptr_low)			; Otherwise, get address of modulation setting
		ld	h,(ix+ch_vibptr_high)
		jp	zSetModulation				; ... and go do it!




; zsub_2E3
zNoteFillUpdate:
		ld	a,(ix+ch_gate)				; Get current note fill value
		or	a
		ret	z					; If zero, return!
		dec	(ix+ch_gate)				; Decrement note fill
		ret	nz					; If not zero, return
		set	chf_rest_bit,(ix+ch_flags)		; Set bit 1 (track is at rest)
		pop	de					; return address -> 'de' (will not return to zUpdateTrack function!!)
		bit	chf_enable_bit,(ix+ch_type)		; Is this a PSG track?
		jp	nz,zPSGNoteOff				; If so, jump to zPSGNoteOff
		jp	zFMNoteOff				; Else, jump to zFMNoteOff
; End of function zNoteFillUpdate

; zsub_2FB
zDoModulation:
		pop	de					; keep return address -> de (MAY not return to caller)

		bit	chf_rest_bit,(ix+ch_flags)		; Is "track in rest"?
		ret	nz					; If so, quit
		bit	chf_vib_bit,(ix+ch_flags)		; Is modulation on?
		ret	z					; If not, quit
		ld	a,(ix+ch_vib_delay)			; 'ww' period of time before modulation starts
		or	a
		jr	z,.waitdone				; if zero, go to it!
		dec	(ix+ch_vib_delay)			; Otherwise, decrement timer
		ret						; return if decremented (does NOT return to zUpdateTrack!!)

.waitdone:
		dec	(ix+ch_vib_speed)			; Decrement modulation speed counter
		ret	nz					; Return if not yet zero
		ld	l,(ix+ch_vibptr_low)
		ld	h,(ix+ch_vibptr_high)			; 'hl' points to modulation setting
		inc	hl					; skip passed 'ww' period of time
		ld	a,(hl)					; Get modulation speed
		ld	(ix+ch_vib_speed),a			; Restore speed counter
		ld	a,(ix+ch_vib_steps)			; Get number of steps in modulation
		or	a
		jr	nz,.calcfreq				; If not zero, skip to .calcfreq

; If steps have reached zero...
		inc	hl					; passed mod speed
		inc	hl					; passed mod change per mod step
		ld	a,(hl)					; get number of steps in modulation
		ld	(ix+ch_vib_steps),a			; restore modulation steps
		ld	a,(ix+ch_vib_delta)			; get modulation change per mod step
		neg						; flip it negative
		ld	(ix+ch_vib_delta),a			; store negated value
		ret

.calcfreq:
		dec	(ix+ch_vib_steps)			; Decrement the step
		ld	l,(ix+ch_vibval_low)
		ld	h,(ix+ch_vibval_high)			; Get 16-bit modulation value

; This is a 16-bit sign extension for 'bc'
    if OptimizeSoundDriver
		ld	a,(ix+ch_vib_delta)			; Get current modulation change per step -> 'a'
		ld	c,a
		rla						; Carry contains sign of delta
		sbc	a,a					; a = 0 or -1 if carry is 0 or 1
		ld	b,a					; bc = sign extension of delta
    else
		ld	b,0
		ld	c,(ix+ch_vib_delta)			; Get current modulation change per step -> 'c'
		bit	7,c
		jp	z,.nosignextend
		ld	b,0FFh					; Sign extend if negative

.nosignextend:
    endc
		add	hl,bc					; Add to current modulation value
		ld	(ix+ch_vibval_low),l
		ld	(ix+ch_vibval_high),h			; Store new 16-bit modulation value
		ld	c,(ix+ch_freq_low)			; frequency low byte -> c
		ld	b,(ix+ch_freq_high)			; frequency high byte -> b
		add	hl,bc					; Add modulation value
		ex	de,hl
		jp	(hl)					; WILL return to zUpdateTrack
; End of function zDoModulation

; ===========================================================================
; This the note -> frequency setting lookup
; the same array is found at $729CE in Sonic 1, and at $C9C44 in Ristar
; zword_359:
		ensure1byteoffset 8Ch

GenNotePSG:	macro	const, psgfq, fmfq
		if strlen("\psgfq")>0
			dw \psgfq				; add PSG note value into ROM
		endc
		endm		
		
PSGFrequencies:
		DefineNotes		GenNotePSG		; generate PSG note array

; ===========================================================================

; zloc_3E5
zFMPrepareNote:
		bit	chf_rest_bit,(ix+ch_flags)		; Is track in rest?
		ret	nz					; If so, quit
		ld	e,(ix+ch_freq_low)			; Get frequency low
		ld	d,(ix+ch_freq_high)			; Get frequency high
		ld	a,d
		or	a,e
		jp	z,zSetRest				; If de == 0, go to zSetRest

; zloc_3F5
zFMUpdateFreq:
		bit chf_mask_bit,(ix+ch_flags)			; Is SFX overriding this track?
		ret	nz					; If so, quit!
; This is a 16-bit sign extension of (ix+19h)
    if OptimizeSoundDriver
		ld	a,(ix+ch_detune)			; Get ch_detune value
		ld	l,a
		rla						; Carry contains sign of ch_detune
		sbc	a,a					; a = 0 or -1 if carry is 0 or 1
		ld	h,a					; hl = sign extension of ch_detune
    else
		ld	h,0					; h = 0
		ld	l,(ix+ch_detune)			; Get ch_detune value
		bit	7,l					; Did prior value have 80h set?
		jr	z,.nosignextend				; If not, skip next step
		ld	h,0FFh					; h = FFh

.nosignextend:
    endc
		add	hl,de					; Alter frequency just a tad
		ld	c,h					; Upper part of frequency as data to FM ('c')
		ld	a,(ix+ch_type)				; "voice control" byte -> 'a'
		and	a,t_fm_assignment			; Strip to only channel assignment
		add	a,0A4h					; Change to proper register
		rst	zWriteFMIorII				; Write it!
		ld	c,l					; lower part of frequency
		sub	a,4					; A0h+ register
		rst	zWriteFMIorII				; Write it!
		ret

; zsub_414
zPSGUpdateTrack:
		dec	(ix+ch_delay)				; decrement current duration timeout..
		jr	nz,.notegoing				; If not time-out yet, go do updates only
		res	chf_tie_bit,(ix+ch_flags)		; Reset "do not attack next note" bit
		call	zPSGDoNext				; Handle coordination flags, get next note and duration
		call	zPSGDoNoteOn				; Actually key it (if allowed)
		call	zPSGDoVolFX				; This applies PSG ch_volume as well as its special ch_volume-based effects that I call "flutter"
		call	zDoModulation				; Update modulation (if modulation doesn't change, we do not return here)
		jp	zPSGUpdateFreq

.notegoing:
		call	zNoteFillUpdate				; Applies "note fill" (time until cut-off); NOTE: Will not return here if "note fill" expires
		call	zPSGUpdateVolFX				; Update ch_volume effects
		call	zDoModulation				; Update modulation (if modulation doesn't change, we do not return here)
		jp	zPSGUpdateFreq
; End of function zPSGUpdateTrack

; zsub_438
zPSGDoNext:
		ld	l,(ix+ch_dataptr_low)			; Load track position low byte
		ld	h,(ix+ch_dataptr_high)			; Load track position high byte
		res	chf_rest_bit,(ix+ch_flags)		; Clear bit 1 (02h) "track is rest" from track

.noteloop:
		ld	a,(hl)
		inc	hl					; Increment track to next byte
		cp	_firstCom				; Is it a control byte / "coordination flag"?
		jr	c,.gotnote				; If not, jump over
		call	zCoordFlag				; Handle coordination flag
		jr	.noteloop				; Go around, get next byte

.gotnote:
		or	a					; Test 'a' for 80h not set, which is a note duration
		jp	p,.gotduration				; If note duration, jump to .gotduration
		call	zPSGSetFreq				; Get frequency for this note
		ld	a,(hl)					; Get next byte
		or	a					; Test 'a' for 80h set, which is a note
		jp	m,zFinishTrackUpdate			; If this is a note, jump to zFinishTrackUpdate
		inc	hl					; Otherwise, go to next byte; a duration

.gotduration:
		call	zSetDuration
		jp	zFinishTrackUpdate			; Either way, jumping to zFinishTrackUpdate...
; End of function zPSGDoNext

; ===========================================================================

; zloc_460
zPSGSetFreq:
		sub	a,_firstNote				; a = a-$81 (zero-based index from lowest note)
		jr	c,.restpsg				; If carry (only time that happens if 80h because of earlier logic) this is a rest!
		add	a,(ix+ch_transpose)			; Add current channel ch_transpose (coord flag E9)
		add	a,a					; Multiply note value by 2
		add	a,PSGFrequencies&0FFh			; Point to proper place in table
		ld	(.storefreq+2),a			; store into the following instruction (self-modifying code)

; zloc_46D
.storefreq:
		ld	de,(PSGFrequencies)			; Gets appropriate frequency setting -> 'de'
		ld	(ix+ch_freq_low),e			; Frequency low byte   -> trackPtr + 0Dh
		ld	(ix+ch_freq_high),d			; Frequency high byte  -> trackPtr + 0Eh
		ret

.restpsg:
; If you get here, we're doing a PSG rest
		set	chf_rest_bit,(ix+ch_flags)		; Set "track in rest" bit
		ld	a,0FFh
		ld	(ix+ch_freq_low),a			; Frequency low byte = FFh
		ld	(ix+ch_freq_high),a			; Frequency hight byte = FFh
		jp	zPSGNoteOff				; Send PSG Note Off




; zsub_487
zPSGDoNoteOn:
		bit	7,(ix+ch_freq_high)			; If track is at rest (frequency was set to FFh)...
		jr	nz,zSetRest				; jump to zSetRest
		ld	e,(ix+ch_freq_low)			; Frequency low byte -> e
		ld	d,(ix+ch_freq_high)			; Frequency high byte -> d

; zloc_493
zPSGUpdateFreq:
		ld	a,(ix+ch_flags)				; Get playback control byte
		and	a,chf_rest|chf_mask
		ret	nz					; If either bit 1 ("track in rest") and 2 ("SFX overriding this track"), quit!
; This is a 16-bit sign extension of (ix+19h) -> 'hl'
    if OptimizeSoundDriver
		ld	a,(ix+ch_detune)			; Get ch_detune value
		ld	l,a
		rla						; Carry contains sign of ch_detune
		sbc	a,a					; a = 0 or -1 if carry is 0 or 1
		ld	h,a					; hl = sign extension of ch_detune
    else
		ld	h,0
		ld	l,(ix+ch_detune)			; hl = ch_detune value (coord flag E9)
		bit	7,l					; Did prior value have 80h set?
		jr	z,.nosignextend				; If not, skip next step
		ld	h,0FFh					; sign extend negative value

.nosignextend:
    endc
		add	hl,de					; Alter frequency just a tad
; This picks out the reg to write to the PSG
		ld	a,(ix+ch_type)				; Get "voice control" byte...
		cp	tPSG4					; is it the noise channel?
		jr	nz,.notnoise				; if not, branch
		ld	a,tPSG3					; a = C0h instead of E0h

.notnoise:
		ld	b,a					; 'a' -> 'b'
		ld	a,l					; Frequency low byte -> 'a'
		and	a,0Fh					; Keep only lower four bits (first PSG reg write only applies d0-d3 of freq)
		or	a,b					; Apply register bits
		ld	(zPSG),a				; Write it to PSG!
		ld	a,l					; Get frequency low byte -> 'a'
		srl	h					; (h >> 1); lowest bit into carry
		rra						; (a >> 1); carry from 'h' applied at end
		srl	h					; ... and so on ...
		rra
		rra
		rra						; in C, basically (hl >> 4) (except possible garbage from the rotation in upper bits)
		and	a,3Fh					; keep only lower 6 bits (PSG d4-d9)
		ld	(zPSG),a				; Write other frequency byte to PSG!
		ret
; ===========================================================================

; zloc_4C5
zSetRest:
		set	chf_rest_bit,(ix+ch_flags)		; Set "track at rest" bit
		ret

; zsub_4CA
zPSGUpdateVolFX:
		ld	a,(ix+ch_voice)				; Get current PSG tone
		or	a					; Test if it's zero
		ret	z					; If it is, return!
; Otherwise, fall into zPSGDoVolFX...

; zsub_4CF
zPSGDoVolFX:
		ld	b,(ix+ch_volume)			; Channel ch_volume -> 'b'
		ld	a,(ix+ch_voice)				; Current PSG tone -> 'a'
		or	a					; Test it
		jr	z,zPSGUpdateVol				; If tone is zero, jump to zPSGUpdateVol
		ld	hl,Envelopes				; hl points to PSG envelope table
		dec	a					; a--
		add	a,a					; a *= 2
		ld	e,a
		ld	d,0					; de = a
		add	hl,de					; Offset into pointer table...
		ld	a,(hl)					; Get low byte -> 'a'
		inc	hl					; Next byte
		ld	h,(hl)					; Get high byte into 'h'
		add	a,(ix+ch_flutter)			; Apply PSG flutter (provides dynamic ch_volume for special effects)
		ld	l,a
		adc	a,h
		sub	a,l
		ld	h,a					; Basically, hl = (hl+(ix+ch_flutter))
		ld	a,(hl)					; Get byte from this location
		inc	(ix+ch_flutter)				; Increment PSG flutter value
		or	a					; test byte from before
		jp	p,.gotflutter				; Is it a positive value?
		cp	80h					; Check if it's 80h (terminator to the "flutter" list)
		jr	z,zVolEnvHold				; If it is, then jump to zVolEnvHold (which just keeps at this flutter value, i.e. no more changes in ch_volume)

.gotflutter:
		add	a,b					; Apply this "flutter" to channel ch_volume -> 'a'
		ld	b,a					; a -> 'b'

; zloc_4F9
zPSGUpdateVol:
		ld	a,(ix+ch_flags)				; get playback control byte
		and	a,chf_rest|chf_mask			; Checks bits 1 ("track at rest") and 2 ("SFX overriding this track")
		ret	nz					; If either bit is set, quit!
		bit	chf_tie_bit,(ix+ch_flags)		; Is "do not attack next note" set?
		jr	nz,zPSGCheckNoteFill			; If so, jump to zPSGCheckNoteFill

; zloc_505
zPSGSendVol:
		ld	a,b					; 'b' -> 'a'
		cp	10h					; Did the level get pushed below silence level? (i.e. a > 0Fh)
		jr	c,.abovesilence
		ld	a,0Fh					; If so, fix it!

.abovesilence:
		or	a,(ix+ch_type)				; Apply channel info (which PSG to set!)
		or	a,10h					; This bit marks it as an attenuation level assignment (along with channel info just above)
		ld	(zPSG),a				; Write to PSG!!
		ret
; ===========================================================================

; zloc_515
zPSGCheckNoteFill:						; If you get here, then "do not attack next note" was set...
		ld	a,(ix+ch_savedgate)			; Get master "note fill" value
		or	a					; test it
		jr	z,zPSGSendVol				; If it's zero, then just process normally
		ld	a,(ix+ch_gate)				; Otherwise, get current "note fill" value
		or	a					; Test it
		jr	nz,zPSGSendVol				; If it's not zero, then just process normally
		ret
; ===========================================================================
; zloc_522
zVolEnvHold:
; This just decrements the flutter to keep it in place; no more ch_volume changes in this list
    if FixBugs
		dec	(ix+ch_flutter)
		dec	(ix+ch_flutter)				; Put index back (before final ch_volume value)
		jr	zPSGDoVolFX				; Loop back and update ch_volume
    else
; DANGER! This effectively halts all future ch_volume updates, breaking fades.
		dec	(ix+ch_flutter)				; Put index back (before flag 80h)
		ret						; Return and don't update ch_volume on this frame (!!!)
    endc


; zsub_526
zPSGNoteOff:
		bit chf_mask_bit,(ix+ch_flags)			; Is "SFX override" bit set?
		ret	nz					; If so, quit!
		ld	a,(ix+ch_type)				; Get "voice control" byte (loads upper bits which specify attenuation setting)

;                 |a| |1Fh|
; VOL1    0x90	= 100 1xxxx	vol 4b xxxx = attenuation value
; VOL2    0xb0	= 101 1xxxx	vol 4b
; VOL3    0xd0	= 110 1xxxx	vol 4b

		or	a,1Fh					; Attenuation Off
		ld	(zPSG),a
    if FixBugs
		; Without zInitMusicPlayback forcefully muting all channels, there's the
		; risk of music accidentally playing noise because it can't detect if
		; the PSG4/noise channel needs muting, on track initialisation.
		; This bug can be heard be playing the End of Level music in CNZ, whose
		; music uses the noise channel. S&K's driver contains a fix just like this.
		cp	0DFh					; Are we stopping PSG3?
		ret	nz
		ld	a,0FFh					; If so, stop noise channel while we're at it
		ld	(zPSG),a				; Stop noise channel
    endc
		ret
; End of function zPSGNoteOff

; ===========================================================================

    if OptimizeSoundDriver
		ensure1byteoffset 18h
    else
		ensure1byteoffset 0C0h
    endc

GenNoteFM:	macro	const, psgfq, fmfq, firstoctave
		if OptimizeSoundDriver
			; Only include values for the first octave; the rest will be calculated on the fly to save space.
			if strlen("\fmfq")>0&strlen("\firstoctave")>0
			dw \fmfq				; add FM note value into ROM
			endc
		else
			if strlen("\fmfq")>0
			dw \fmfq				; add FM note value into ROM
			endc
		endc	
		endm
		
FMFrequencies:
		DefineNotes	GenNoteFM			; generate the FM frequency table

; zloc_5F4
zPSGSilenceAll:
		ld	hl,zPSG					; PSG reg
		ld	(hl),tPSG1|1Fh				; Stop channel 0
		ld	(hl),tPSG2|1Fh				; Stop channel 1
		ld	(hl),tPSG3|1Fh				; Stop channel 2
		ld	(hl),tPSG4|1Fh				; Stop noise channel
		ret


; zsub_600
zPauseMusic:
		jp	m,.unpause				; If we are to unpause music, jump
		ld	a,(f_paused)				; Get paused flag
		or	a					; Are we paused already?
		ret	nz					; If so, return
		ld	a,0FFh					; a = 0FFh
		ld	(f_paused),a				; Set paused flag
		call	zFMSilenceAll
		jp	zPSGSilenceAll

.unpause:
    if OptimizeSoundDriver
		xor	a					; a = 0
		ld	(z_abs_vars+f_pause_sound),a		; Clear pause/unpause flag
    else
		push	ix					; Save ix (nothing uses this, beyond this point...)
		ld	(ix+f_pause_sound),0			; Clear pause/unpause flag
		xor	a					; a = 0
    endc
		ld	(f_paused),a				; Clear paused flag
		ld	ix,z_song_dac_fm_start			; ix = pointer to track RAM
		ld	b,countof_music_dac_fm_tracks		; 1 DAC + 6 FM
		call	zResumeTrack

		bankswitch SoundIndex				; Now for SFX

		ld	a,0FFh					; a = 0FFH
		ld	(f_dosfx),a				; Set flag to say we are updating SFX
		ld	ix,z_sfx_fm_start			; ix = pointer to SFX track RAM
		ld	b,countof_sfx_fm_tracks			; 3 FM
		call	zResumeTrack
		xor	a					; a = 0
		ld	(f_dosfx),a				; Clear SFX updating flag
    if OptimizeSoundDriver=0
		call	zBankSwitchToMusic			; Back to music (Pointless: music isn't updated until the next frame)
		pop	ix					; Restore ix (nothing uses this, beyond this point...)
    endc
		ret
; End of function zPauseMusic



; zsub_64D
zResumeTrack:
		bit	chf_enable_bit,(ix+ch_flags)		; Is track playing?
		jr	z,.nexttrack				; If not, jump
		bit chf_mask_bit,(ix+ch_flags)			; Is SFX overriding track?
		jr	nz,.nexttrack				; If not, jump
    if OptimizeSoundDriver=0
		; cfSetVoiceCont already does this
		ld	c,(ix+ch_ams_fms_pan)			; AMS/FMS/panning flags
		ld	a,(ix+ch_type)				; Get voice control bits...
		and	a,t_fm_assignment			; ... the FM portion of them
		add	a,0B4h					; Command to select AMS/FMS/panning register
		rst	zWriteFMIorII
    endc
		push	bc					; Save bc
		ld	c,(ix+ch_voice)				; Current track FM instrument
		call	cfSetVoiceCont
		pop	bc					; Restore bc

.nexttrack:
		ld	de,sizeof_trackvars			; de = Track size
		add	ix,de					; Advance to next track
		djnz	zResumeTrack				; loop
		ret


; zsub_674
zCycleQueue:
		ld	a,(z_abs_vars+z_soundqueue)		; Check if a sound request was made zComRange+08h
		cp	80h					; Is queue slot equal to 80h?
		ret	nz					; If not, return
		ld	hl,z_abs_vars+z_queue_0			; Get address of next sound
		ld	a,(z_abs_vars+v_priority)		; Get current SFX priority
		ld	c,a					; a -> c
		ld	b,3					; 3, for z_queue_0, z_queue_1, and z_queue_2

zInputLoop:
		ld	a,(hl)					; Get sound to play -> 'a'
		ld	e,a					; 'a' -> 'e'
		ld	(hl),0					; Clear it back to zero (we got it)
		inc	hl					; hl = pointer to next queue item
		cp	_firstMusic				; Is it before first music?
		jr	c,zQueueNext				; If so, jump
		cp	_firstCmd				; Is it a special command?
		jr	nc,zQueueItem				; If so, jump
		sub	a,_firstSfx				; Subtract first SFX index
		jr	c,zQueueItem				; If it was music, jump
		add	a,zSFXPriority&0FFh			; a = low byte of pointer to SFX priority
		ld	l,a					; l = low byte of pointer to SFX priority
		adc	a,(zSFXPriority&0FF00h)>>8		; a = low byte of pointer to SFX priority + high byte of same pointer
		sub	a,l					; a = high byte of pointer to SFX priority
		ld	h,a					; hl = pointer to SFX priority
		ld	a,(hl)					; Get SFX priority
		cp	c					; Is the new SFX of a higher priority?
		jr	c,.nextinput				; If not, jump
		ld	c,a					; Save new priority
		call	zQueueItem				; Queue the new SFX

.nextinput:
		ld	a,c					; Get back SFX priority
		or	a					; Is it negative (jumping sound)?
		ret	m					; Return if so
		ld	(z_abs_vars+v_priority),a		; Store the new priority
		ret
; ===========================================================================
zQueueNext:
		djnz	zInputLoop
		ret
; ===========================================================================
zQueueItem:
		ld	a,e					; restore a to be the last queue item read
		ld	(z_abs_vars+z_soundqueue),a		; Put it as the next item to play
		ret
; End of function zCycleQueue



; zsub_6B2
zPlaySoundByIndex:
		or	a					; is it sound 00?
		jp	z,zClearTrackPlaybackMem		; if yes, jump to RESET EVERYTHING!!
    if _firstMusic-1 = 80h
		ret	p					; return if it was (invalidates 00h-7Fh; maybe we don't want that someday?)
    else
		cp	_firstMusic
		ret	c					; return if id is less than the first music id
    endc

		ld	(ix+z_soundqueue),80h			; Rewrite zComRange+8 flag so we know nothing new is coming in
		cp	_lastMusic				; is it music (less than index 20)?
		jp	c,Sound_PlayBGM				; if yes, play it
		cp	_firstSfx				; is it not a sound effect? (this check is redundant if _lastMusic == _firstSfx...)
		ret	c					; if not, return (do nothing)
		cp	_lastSfx				; is it a sound effect (less than index 71)?
		jp	c,Sound_PlaySFX				; if yes, play it
		cp	_firstCmd				; is it after the last regular sound but before the first special sound command (between 71 and 78)?
		ret	c					; if yes, return (do nothing)
		cp	cmd_Pause				; is it sound 7E or 7F (pause all or resume all)
		ret	nc					; if yes, return (those get handled elsewhere)
; Otherwise, this is a special command to the music engine...
		sub	a,_firstCmd				; convert index 78-7D to a lookup into the following jump table
		add	a,a
		add	a,a
		ld	(.commandjump+1),a			; store into the following instruction (self-modifying code)

; zloc_6D5
.commandjump:
		jr	*
; ===========================================================================
zCommandIndex:

CmdPtr_StopSFX:		jp	zStopSoundEffects		; sound test index 78
				db	0
CmdPtr_FadeOut:		jp	zFadeOutMusic			; 79
				db	0
CmdPtr_SegaSound:	jp	zPlaySegaSound			; 7A
				db	0
CmdPtr_SpeedUp:		jp	zSpeedUpMusic			; 7B
				db	0
CmdPtr_SlowDown:	jp	zSlowDownMusic			; 7C
				db	0
CmdPtr_Stop:		jp	zStopSoundAndMusic		; 7D
				db	0
CmdPtr__End:
; ===========================================================================
; zloc_6EF
zPlaySegaSound:
    if FixBugs
; reset panning (don't want Sega sound playing on only one speaker)
		ld	a,0B6h					; Set Panning / AMS / FMS
		ld	c,pan_right|pan_left			; default Panning / AMS / FMS settings (only stereo L/R enabled)
		rst	zWriteFMII				; Set it!
    endc

		ld	a,2Bh					; DAC enable/disable register
		ld	c,80h					; Command to enable DAC
		rst	zWriteFMI

		bankswitch SegaPCM				; We want the Sega sound

		;ld	hl,zmake68kPtr(SegaPCM) ; was: 9E8Ch
		ld	hl,z_rom_window+(SegaPCM&7FFFh)
		ld	de,sizeof_SegaPCM/2			; was: 30BAh
		ld	a,2Ah					; DAC data register
		ld	(ym_reg_a0),a				; Select it
		ld	c,80h					; If z_soundqueue is not this, stops Sega PCM

	.loop:
		ld	a,(hl)					; Get next PCM byte
		ld	(ym_reg_d0),a				; Send to DAC
		inc	hl					; Advance pointer
		nop
		ld	b,0Ch					; Sega PCM pitch
		
		djnz	*					; Delay loop

		nop
		ld	a,(z_abs_vars+z_soundqueue)		; Get next item to play
		cp	c					; Is it 80h?
		jr	nz,.stop				; If not, stop Sega PCM
		ld	a,(hl)					; Get next PCM byte
		ld	(ym_reg_d0),a				; Send to DAC
		inc	hl					; Advance pointer
		nop
		ld	b,0Ch					; Sega PCM pitch
	
		djnz	*					; Delay loop

		nop
		dec	de					; 2 less bytes to play
		ld	a,d					; a = d
		or	a,e					; Is de zero?
		jp	nz,.loop				; If not, loop

	.stop:
		call	zBankSwitchToMusic
		ld	a,(z_abs_vars+f_dac_enabled)		; DAC status
		ld	c,a					; c = DAC status
		ld	a,2Bh					; DAC enable/disable register
		rst	zWriteFMI
		ret
; ===========================================================================
; zloc_73D
Sound_PlayBGM:
    if FixBugs=0
		; This is a workaround for a bug, where playing a new song will distort any SFX that were already playing
		push	af
		call	zStopSoundEffects			; stop all sounds before starting BGM
		pop	af
    endc
		ld	(v_current_song),a			; get current BGM
		cp	mus_ExtraLife				; is it the Extra Life jingle?
		jr	nz,.bgmnot1up				; if not, branch
		; The following code disables all sound (technically for duration of 1-up)
		ld	a,(z_abs_vars+f_has_backup)		; Check if 1-up sound is already playing
		or	a					; Test it
		jr	nz,.bgm_loadmusic			; If it is, then just reload it! Otherwise, the track would play over and over again...
		ld	ix,z_tracks_start			; Starting at beginning of all tracks...
		ld	de,sizeof_trackvars			; Each track size
		ld	b,countof_music_tracks			; All 10 (DAC, 6FM, 3PSG) tracks

	.clearsfxloop:
		res chf_mask_bit,(ix+ch_flags)			; Clear "SFX is overriding" bit (no SFX are allowed!)
		add	ix,de					; Next track
		djnz	.clearsfxloop

		ld	ix,z_tracks_sfx_start			; 'ix' points to start of SFX track memory (10 prior tracks were DAC, 6 FM, 3 PSG)
		ld	b,countof_sfx_tracks			; 6 SFX tracks total (3FM, 3PSG)

	.cleartrackplayloop:
		res	chf_enable_bit,(ix+ch_flags)		; Clear "is playing" bit!  (No SFX allowed!)
		add	ix,de					; Next track
		djnz	.cleartrackplayloop

		; This performs a "massive" backup of all of the current track positions
		; for restoration after 1-up BGM completes
		ld	de,z_tracks_save_start			; Backup memory address
		ld	hl,z_abs_vars				; Starts from zComRange
		ld	bc,z_tracks_save_end-z_tracks_save_start ; for this many bytes
		ldir						; Go!
		ld	a,80h
		ld	(z_abs_vars+f_has_backup),a		; Set 1-up song playing flag
		xor	a
		ld	(z_abs_vars+v_priority),a		; Clears SFX priority
		jr	.bgm_loadmusic				; Now load 1-up BGM
; ===========================================================================

	; zloc_784
	.bgmnot1up:
		xor	a
		ld	(z_abs_vars+f_has_backup),a		; clear 1-up is playing flag (it isn't)
		ld	(z_abs_vars+v_fadein_counter),a		; clear fade-in frame count
		ld	(z_abs_vars+v_fadeout_counter),a	; clear fade-out frame count

; zloc_78E
.bgm_loadmusic:
		call	zInitMusicPlayback
		ld	a,(v_current_song)			; So, let's take your desired song, put it into 'a'
		sub	a,_firstMusic				; Make it a zero-based entry ...
		ld	e,a					; Transform 'a' into 16-bit de
		ld	d,0
		ld	hl,SpeedUpIndex				; Load 'hl' of "sped up" tempos [I think]
		add	hl,de					; Offset by 16-bit version of song index to proper tempo
		ld	a,(hl)					; Get value at this location -> 'a'
		ld	(z_abs_vars+v_tempo_speed),a		; Store 'a' here (provides an alternate tempo or something for speed up mode)
		ld	hl,zMasterPlaylist			; Get address of the zMasterPlaylist
		add	hl,de					; Add the 16-bit offset here
		ld	a,(hl)					; Get "fixed" index
		ld	b,a					; 'a' -> 'b'
		; The following instructions enable a bankswitch routine
		and	a,80h					; Get only 'bank' bit
		ld	(z_abs_vars+v_bank_number),a		; Store this (use to enable alternate bank)
		ld	a,b					; Restore 'a'
		add	a,a					; Adding a+a causes a possible overflow and a multiplication by 2
		add	a,a					; Now multiplied by 4 and another possible overflow
		ld	c,a					; Result -> 'c'
		ccf						; Invert carry flag...
		sbc	a,a					; ... so that this sets a to FFh if bit 6 of original a was clear (allow PAL double-update), zero otherwise (do not allow PAL double-update)
		ld	(z_abs_vars+f_adjust_pal),a		; Set f_adjust_pal
		ld	a,c					; Put prior multiply result back in
		add	a,a					; Now multiplied by 8!
		sbc	a,a					; This is FFh if bit 5 of original a was set (uncompressed song), zero otherwise (compressed song)
		push	af					; Backing up result...?
		ld	a,b					; Put 80h based index -> 'a'
		and	a,1Fh					; Strip the flag bits
		add	a,a					; multiply by 2; now 'a' is offset into music table, save for the $8000
		ld	e,a
		ld	d,0					; de = a
		ld	hl,zROMWindow
		add	hl,de					; "hl" now contains 2-byte offset for music address table lookup
		push	hl					; Save 'hl' (will be damaged by bank switch)
		call	zBankSwitchToMusic			; Bank switch to start of music in ROM!
		pop	hl					; Restore 'hl'
		ld	e,(hl)
		inc	hl
		ld	d,(hl)					; Getting offset within bank to music -> de

; If we bypass the Saxman decompressor, the Z80 engine starts
; with the assumption that we're already decompressed with 'de' pointing
; at the decompressed data (which just so happens to be the ROM window)
		pop	af
		or	a					; Was the uncompressed song flag set?
		jr	nz,.nodecomp				; Bypass the Saxman decompressor if so

; This begins a call to the Saxman decompressor:
		ex	de,hl
		exx
		push	hl
		push	de
		push	bc
    if OptimizeSoundDriver=0
		exx
    endc
		call	zSaxmanDec
		exx
		pop	bc
		pop	de
		pop	hl
		exx
		ld	de,z_music_data				; Saxman compressed songs start at z_music_data (1380h)

.nodecomp:
		; Begin common track init code
		push	de
		pop	ix					; ix = de (BGM's starting address)
		ld	e,(ix)					; Get voice table pointer low byte -> 'e'
		ld	d,(ix+1)				; Get voice table pointer high byte -> 'd'
		ld	(z_abs_vars+v_music_voice_table),de	; Set master copy of this value in local memory
		ld	a,(ix+5)				; Get main tempo value
		ld	(z_abs_vars+v_tempo_main),a		; Store it at (zComRange+12h)
		ld	b,a					; tempo -> 'b'
		ld	a,(z_abs_vars+f_speedup)		; Get found speed shoe flag (zComRange+14h) (preloaded before this)
		or	a					; test it
		ld	a,b					; Restore normal song tempo
		jr	z,.nospeedshoes				; if the speed shoe flag was zero, skip this step
		ld	a,(z_abs_vars+v_tempo_speed)		; Put the corresponding speed shoe tempo for song

	.nospeedshoes:
		ld	(z_abs_vars+f_current_tempo),a		; Current tempo for TempoWait
		ld	(z_abs_vars+f_tempo_counter),a		; Tempo accumulator for TempoWait
		ld	a,5
		ld	(v_pal_update_counter),a		; reset PAL update tick to 5 (update immediately)
		push	ix
		pop	hl					; hl = ix (BGM's starting address)
		ld	de,6
		add	hl,de					; +06h (to DAC pointer)
		ld	a,(ix+2)				; Get number of FM+DAC channels this BGM has
		or	a					; Test it
		jp	z,.bgm_psgload				; If zero, then don't init any
		ld	b,a					; 'a' -> 'b' (num FM+DAC channels this song, for loop)
		push	iy					; Save 'iy'
		ld	iy,z_tracks_start			; 'iy' points to start of track memory
		ld	c,(ix+4)				; Get tempo divider -> 'c'
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		ld	de,FMDACInitBytes			; 'de' points to FMDACInitBytes
    endc

.bgm_fmloadloop:
    if FixBugs
	; Enabling the 'track at rest' bit was a workaround for a bug that is no longer necessary (see zUpdateMusic)
		ld	(iy+ch_flags),chf_enable		; Set "track is playing" bit
    else
		ld	(iy+ch_flags),chf_rest|chf_enable	; Set "track is playing" bit and "track at rest" bit
    endc
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		ld	a,(de)					; Get current byte from FMDACInitBytes -> 'a'
		inc	de					; will get next byte from FMDACInitBytes next time
		ld	(iy+ch_type),a				; Store this byte to "voice control" byte
    endc
		ld	(iy+ch_tick),c				; Store timing divisor from header for this track
		ld	(iy+ch_stackptr),ch_stack		; set "gosub" (coord flag F8h) stack init value (starts at end of this track's memory)
		ld	(iy+ch_ams_fms_pan),pan_right|pan_left	; default Panning / AMS / FMS settings (only stereo L/R enabled)
		ld	(iy+ch_delay),1				; set current duration timeout to 1 (should expire next update, play first note, etc.)
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		push	de					; saving FMDACInitBytes pointer
    endc
		push	bc					; saving number of channels and tempo divider ('bc' gets needlessly damaged by 'ldi' instructions coming up)
		ld	a,iyl					; current track pointer low byte -> 'a'
		add	a,ch_dataptr_low
		ld	e,a
		adc	a,iyh
		sub	a,e
		ld	d,a					; de = iy + 3 ('de' is pointing to track offset address)
    if OptimizeSoundDriver
		ld	bc,4
		ldir						; while (bc-- > 0) *de++ = *hl++; (copy track address, default key offset, default ch_volume)
    else
		ldi						; *de++ = *hl++ (copy track address low byte from header to track's copy of this value)
		ldi						; *de++ = *hl++ (copy track address high byte from header to track's copy of this value)
		ldi						; *de++ = *hl++ (default key offset, typically 0, can be set later by coord flag E9)
		ldi						; *de++ = *hl++ (track default ch_volume)
    endc
		ld	de,sizeof_trackvars			; size of all tracks -> 'de'
		add	iy,de					; offset to next track!
		pop	bc					; restore 'bc' (number of channels and tempo divider)
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		pop	de					; restore 'de' (FMDACInitBytes current pointer)
    endc
		djnz	.bgm_fmloadloop				; loop for all tracks we're init'ing...
; End of FM+DAC track init loop

		pop	iy					; restore 'iy'
		ld	a,(ix+2)				; 'ix' still points to start of BGM; get number of FM+DAC -> 'a'
		cp	7					; Does it equal 7?  (6 FM channels)
		jr	nz,.silencefm6				; If not, skip this next part
		xor	a					; Clear 'a'
    if OptimizeSoundDriver=0
		ld	c,a					; c = 0
    endc
		jr	.writesilence				; jump to .writesilence

	.silencefm6:
	; Silence FM Channel 6 specifically if it's not in use
    if OptimizeSoundDriver=0
	; A later call to zFMNoteOff does this, already
		ld	a,28h					; Key on/off FM register
		ld	c,6					; FM channel 6
		rst	zWriteFMI				; All operators off
    endc
    if FixBugs=0
	; The added zFMSilenceChannel does this, already
		ld	a,42h					; Starting at FM Channel 6 Operator 1 Total Level register
		ld	c,0FFh					; Silence value
		ld	b,4					; Write to all four FM Channel 6 operators

	; Set all TL values to silence!
	.silencefm6loop:
		rst	zWriteFMII
		add	a,4					; Next operator
		djnz	.silencefm6loop
    endc

	; Panning isn't normally set until zSetVoice.
	; This is a problem for the DAC track since it never uses zSetVoice
	; (or at least it shouldn't), so we reset the panning here.
		ld	a,0B6h					; Set Panning / AMS / FMS
		ld	c,pan_right|pan_left			; default Panning / AMS / FMS settings (only stereo L/R enabled)
		rst	zWriteFMII				; Set it!
		ld	a,80h					; FM Channel 6 is NOT in use (will enable DAC)
    if OptimizeSoundDriver=0
		ld	c,a					; Set this as value to be used in FM register write coming up...
    endc

; zloc_87E
.writesilence:
    if OptimizeSoundDriver
		ld	c,a
    endc
		ld	(z_abs_vars+f_dac_enabled),a		; Note whether FM Channel 6 is in use (enables DAC if not)
		ld	a,2Bh					; Set DAC Enable appropriately
		rst	zWriteFMI				; Set it!

; End of DAC/FM init, begin PSG init

; zloc_884
.bgm_psgload:
		ld	a,(ix+3)				; Get number of PSG tracks
		or	a					; Test it
		jp	z,.bgm_psgdone				; If zero, skip this part!
		ld	b,a					; 'a' -> 'b' (num PSG tracks this song, for loop)
		push	iy					; Save 'iy'
		ld	iy,z_song_psg1				; 'iy' points to start of PSG track memory (7 prior tracks were DAC and 6 FM)
		ld	c,(ix+4)				; Get tempo divider -> 'c'
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		ld	de,PSGInitBytes				; 'de' points to PSGInitBytes
    endc

	.bgm_psgloadloop:
    if FixBugs
	; Enabling the 'track at rest' bit was a workaround for a bug that is no longer necessary (see zUpdateMusic)
		ld	(iy+ch_flags),chf_enable		; Set "track is playing" bit
    else
		ld	(iy+ch_flags),chf_rest|chf_enable	; Set "track is playing" bit and "track at rest" bit
    endc
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		ld	a,(de)					; Get current byte from PSGInitBytes -> 'a'
		inc	de					; will get next byte from PSGInitBytes next time
		ld	(iy+ch_type),a				; Store this byte to "voice control" byte
    endc
		ld	(iy+ch_tick),c				; Store timing divisor from header for this track
		ld	(iy+ch_stackptr),ch_stack		; "gosub" stack init value
		ld	(iy+ch_delay),1				; set current duration timeout to 1 (should expire next update, play first note, etc.)
    if FixBugs=0
	; The bugfix in zInitMusicPlayback does this, already
		push	de					; saving PSGInitBytes pointer
    endc
		push	bc					; saving number of channels and tempo divider ('bc' gets needlessly damaged by 'ldi' instructions coming up)
		ld	a,iyl					; current track pointer low byte -> 'a'
		add	a,ch_dataptr_low
		ld	e,a
		adc	a,iyh
		sub	a,e
		ld	d,a					; de = iy + 3 ('de' is pointing to track offset address)
    if OptimizeSoundDriver
		ld	bc,4
		ldir						; while (bc-- > 0) *de++ = *hl++; (copy track address, default key offset, default ch_volume)
    else
		ldi						; *de++ = *hl++ (copy track address low byte from header to track's copy of this value)
		ldi						; *de++ = *hl++ (copy track address high byte from header to track's copy of this value)
		ldi						; *de++ = *hl++ (default key offset, typically 0, can be set later by coord flag E9)
		ldi						; *de++ = *hl++ (track default ch_volume)
    endc
		inc	hl					; Get default PSG tone
		ld	a,(hl)					; -> 'a'
		inc	hl					; This byte is usually the same as the prior, unused
		ld	(iy+ch_voice),a				; Store current PSG tone
		ld	de,sizeof_trackvars			; size of all tracks -> 'de'
		add	iy,de					; offset to next track!
		pop	bc					; restore 'bc' (number of channels and tempo divider)
    if FixBugs=0
; The bugfix in zInitMusicPlayback does this, already
		pop	de					; restore 'de' (PSGInitBytes current pointer)
    endc
		djnz	.bgm_psgloadloop			; loop for all tracks we're init'ing...

		pop	iy					; restore 'iy'
; End of PSG tracks init, begin SFX tracks init

; zloc_8D0
; zInitSFX
.bgm_psgdone:
		ld	ix,z_tracks_sfx_start			; 'ix' points to start of SFX track memory (10 prior tracks were DAC, 6 FM, 3 PSG)
		ld	b,countof_sfx_tracks			; 6 SFX tracks total (3FM, 3PSG)
		ld	de,sizeof_trackvars			; size between tracks

	; zloc_8D9
	.sfxstoploop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track currently playing?
		jr	z,.sfxnext				; If not, jump ahead (no work to do!)
		ld	a,(ix+ch_type)				; Get "voice control" byte...
		or	a					; Test it
		jp	m,.sfxpsgchannel			; If this is a PSG track, jump to .sfxpsgchannel
		sub	a,2					; Otherwise, subtract 2...
		add	a,a					; ... multiply by 2 (preparing to index starting from FM 3 only)
		jr	.gotchannelindex			; Jump ahead (general track setup)

; ===========================================================================
	.sfxpsgchannel:
		rra
		rra
		rra
		rra
		and	a,0Fh					; for PSG, just shift it down by 4 and we have its index!

	; zloc_8F1
	.gotchannelindex:
		add	a,zMusicTrackOffs&0FFh			; get offset into appropriate music track...
		ld	(.trackstore+1),a			; store into the following instruction (self-modifying code)

	; zloc_8F6
	.trackstore:
		ld	hl,(zMusicTrackOffs)			; This loads address of corresponding MUSIC track (the track that this SFX track would normally play over)
    if FixBugs
		set chf_mask_bit,(hl)				; Set the "SFX override" bit
    else
		res chf_mask_bit,(hl)				; Clear the "SFX override" bit (Why??? According to S1's driver, this should be a 'set')
    endc

	; zloc_8FB
	.sfxnext:
		add	ix,de					; Next track..
		djnz	.sfxstoploop				; Loop for all tracks
	; End of SFX tracks init...

;.sendfmnoteoff:
		ld	ix,z_song_fm1				; 'ix' points to first FM music track
		ld	b,countof_music_fm_tracks		; For all 6 of those...

.fmnoteoffloop:
    if FixBugs
	; zFMNoteOff isn't enough to silence the entire channel:
	; For added measure, we set Total Level and Release Rate, too.
		push	bc
		bit chf_mask_bit,(ix+ch_flags)			; Is bit 2 (SFX overriding) set?
		call	z,zFMSilenceChannel			; If not, jump
		add	ix,de					; Next track
		pop	bc
    else
		call	zFMNoteOff				; Send Key Off
		add	ix,de					; Next track
    endc
		djnz	.fmnoteoffloop
		
		ld	b,countof_music_psg_tracks		; For all 3 PSG tracks...

	.psgnoteoffloop:
		call	zPSGNoteOff				; Send Note Off
		add	ix,de					; Next track
		djnz	.psgnoteoffloop
		ret

    if FixBugs
zFMSilenceChannel:
		call	zSetMaxRelRate
		ld	a,(ix+ch_type)				; Get voice control byte
		and	a,t_fm_assignment			; Channels only!
		add	a,40h					; Set total level...
		ld	c,7Fh					; ... to minimum envelope amplitude...
		call	zFMOperatorWriteLoop			; ... for all operators of this track's channel
		jp	zFMNoteOff

zSetMaxRelRate:
		ld	a,(ix+ch_type)				; Get voice control byte
		and	a,t_fm_assignment			; Channels only!
		add	a,80h					; Add register 80, set D1L to minimum and RR to maximum...
		ld	c,0FFh					; ... for all operators on this track's channel

zFMOperatorWriteLoop:
		ld	b,4					; Loop 4 times

	.loop:
		rst	zWriteFMIorII				; Write to part I or II, as appropriate
		add	a,4					; a += 4
		djnz	.loop					; Loop
		ret
    endc
; ===========================================================================
; FM channel assignment bits
; zbyte_916
FMDACInitBytes:
		db 	tDAC,tFM1,tFM2,tFM3			; port 1 
		db	tFM4,tFM5,tFM6				; port 2

; Default values for PSG tracks
; zbyte_91D
PSGInitBytes:
		db  tPSG1,tPSG2,tPSG3				; Specifically, these configure writes to the PSG port for each channel

; ---------------------------------------------------------------------------
; Play a sound effect
; ---------------------------------------------------------------------------
; zloc_920
; zPlaySound_CheckRing
Sound_PlaySFX:
		ld	c,a					; Store sound index -> 'c'
		ld	a,(ix+f_has_backup)			; Get "is 1-up playing" flag...
		or	a,(ix+f_fadein)				; Or it with fading in flag
		jp	nz,.clear_sndprio			; If either is set, SFX cannot be played!!
		xor	a
		ld	(f_spindash),a				; Clear spindash sound flag
		ld	a,c					; Sound index -> 'a'
		cp	sfx_Ring				; is this the ring sound?
		jr	nz,.checkgloop				; if not, jump

		; This is the ring sound...
		ld	a,(f_stereo_alt)			; 0 plays left, FFh plays right
		or	a					; Test it
		jr	nz,.gotringspeaker			; If it's not zero, we skip this next step
		ld	c,sfx_RingLeft				; do something different (probably speaker change)...

	.gotringspeaker:
		cpl						; If it was 0, it's now FFh, or vice versa
		ld	(f_stereo_alt),a			; Store new ring speaker value (other side)
		jp	.playsound				; now play the ring sound
; ===========================================================================

	; zloc_942:
	.checkgloop:
    if OptimizeSoundDriver=0
    	; Reduntant.
		ld	a,c
    endc
		cp	sfx_Gloop				; Is this the bloop/gloop noise?
		jr	nz,.checkspindash			; if not, jump
		ld	a,(f_gloop)
		cpl
		ld	(f_gloop),a
		or	a
		ret	z					; Sometimes don't play it
		jp	.playsound				; Now play the gloop sound
; ===========================================================================

	; zloc_953:
	.checkspindash:
    if OptimizeSoundDriver=0
    	; Reduntant.
		ld	a,c
    endc
		cp	sfx_SpinDashCharge			; is this the spindash rev sound playing?
		jr	nz,.playsound				; if not, jump

		ld	a,(v_spindash_counter)
		or	a
		ld	a,(v_spindash_freq_index)
		jr	nz,.incfreq				; if the spindash sound is already playing, jump
		ld	a,-1					; reset the extra frequency (becomes 0 on the next line)

	.incfreq:
		inc	a					; increase the frequency
		cp	0Ch
		jr	nc,.maxfreq
		ld	(v_spindash_freq_index),a

	.maxfreq:
		ld	a,3Ch
		ld	(v_spindash_counter),a
		ld	a,-1
		ld	(f_spindash),a

; zloc_975:
.playsound:
		bankswitch SoundIndex				; Switch to SFX banks

		ld	hl,z_rom_window+(SoundIndex&7FFFh)
		ld	a,c					; 'c' -> 'a'
		sub	a,_firstSfx				; Bring 'a' down to index value
		add	a,a					; Multiply it by 2
		ld	e,a
		ld	d,0					; de = a
		add	hl,de					; now hl points to a pointer in the SoundIndex list (such as rom_ptr_z80 Sound20)
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a					; now hl points to a sound's data (such as Sound20: ...)
		ld	e,(hl)
		inc	hl
		ld	d,(hl)					; 'de' points to custom voice table (if any; otherwise is 0000h)
		inc	hl
		ld	(.voiceptr+1),de			; Store into the instruction after .voiceptr (self-modifying code)
		ld	c,(hl)					; Timing divisor -> 'c'
		inc	hl
		ld	b,(hl)					; Total channels used -> 'b'
		inc	hl

	; zloc_99F
	.sfx_loadloop:
		push	bc					; Backup divisor/channel usage
		xor	a					; a = 0 (will end up being NO CUSTOM VOICE TABLE!)
		ld	(.is_psg+1),a				; Store into the instruction after .bgmchannel (self-modifying code)
		push	hl					; Save current position within sound (offset 04h)
		inc	hl					; Next byte...

		ld	a,(hl)					; Track sound def -> 'a' (if 80h set, it's PSG, otherwise it's FM) -- note this also tells what channel it's on (80, A0, C0 for PSG, FM channel assignments otherwise)
		or	a					; Test it
		jp	m,.sfxinitpsg				; If bit 7 (80h) set (meaning PSG track), skip next part...
		sub	a,2					; Subtract 2 from this value
		add	a,a					; Multiply it by 2
		jp	.sfxinitfm				; This is an FM sound track...

	.sfxinitpsg:
		; This is a PSG track!
		; Always ends up writing zero to voice table pointer?
		ld	(.is_psg+1),a				; Store into the instruction after .bgmchannel (self-modifying code)
		cp	0C0h					; Is this PSG3?
		jr	nz,.getindex				; If not, skip this part
		push	af
		or	a,1Fh					; Set silence on PSG!
		ld	(zPSG),a
		xor	a,20h
		ld	(zPSG),a
		pop	af

	.getindex:
		rra
		rra
		rra
		rra
		and	a,0Fh					; For PSG, just shift it down by 4 and we have its index!

	; zloc_9CA
	.sfxinitfm:
		add	a,zMusicTrackOffs&0FFh			; Offset to corresponding music track
		ld	(.bgm_to_override+1),a			; Store into the instruction after .bgm_to_override (self-modifying code)

	; zloc_9CF
	.bgm_to_override:
		ld	hl,(zMusicTrackOffs)			; Self-modified code: 'hl' is now start of corresponding music track
		set chf_mask_bit,(hl)				; Set "SFX is overriding this track!" bit
		add	a,zSFXTrackOffs-zMusicTrackOffs		; Jump to corresponding SFX track
		ld	(.clearsfxtrackram+2),a			; Store into the instruction after .clearsfxtrackram (self-modifying code)

	; zloc_9D9
	.clearsfxtrackram:
		ld	ix,(zSFXTrackOffs)			; 'ix' is now start of corresponding SFX track

	; Little bit busy there, but basically for a given 'a' value, where a == 0
	; means first SFX track (FM3), 'hl' now points to the music track and 'ix' points
	; to the SFX track that both correspond to track 'a'

	; Now we're going to clear this SFX track...
		ld	e,ixl
		ld	d,ixh					; de = ix
		push	de					; Save 'de'
		ld	l,e					; hl = de (start of SFX track)
		ld	h,d
		ld	(hl),0					; Store 00h on first byte of track
		inc	de					; Next byte...
		ld	bc,sizeof_trackvars-1			; For all bytes in the track, minus 1 (since we're copying 00h from first byte)
		ldir						; Clear track memory!
		pop	de					; Restore 'de' (start of SFX track yet again)
		pop	hl					; Get 'hl' back from way before (offset of sound in ROM + 04h)
	;	ld	a,e
	;	add	a,ch_flags
	;	ld	e,a
	;	adc	a,d
	;	sub	a,e
	;	ld	d,a
		ldi						; *de++ = *hl++ (write playback control byte) (... not really sure why this is used)
		ldi						; *de++ = *hl++ (write voice control byte) (sets whether is PSG or what)
		pop	bc					; Restore 'bc'...
		push	bc					; ...and back it up again!
		ld	(ix+ch_tick),c				; Set timing divisor of SFX track
		ld	(ix+ch_delay),1				; Current duration timeout to 1 (will expire immediately and thus update)
		ld	(ix+ch_stackptr),ch_stack		; Reset track "gosub" stack
		ld	a,e
		add	a,ch_dataptr_low-ch_tick
		ld	e,a
		adc	a,d
		sub	a,e
		ld	d,a					; de += 1 (skip timing divisor; already set)
    if OptimizeSoundDriver
		ld	bc,3
		ldir						; while (bc-- > 0) *de++ = *hl++; (copy track address, default key offset)
    else
		ldi						; *de++ = *hl++ (track position low byte)
		ldi						; *de++ = *hl++ (track position high byte)
		ldi						; *de++ = *hl++ (key offset)
    endc

; If spindash active, the following block updates its frequency specially:
		ld	a,(f_spindash)
		or	a
		jr	z,.notspindash				; If spindash not last sound played, skip this
		ld	a,(v_spindash_freq_index)		; Get current frequency index
		dec	de					; Go back to key offset
		ex	de,hl					; hl <=> de
		add	a,(hl)					; Add spindash key offset!
		ex	de,hl					; de <=> hl (just done because we wanted add a,(hl))
		ld	(de),a					; Store it!
		inc	de					; Go passed key offset again

	.notspindash:
		ldi						; *de++ = *hl++ (channel ch_volume)

	; zloc_A1D
	.is_psg:						; Modified way back within .sfx_loadloop
		ld	a,0					; Self-modified code
		or	a					; Test it
		jr	nz,.sfxpsginitdone			; Jump, if this is a PSG track
	; Do some more FM-related initialisation
		ld	(ix+ch_ams_fms_pan),pan_right|pan_left	; Default panning / AMS / FMS settings (just L/R Stereo enabled)

	; zloc_A26
	.voiceptr:
		ld	de,0					; Self-modified code: This will be modified to custom voice table address (possibly still 0000h)
		ld	(ix+ch_voice_ptr_low),e			; Low byte of custom voice table (for SFX)
		ld	(ix+ch_voice_ptr_high),d		; High byte of custom voice table (for SFX)

	.sfxpsginitdone:
		pop	bc					; Restore divisor (c) and channel counts (b0)
		dec	b					; One less FM channel
		jp	nz,.sfx_loadloop			; If more to go, loop!

		jp	zBankSwitchToMusic			; Otherwise, prepare to do music...
; ===========================================================================
	
	; zloc_KillSFXPrio
	; zKillSFXPrio:
	.clear_sndprio:
		xor	a
		ld	(z_abs_vars+v_priority),a		; Reset SFX priority
		ret

; zsub_A3C
zStopSoundEffects:
		xor	a
		ld	(z_abs_vars+v_priority),a		; Reset SFX priority
		ld	ix,z_tracks_sfx_start			; 'ix' points to start of SFX track memory (10 prior tracks were DAC, 6 FM, 3 PSG)
		ld	b,countof_sfx_tracks			; All 6 SFX tracks...

; zloc_A46
.trackloop:
		push	bc					; Save 'bc'
		bit	chf_enable_bit,(ix+ch_flags)		; Check if this track was playing
		jp	z,.nexttrack				; If not
		res	chf_enable_bit,(ix+ch_flags)		; You're not playing anymore!
		res	chf_tie_bit,(ix+ch_flags)		; Not attacking, either
		ld	a,(ix+ch_type)				; Get "voice control" byte
		or	a					; Test it
		jp	m,.trackpsg				; If 80h set (PSG track) jump to .trackpsg
		push	af
		call	zFMNoteOff				; FM key off
		pop	af
		push	ix
		sub	a,2					; Determine proper corresponding music track (starting on FM3, so subtract 2 from channel assignment)
		add	a,a					; Multiply by 2 (each index 2 bytes)
		add	a,zMusicTrackOffs&0FFh			; Get offset -> 'a'
		ld	(.fmpointer+2),a			; Store into the instruction after .fmpointer (self-modifying code)

; zloc_A6C
.fmpointer:
		ld	ix,(zMusicTrackOffs)			; Self-modified code: will load appropriate corresponding music track address
		bit chf_mask_bit,(ix+ch_flags)			; Was this music track is overridden by an SFX track?
		jr	z,.notoverridden			; If not, do nothing
		res chf_mask_bit,(ix+ch_flags)			; Otherwise, tell it is is no longer!
		set	chf_rest_bit,(ix+ch_flags)		; Set track to rest
		ld	a,(ix+ch_voice)				; Get current voice
		call	zSetVoiceMusic				; Reset FM voice

.notoverridden:
		pop	ix
		jp	.nexttrack				; Jump down to loop
; ===========================================================================

; zloc_A89
.trackpsg:
		push	af
		call	zPSGNoteOff				; PSG Note off
		pop	af
		push	ix
		rra
		rra
		rra
		rra
		and	a,0Fh					; 'a' is now 08, 0A, 0C, or 0E
		add	a,zMusicTrackOffs&0FFh
		ld	(.psgpointer+2),a			; Store into the instruction after .psgpointer (self-modifying code)

; zloc_A9B
.psgpointer:
		ld	ix,(zMusicTrackOffs)			; Self-modified code from just above: 'ix' points to corresponding Music PSG track
		res chf_mask_bit,(ix+ch_flags)			; Tell this track it is is no longer overridden by SFX!
		set	chf_rest_bit,(ix+ch_flags)		; Set track to rest
		ld	a,(ix+ch_type)				; Get voice control
		cp	0E0h					; Is this a PSG 3 noise (not tone) track?
		jr	nz,.nexttrackpop			; If it isn't, don't do next part (non-PSG Noise doesn't restore)
		ld	a,(ix+ch_noisemode)			; Get PSG noise setting
		ld	(zPSG),a				; Write it to PSG

.nexttrackpop:
		pop	ix

; zloc_AB6
.nexttrack:
		ld	de,sizeof_trackvars
		add	ix,de					; Got to next track
		pop	bc					; Restore 'bc'
		djnz	.trackloop				; Loop around...
		ret
; End of function zStopSoundEffects

; ===========================================================================
; zloc_ABF
zFadeOutMusic:
		ld	a,3
		ld	(z_abs_vars+v_fadeout_delay),a		; Set delay ticker to 3
		ld	a,28h
		ld	(z_abs_vars+v_fadeout_counter),a	; Set total frames to decrease ch_volume over
		xor	a
		ld	(z_song_dac+ch_flags),a			; Stop DAC track (can't fade it)
		ld	(z_abs_vars+f_speedup),a		; No speed shoe tempo?
		ret

; zsub_AD1
zUpdateFadeout:
		ld	a,(z_abs_vars+v_fadeout_delay)		; Get current tick count before next ch_volume decrease
		or	a
		jr	z,.continuefade				; If not yet zero...
		dec	(ix+v_fadeout_delay)			; Just decrement it
		ret

.continuefade:
		dec	(ix+v_fadeout_counter)			; Otherwise, decrement fadeout!
		jp	z,zClearTrackPlaybackMem		; If it hits zero, clear everything!
		ld	(ix+v_fadeout_delay),3			; Otherwise, reload tick count with 3
		push	ix
		ld	ix,z_song_fm1				; 'ix' points to first FM music track
		ld	b,countof_music_fm_tracks		; 6 FM tracks to follow...

; zloc_AED
.fmloop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track playing?
		jr	z,.nextfm				; If not, do nothing
		inc	(ix+ch_volume)				; Increment channel ch_volume (remember -- higher is quieter!)
		jp	p,.sendfmtl				; Don't let it overflow
		res	chf_enable_bit,(ix+ch_flags)		; Otherwise, stop playing this track
		jr	.nextfm					; Just loop

.sendfmtl:
		push	bc
		call	zSetChanVol				; We need to update ch_volume
		pop	bc

; zloc_B04
.nextfm:
		ld	de,sizeof_trackvars
		add	ix,de					; Next track
		djnz	.fmloop					; Keep going for all FM tracks...
		ld	b,countof_music_psg_tracks		; 3 PSG tracks to follow...

; zloc_B0D
.psgloop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track playing?
		jr	z,.nextpsg				; If not, do nothing
		inc	(ix+ch_volume)				; increment channel ch_volume (remember -- higher is quieter!)
		ld	a,10h
		cp	(ix+ch_volume)				; Don't let ch_volume go over 0Fh on PSG tracks!
		jp	nc,.sendpsgvol
		res	chf_enable_bit,(ix+ch_flags)		; Otherwise, stop playing this track
		jr	.nextpsg

.sendpsgvol:
		push	bc
		ld	b,(ix+ch_volume)			; Channel ch_volume -> 'b'
    if FixBugs
		ld	a,(ix+ch_voice)
		or	a					; Is this track using ch_volume envelope 0 (no envelope)?
		call	z,zPSGUpdateVol				; If so, update ch_volume (this code is only run on envelope 1+, so we need to do it here for envelope 0)
    else
; DANGER! This code ignores ch_volume envelopes, breaking fade on envelope-using tracks.
; (It's also a part of the envelope-processing code, so calling it here is redundant)
; This is only useful for envelope 0 (no envelope).
		call	zPSGUpdateVol				; Update ch_volume (ignores current envelope!!!)
    endc
		pop	bc

; zloc_B2C
.nextpsg:
		ld	de,sizeof_trackvars
		add	ix,de					; Next track
		djnz	.psgloop				; Keep going for all PSG tracks...
		pop	ix
		ret
; End of function zUpdateFadeout

; zsub_B36
zFMSilenceAll:
		ld	a,28h					; Start at FM KEY ON/OFF register
		ld	b,3					; Three key on/off per part

	.noteoffloop:
		ld	c,b					; Current key off -> 'c
		dec	c					; c--
		rst	zWriteFMI				; Write key off for part I
		set t_fmii_bit,c				; Set part II select
		rst	zWriteFMI				; Write key off for part II
		djnz	.noteoffloop

		ld	a,30h					; Starting at FM register 30h...
		ld	c,0FFh					; Write dummy kill-all values
		ld	b,60h					; ...up to register 90h

	.channelloop:
		rst	zWriteFMI				; ...on part I
		rst	zWriteFMII				; ...and part II
		inc	a					; Next register!
		djnz	.channelloop

		ret
; End of function zFMSilenceAll

; ===========================================================================
; zloc_B4E
zStopSoundAndMusic:
		xor	a
		ld	(z_abs_vars+f_pause_sound),a

; zsub_B52
zClearTrackPlaybackMem:
; This totally wipes out the track memory and resets playback hardware
		ld	a,2Bh					; DAC Enable register
		ld	c,80h					; Enable DAC
		rst	zWriteFMI				; Write it!
		ld	a,c					; 80h -> 'a'
		ld	(z_abs_vars+f_dac_enabled),a		; Store that to DAC Enabled byte
		ld	a,27h					; Channel 3 special settings
		ld	c,0					; All clear
		rst	zWriteFMI				; Write it!
; This performs a full clear across all track/playback memory
		ld	hl,z_abs_vars
		ld	de,z_abs_vars+1
		ld	(hl),0					; Starting byte is 00h
		ld	bc,(z_tracks_sfx_end-z_abs_vars)-1	; For 695 bytes...
		ldir						; 695 bytes of clearing! (Because it will keep copying the byte prior to the byte after; thus 00h repeatedly)
		ld	a,80h
		ld	(z_abs_vars+z_soundqueue),a		; Nothing is queued
		call	zFMSilenceAll				; Silence FM
		jp	zPSGSilenceAll				; Silence PSG


; zsub_B78
zInitMusicPlayback:
; This function saves some of the queue/flag items and
; otherwise resets all music-related playback memory and
; silences the hardware.  Used prior to playing a new song.
; Very similar to zClearTrackPlaybackMem except that it is
; specific to the music tracks...

; Save some queues/flags:
		ld	ix,z_abs_vars
		ld	b,(ix+v_priority)
		ld	c,(ix+f_has_backup)			; 1-up playing flag
		push	bc
		ld	b,(ix+f_speedup)			; Speed shoe flag
		ld	c,(ix+v_fadein_counter)			; Fade in frames
		push	bc
		ld	b,(ix+z_queue_0)
		ld	c,(ix+z_queue_1)
		push	bc
    if FixBugs
; z_queue_2 isn't backed up! This was a bug in Sonic 1's driver as well.
		ld	b,(ix+z_queue_2)
		push	bc
    endc
; The following clears all playback memory and non-SFX tracks
		ld	hl,z_abs_vars
		ld	de,z_abs_vars+1
		ld	(hl),0
		ld	bc,(z_tracks_end-z_abs_vars)-1		; This many bytes (from start of zComRange to just short of end of PSG3 music track)
		ldir
; Restore those queue/flags:
		pop	bc
		ld	(ix+z_queue_0),b
		ld	(ix+z_queue_1),c
    if FixBugs
; Ditto.
		pop	bc
		ld	(ix+z_queue_2),b
    endc
		pop	bc
		ld	(ix+f_speedup),b			; Speed shoe flag
		ld	(ix+v_fadein_counter),c			; Fade in frames
		pop	bc
		ld	(ix+v_priority),b
		ld	(ix+f_has_backup),c			; 1-up playing flag
		ld	a,80h
		ld	(z_abs_vars+z_soundqueue),a

    if FixBugs
; If a music file's header doesn't define each and every channel, they
; won't be silenced by .sfxnext, because their tracks aren't properly
; initialised. This can cause hanging notes. So, we'll set them up
; properly here.
		ld	ix,z_tracks_start			; Start at the first music track...
		ld	b,countof_music_tracks			; ...and continue to the last
		ld	de,sizeof_trackvars
		ld	hl,FMDACInitBytes			; This continues into PSGInitBytes

.loop:
		ld	a,(hl)
		inc	hl
		ld	(ix+ch_type),a				; Set channel type while we're at it, so subroutines understand what the track is
		add	ix,de					; Next track
		djnz	.loop					; Loop for all channels

		ret
    else
; This silences all channels, even those being used by SFX!
; .sfxnext does the same thing, only better (it doesn't affect SFX channels)
		call	zFMSilenceAll
		jp	zPSGSilenceAll
    endc
; End of function zInitMusicPlayback

; ===========================================================================
; zloc_BBE
; increases the tempo of the music
zSpeedUpMusic:
		ld	b,80h
		ld	a,(z_abs_vars+f_has_backup)
		or	a
		ld	a,(z_abs_vars+v_tempo_speed)
		jr	z,zSetTempo
		jr	zSetTempo_1up

; ===========================================================================
; zloc_BCB
; returns the music tempo to normal
zSlowDownMusic:
		ld	b,0
		ld	a,(z_abs_vars+f_has_backup)
		or	a
		ld	a,(z_abs_vars+v_tempo_main)
		jr	z,zSetTempo
		jr	zSetTempo_1up

; ===========================================================================
; helper routines for changing the tempo
zSetTempo:
		ld	(z_abs_vars+f_current_tempo),a		; Store new tempo value
		ld	a,b
		ld	(z_abs_vars+f_speedup),a
		ret
; ===========================================================================
; zloc_BE0
zSetTempo_1up:
		ld	(z_savevar+f_current_tempo),a		; Store new tempo value
		ld	a,b
		ld	(z_savevar+f_speedup),a
		ret


; zsub_BE8
zUpdateFadeIn:
		ld	a,(z_abs_vars+v_fadein_delay)		; Get current tick count before next ch_volume increase
		or	a
		jr	z,.continuefade				; If not yet zero...
		dec	(ix+v_fadein_delay)			; Just decrement it
		ret

.continuefade:
		ld	a,(z_abs_vars+v_fadein_counter)		; Get current fade out frame count
		or	a
		jr	nz,.fadenotdone				; If fadeout hasn't reached zero yet, skip this
		ld	a,(z_song_dac+ch_flags)			; Get DAC's playback control byte
		and	a,~chf_mask				; Clear "SFX is overriding" bit
		ld	(z_song_dac+ch_flags),a			; Set that
		xor	a
		ld	(z_abs_vars+f_fadein),a			; Done fading-in, SFX can play now
		ret

.fadenotdone:
		dec	(ix+v_fadein_counter)			; Otherwise, we decrement fadein!
		ld	(ix+v_fadein_delay),2			; Otherwise, reload tick count with 2 (little faster than fadeout)
		push	ix
		ld	ix,z_song_fm1				; 'ix' points to first FM music track
		ld	b,countof_music_fm_tracks		; 6 FM tracks to follow...

.fmloop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track playing?
		jr	z,.nextfm				; If not, do nothing
		dec	(ix+ch_volume)				; Decrement channel ch_volume (remember -- lower is louder!)
		push	bc
		call	zSetChanVol				; We need to update ch_volume
		pop	bc

.nextfm:
		ld	de,sizeof_trackvars
		add	ix,de					; Next track
		djnz	.fmloop					; Keep going for all FM tracks...

		ld	b,countof_music_psg_tracks		; 3 PSG tracks to follow...

.psgloop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track playing?
		jr	z,.nextpsg				; If not, do nothing
		dec	(ix+ch_volume)				; Decrement channel ch_volume (remember -- lower is louder!)
		push	bc
		ld	b,(ix+ch_volume)			; Channel ch_volume -> 'b'
    if FixBugs
		ld	a,(ix+ch_voice)
		or	a					; Is this track using ch_volume envelope 0 (no envelope)?
		call	z,zPSGUpdateVol				; If so, update ch_volume (this code is only run on envelope 1+, so we need to do it here for envelope 0)
    else
		; DANGER! This code ignores ch_volume envelopes, breaking fade on envelope-using tracks.
		; (It's also a part of the envelope-processing code, so calling it here is redundant)
		; This is only useful for envelope 0 (no envelope).
		call	zPSGUpdateVol				; Update ch_volume (ignores current envelope!!!)
    endc
		pop	bc

.nextpsg:
		ld	de,sizeof_trackvars
		add	ix,de					; Next track
		djnz	.psgloop				; Keep going for all PSG tracks...

		pop	ix
		ret

; zsub_C46
zFMNoteOn:
		ld	a,(ix+ch_flags)				; Get playback control byte
		and	a,chf_rest|chf_mask
		ret	nz					; If either bit 1 ("track in rest") and 2 ("SFX overriding this track"), quit!
		ld	a,(ix+ch_type)				; Get "voice control" byte
		or	a,0F0h					; Turn on ALL operators
		ld	c,a					; Set as data to write to FM
		ld	a,28h					; Write to KEY ON/OFF port (key ON in this case)
		rst	zWriteFMI				; Do it!
		ret

; zsub_C56
zFMNoteOff:
		ld	a,(ix+ch_flags)				; Load this track's playback control byte
		and	a,chf_mask|chf_tie			; Are bits 4 (no attack) or 2 (SFX overriding) set?
		ret	nz					; If they are, return
		ld	a,28h					; Otherwise, send a KEY ON/OFF
		ld	c,(ix+ch_type)				; Track's data for this key operation

; Format of key on/off:
; 4321 .ccc
; Where 4321 are the bits for which operator,
; and ccc is which channel (0-2 for channels 1-3, 4-6 for channels 4-6 WATCH BIT GAP)

		rst	zWriteFMI				; Write to part I (note this particular register is ALWAYS sent to part I)
		ret

; Performs a bank switch to where the music for the current track is at
; (there are two possible bank locations for music)

; zsub_C63:
zBankSwitchToMusic:
		ld	a,(z_abs_vars+v_bank_number)
		or	a
		jr	nz,zSwitchToBank2

		bankswitch MusicPoint1
		ret

zSwitchToBank2:
		bankswitch MusicPoint2
		ret
; End of function zBankSwitchToMusic

; ===========================================================================

; zloc_C89
zCoordFlag:
		sub	a,_firstCom
    if OptimizeSoundDriver
		ld	c,a					; Multiply by 3; this lets us remove padding that was
		add	a,a					; left over from Sonic 1's sound driver, which used
		add	a,c					; 4 byte-long instructions for each entry
    else
		add	a,a					; Multiply by 4, skipping past padding
		add	a,a
    endc
		ld	(coordflagLookup+1),a			; store into the instruction after coordflagLookup (self-modifying code)
		ld	a,(hl)
		inc	hl

; This is the lookup for Coordination flag routines

; zloc_C92
coordflagLookup:
		jr	*
; ===========================================================================
		jp	cfPanningAMSFMS				; E0
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfDetune				; E1
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetCommunication			; E2
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfJumpReturn				; E3
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfFadeInToPrevious			; E4
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetTempoDivider			; E5
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfChangeFMVolume			; E6
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfPreventAttack				; E7
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfNoteFill				; E8
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfChangeTransposition			; E9
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetTempo				; EA
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetTempoMod				; EB
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfChangePSGVolume			; EC
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfClearPush				; ED
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfStopSpecialFM4			; EE
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetVoice				; EF
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfModulation				; F0
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfEnableModulation			; F1
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfStopTrack				; F2
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetPSGNoise				; F3
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfDisableModulation			; F4
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfSetPSGTone				; F5
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfJumpTo				; F6
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfRepeatAtPos				; F7
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfJumpToGosub				; F8
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================
		jp	cfOpF9					; F9
    if OptimizeSoundDriver=0
		db	0
    endc
; ===========================================================================

; (via Saxman's doc): panning, AMS, FMS
; zloc_CFC
cfPanningAMSFMS:
; Note that the AMS and FMS bits are saved; this command was only meant to
; change the panning of a given channel.

		bit	t_psg_bit,(ix+ch_type)			; Is this a PSG track?
		ret	m					; If so, quit!
    if FixBugs=0
		; This check is in the wrong place.
		; If this flag is triggered by a music track while it's being overridden
		; by an SFX, it will use the old panning when the SFX ends.
		; This is because ch_ams_fms_pan doesn't get updated.
		bit chf_mask_bit,(ix+ch_flags)			; If "SFX overriding" bit set...
		ret	nz					; return
    endc
		ld	c,a					; input val 'a' -> c
		ld	a,(ix+ch_ams_fms_pan)			; old PAF value
		and	a,ams_fms_settings			; retains AMS and FMS bits
		or	a,c					; OR'd with new settings
		ld	(ix+ch_ams_fms_pan),a			; new PAF value
    if FixBugs
		; The check should only stop hardware access, like this.
		bit chf_mask_bit,(ix+ch_flags)			; If "SFX overriding" bit set...
		ret	nz					; return
    endc
		ld	c,a					; a -> c (YM2612 data write)
		ld	a,(ix+ch_type)				; Get voice control byte
		and	a,t_fm_assignment			; Channels only!
		add	a,0B4h					; Add register B4, stereo output control and LFO sensitivity
		rst	zWriteFMIorII				; Depends on bit 2 of (ix+ch_type)
		ret
; ===========================================================================

; (via Saxman's doc): Alter note values by xx
; More or less a pitch bend; this is applied to the frequency as a signed value
; zloc_D1A cfAlterNotesUNK cfAlterNotes
cfDetune:
		ld	(ix+ch_detune),a			; set new ch_detune value
		ret
; ===========================================================================

; Set otherwise unused timing byte to parameter
; Used for triggering a boss' attacks in Ristar
; zloc_D1E cfUnknown1
cfSetCommunication:
		ld	(z_abs_vars+v_timing),a
		ret
; ===========================================================================

; Return (Sonic 1 & 2)
; zloc_D22
cfJumpReturn:
		ld	c,(ix+ch_stackptr)			; Get current stack offset -> 'c'
		ld	b,0					; b = 0
		push	ix
		pop	hl					; hl = ix
		add	hl,bc					; hl += bc (latest item on "gosub" stack)
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a					; hl = address from "gosub" stack
		inc	c
		inc	c
		ld	(ix+ch_stackptr),c			; add 2 to "gosub" stack offset (pop)
		ret
; ===========================================================================

; Fade-in to previous song (needed on DAC channel, Sonic 1 & 2)
; zloc_D35
cfFadeInToPrevious:
; This performs a "massive" restoration of all of the current
; track positions as they were prior to 1-up BGM
		ld	hl,z_tracks_save_start			; Backup memory address
		ld	de,z_abs_vars				; Ends at zComRange
		ld	bc,z_tracks_save_end-z_tracks_save_start ; for this many bytes
		ldir						; Go!

		call	zBankSwitchToMusic
		ld	a,(z_song_dac+ch_flags)			; Get DAC's playback bit
		or	a,chf_mask
		ld	(z_song_dac+ch_flags),a			; Set "SFX is overriding" on it (not normal, but will work for this purpose)
		ld	a,(z_abs_vars+v_fadein_counter)		; Get current count of many frames to continue bringing ch_volume up
		ld	c,a
		ld	a,28h
		sub	a,c					; a = 28h - c (don't overlap fade-ins?)
		ld	c,a					; 'a' -> 'c'
		ld	b,countof_music_fm_tracks		; 6 FM tracks to follow...
		ld	ix,z_song_fm1				; 'ix' points to first FM music track

.fmloop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track playing?
		jr	z,.nextfm				; If not, do nothing
		set	chf_rest_bit,(ix+ch_flags)		; Mark track at rest
		ld	a,(ix+ch_volume)			; Get channel ch_volume
		add	a,c					; Apply current fade value
		ld	(ix+ch_volume),a			; Store it back
    if OptimizeSoundDriver=0
; This bit is always cleared (see Sound_PlayBGM)
		bit chf_mask_bit,(ix+ch_flags)			; Is track being overridden by SFX?
		jr	nz,.nextfm				; If so, skip next part
    endc
		push	bc
		ld	a,(ix+ch_voice)				; Get voice
		call	zSetVoiceMusic				; Update voice (and set ch_volume)
		pop	bc

.nextfm:
		ld	de,sizeof_trackvars
		add	ix,de					; Next track
		djnz	.fmloop					; Keep going for all FM tracks...

		ld	b,countof_music_psg_tracks		; 3 PSG tracks to follow...

.psgloop:
		bit	chf_enable_bit,(ix+ch_flags)		; Is this track playing?
		jr	z,.nextpsg				; If not, do nothing
		set	chf_rest_bit,(ix+ch_flags)		; Set track at rest
		call	zPSGNoteOff				; Shut off PSG
		ld	a,(ix+ch_volume)			; Get channel ch_volume
		add	a,c					; Apply current fade value
		ld	(ix+ch_volume),a			; Store it back
    if FixBugs
; Restore PSG noise type
		ld	a,(ix+ch_type)
		cp	0E0h					; Is this the noise channel?
		jr	nz,.nextpsg				; If not, jump
		ld	a,(ix+ch_noisemode)
		ld	(zPSG),a				; Restore Noise setting
    endc

.nextpsg:
		ld	de,sizeof_trackvars
		add	ix,de					; Next track
		djnz	.psgloop				; Keep going for all FM tracks...

		ld	a,80h
		ld	(z_abs_vars+f_fadein),a			; Stop any SFX during fade-in
		ld	a,28h
		ld	(z_abs_vars+v_fadein_counter),a		; Fade in for 28h frames
		xor	a
		ld	(z_abs_vars+f_has_backup),a		; Set to zero; 1-up ain't playin' no more
		ld	a,(z_abs_vars+f_dac_enabled)		; DAC not yet enabled...
		ld	c,a
		ld	a,2Bh
		rst	zWriteFMI				; Tell hardware his DAC ain't enabled yet either
		pop	bc
		pop	bc
		pop	bc					; These screw with the return address to make sure DAC doesn't run any further
		jp	zUpdateDAC				; But we update DAC regardless
; ===========================================================================

; Change tempo divider to xx
; zloc_DB7
cfSetTempoDivider:
		ld	(ix+ch_tick),a				; Set tempo divider on this track only
		ret
; ===========================================================================

; (via Saxman's doc): Change channel ch_volume BY xx; xx is signed
; zloc_DBB cfSetVolume
cfChangeFMVolume:
		add	a,(ix+ch_volume)			; Add to current ch_volume
		ld	(ix+ch_volume),a			; Update ch_volume
		jp	zSetChanVol				; Immediately set this new ch_volume
; ===========================================================================

; (via Saxman's doc): prevent next note from attacking
; zloc_DC4
cfPreventAttack:
		set	chf_tie_bit,(ix+ch_flags)		; Set bit 4 (10h) on playback control; do not attack next note
		dec	hl					; Takes no argument, so just put it back
		ret
; ===========================================================================

; (via Saxman's doc): set note fill amount to xx
; zloc_DCA
cfNoteFill:
		ld	(ix+ch_gate),a				; Note fill value (modifiable)
		ld	(ix+ch_savedgate),a			; Note fill value (master copy, rewrites +0Fh when necessary)
		ret
; ===========================================================================

; (via Saxman's doc): add xx to channel key
; zloc_DD1 cfAddKey
cfChangeTransposition:
		add	a,(ix+ch_transpose)			; Add to current ch_transpose value
		ld	(ix+ch_transpose),a			; Store updated ch_transpose value
		ret
; ===========================================================================

; (via Saxman's doc): set music tempo to xx
; zloc_DD8
cfSetTempo:
		ld	(z_abs_vars+f_current_tempo),a		; Set tempo
		ret
; ===========================================================================

; (via Saxman's doc): Change tempo modifier to xx for ALL channels
; zloc_DDC
cfSetTempoMod:
		push	ix					; Save 'ix'
		ld	ix,z_tracks_start			; Start at beginning of track memory
		ld	de,sizeof_trackvars			; Track size
		ld	b,countof_music_tracks			; All 10 tracks

.trackloop:
		ld	(ix+ch_tick),a				; Sets the timing divisor for ALL tracks; this can result in total half-speed, quarter-speed, etc.
		add	ix,de
		djnz	.trackloop

		pop	ix					; Restore 'ix'
		ret
; ===========================================================================
; This controls which TL registers are set for a particular
; algorithm; it actually makes more sense to look at a zVolTLMaskTbl entry as a bitfield.
; Bit 0-4 set which TL operators are actually effected for setting a ch_volume;
; this table helps implement the following from the Sega Tech reference:
; "To make a note softer, only change the TL of the slots (the output operators).
; Changing the other operators will affect the flavor of the note."
; zloc_DF1
		ensure1byteoffset 8
zVolTLMaskTbl:
		db	  8,  8,  8,  8
		db	0Ch,0Eh,0Eh,0Fh
; ===========================================================================

; Alters a channel's ch_volume by xx. This is only meant to be used by PSG channels. 
; zloc_DF9 cfChangeVolume
cfChangePSGVolume:
		add	a,(ix+ch_volume)			; Add to channel ch_volume
		ld	(ix+ch_volume),a			; Store updated ch_volume
		ret
; ===========================================================================

; Unused command EDh
; This used to be Sonic 1's cfClearPush. The whole Push SFX feature
; was retained when the driver was ported to Z80, but eventually removed in Beta 5.
; This broken code is all that's left of it.
; zlocret_E00 cfUnused cfUnused1
cfClearPush:
    if (OptimizeSoundDriver=0)&(FixBugs=0)
; Dangerous!  It doesn't put back the byte read, meaning one gets skipped!
		ret
    endc
; ===========================================================================

; Unused command EEh
; This used to be Sonic 1's cfStopSpecialFM4. But the Special SFX function hasn't been ported...
; zloc_E01 cfVoiceUNK cfUnused2
cfStopSpecialFM4:
		dec	hl					; Put back byte; does nothing
		ret
; ===========================================================================

; (via Saxman's doc): set voice selection to xx
; zloc_E03
cfSetVoice:
		ld	(ix+ch_voice),a				; Set current voice
		ld	c,a					; a -> c (saving for later, if we go to cfSetVoiceCont)
		bit chf_mask_bit,(ix+ch_flags)			; If "SFX is overriding this track" bit set...
		ret	nz					; ...return!
		push	hl					; Save 'hl'
		call	cfSetVoiceCont				; Set the new voice!
		pop	hl					; Restore 'hl'
		ret

; zsub_E12
cfSetVoiceCont:
		ld	a,(f_dosfx)				; Check SFX flag 0 = updating music, 80h means busy, FFh set means updating SFX (use custom voice table)
		or	a					; Test
		ld	a,c					; c -> a (restored 'a')
		jr	z,zSetVoiceMusic			; If not busy, jump to zSetVoiceMusic (set 'hl' to v_music_voice_table)
		ld	l,(ix+ch_voice_ptr_low)			; Get low byte of custom voice table
		ld	h,(ix+ch_voice_ptr_high)		; Get high byte of custom voice table
		jr	zSetVoice				; Do not set 'hl' to v_music_voice_table
; End of function cfSetVoiceCont

; zsub_E21
zSetVoiceMusic:
; Set 'hl' to normal voice table pointer
		ld	hl,(z_abs_vars+v_music_voice_table)

; zloc_E24
zSetVoice:
; This does the actual setting of the FM registers for the specific voice
; 'a' is the voice index to set
; 'hl' is set to the address of the voice table pointer (can be substituted, probably mainly for SFX)

    if OptimizeSoundDriver
		ld	e,a
		ld	d,0

		ld	b,25

.voicemultiply:
		add	hl,de
		djnz	.voicemultiply
    else
		push	hl					; push 'hl' for the end of the following block...

; The following is a crazy block designed to 'multiply' our target voice value by 25...
; Where a single voice is 25 bytes long
		ld	c,a					; a -> c
		ld	b,0					; b = 0 (so only low byte of 'bc' is set, basically voice to set)
		add	a,a					; a *= 2 (indexing something...)
		ld	l,a					; low byte of 'hl' set to 'a'
		ld	h,b					; high byte = 0
		add	hl,hl					; hl *= 2
		add	hl,hl					; hl *= 2 (total hl * 4!!)
		ld	e,l
		ld	d,h					; de = hl
		add	hl,hl					; hl *= 2
		add	hl,de					; hl += de
		add	hl,bc					; hl += bc (waaah!)
		pop	de					; old 'hl' value -> 'de'
		add	hl,de					; hl += de (Adds address from the very beginning)
; End crazy multiply-by-25 block
    endc

; Sets up a value for future total level setting...
		ld	a,(hl)					; Get feedback/algorithm -> a
		inc	hl					; Next byte of voice...
		ld	(.a_backup+1),a				; Self-modified code: basically enables 'a' restored to its current value later
		ld	c,a					; a -> c (will be data to YM2612)
		ld	a,(ix+ch_type)				; Get "voice control" byte
		and	a,t_fm_assignment			; Only keep bits 0-2 (bit 2 specifies which chip to write to)
		add	a,0B0h					; Add to get appropriate feedback/algorithm register
		rst	zWriteFMIorII				; Write new value to appropriate part

; ch_detune/coarse freq, all channels
		sub	a,80h					; Subtract 80h from 'a' (ch_detune/coarse frequency of operator 1 register)
		ld	b,4					; Do next 4 bytes (operator 1, 2, 3, and 4)

.detuneloop:
		ld	c,(hl)					; Get next ch_detune/coarse freq
		inc	hl					; Next voice byte
		rst	zWriteFMIorII				; Write this ch_detune/coarse freq
		add	a,4					; Next ch_detune/coarse freq register
		djnz	.detuneloop

		push	af					; Daving 'a' for much later... will be restored when time to "Total Level"

; other regs up to just before "total level", all channels
		add	a,10h					; We're at 40h+, now at 50h+ (RS/AR of operator 1 register)
		ld	b,10h					; Perform 16 writes (basically goes through RS/AR, AM/D1R, D2R, D1L)

.registerloop:
		ld	c,(hl)					; Get next reg data value
		inc	hl					; Next voice byte
		rst	zWriteFMIorII				; Write to FM
		add	a,4					; Next register
		djnz	.registerloop

; Now going to set "stereo output control and LFO sensitivity"
		add	a,24h					; Sets to reg B4h+ (stereo output control and LFO sensitivity)
		ld	c,(ix+ch_ams_fms_pan)			; Panning / AMS / FMS settings from track
		rst	zWriteFMIorII				; Write it!
		ld	(ix+ch_tl_ptr_low),l			; Save current position (TL bytes begin)
		ld	(ix+ch_tl_ptr_high),h			; ...for updating ch_volume correctly later later

; zloc_E65
.a_backup:
		ld	a,0					; Self-modified code: 'a' will actually be set to the feedback/algorithm byte
		and	a,7					; Only keeping the "algorithm" part of it
		add	a,zVolTLMaskTbl&0FFh			; Adds offset to zVolTLMaskTbl table (low byte only)
		ld	e,a					; Puts this low byte into 'e'
		ld	d,(zVolTLMaskTbl&0FF00h)>>8		; Get high byte -> 'd'
		ld	a,(de)					; Get this zVolTLMaskTbl value by algorithm
		ld	(ix+ch_vol_tl_mask),a			; Store this zVolTLMaskTbl value into (ix+1Ah)
		ld	e,a					; Store zVolTLMaskTbl value -> 'e'
		ld	d,(ix+ch_volume)			; Store channel ch_volume -> 'd'
		pop	af					; Restore 'a'; it's now back at appropriate 40h+ register for Total Level setting!

; Set "total levels" (general ch_volume control)
zSetFMTLs:
		ld	b,4					; Loop 4 times (for each total level register on this channel)

.loop:
		ld	c,(hl)					; Get next TL byte -> c
		inc	hl					; Next voice byte...
		rr	e					; zVolTLMaskTbl value is rotated right; if the bit 0 of this value prior to the rotate was reset (0)...
		jr	nc,.write				; ...then we make the jump here (just write the TL value directly, don't modify it)

; Otherwise, apply channel ch_volume to TL here
; It's not appropriate to alter ALL TL values, only
; the ones which are "slots" (output operators)
		push	af					; Save 'a'
    if FixBugs
		res	7,c
    endc
		ld	a,d					; Channel ch_volume -> d
		add	a,c					; Add it to the TL value
    if FixBugs
; Prevent attenuation overflow (ch_volume underflow)
		jp	p,.belowmax
		ld	a,7Fh

.belowmax:
    endc
		ld	c,a					; Modified value -> c
		pop	af					; Restore 'a'

.write:
		rst	zWriteFMIorII				; Write TL value
		add	a,4					; Next TL reg...
		djnz	.loop

		ret
; End of function zSetVoiceMusic

; zsub_E8A
zSetChanVol:
		bit	t_psg_bit,(ix+ch_type)			; Is this a PSG track?
		ret	nz					; If so, quit!
		bit chf_mask_bit,(ix+ch_flags)			; If playback control byte "SFX is overriding this track" bit set...
		ret	nz					; ...then quit!
		ld	e,(ix+ch_vol_tl_mask)			; zVolTLMaskTbl value from last voice setting (marks which specific TL operators need updating)
		ld	a,(ix+ch_type)				; Load current voice control byte
		and	a,t_fm_assignment			; Keep only bits 0-2
		add	a,40h					; Add 40h -- appropriate TL register
		ld	d,(ix+ch_volume)			; Get channel ch_volume
		bit	7,d					; If bit 7 (80h) is set...
		ret	nz					; ...then quit!
		push	hl					; Save 'hl'
		ld	l,(ix+ch_tl_ptr_low)			; Low byte of where TL bytes begin (set during last voice setting)
		ld	h,(ix+ch_tl_ptr_high)			; High byte of where TL bytes begin (set during last voice setting)
		call	zSetFMTLs				; Set the appropriate Total Levels
		pop	hl					; Restore 'hl'
		ret
; End of function zSetChanVol

; ===========================================================================

; (via Saxman's doc): F0wwxxyyzz - modulation
; o	ww - Wait for this period of time before modulation starts
; o	xx - Modulation speed
; o	yy - Modulation change per mod. step
; o	zz - Number of steps in modulation
; zloc_EB0
cfModulation:
		set	chf_vib_bit,(ix+ch_flags)		; Set bit 3 (08h) of "playback control" byte (modulation on)
		dec	hl					; Move 'hl' back one...
		ld	(ix+ch_vibptr_low),l			; Back up modulation setting address into (ix+11h), (ix+12h)
		ld	(ix+ch_vibptr_high),h

; zloc_EBB
zSetModulation:
; Sets up modulation for this track; expects 'hl' to point to modulation
; configuration info...
		ld	a,ixl					; Get lower byte of current track address (ew :P)
		add	a,ch_vib_delay				; ... and add 19 bytes to it
		ld	e,a					; put that into 'e'
		adc	a,ixh					; If carry occurred, add that to upper part of address
		sub	a,e					; subtract 'e'
		ld	d,a					; Basically, 'd' is now the appropriate upper byte of the address, completing de = (ix + 19)
; Copying next three bytes
    if OptimizeSoundDriver
		ld	bc,3
		ldir						; while (bc-- > 0) *de++ = *hl++; (wait, modulation speed, modulation change)
    else
		ldi						; *(de)++ = *(hl)++		(Wait for ww period of time before modulation starts)
		ldi						; *(de)++ = *(hl)++		(Modulation Speed)
		ldi						; *(de)++ = *(hl)++		(Modulation change per Mod. Step)
    endc
		ld	a,(hl)					; Get Number of steps in modulation
		inc	hl					; Next byte...
		srl	a					; divide number of steps by 2
		ld	(ix+ch_vib_steps),a			; Store this step count into trackPtr+16h
		bit	chf_tie_bit,(ix+ch_flags)		; Is bit 4 "do not attack next note" (10h) set?
		ret	nz					; If so, quit!
		xor	a					; Clear 'a'
		ld	(ix+ch_vibval_low),a			; Clear modulation value low byte
		ld	(ix+ch_vibval_high),a			; Clear modulation value high byte
		ret
; ===========================================================================

; (via Saxman's doc): Turn on modulation
; zloc_EDE
cfEnableModulation:
		dec	hl
		set	chf_vib_bit,(ix+ch_flags)		; Playback byte bit 3 (08h) -- modulation on
		ret
; ===========================================================================

; (via Saxman's doc): stop the track
; zloc_EE4
cfStopTrack:
		res	chf_enable_bit,(ix+ch_flags)		; Clear playback byte bit 7 (80h) -- currently playing (not anymore)
		res	chf_tie_bit,(ix+ch_flags)		; Clear playback byte bit 4 (10h) -- do not attack
		bit	t_psg_bit,(ix+ch_type)			; Is voice control bit 7 (80h) a PSG track set?
		jr	nz,zStopPSGTrack			; If so, skip this next part...
		ld	a,(z_abs_vars+f_updating_dac)		; Is DAC updating?  (FF if so)
		or	a					; test it
		jp	m,zDACStopTrack				; If DAC is updating, go here (we're in a DAC track)
		call	zFMNoteOff				; Otherwise, stop this FM track
		jr	zStoppedChannel

; zcall_zsub_526
zStopPSGTrack:
		call	zPSGNoteOff

zStoppedChannel:						; General stop track continues here...
		ld	a,(f_dosfx)				; Check if we're an SFX track
		or	a					; test it
		jp	p,zStopMusicTrack			; if not, jump
		xor	a					; a = 0
		ld	(z_abs_vars+v_priority),a		; Reset SFX priority
		ld	a,(ix+ch_type)				; Load "voice control" byte
		or	a					; test it..
		jp	m,zStopPSGSFXTrack			; If this is a PSG SFX track, jump
		push	ix					; save 'ix'
; This is an FM SFX track that's trying to stop
		sub	a,2					; Take channel assignment - 2 (since SFX never use FM 1 or FM 2)
		add	a,a					; a *= 2 (each table entry is 2 bytes wide)
		add	a,zMusicTrackOffs&0FFh			; Get low byte value from zMusicTrackOffs
		ld	(.fmtrackoffs+2),a			; Store into the instruction after .fmtrackoffs (self-modifying code)

; zloc_F1D:
.fmtrackoffs:
		ld	ix,(zMusicTrackOffs)			; Self-modified code from just above: 'ix' points to corresponding Music FM track
		bit chf_mask_bit,(ix+ch_flags)			; If "SFX is overriding this track" is not set...
		jp	z,zNoVoiceUpdate			; Skip this part (i.e. if SFX was not overriding this track, then nothing to restore)
		call	zBankSwitchToMusic			; Bank switch back to music track
		res chf_mask_bit,(ix+ch_flags)			; Clear SFX is overriding this track from playback control
		set	chf_rest_bit,(ix+ch_flags)		; Set track as resting bit
		ld	a,(ix+ch_voice)				; Get voice this track was using
		call	zSetVoiceMusic				; And set it! (takes care of ch_volume too)

		bankswitch SoundIndex

zNoVoiceUpdate:
		pop	ix					; restore 'ix'
		pop	bc					; removing return address from stack; will not return to coord flag loop
		pop	bc					; removing return address from stack; will not return to zUpdateTrack function
		ret
; ===========================================================================

zStopPSGSFXTrack:
		push	ix					; save 'ix'

; Keep in mind that we just entered with a PSG "voice control" byte
; which is one of the following values (PSG1-3/3N) -- 80h, A0h, C0h, E0h
		rra
		rra
		rra
		rra						; in effect, ">> 4"
		and	a,0Fh					; 'a' is now 08, 0A, 0C, or 0E
		add	a,zMusicTrackOffs&0FFh
		ld	(.psgtrackoffs+2),a			; store into the instruction after .psgtrackoffs (self-modifying code)

; zloc_F5A
.psgtrackoffs:
		ld	ix,(zMusicTrackOffs)			; Self-modified code from just above: 'ix' points to corresponding Music PSG track
		res chf_mask_bit,(ix+ch_flags)			; Clear SFX is overriding this track from playback control
		set	chf_rest_bit,(ix+ch_flags)		; Set track as resting bit
		ld	a,(ix+ch_type)				; Get voice control byte
		cp	0E0h					; Is this a PSG 3 noise (not tone) track?
		jr	nz,.exit				; If it isn't, don't do next part (non-PSG Noise doesn't restore)
		ld	a,(ix+ch_noisemode)			; Get PSG noise setting
		ld	(zPSG),a				; Write it to PSG

.exit:
		pop	ix					; restore 'ix'

; zloc_F75
zStopMusicTrack:
		pop	bc					; removing return address from stack; will not return to coord flag loop

; zloc_F76
zDACStopTrack:
		pop	bc					; removing return address from stack; will not return to zUpdateTrack function (anything other than DAC) or not to coord flag loop (if DAC)
		ret
; ===========================================================================

; (via Saxman's doc): Change current PSG noise to xx (For noise channel, E0-E7)
; zloc_F78
cfSetPSGNoise:
		ld	(ix+ch_type),0E0h			; This is a PSG noise track now!
		ld	(ix+ch_noisemode),a			; Save PSG noise setting for restoration if SFX overrides it
		bit chf_mask_bit,(ix+ch_flags)			; If SFX is currently overriding it, don't actually set it!
		ret	nz
		ld	(zPSG),a				; Otherwise, please do
		ret
; ===========================================================================

; (via Saxman's doc): Turn off modulation
; zloc_F88
cfDisableModulation:
		dec	hl					; No parameters used, must back up a byte
		res	chf_vib_bit,(ix+ch_flags)		; Clear "modulation on" bit setting
		ret
; ===========================================================================

; (via Saxman's doc): Change current PSG tone to xx
; zloc_F8E
cfSetPSGTone:
		ld	(ix+ch_voice),a				; Set current PSG tone
		ret
; ===========================================================================

; (via Saxman's doc): jump to position yyyy
; zloc_F92
cfJumpTo:
		ld	h,(hl)					; Get hight byte of jump destination (since pointer advanced to it)
		ld	l,a					; Put low byte (already retrieved)
		ret
; ===========================================================================

; (via Saxman's doc): $F7xxyyzzzz - repeat section of music
;    * xx - loop index, for loops within loops without confusing the engine.
;          o EXAMPLE: Some notes, then a section that is looped twice, then some more notes, and finally the whole thing is looped three times.
;            The "inner" loop (the section that is looped twice) would have an xx of 01, looking something along the lines of F70102zzzz, whereas the "outside" loop (the whole thing loop) would have an xx of 00, looking something like F70003zzzz.
;    * yy - number of times to repeat
;          o NOTE: This includes the initial encounter of the F7 flag, not number of times to repeat AFTER hitting the flag.
;    * zzzz - position to loop back to
; zloc_F95
cfRepeatAtPos:
; Loop index is in 'a'
		ld	c,(hl)					; Get next byte (number of repeats) -> 'c'
		inc	hl					; Next byte...
		push	hl					; Save 'hl'
		add	a,ch_loopcounters			; Add to make loop index offset (starts at 20h in track memory)
		ld	l,a					; Set hl = offset index
		ld	h,0
		ld	e,ixl					; Set 'de' to beginning of track
		ld	d,ixh
		add	hl,de					; hl is now pointing to track memory offset for this loop
		ld	a,(hl)					; Get loop count at this address
		or	a					; Test it
		jr	nz,.loopexists				; If not zero, then skip next step (i.e. we're currently looping)
		ld	(hl),c					; Otherwise, set it to the new number of repeats

.loopexists:
		dec	(hl)					; One less loop
		pop	hl					; Restore 'hl' (now at the position)
		jr	z,.noloop				; If counted to zero, skip the rest of this (hence start loop count of 1 terminates the loop without ever looping)
		ld	a,(hl)					; Get low byte of jump address
		inc	hl					; Next byte
		ld	h,(hl)					; Get high byte of jump address -> 'h'
		ld	l,a					; Put low byte of jump address -> 'l'

		; Note then that this loop command only works AFTER the section you mean to loop
		ret

.noloop:
; If you get here, the loop terminated; just bypass the loop jump address
		inc	hl
		inc	hl
		ret
; ===========================================================================

; (via Saxman's doc): jump to position yyyy (keep previous position in memory for returning)
; zloc_FB3
cfJumpToGosub:
		ld	c,a					; a -> c
		ld	a,(ix+ch_stackptr)			; Get current "stack" offset (starts at 2Ah, i.e. beginning of next track)
		sub	a,2					; Move back by two (we need to store a new return address)
		ld	(ix+ch_stackptr),a			; Set current stack offset
		ld	b,(hl)					; Get high byte of jump position -> 'b'
		inc	hl					; Next byte...
		ex	de,hl					; hl <=> de
		add	a,ixl					; Add low byte of current track pointer to stack offset (low byte of stack location)
		ld	l,a					; Keep this in 'l'
		adc	a,ixh					; Update high byte, if necessary
		sub	a,l					; Fixup
		ld	h,a					; a -> 'h' (Simply, we just did hl = ix + stack_offset)
		ld	(hl),e					; Store current address low byte (just after jump) into stack
		inc	hl					; Next byte
		ld	(hl),d					; Store current address high byte (just after jump) into stack
		ld	h,b
		ld	l,c					; hl = bc (current location is where you wanted to jump to)
		ret
; ===========================================================================

; Leftover from Sonic 1: was used in Spring Yard Zone's music.
; zloc_FCC
cfOpF9:
		ld	a,88h					; D1L/RR of Operator 3
		ld	c,0Fh					; Loaded with fixed value (max RR, 1TL)
		rst	zWriteFMI				; Written to part I
		ld	a,8Ch					; D1L/RR of Operator 4
		ld	c,0Fh					; Loaded with fixed value (max RR, 1TL)
		rst	zWriteFMI				; Written to part I
		dec	hl					; Doesn't take an arg, so put back one byte
		ret

; ===========================================================================

; ---------------------------------------------------------------------------
; Priority table
; ---------------------------------------------------------------------------

GenPriority:	macro	name, priority
		db \priority
		endm
		
zSFXPriority:		
		SFXFiles	GenPriority			; generate the SFX priority list

; ---------------------------------------------------------------------------
; Envelope pointer list
; ---------------------------------------------------------------------------
		
GenEnvTable:	macro	name
		numstr: substr 1,2,"\name"			; get digits for constant
		dw EnvData_\numstr\				; create a pointer for every envelope
		endm		

Envelopes:
		VolumeEnv	GenEnvTable			; generate the envelope pointers

; ---------------------------------------------------------------------------
; Envelope includes
; ---------------------------------------------------------------------------

EnvData_01:
		db	0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5
		db	5,5,6,6,6,7,80h

; byte_105A
EnvData_02:
		db	0,2,4,6,8,10h,80h

; byte_1061
EnvData_03:
		db	0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,80h

; byte_1072
EnvData_04:
		db	0,0,2,3,4,4,5,5,5,6,80h

; The next two envelopes appear in a different order than in the list above.

; byte_107D
EnvData_06:
		db	3,3,3,2,2,2,2,1,1,1,0,0,0,0,80h

; byte_108C
EnvData_05:
		db	0,0,0,0,0,0,0,0,0,0,1,1
		db	1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2
		db	2,2,2,2,3,3,3,3,3,3,3,3,4,80h

; byte_10B6
EnvData_07:
		db	0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2
		db	3,3,3,4,4,4,5,5,5,6,7,80h

; byte_10D2
EnvData_08:
		db	0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2
		db	3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6
		db	6,6,6,6,7,7,7,80h

; byte_10FA
EnvData_09:
		db	0,1,2,3,4,5,6,7,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh,80h

; byte_110B
EnvData_0A:
		db	0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
		db	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
		db	1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2
		db	2,2,3,3,3,3,3,3,3,3,3,3,4,80h

; byte_1149
EnvData_0B:
		db	4,4,4,3,3,3,2,2,2,1,1,1,1,1,1,1
		db	2,2,2,2,2,3,3,3,3,3,4,80h

; byte_1165
EnvData_0C:
		db	4,4,3,3,2,2,1,1,1,1,1,1,1,1,1,1
		db	1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2
		db	2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3
		db	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
		db	3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4
		db	4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5
		db	5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6
		db	6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,80h

; byte_11E5
EnvData_0D:
		db	0Eh,0Dh,0Ch,0Bh,0Ah,9,8,7,6,5,4,3,2,1,0,80h


MasterPlaylist: macro  name,tempo,flag
		
		if ~def(zptr_id)
			zptr_id: = 80h
		endc
		
		db	ptr_musfile_\1\+\flag			; generate playlist entry with value generated by sndbnk_ptr macro plus flag value if applicable
		zptr_mus_\1\: equ zptr_id			; generate signed byte constant for use in sound driver
		
		zptr_id: = zptr_id+1				; increment each pointer value
	endm	

; zbyte_11F5h
zMasterPlaylist:		
		MusicFiles	MasterPlaylist			; generate playlist entries and Z80 constants

GenSpeedup:	macro	name,tempo,flag
		db \tempo
		endm
		
SpeedUpIndex:
		MusicFiles	GenSpeedup			; generate the speed shoes tempo list
		
		ensure1byteoffset 1Ch

zsample:	macro	sample
		dw	zbankptr_\sample
		dw	sizeof_\sample
		endm

;zbyte_1233
zDACPtrTbl:
		zsample	DAC_Kick
		zsample	DAC_Snare
		zsample	DAC_Clap
		zsample	DAC_RecordScratch
		zsample	DAC_Timpani			
		zsample DAC_Tom			
		zsample	DAC_VLowClap			


		ensure1byteoffset 22h
; zbyte_124F
zDACMasterPlaylist:
; something else for DAC sounds
; First byte selects one of the DAC samples. The number that
; follows it is a wait time between each nibble written to the DAC
; (thus higher = slower)

		db	dKick,		17h			; 81h ; kick
		db	dSnare,		1			; 82h ; snare
		db	dClap,		6			; 83h ; clap
		db	dScratch,	8			; 84h ; scratch
		db	dTimpani,	1Bh			; 85h ; timpani
		db	dHiTom,		0Ah			; 86h ; hitom
		db	dVLowClap,	1Bh			; 87h ; vlowclap
		db	dTimpani,	12h			; 88h ; hitimpani
		db	dTimpani,	15h			; 89h ; midtimpani
		db	dTimpani,	1Ch			; 8Ah ; lowtimpani
		db	dTimpani,	1Dh			; 8Bh ; vlowtimpani
		db	dHiTom,		2			; 8Ch ; midtom
		db	dHiTom,		5			; 8Dh ; lowtom
		db	dHiTom,		8			; 8Eh ; floortom
		db	dVLowClap,	8			; 8Fh ; hiclap
		db	dVLowClap,	0Bh			; 90h ; midclap
		db	dVLowClap,	12h			; 91h ; lowclap

; zsub_1271
zSaxmanDec:
    if OptimizeSoundDriver
		xor	a
		ld	b,a
		ld	d,a
		ld	e,a
    else
		exx
		ld	bc,0
		ld	de,0
    endc
		exx
		ld	de,z_music_data
		ld	c,(hl)
		inc	hl
		ld	b,(hl)					; bc = (hl) i.e. "size of song"
		inc	hl
		ld	(zGetNextByte+1),hl			; modify inst. @ zGetNextByte -- set to beginning of decompression stream
    if OptimizeSoundDriver=0
		inc	bc
    endc
		ld	(zDecEndOrGetByte+1),bc			; modify inst. @ zDecEndOrGetByte -- set to length of song, +1

; zloc_1288
zSaxmanReadLoop:
		exx						; shadow reg set
    if OptimizeSoundDriver
		srl	b					; b >> 1 (just a mask that lets us know when we need to reload)
		jr	c,.skip_fetching_descriptor		; if next bit of 'b' is set, we still have bits left in 'c', so continue
; If you get here, we're out of bits in 'c'!
		call	zDecEndOrGetByte			; get next byte -> 'a'
		ld	c,a					; a -> 'c'
		ld	b,7Fh					; b = 7Fh (7 new bits in 'c')

.skip_fetching_descriptor:
		srl	c					; test next bit of 'c'
		exx						; normal reg set
		jr	nc,.is_dictionary_reference		; if bit not set, it's a compression bit; jump accordingly
    else
		srl	c					; c >> 1 (active control byte)
		srl	b					; b >> 1 (just a mask that lets us know when we need to reload)
		bit	0,b					; test next bit of 'b'
		jr	nz,.skip_fetching_descriptor		; if it's set, we still have bits left in 'c', so continue
; If you get here, we're out of bits in 'c'!
		call	zDecEndOrGetByte			; get next byte -> 'a'
		ld	c,a					; a -> 'c'
		ld	b,0FFh					; b = FFh (8 new bits in 'c')

.skip_fetching_descriptor:
		bit	0,c					; test next bit of 'c'
		exx						; normal reg set
		jr	z,.is_dictionary_reference		; if bit not set, it's a compression bit; jump accordingly
    endc
; If you get here, there's a non-compressed byte
		call	zDecEndOrGetByte			; get next byte -> 'a'
		ld	(de),a					; store it directly to the target memory address
		inc	de					; de++
		exx						; shadow reg set
		inc	de					; Also increase shadow-side 'de'... relative pointer only, does not point to output Z80_RAM
		exx						; normal reg set
		jr	zSaxmanReadLoop				; loop back around...

.is_dictionary_reference:
		call	zDecEndOrGetByte			; get next byte -> 'a'
		ld	c,a					; a -> 'c' (low byte of target address)
		call	zDecEndOrGetByte			; get next byte -> 'a'
		ld	b,a					; a -> 'b' (high byte of target address + count)
		and	a,0Fh					; keep only lower four bits...
		add	a,3					; add 3 (minimum 3 bytes are to be read in this mode)
		push	af					; save 'a'...
		ld	a,b					; b -> 'a' (low byte of target address)
		rlca
		rlca
		rlca
		rlca
		and	a,0Fh					; basically (b >> 4) & 0xF (upper four bits now exclusively as lower four bits)
		ld	b,a					; a -> 'b' (only upper four bits of value make up part of the address)
		ld	a,c
		add	a,12h
		ld	c,a
		adc	a,b
		sub	a,c
		and	a,0Fh
		ld	b,a					; bc += 12h
		pop	af					; restore 'a' (byte count to read; no less than 3)
		exx						; shadow reg set
		push	de					; keep current 'de' (relative pointer) value...
		ld	l,a					; how many bytes we will read -> 'hl'
		ld	h,0
		add	hl,de					; add current relative pointer...
		ex	de,hl					; effectively, de += a
		exx						; normal reg set
		pop	hl					; shadow 'de' -> 'hl' (relative pointer, prior to all bytes read, relative)
		or	a					; Clear carry
		sbc	hl,bc					; hl -= bc
		jr	nc,.is_not_zero_fill			; if result positive, jump ahead
		ex	de,hl					; current output pointer -> 'hl'
		ld	b,a					; how many bytes to load -> 'b'

.fill_zero_loop:
		ld	(hl),0					; fill in zeroes that many times
		inc	hl
		djnz	.fill_zero_loop

		ex	de,hl					; output pointer updated
		jr	zSaxmanReadLoop				; loop back around...

.is_not_zero_fill:
		ld	hl,z_music_data				; point at beginning of decompression point
		add	hl,bc					; move ahead however many bytes
		ld	c,a
		ld	b,0
		ldir
		jr	zSaxmanReadLoop



; This is an ugly countdown to zero implemented in repeatedly modifying code!!
; But basically, it starts at the full length of the song +1 (so it can decrement)
; and waits until 'hl' decrements to zero
; zsub_12E8
zDecEndOrGetByte:
		ld	hl,0					; Self-modified code: starts at full length of song +1, waits until it gets to 1...
    if OptimizeSoundDriver
		ld	a,h
		or	a,l
		jr	z,zDecEnd				; If 'h' and 'l' both equal zero, we quit!!
    endc
		dec	hl					; ...where this will be zero
		ld	(zDecEndOrGetByte+1),hl			; Self-modified code: update the count in case it's not zero
    if OptimizeSoundDriver=0
		ld	a,h
		or	a,l
		jr	z,zDecEnd				; If 'h' and 'l' both equal zero, we quit!!
    endc

; zloc_12F3
zGetNextByte:
		ld	hl,0					; Self-modified code: get address of next compressed byte
		ld	a,(hl)					; put it into -> 'a'
		inc	hl					; next byte...
		ld	(zGetNextByte+1),hl			; change inst @ zGetNextByte so it loads next compressed byte
		ret						; still going...

; zloc_12FC
zDecEnd:
		pop	hl					; throws away return address to this function call so that next 'ret' exits decompressor (we're done!)
		ret						; Exit decompressor

; ===========================================================================
; space for a few global variables

		include_global_vars


; end of Z80 'ROM'
		if offset(*)>z_music_data
			inform 3,"Your Z80 code won't fit before the music RAM. It's %hh bytes past the start of music data at %hh",\offset(*)-z_music_data,z_music_data
		endc
