;  =========================================================================
; |           Sonic the Hedgehog 2 Disassembly for Sega Mega Drive          |
;  =========================================================================

; originally created by Nemesis in 2004
; sound driver disassembly by Xenowhirl in 2007, with further work by RAS 2008

; ported to AXM68K/Z80 Macros by Orion Navattan, including documentation
; from Sonic Retro AS and Sonic 1 Hivebrain 2022

; Thank you to Hivebrain, Clownacy, and MoDule

;  =========================================================================

		opt	l.					; . is the local label symbol
		opt	ae-					; automatic evens disabled by default
		opt oz+						; address register indirect zero-displacement optimization enabled by default (but see the ZeroOffsetOptimization conditional below)
		opt	an+					; allow Intel/Zilog-style number suffixes (used in the Z80 code and definitions)
		opt	ws+					; allow statements to contain white-spaces
		opt	w+					; print warnings
;		opt	m+					; do not expand macros - if enabled, this can break assembling

; Main section for all 68k code + startup dummy z80 program;
; sound driver and S2 Driver Compress data are seperate sections.

Main:	group word,org(0)					; we have to use the long form of group declaration to avoid triggering an overlay warning during assembly
		section MainProgram,Main

	if ~def(Revision)
Revision: equ 1
; if 0, builds a REV00 ROM
; if 1, builds a REV01 ROM, which contains some fixes
; if 2, builds a hypothetical standalone REV02 ROM (based on the changes found in all
; known appearances, without any of the implementation-specific bugs) which contains even more fixes
	endc

FixBugs: equ 0
; If 1, enables a number of engine and gameplay bug-fixes, including some in the music and sound driver.

OptimizeSoundDriver: equ 0
; If 1, enables a number of optimizations in the sound driver.

AllOptimizations: equ 0
; If 1, enables all REV02 assembler optimizations as well as optimized leas from REV00 & REV01
; and the zero-displacement optimization.

ZeroOffsetOptimization: equ 0|AllOptimizations
; If 1, enables the zero-displacement optimization for 156 instances of address register
; indirect displacement instructions that were unoptimized in the original game.
; See the macro definitions for a more complete explanation.

RemoveJmpTos: equ 0|(Revision=2|AllOptimizations)
; If 1, many unnecessary JmpTos are removed, improving performance.
; See the jsrto amd jmpto macro definitions for more information.

AddSubOptimize: equ 0|(Revision=2|AllOptimizations)
; If 1, many addi/subi/adda instructions are optimized to addq/subq.

RelativeLea: equ 0|(Revision<>2|AllOptimizations)
; If 1, makes some lea instructions use pc-relative addressing, instead of absolute long.

WaterPhysicsFixes:	equ 0
; If 1, applies some consistency changes to the water physics

DebugImprovements:	equ 0
; If 1, enables some improvements to debug mode	(make some otherwise invisible objects visible)

;SkipChecksumCheck equ 0
; If 1, disables the slow bootup checksum calculation

;UseFullWaterTables equ 0
; If 1, zone offset tables for water levels cover all level slots instead of only slots 8-$F
; If you've shifted level IDs around or you want water in levels with a level slot below 8

		include "Macros - More CPUs.asm"
		cpu 68000

		include "Mega Drive.asm"
		include "Macros.asm"
		include "Constants.asm"

		include "sound/Sound Equates.asm"		; variables and constants for the sound driver
		include "sound/Frequency, Note, Envelope, & Sample Definitions.asm" ; definitions used in both the sound driver and SMPS2ASM
		include "sound/Sound Language.asm"		; SMPS2ASM macros and conversion functionality
		include "sound/Sounds.asm"

		include "File List.asm"
		include "RAM Addresses.asm"
		include "VRAM Addresses.asm"
		include "Object Subtypes.asm"			; object subtype constants
		include "Compatibility.asm"			; compatibility with Sonic 2 AS

ROM_Start:
		if offset(*)<>0
			inform 3,"ROM_Start is at $%h, but it must be 0. Make sure you haven't accidentally defined code in the equate and macro files.",offset(ROM_Start)
		endc
Vectors:
		dc.l v_stack_pointer				; Initial stack pointer value
		dc.l EntryPoint					; Start of program
		dc.l ErrorTrap					; Bus error
		dc.l ErrorTrap					; Address error (4)
		dc.l ErrorTrap					; Illegal instruction
		dc.l ErrorTrap					; Division by zero
		dc.l ErrorTrap					; CHK exception
		dc.l ErrorTrap					; TRAPV exception (8)
		dc.l ErrorTrap					; Privilege violation
		dc.l ErrorTrap					; TRACE exception
		dc.l ErrorTrap					; Line-A emulator
		dc.l ErrorTrap					; Line-F emulator (12)
		dcb.l 2,ErrorTrap				; Unused (reserved)
		dc.l ErrorTrap					; Format error
		dc.l ErrorTrap					; Uninitialized interrupt
		dcb.l 8,ErrorTrap				; Unused (reserved)
		dc.l ErrorTrap					; Spurious exception
		dc.l ErrorTrap					; IRQ level 1
		dc.l ErrorTrap					; IRQ level 2 (joypad and EXT /TH pin interrupt, unused here)
		dc.l ErrorTrap					; IRQ level 3 (28)
		dc.l HBlank					; IRQ level 4 (horizontal interrupt)
		dc.l ErrorTrap					; IRQ level 5
		dc.l VBlank					; IRQ level 6 (vertical interrupt)
		dc.l ErrorTrap					; IRQ level 7 (32)
		dcb.l 16,ErrorTrap				; TRAP #00..#15 exceptions
		dcb.l 16,ErrorTrap				; Unused (reserved)

Header:
		dc.b 'SEGA GENESIS    '				; Console name
		dc.b '(C)SEGA 1992.SEP'				; Copyright/Date
		dc.b 'SONIC THE             HEDGEHOG 2                ' ; Domestic name
		dc.b 'SONIC THE             HEDGEHOG 2                ' ; International name
    if Revision=0
		dc.b "GM 00001051-00"				; Version (REV00)
    elseif Revision=1
		dc.b "GM 00001051-01"				; Version (REV01)
    elseif Revision=2
		dc.b "GM 00001051-02"				; Version (REV02)
    endc
Checksum:	dc.w $D951					; Checksum
		dc.b 'J               '				; I/O Support
ROMStartLoc:	dc.l Rom_Start					; ROM Start
ROMEndLoc:	dc.l Rom_End-1					; ROM End
RAMStartLoc:	dc.l ram_start					; RAM Start
RAMEndLoc:	dc.l ram_end					; RAM End
		dc.b '                                                          ' ; Notes
		dc.b '      '
		dc.b 'JUE             '				; Country
EndOfHeader:
; ===========================================================================

ErrorTrap:
		nop
		nop
		bra.s	ErrorTrap				; any exceptions are dumped in this infinite loop
; ===========================================================================

EntryPoint:
		tst.l	(port_1_control_hi).l			; test port 1 control register
		bne.s	.skip					; branch if not 0
		tst.w	(port_e_control_hi).l			; test ext port control register

	.skip:
		bne.s	SkipSetup				; branch if not 0
		; If both of the above tests return 0, then this is a cold boot or we were handed off
		; from the TMSS ROM. Satisfy the TMSS if necessary, and initialize the VDP.
		lea	SetupValues(pc),a5			; load setup values array address
		movem.w	(a5)+,d5-d7				; d5 = VDP reg baseline; d6 = RAM size; d7 = VDP reg diff
		movem.l	(a5)+,a0-a4				; a0 = z80_ram ; a1 = z80_bus_request; a2 = z80_reset; a3 = vdp_data_port; a4 = vdp_control_port
		move.b	console_version-z80_bus_request(a1),d0	; get hardware version (from $A10001)
		andi.b	#console_revision,d0
		beq.s	.no_tmss				; if Model 1 VA4 or earlier (no TMSS), branch
		move.l	#'SEGA',tmss_sega-z80_bus_request(a1)	; move "SEGA" to TMSS register ($A14000)

		; Initialize the VDP and clear the RAM, VRAM, VSRAM, and CRAM.
	.no_tmss:
		move.w	(a4),d0					; clear write-pending flag in VDP to prevent issues if the 68k has been reset in the middle of writing a command long word to the VDP.
		moveq	#0,d0					; clear d0
		movea.l	d0,a6					; clear a6
		move.l	a6,usp					; set usp to $0

		moveq	#sizeof_SetupVDP-1,d1			; number of times to loop
	.loop_vdp:
		move.b	(a5)+,d5				; add $8000 to value
		move.w	d5,(a4)					; move value to VDP register
		add.w	d7,d5					; next register
		dbf	d1,.loop_vdp				; repeat until all registers have been written

		move.l	(a5)+,(a4)
		move.w	d0,(a3)					; clear the VRAM
		move.w	d7,(a1)					; stop the Z80
		move.w	d7,(a2)					; reset the Z80

	.waitz80:
		btst	d0,(a1)					; has the Z80 stopped?
		bne.s	.waitz80				; if not, branch
		moveq	#Z80_Startup_size-1,d2			; load the number of bytes in Z80_Startup program into d2

	.loadz80:
		move.b	(a5)+,(a0)+				; load the Z80_Startup program byte by byte to Z80 RAM
		dbf	d2,.loadz80

		move.w	d0,(a2)
		move.w	d0,(a1)					; start the z80
		move.w	d7,(a2)					; reset the z80

	.loop_ram:
		move.l	d0,-(a6)				; clear 4 bytes of RAM and decrement
		dbf	d6,.loop_ram				; repeat until entire RAM is clear
		move.l	(a5)+,(a4)				; set VDP display mode and increment mode
		move.l	(a5)+,(a4)				; set VDP to CRAM write

		moveq	#(sizeof_pal_all/4)-1,d3		; set repeat times
	.loop_cram:
		move.l	d0,(a3)					; clear 2 palette entries
		dbf	d3,.loop_cram				; repeat until entire CRAM is clear
		move.l	(a5)+,(a4)				; set VDP to VSRAM write

		moveq	#(sizeof_vsram/4)-1,d4
	.loop_vsram:
		move.l	d0,(a3)					; clear 4 bytes of VSRAM
		dbf	d4,.loop_vsram				; repeat until entire VSRAM is clear

		moveq	#countof_music_psg_tracks,d5		; actually four channels, but one is never used
	.loop_psg:
		move.b	(a5)+,psg_input-vdp_data_port(a3)	; reset PSG0
		dbf	d5,.loop_psg				; repeat for all other channels

		move.w	d0,(a2)
		movem.l	(a6),d0-a6				; clear all registers
		disable_ints					; disable interrupts

SkipSetup:
		bra.s	GameProgram				; begin game
; ===========================================================================

SetupValues:
		dc.w vdp_mode_register1				; VDP register start number
		dc.w (sizeof_ram/4)-1				; size of RAM/4
		dc.w vdp_mode_register2-vdp_mode_register1	; VDP register diff

		dc.l z80_ram					; start	of Z80 RAM
		dc.l z80_bus_request				; Z80 bus request
		dc.l z80_reset					; Z80 reset
		dc.l vdp_data_port				; VDP data
		dc.l vdp_control_port				; VDP control

; The following values are overwritten by VDPSetupGame (and later by game modes), so end up basically unused.
SetupVDP:
		dc.b vdp_md_color&$FF				; $80 - normal color mode, horizontal interrupts disabled
		dc.b (vdp_enable_dma|vdp_md_display)&$FF	; $81 - mode 5, NTSC, vertical interrupts disabled, DMA enabled
		dc.b (vdp_fg_nametable+($C000>>10))&$FF		; $82 - foreground nametable address
		dc.b (vdp_window_nametable+($F000>>10))&$FF	; $83 - window nametable address
		dc.b (vdp_bg_nametable+($E000>>13))&$FF		; $84 - background nametable address
		dc.b (vdp_sprite_table+($D800>>9))&$FF		; $85 - sprite attribute table address
		dc.b vdp_sprite_table2&$FF			; $86 - unused (high bit of sprite attribute table address for 128KB VRAM)
		dc.b (vdp_bg_color+0)&$FF			; $87 - background color
		dc.b vdp_sms_hscroll&$FF			; $88 - unused (mode 4 hscroll register)
		dc.b vdp_sms_vscroll&$FF			; $89 - unused (mode 4 vscroll register)
		dc.b (vdp_hint_counter+255)&$FF			; $8A - horizontal interrupt register
		dc.b (vdp_full_hscroll|vdp_full_vscroll)&$FF	; $8B - full-screen vertical/horizontal scrolling
		dc.b vdp_320px_screen_width&$FF			; $8C - H40 display mode
		dc.b (vdp_hscroll_table+($DC00>>10))&$FF	; $8D - HScroll table address
		dc.b vdp_nametable_hi&$FF			; $8E - unused (high bits of fg and bg nametable addresses for 128KB VRAM)
		dc.b (vdp_auto_inc+1)&$FF			; $8F - VDP increment
		dc.b (vdp_plane_width_64|vdp_plane_height_32)&$FF ; $90 - 64x32 cell plane size
		dc.b vdp_window_x_pos&$FF			; $91 - window horizontal position
		dc.b vdp_window_y_pos&$FF			; $92 - window vertical position
		dc.b (vdp_dma_length_low+((sizeof_vram-1)&$FF))&$FF ; $93/$94 - DMA length
		dc.b (vdp_dma_length_hi+((sizeof_vram-1)>>8))&$FF
		dc.b (vdp_dma_source_low+0)&$FF			; $95/96 - DMA source
		dc.b (vdp_dma_source_mid+0)&$FF
		dc.b vdp_dma_vram_fill&$FF			; VDP $97 - DMA fill VRAM
		arraysize	SetupVDP

		vdp_comm.l	dc,vram_start,vram,dma		; VRAM DMA write address 0

Z80_Startup:
		cpu	z80
		obj 0

		; fill the Z80 RAM with 00's (with the exception of this program)
		xor	a					; clear a
		ld	bc,sizeof_z80_ram-(.end+1)		; load the number of bytes to fill
		ld	de,.end+1				; load the destination address of the RAM fill (1 byte after end of program)
		ld	hl,.end					; load the source address of the RAM fill (a single 00 byte)
		ld	sp,hl					; set stack pointer to end of program(?)
		ld	(hl),a					; clear the first byte after the program code
		ldir						; fill the rest of the Z80 RAM with 00's

		; clear all registers
		pop	ix
		pop	iy
		ld	i,a
		ld	r,a
		pop	de
		pop	hl
		pop	af

		ex	af,af					; swap af with af'
		exx						; swap bc, de, and hl
		pop	bc
		pop	de
		pop	hl
		pop	af
		ld	sp,hl					; clear stack pointer

		; put z80 into an infinite loop
		di						; disable interrupts
		im	1					; set interrupt mode to 1 (the only officially supported interrupt mode on the MD)
		ld	(hl),0E9h				; set the first byte into a jp	(hl) instruction
		jp	(hl)					; jump to the first byte, causing an infinite loop to occur.

	.end:							; the space from here til end of Z80 RAM will be filled with 00's
		even						; align the Z80 start up code to the next even byte. Values below require alignment

Z80_Startup_size:
		cpu	68000
		objend

		dc.w	vdp_md_display				; VDP display mode
		dc.w	vdp_auto_inc+2				; VDP increment
		vdp_comm.l	dc,0,cram,write			; CRAM write address 0
		vdp_comm.l	dc,0,vsram,write		; VSRAM write address 0
		dc.b tPSG1|psg_silence,tPSG2|psg_silence,tPSG3|psg_silence,tPSG4|psg_silence ; PSG mute values
; ===========================================================================

GameProgram:
		tst.w	(vdp_control_port).l

CheckSumCheck:
		move.w	(vdp_control_port).l,d1			; get status register

	if Revision>0
		btst	#dma_status_bit,d1			; was the console soft reset during a DMA operation?
		bne.s	CheckSumCheck				; if so, wait until it's finished
	endc

		btst	#6,(port_e_control).l			; was this a soft reset?
		beq.s	ChecksumTest				; if so, branch
		cmpi.l	#'init',(v_checksum_pass).w		; has checksum routine already run?
		beq.w	GameInit				; if it has, branch

ChecksumTest:
		movea.l	#EndOfHeader,a0				; start checking bytes after the header ($200)
		movea.l	#ROMEndLoc,a1				; stop at end of ROM
		move.l	(a1),d0
		moveq	#0,d1

	.loop:
		add.w	(a0)+,d1				; add bytes at current address to d1
		cmp.l	a0,d0					; have we reached tne end?
		bcc.s	.loop					; if not, branch
		movea.l	#Checksum,a1				; read the checksum
		cmp.w	(a1),d1					; compare checksum in header to rom
		bne.w	ChecksumError				; if they don't match, branch

;.checksumok:
		lea	(v_keep_after_reset).w,a6
		moveq	#0,d7
		move.w	#(((ram_end|$FF000000)-v_keep_after_reset+1)/4)-1,d6

	.clearramloop:
		move.l	d7,(a6)+				; clear RAM ($FE00-$FFFF) only on a cold bot
		dbf	d6,.clearramloop

		move.b	(console_version).l,d0			; get console region
		andi.b	#console_region+console_speed,d0
		move.b	d0,(v_console_region).w			; set region variable in RAM
		move.l	#'init',(v_checksum_pass).w		; set flag so checksum won't run again

GameInit:
		lea	(ram_start).l,a6
		moveq	#0,d7
		move.w	#((v_keep_after_reset&$FFFF)/4)-1,d6

	.clearRAM:
		move.l	d7,(a6)+				; clear RAM ($0000-$FDFF)
		dbf	d6,.clearRAM
		bsr.w	VDPSetupGame
		bsr.w	JmpTo_SoundDriverLoad
		bsr.w	JoypadInit
		move.b	#id_Sega,(v_gamemode).w			; set initial game mode (Sega screen)

MainGameLoop:
		move.b	(v_gamemode).w,d0			; load game mode
		andi.w	#$3C,d0					; limit to $1C max
		jsr	GameModeArray(pc,d0.w)			; jump to apt location in ROM
		bra.s	MainGameLoop				; infinite loop
; ===========================================================================
gmptr:		macro
		id_\1:	equ offset(*)-GameModeArray
		if narg=1
		bra.w	GM_\1
		else
		bra.w	GM_\2
		endc
		endm

GameModeArray:
		gmptr	Sega					; 0
		gmptr	Title					; 4
		gmptr	Demo, Level				; 8
		gmptr	Level					; $C
		gmptr	SpecialStage				; $10
		gmptr	Continue				; $14
		gmptr	TwoPlayerResults			; $18
		gmptr	LevelSelectMenu2P			; $1C
		gmptr	EndingSequence				; $20
		gmptr	OptionsMenu				; $24
		gmptr	LevelSelectMenu				; $28


ChecksumError:
		move.l	d1,-(sp)				; back up incorrect checksum to stack
		bsr.w	VDPSetupGame
		move.l	(sp)+,d1				; restore incorrect checksum from stack (possibly used when determining what it should be)
		vdp_comm.l move,0,cram,write,(vdp_control_port).l ; set VDP to CRAM write
		moveq	#(sizeof_pal_all/2)-1,d7

	.fillred:
		move.w	#cRed,(vdp_data_port).l			; fill palette with red
		dbf	d7,.fillred				; repeat $3F more time

	.endlessloop:
		bra.s	.endlessloop				; loop forever
; ===========================================================================

GM_LevelSelectMenu2P:
		jmp	(MenuScreen).l

GM_EndingSequence:
		jmp	(EndingSequence).l

GM_OptionsMenu:
		jmp	(MenuScreen).l

GM_LevelSelectMenu:
		jmp	(MenuScreen).l

; ---------------------------------------------------------------------------
; Vertical interrupt
; ---------------------------------------------------------------------------

VBlank:
		pushr.l	d0-a6					; save all registers to stack
		tst.b	(v_vblank_routine).w			; is routine number 0?
		beq.w	VBlank_Lag				; if yes, branch

	.waitvblank:
		move.w	(vdp_control_port).l,d0			; get status register
		andi.w	#8,d0					; is VBlank register set?
		beq.s	.waitvblank				; if not, branch
		vdp_comm.l	move,0,vsram,write,(vdp_control_port).l ; set VDP to VSRAM write, destination address 0
		move.l	(v_fg_y_pos_vsram).w,(vdp_data_port).l	; send screen y-axis pos. to VSRAM
		btst	#console_speed_bit,(v_console_region).w	; is Mega Drive PAL?
		beq.s	.notPAL
		move.w	#$701-1,d0

	.waitPAL:
		dbf	d0,.waitPAL				; wait here in a loop doing nothing for a while...

	.notPAL:
		move.b	(v_vblank_routine).w,d0			; get routine number
		move.b	#0,(v_vblank_routine).w			; reset to 0
		move.w	#1,(f_hblank).w				; set flag to let HBlank know a frame has finished
		andi.w	#$3E,d0
		move.w	VBlank_Index(pc,d0.w),d0
		jsr	VBlank_Index(pc,d0.w)			; run the relevant VBlank routine

VBlank_Exit:
		addq.l	#1,(v_vblank_counter).w			; increment frame counter
		popr.l	d0-a6					; restore all registers
		rte						; end of VBlank; restore status register and return
; ===========================================================================
VBlank_Index:	index offset(*),,2
		ptr	 VBlank_Lag				; 0
		ptr  VBlank_Sega				; 2
		ptr	 VBlank_Title				; 4
		ptr	 VBlank_Unused6				; 6
		ptr  VBlank_Level				; 8
		ptr  VBlank_SpecialStage			; $A
		ptr  VBlank_TitleCard				; $C
		ptr  VBlank_UnusedE				; $E
		ptr	 VBlank_Pause				; $10
		ptr  VBlank_Fade				; $12
		ptr  VBlank_PCM					; $14
		ptr  VBlank_Menu				; $16
		ptr  VBlank_Ending				; $18
		ptr  VBlank_DMA					; $1A

; ---------------------------------------------------------------------------
; VBlank Routine 0 - runs when a frame ends before the game loop reaches
; WaitForVBlank - e.g., the game is lagging due to a large number of
; objects on screen

; If not in level, only update sound; if in a water level, update sound and
; palettes; if in non-water level, update sound, vscroll, and sprite table
; ---------------------------------------------------------------------------

VBlank_Lag:
		cmpi.b	#titlecard_flag|id_Demo,(v_gamemode).w	; is game on level init sequence in demo mode?
		beq.s	.islevel				; if yes, branch
		cmpi.b	#titlecard_flag|id_Level,(v_gamemode).w	; is game on level init in normal play mode?
		beq.s	.islevel				; if yes, branch
		cmpi.b	#id_Demo,(v_gamemode).w			; is game on a level proper in demo mode?
		beq.s	.islevel				; if yes, branch
		cmpi.b	#id_Level,(v_gamemode).w		; is game on a level proper?
		beq.s	.islevel				; if yes, branch

		stopZ80
		waitz80
		bsr.w	SoundDriverInput			; give input to the sound driver
		startZ80

		bra.s	VBlank_Exit
; ===========================================================================

	.islevel:
		tst.b	(f_water).w				; does level have water?
		beq.w	.nowater				; if it does, branch
		move.w	(vdp_control_port).l,d0
		btst	#console_speed_bit,(v_console_region).w	; is console PAL?
		beq.s	.notPAL1				; if not, branch

		move.w	#$701-1,d0
	.waitPAL1:
		dbf	d0,.waitPAL1

	.notPAL1:
		move.w	#1,(f_hblank).w				; set flag to let HBlank know a frame has finished
		stopZ80
		waitz80
		tst.b	(f_water_pal_full).w			; is water covering the whole screen?
		bne.s	.allwater				; if so, branch
		dma v_pal_dry,sizeof_pal_all,cram		; DMA normal palette to CRAM (water palette will be copied by HBlank later)

		bra.s	.waterbelow
; ===========================================================================

	.allwater:
		dma	v_pal_water,sizeof_pal_all,cram		; DMA water palette to CRAM

	.waterbelow:
		move.w	(v_vdp_hint_counter).w,(a5)		; set water palette position by sending VDP register $8Axx to control port (vdp_control_port)
		move.w	#vdp_fg_nametable|(vram_fg>>10),(vdp_control_port).l ; set fg scroll base to $C000
		bsr.w	SoundDriverInput
		startZ80
		bra.w	VBlank_Exit
; ===========================================================================

	.nowater:
		move.w	(vdp_control_port).l,d0
	if FixBugs=0
		; This only needs to be done in 2P mode.
		vdp_comm.l	move,0,vsram,write,(vdp_control_port).l ; set VDP to VSRAM write
		move.l	(v_fg_y_pos_vsram).w,(vdp_data_port).l	; update VScroll values
	endc
		btst	#console_speed_bit,(v_console_region).w
		beq.s	.notPAL2

		move.w	#$701-1,d0
	.waitPAL2:
		dbf	d0,.waitPAL2

	.notPAL2:
		move.w	#1,(f_hblank).w				; set flag to let HBlank know a frame has finished
		move.w	(v_vdp_hint_counter).w,(vdp_control_port).l
		move.w	#vdp_fg_nametable|(vram_fg>>10),(vdp_control_port).l ; set fg nametable base to $C000
	if FixBugs=0
		; Does not need to be done on lag frames.
		move.l	(v_fg_y_pos_vsram_p2).w,(v_hblank_fg_y_pos_vsram_p2).w
	endc
		stopZ80
		waitz80
	if FixBugs
		; In two-player mode, we have to update the sprite table and
		; VScroll values even during a lag frame so that the top half
		; of the screen shows the correct sprites.
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not2P					; branch if not

		vdp_comm.l	move,0,vsram,write,(vdp_control_port).l ; set VDP to VSRAM write
		move.l	(v_fg_y_pos_vsram).w,(vdp_data_port).l	; update VScroll values

		tst.b	(f_sprite_buffer_page).w
		beq.s	.usealt					; branch if we're using the alternate page for player 1
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite table for player 1
		bra.s	.not2P
; ===========================================================================

	.usealt:
		dma	v_sprite_buffer_alt,sizeof_vram_sprites,vram_sprites ; update sprite table for player 1 with alternate page
	.not2P:
	else
		; In the original game, the sprite table is needlessly updated on lag frames in 1P mode.
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites
	endc
		bsr.w	SoundDriverInput
		startZ80
		bra.w	VBlank_Exit
; ===========================================================================

VBlank_Sega:
		bsr.w	ReadPad_Palette_Sprites_HScroll
		dma v_hscroll_buffer,sizeof_vram_hscroll,vram_hscroll ; update H-scroll values
		jsrto	SegaScreen_VBlank,JmpTo_SegaScreen_VBlank
		tst.w	(v_countdown).w				; is there time left on the counter?
		beq.w	.end					; if not, return
		subq.w	#1,(v_countdown).w			; subtract 1 from time left

	.end:
		rts
; ===========================================================================

VBlank_PCM:
		move.b	(v_vblank_counter_byte).w,d0		; get frame count
		andi.w	#$F,d0
		bne.s	.skip					; read joypads every 16 frames

		stopZ80
		waitZ80
		bsr.w	ReadJoypads
		startZ80

	.skip:
		tst.w	(v_countdown).w				; is there time left on the demo?
		beq.w	.end					; if not, return
		subq.w	#1,(v_countdown).w			; subtract 1 from time left

	.end:
		rts
; ===========================================================================

VBlank_Title:
		bsr.w	ReadPad_Palette_Sprites_HScroll		; update palettes, SAT, and H-scroll
		bsr.w	ProcessPLC				; process pending PLCs
		tst.w	(v_countdown).w				; is there time left on the demo?
		beq.w	.end					; if not, return
		subq.w	#1,(v_countdown).w			; subtract 1 from time left in demo

	.end:
		rts
; ===========================================================================

VBlank_Unused6:
		bsr.w	ReadPad_Palette_Sprites_HScroll
		rts
; ===========================================================================

VBlank_Pause:
		cmpi.b	#id_SpecialStage,(v_gamemode).w
		beq.w	VBlank_Pause_SpecialStage

VBlank_Level:
		stopZ80
		waitz80
		bsr.w	ReadJoypads
		tst.b	(v_teleport_timer).w			; is a teleport in progress?
		beq.s	.chkpalettes				; if not, branch
		lea	(vdp_control_port).l,a5
		tst.w	(f_pause).w				; is the game paused?
		bne.w	.finish					; if so, branch
		subq.b	#1,(v_teleport_timer).w			; subtract one from teleport timer
		bne.s	.notdone				; if time remains, branch
		move.b	#0,(f_teleport).w			; clear teleport flag

	.notdone:
		cmpi.b	#$10,(v_teleport_timer).w		; 16 frames or fewer left in teleport?
		bcs.s	.chkpalettes				; if so, branch

		lea	(vdp_data_port).l,a6
		vdp_comm.l move,$0000,cram,write,(vdp_control_port).l ; set VDP to CRAM write
		move.w	#cWhite,d0

		move.w	#(countof_color*2)-1,d1			; two palette lines
	.whiteloop1:
		move.w	d0,(a6)					; fill first two palette lines with white for teleport effect
		dbf	d1,.whiteloop1				; repeat 31 times

		vdp_comm.l	move,$0042,cram,write,(vdp_control_port).l ; skip one color

	if FixBugs
		move.w	#((countof_color*2)-1)-1,d1		; two palette lines	minus 1
	else
		; This does one more color than necessary: it isn't accounting for
		; the color that was skipped earlier!
		move.w	#(countof_color*2)-1,d1			; two palette lines
	endc

	.whiteloop2:
		move.w	d0,(a6)
		dbf	d1,.whiteloop2
		bra.s	.finish
; ===========================================================================

	.chkpalettes:
		tst.b	(f_water_pal_full).w
		bne.s	.allwater
		dma v_pal_dry,sizeof_pal_all,cram		; DMA normal palette to CRAM (water palette will be copied by HBlank later)
		bra.s	.finish
; ===========================================================================

	.allwater:
		dma	v_pal_water,sizeof_pal_all,cram		; DMA water palette to CRAM

	.finish:
		move.w	(v_vdp_hint_counter).w,(a5)
		move.w	#vdp_fg_nametable|(vram_fg>>10),(vdp_control_port).l
		dma v_hscroll_buffer,sizeof_vram_hscroll,vram_hscroll ; update HScroll values

	if FixBugs
		; Like in Sonic 3, the sprite tables are page-flipped in two-player mode.
		; This fixes a race-condition where incomplete sprite tables can be uploaded
		; to the VDP on lag frames, causing corrupted sprites to appear.
		tst.b	(f_sprite_buffer_pageflip).w
		beq.s	.nopageflip				; branch if we aren't flipping the sprite table page
		sf.b	(f_sprite_buffer_pageflip).w
		not.b	(f_sprite_buffer_page).w

	.nopageflip:
		tst.b	(f_sprite_buffer_page).w
		bne.s	.useprimary				; branch if we're using the primary page for player 1
		dma	v_sprite_buffer_alt,sizeof_vram_sprites,vram_sprites ; update sprite attribute table with alternate page
		bra.s	.processdma

	.useprimary:
	endc
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite attribute table

	.processdma:
		bsr.w	ProcessDMA				; process pending DMAs
		bsr.w	SoundDriverInput			; update sound

		startZ80

		; copy camera position variables to their duplicates used by DrawTilesWhenMoving
		movem.l	(v_camera_x_pos).w,d0-d7
		movem.l	d0-d7,(v_camera_x_pos_copy).w
		movem.l	(v_camera_x_pos_p2).w,d0-d7
		movem.l	d0-d7,(v_camera_pos_p2_copy).w
		movem.l	(v_fg_redraw_direction).w,d0-d3
		movem.l	d0-d3,(v_fg_redraw_direction_copy).w
		move.l	(v_fg_y_pos_vsram_p2).w,(v_hblank_fg_y_pos_vsram_p2).w

		cmpi.b	#92,(v_vdp_hint_line).w			; is HBlank set to run on scanline 92 or lower?
		bcc.s	DrawTiles_LevelGfx_HUD_PLC		; if so, branch
		move.b	#1,(f_hblank_run_snd).w			; set flag to run sound driver on HBlank
		rts

; ---------------------------------------------------------------------------
; Subroutine to	update fg/bg, run tile animations, HUD and and decompress up
; to 3 cells of Nemesis graphics
; ---------------------------------------------------------------------------

DrawTiles_LevelGfx_HUD_PLC:
		jsrto	DrawTilesWhenMoving,JmpTo_DrawTilesWhenMoving
		jsr	(HUD_Update).l
		bsr.w	ProcessPLC2
		tst.w	(v_countdown).w
		beq.w	.end
		subq.w	#1,(v_countdown).w

	.end:
		rts
; ===========================================================================

VBlank_Pause_SpecialStage:
		stopZ80
		waitz80

		bsr.w	ReadJoypads
		jsr	(SoundDriverInput).l			; can be shortened to bsr.w
		tst.b	(v_ss_last_alt_hscroll_buffer).w	; which HScroll buffer was used on the last frame?
		beq.s	.primarybuffer				; if it was the primary one, branch

	;.secondarybuffer:
		dma v_ss_hscroll_buffer_2,sizeof_vram_hscroll,vram_hscroll
		bra.s	.end
; ===========================================================================

	.primarybuffer:
		dma v_ss_hscroll_buffer_1,sizeof_vram_hscroll,vram_hscroll

	.end:
		startZ80
		rts
; ===========================================================================

VBlank_SpecialStage:
		stopZ80
		waitz80
		bsr.w	ReadJoypads
		bsr.w	SS_Set_VScroll				; update VScroll values
		dma v_pal_dry,sizeof_pal_all,cram		; DMA normal palette to CRAM
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite attribute table

		tst.b	(v_ss_alt_hscroll_buffer).w		; which HScroll buffer was used on the last frame?
		beq.s	.primarybuffer				; if it was the primary one, branch

		dma v_ss_hscroll_buffer_2,sizeof_vram_hscroll,vram_hscroll
		bra.s	.continue
; ===========================================================================

	.primarybuffer:
		dma v_ss_hscroll_buffer_1,sizeof_vram_hscroll,vram_hscroll

	.continue:
		tst.b	(v_ss_track_orientation).w		; is the current track frame flipped?
		beq.s	.not_flipped				; if not, branch
		moveq	#0,d0
		move.b	(v_ss_track_drawing_index).w,d0		; get drawing position
		cmpi.b	#4,d0					; have we finished drawing and streaming track frame?
		bge.s	.not_flipped				; if so, branch (nothing to draw)
		add.b	d0,d0					; convert to index
		tst.b	(f_ss_alternate_fg_table).w		; are we using the primary FG table? [(v_ss_track_drawing_index) * 2] = subroutine
		beq.s	.transfer_table				; if not, branch
		addi_.w	#8,d0					; we're using the secondary FG table ; ([(v_ss_track_drawing_index) * 2] + 8) = subroutine

	.transfer_table:
		move.w	.SS_FG_Transfer_Table_Index(pc,d0.w),d0
		jsr	.SS_FG_Transfer_Table_Index(pc,d0.w)	; jsr to relevant transfer DMA sub

	.not_flipped:
		bsr.w	SS_Run_Animation_Timers
		addi_.b	#1,(v_ss_track_drawing_index).w		; run track timer
		move.b	(v_ss_track_drawing_index).w,d0		; get new timer value
		cmp.b	d1,d0					; is it less than the player animation timer?
		blt.s	.tracktrans_done			; if so, branch
		move.b	#0,(v_ss_track_drawing_index).w		; start drawing new frame
		lea	(vdp_control_port).l,a6
		tst.b	(f_ss_alternate_fg_table).w		; are we using the primary FG table?
		beq.s	.secondarybuffer			; if not, branch
		move.w 	#vdp_fg_nametable|(vram_ss_fg1>>10),(a6) ; primary FG plane table starts at $C000
		bra.s	.switchtables
; ===========================================================================

.SS_FG_Transfer_Table_Index:	index offset(*)
		ptr SS_FGTblTrans_2_0				; 0
		ptr SS_FGTblTrans_2_1				; 1
		ptr SS_FGTblTrans_2_2				; 2
		ptr SS_FGTblTrans_2_3				; 3
		ptr SS_FGTblTrans_1_0				; 4
		ptr SS_FGTblTrans_1_1				; 5
		ptr SS_FGTblTrans_1_2				; 6
		ptr SS_FGTblTrans_1_3				; 7
; ===========================================================================

	.secondarybuffer:
		move.w 	#vdp_fg_nametable|(vram_ss_fg2>>10),(a6) ; secondary FG plane table starts at $C000

	.switchtables:
		eori.b	#1,(f_ss_alternate_fg_table).w		; toggle the FG table flag

	.tracktrans_done:
		bsr.w	ProcessDMA				; process pending DMAs
		jsr	(SoundDriverInput).l			; update sound
		startZ80
		bsr.w	ProcessPLC2
		tst.w	(v_countdown).w
		beq.w	.end
		subq.w	#1,(v_countdown).w

	.end:
		rts

; ---------------------------------------------------------------------------
; Each of these functions copies one fourth of the FG plane table into VRAM
; from the buffer in main RAM. $700 bytes are copied each frame, with the target
; area in VRAM depending on the current drawing position.
; ---------------------------------------------------------------------------

SS_FGTblTrans_1_0:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg1
		rts
; ===========================================================================
SS_FGTblTrans_1_1:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg1+sizeof_v_ss_fg_buffer
		rts
; ===========================================================================
SS_FGTblTrans_1_2:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg1+(sizeof_v_ss_fg_buffer*2)
		rts
; ===========================================================================
SS_FGTblTrans_1_3:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg1+(sizeof_v_ss_fg_buffer*3)
		rts
; ===========================================================================
SS_FGTblTrans_2_0:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg2
		rts
; ===========================================================================
SS_FGTblTrans_2_1:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg2+sizeof_v_ss_fg_buffer
		rts
; ===========================================================================
SS_FGTblTrans_2_2:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg2+(sizeof_v_ss_fg_buffer*2)
		rts
; ===========================================================================

SS_FGTblTrans_2_3:
		dma v_ss_fg_buffer,sizeof_v_ss_fg_buffer,vram_ss_fg2+(sizeof_v_ss_fg_buffer*3)
		rts
; ===========================================================================

SS_Set_VScroll:
		move.w	(vdp_control_port).l,d0
		vdp_comm.l	move,0,vsram,write,(vdp_control_port).l ; set VDP to VSRAM write
		move.l	(v_fg_y_pos_vsram).w,(vdp_data_port).l	; unnecessary, as this was already done by the global VBlank code!
		rts
; ===========================================================================

SS_Run_Animation_Timers:
		move.w	(v_ss_cur_speed_factor).w,d0		; get current speed factor
		cmp.w	(v_ss_new_speed_factor).w,d0		; has the speed factor changed?
		beq.s	.factorchange				; if it has, branch
		move.l	(v_ss_new_speed_factor).w,(v_ss_cur_speed_factor).w ; save new speed factor
		move.b	#0,(v_ss_track_duration_timer).w	; reset timer

	.factorchange:
		subi_.b	#1,(v_ss_track_duration_timer).w	; run track timer
		bgt.s	.not_expired				; if it has not expired, branch
		lea	(SS_Anim_Base_Duration).l,a0		; load duration array (could be PC relative)
		move.w	(v_ss_cur_speed_factor).w,d0		; current speed factor is the index
		lsr.w	#1,d0
		move.b	(a0,d0.w),d1				; get new duration value
		move.b	d1,(v_ss_player_anim_frame_timer).w	; new player animation length (later halved)
		move.b	d1,(v_ss_track_duration_timer).w	; new track timer
		subq.b	#1,(v_ss_player_anim_frame_timer).w	; subtract 1
		rts
; ===========================================================================

	.not_expired:
		move.b	(v_ss_player_anim_frame_timer).w,d1
		addq.b	#1,d1
		rts
; ===========================================================================

SS_Anim_Base_Duration:
		dc.b $3C					; 0
		dc.b $1E					; 1
		dc.b  $F					; 2
		dc.b  $A					; 3
		dc.b   8					; 4
		dc.b   6					; 5
		dc.b   5					; 6
		dc.b   0					; 7
; ===========================================================================
; Only used during Special Stage init
VBlank_DMA:
		stopZ80
		waitz80
		jsr	(ProcessDMA).l				; why jsr? every other call to this in the VBlank routines is a bsr.w
		startZ80
		rts
; ===========================================================================

VBlank_TitleCard:
		stopZ80
		waitz80

		bsr.w	ReadJoypads
		tst.b	(f_water_pal_full).w			; is water covering the entire screen?
		bne.s	.allwater				; if so, branch

		dma	v_pal_dry,sizeof_pal_all,cram		; update main palette

		bra.s	.waterbelow
; ===========================================================================

	.allwater:
		dma	v_pal_water,sizeof_pal_all,cram		; update water palette

	.waterbelow:
		move.w	(v_vdp_hint_counter).w,(a5)

		dma v_hscroll_buffer,sizeof_vram_hscroll,vram_hscroll ; update HScroll values

	if FixBugs
		; Like in Sonic 3, the sprite tables are page-flipped in two-player mode.
		; This fixes a race-condition where incomplete sprite tables can be uploaded
		; to the VDP on lag frames, causing corrupted sprites to appear.
		tst.b	(f_sprite_buffer_pageflip).w
		beq.s	.nopageflip				; branch if we aren't flipping the sprite table page
		sf.b	(f_sprite_buffer_pageflip).w
		not.b	(f_sprite_buffer_page).w

	.nopageflip:
		tst.b	(f_sprite_buffer_page).w
		bne.s	.useprimary				; branch if we're using the primary page for player 1
		dma	v_sprite_buffer_alt,sizeof_vram_sprites,vram_sprites ; update sprite attribute table with alternate page
		bra.s	.processdma

	.useprimary:
	endc
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite attribute table

	.processdma:
		bsr.w	ProcessDMA
		jsr	(DrawLevelTitleCard).l
		jsr	(SoundDriverInput).l			; can be optimized to bsr.w

		startZ80

		movem.l	(v_camera_x_pos).w,d0-d7
		movem.l	d0-d7,(v_camera_x_pos_copy).w
		movem.l	(v_fg_redraw_direction).w,d0-d1
		movem.l	d0-d1,(v_fg_redraw_direction_copy).w
		move.l	(v_fg_y_pos_vsram_p2).w,(v_hblank_fg_y_pos_vsram_p2).w
		bsr.w	ProcessPLC
		rts
; ===========================================================================

VBlank_UnusedE:
		bsr.w	ReadPad_Palette_Sprites_HScroll
		addq.b	#1,(v_vblank_0e_counter).w
		move.b	#id_VBlank_UnusedE,(v_vblank_routine).w
		rts
; ===========================================================================

VBlank_Fade:
		bsr.w	ReadPad_Palette_Sprites_HScroll
		move.w	(v_vdp_hint_counter).w,(a5)		; a5 = VDP control port
		bra.w	ProcessPLC
; ===========================================================================

VBlank_Ending:
		stopZ80
		waitz80

		bsr.w	ReadJoypads

		dma	v_pal_dry,sizeof_pal_all,cram		; update main palette
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite attribute table
		dma v_hscroll_buffer,sizeof_vram_hscroll,vram_hscroll ; update HScroll values

		bsr.w	ProcessDMA
		bsr.w	SoundDriverInput
		movem.l	(v_camera_x_pos).w,d0-d7
		movem.l	d0-d7,(v_camera_x_pos_copy).w
		movem.l	(v_fg_redraw_direction).w,d0-d3
		movem.l	d0-d3,(v_fg_redraw_direction_copy).w
		jsrto	DrawTilesWhenMoving,JmpTo_DrawTilesWhenMoving

		startZ80

		move.w	(v_ending_vblank_sub).w,d0
		beq.s	.end					; exit if nothing to do
		clr.w	(v_ending_vblank_sub).w
		move.w	VBlank_Ending_DMA_Index-2(pc,d0.w),d0
		jsr	VBlank_Ending_DMA_Index(pc,d0.w)

	.end:
		rts
; ===========================================================================

VBlank_Ending_DMA_Index:	index offset(*)
		ptr VBlank_Ending_ClearForegound		; 0
		ptr VBlank_Ending_VDP_Setup			; 1
; ===========================================================================

VBlank_Ending_ClearForegound:
		dma_fill	0,sizeof_vram_planetable_64x64,vram_ending_fg
		rts
; ===========================================================================

VBlank_Ending_VDP_Setup:
		dma_fill	0,sizeof_vram_planetable_64x64,vram_ending_bg2
		dma_fill	0,sizeof_vram_planetable_64x64,vram_ending_fg

		lea	(vdp_control_port).l,a6			; could just use a5 here, as that was set by the preceding DMA fill
		move.w	#vdp_full_vscroll|vdp_full_hscroll,(a6)	; full VScroll and HScroll
		move.w	#vdp_bg_nametable+(vram_ending_bg2>>13),(a6) ; BG table 2 starts at $4000
		move.w	#vdp_plane_height_64|vdp_plane_width_64,(a6) ; 64x64 plane table size
		lea	(v_128x128_tiles).l,a1
		vdp_comm.l	move,(vram_ending_fg+((sizeof_vram_row_64*33)+(2*22))),vram,write,d0 ; VRAM write, starting at $D0AC (row 33, column 22)

		moveq	#23-1,d1
		moveq	#15-1,d2
		jsrto	TilemapToVRAM,TilemapToVRAM		; unnecessarily changed from bsr.w to jsr in REV02
		rts
; ===========================================================================

VBlank_Menu:
		stopZ80
		waitz80

		bsr.w	ReadJoypads

		dma	v_pal_dry,sizeof_pal_all,cram		; update main palette
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite attribute table
		dma v_hscroll_buffer,sizeof_vram_hscroll,vram_hscroll ; update H-scroll values

		bsr.w	ProcessDMA				; perform any queued DMAs
		bsr.w	SoundDriverInput			; update sound
		startZ80
		bsr.w	ProcessPLC				; process any pending PLCs
		tst.w	(v_countdown).w
		beq.w	.end
		subq.w	#1,(v_countdown).w

	.end:
		rts

; ---------------------------------------------------------------------------
; Subroutine to read joypad and DMA palettes, sprite table and hscroll table
; ---------------------------------------------------------------------------

ReadPad_Palette_Sprites_HScroll:
		stopZ80
		waitz80
		bsr.w	ReadJoypads
		tst.b	(f_water_pal_full).w
		bne.s	.allwater

		dma	v_pal_dry,sizeof_pal_all,cram		; update main palette

		bra.s	.waterbelow
; ===========================================================================

	.allwater:
		dma	v_pal_water,sizeof_pal_all,cram		; update water palette

	.waterbelow:
		dma	v_sprite_buffer,sizeof_vram_sprites,vram_sprites ; update sprite attribute table
		dma v_hscroll_buffer,sizeof_vram_hscroll,vram_hscroll ; update H-scroll values

		bsr.w	SoundDriverInput
		startZ80
		rts

; ---------------------------------------------------------------------------
; Horizontal interrupt
; ---------------------------------------------------------------------------

HBlank:
		tst.w	(f_hblank).w				; is HBlank set to run (water level or 2P mode)?
		beq.w	.end					; if not, exit
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.w	HBlank_PalToCRAM			; if not, branch (change to water palette mid-frame)
		move.w	#0,(f_hblank).w
		pushr.l	a5
		pushr.l	d0

	.wait_hblank1:
		move.w	(vdp_control_port).l,d0			; get status register
		andi.w	#hblank_bit<<1,d0			; %00000100; is hblank_bit set?
		beq.s	.wait_hblank1				; if not, loop until it is

		; Switch to drawing Player 2's half of the screen.
		disable_display
		move.w	#vdp_fg_nametable|(vram_fg_2p>>10),(vdp_control_port).l ; FG plane table starts at $A000
		vdp_comm.l	move,$0000,vsram,write,(vdp_control_port).l ; set VDP to VSRAM write
		move.l	(v_hblank_fg_y_pos_vsram_p2).w,(vdp_data_port).l ; update VSRAM

		stopZ80
		waitz80

	if FixBugs
		; Like in Sonic 3, the sprite tables are page-flipped in two-player mode.
		; This fixes a race-condition where incomplete sprite tables can be uploaded
		; to the VDP on lag frames.
		tst.b	(f_sprite_buffer_page).w
		beq.s	.usealt					; branch if we;re using the alternate sprite table page for player 2
		dma v_sprite_buffer_2,sizeof_vram_sprites,vram_sprites ; update sprite table for player 2's half of screen
		bra.s	.startz80

	.usealt:
		dma v_sprite_buffer_alt_2,sizeof_vram_sprites,vram_sprites ; update sprite table for player 2 with alternate page

	.startz80:
	else
		dma v_sprite_buffer_2,sizeof_vram_sprites,vram_sprites ; update sprite table for player 2
	endc
		startZ80

	.wait_hblank2:
		move.w	(vdp_control_port).l,d0			; get status register
		andi.w	#hblank_bit<<1,d0			; %00000100; is hblank_bit set?
		beq.s	.wait_hblank2				; if not, loop until it is

		enable_display
		popr.l	d0
		popr.l	a5

	.end:
		rte
; ===========================================================================

HBlank_PalToCRAM:
		disable_ints
		move.w	#0,(f_hblank).w
		pushr.l	a0-a1
		lea	(vdp_data_port).l,a1
		lea	(v_pal_water).w,a0
		vdp_comm.l	move,0,cram,write,vdp_control_port-vdp_data_port(a1) ; set VDP to CRAM write
		rept 32
		move.l	(a0)+,(a1)				; move water palette to CRAM (all 64 colors at once)
		endr
		move.w	#vdp_hint_counter|(screen_height-1),vdp_control_port-vdp_data_port(a1) ; horizontal interupt every 224th line
		popr.l	a0-a1
		tst.b	(f_hblank_run_snd).w
		bne.s	.do_updates
		rte
; ===========================================================================

	.do_updates:
		clr.b	(f_hblank_run_snd).w
		pushr.l	d0-a6
		bsr.w	DrawTiles_LevelGfx_HUD_PLC
		popr.l	d0-a6
		rte
; ===========================================================================

SoundDriverInput:
		lea	(v_soundqueue&$FFFFFF).l,a0
		lea	(z80_ram+z_abs_vars).l,a1		; $A01B80

		cmpi.b	#com_Null,v_sound_id(a1)		; is sound driver processing a previous sound request?
		bne.s	.doSFX					; if so, branch; we'll try again on the next VBlank

		_move.b	music_0(a0),d0				; is there anything in music queue 0?
		beq.s	.checkmusic2				; if not, branch
		_clr.b	music_0(a0)				; clear queue slot
		bra.s	.playmusic
; ===========================================================================

	.checkmusic2:
		move.b	music_1(a0),d0				; is there anything in music queue 1?
		beq.s	.doSFX					; if not, branch
		clr.b	music_1(a0)				; clear queue slot

	.playmusic:
		; If this is 'cmd_Pause' or 'cmd_Unpause', then this isn't a real
		; sound ID, and it shouldn't be passed to the driver. Instead, it
		; should be used here to manually set the driver's pause flag.
		move.b	d0,d1
		subi.b	#cmd_Pause,d1				; is it the pause command?
		bcs.s	.notpause				; if not, branch
		addi.b	#$7F,d1
		move.b	d1,f_pause_sound(a1)
		bra.s	.doSFX
; ===========================================================================
	.notpause:
		move.b	d0,v_sound_id(a1)			; send the music's sound id to the driver

	.doSFX:
		; process the SFX queue
    if FixBugs
		moveq	#3-1,d1
    else
		; This is too high: there is only room for three bytes in the
		; driver's queue. This causes the first byte of 'v_music_voice_table' to be
		; overwritten.
		moveq	#4-1,d1
    endc

	.loop:
		move.b	sfx_0(a0,d1.w),d0			; is a sound queued in this slot?
		beq.s	.skip					; if not, branch
		tst.b	z_queue_0(a1,d1.w)			; is this slot in the driver's queue occupied?
		bne.s	.skip					; if so, branch
		clr.b	sfx_0(a0,d1.w)				; remove this sound from the 68k queue...
		move.b	d0,z_queue_0(a1,d1.w)			; ..and place it in the Z80 queue

	.skip:
		dbf	d1,.loop				; loop until all three queues have been processed
		rts
; ===========================================================================

	if RemoveJmpTos=0
JmpTo_DrawTilesWhenMoving:
		jmp	(DrawTilesWhenMoving).l
JmpTo_SegaScreen_VBlank:
		jmp	(SegaScreen_VBlank).l

		align 4
	endc

; ---------------------------------------------------------------------------
; Subroutine to initialize joypads
;	uses d0.l
; ---------------------------------------------------------------------------

JoypadInit:
		stopZ80						; unnecessary, this is a workaround for an I/O controller
		waitz80						; bug exposed by early mask ROM cartridges
		moveq	#$40,d0
		move.b	d0,(port_1_control).l			; init port 1 (joypad 1)
		move.b	d0,(port_2_control).l			; init port 2 (joypad 2)
		move.b	d0,(port_e_control).l			; init port 3 (EXT port on Model 1 VA6 and older)
		startZ80
		rts

; ---------------------------------------------------------------------------
; Subroutine to read joypad input, and send it to the RAM
; output:
;	d0 = actual joypad input (SACBRLDU)
;	d1 = actual joypad input, new since last frame only (SACBRLDU)
;	a1 = port_2_data ($A10005)
;	uses a0
; ---------------------------------------------------------------------------

ReadJoypads:
		lea	(v_joypad_hold_actual).w,a0		; address where joypad states are written
		lea	(port_1_data).l,a1			; first joypad port
		bsr.s	.read					; do the first joypad
		addq.w	#2,a1					; do the second	joypad

	.read:
		move.b	#0,(a1)					; set port to read 00SA00DU
		nop
		nop
		move.b	(a1),d0					; d0 = 00SA00DU
		lsl.b	#2,d0					; d0 = SA00DU00
		andi.b	#btnStart|btnA,d0			; d0 = SA000000
		move.b	#$40,(a1)				; set port to read 00CBRLDU
		nop
		nop
		move.b	(a1),d1					; d1 = 00CBRLDU
		andi.b	#btnDir|btnB|btnC,d1			; d1 = 00CBRLDU
		or.b	d1,d0					; d0 = SACBRLDU
		not.b	d0					; invert bits, so that 1 = pressed
		move.b	(a0),d1					; d1 = previous joypad state
		eor.b	d0,d1
		move.b	d0,(a0)+				; v_joypad_hold_actual = SACBRLDU
		and.b	d0,d1					; d1 = new joypad inputs only
		move.b	d1,(a0)+				; v_joypad_press_actual = SACBRLDU (new only)
		rts

; ---------------------------------------------------------------------------
; Subroutine to	clear CRAM and set default VDP register values

; output:
;	a0 = vdp_control_port ($C00004)
;	a1 = vdp_data_port ($C00000)
;	a5 = vdp_control_port ($C00004)

;	uses d0.l, d7.l, a2
; ---------------------------------------------------------------------------

VDPSetupGame:
		lea	(vdp_control_port).l,a0
		lea	(vdp_data_port).l,a1
		lea	(VDPSetupArray).l,a2
		moveq	#((sizeof_VDPSetupArray)/2)-1,d7

	.setreg:
		move.w	(a2)+,(a0)
		dbf	d7,.setreg				; set the VDP registers

		move.w	(VDPSetupArray+2).l,d0
		move.w	d0,(v_vdp_mode_buffer).w		; save $8134 to buffer for later use
		move.w	#vdp_hint_counter+(screen_height-1),(v_vdp_hint_counter).w ; H-Blank every 224th scanline
		moveq	#0,d0

		vdp_comm.l	move,0,vsram,write,(vdp_control_port).l ; clear the first longword of VSRAM (as that is all the game uses)
		move.w	d0,(a1)
		move.w	d0,(a1)

		vdp_comm.l	move,0,cram,write,(vdp_control_port).l
		move.w	#(sizeof_pal_all/2)-1,d7

	.loop_cram:
		move.w	d0,(a1)					; clear CRAM
		dbf	d7,.loop_cram

		clr.l	(v_fg_y_pos_vsram).w			; clear VSRAM buffer
		clr.l	(v_unused_ss).w
		move.l	d1,-(sp)
		dma_fill	0,$100000,vram_start		; clear entire VRAM
		move.l	(sp)+,d1
		rts
; ===========================================================================

VDPSetupArray:
		dc.w vdp_md_color				; $8004 ; normal color mode, horizontal interrupts disabled
		dc.w vdp_enable_vint|vdp_enable_dma|vdp_ntsc_display|vdp_md_display ; $8134 ; Mode 5, NTSC, DMA and vertical interrupts enabled
		dc.w vdp_fg_nametable+(vram_fg>>10)		; $8230 ; FG nametable at $C000
		dc.w vdp_window_nametable+(vram_window>>10)	; $8328 ; window nametable at $A000 (unused)
		dc.w vdp_bg_nametable+(vram_bg>>13)		; $8407 ; BG nametable at $E000
		dc.w vdp_sprite_table+(vram_sprites>>9)		; $857C ; sprite attribute table at $F800
		dc.w vdp_sprite_table2				; $8600; unused (high bit of sprite attribute table address for 128KB VRAM)
		dc.w vdp_bg_color+0				; $8700 ; VDP BG color (palete line 0 color 0)
		dc.w vdp_sms_hscroll				; $8800; unused (mode 4 Hscroll register)
		dc.w vdp_sms_vscroll				; $8900; unused (mode 4 Vscroll register)
		dc.w vdp_hint_counter				; $8A00 ; default horizontal interrupt register
		dc.w vdp_full_vscroll|vdp_full_hscroll		; $8B00 ; full-screen vertical/horizontal scrolling
		dc.w vdp_320px_screen_width			; $8C81 ; 40-cell display mode
		dc.w vdp_hscroll_table+(vram_hscroll>>10)	; $8D3F ;  HScroll table at $FC00
		dc.w vdp_nametable_hi				; $8E00 : unused (high bits of fg and bg nametable addresses for 128KB VRAM)
		dc.w vdp_auto_inc+2				; $8F02 ; set VDP increment size to 2
		dc.w vdp_plane_width_64|vdp_plane_height_32	; $9001 ; 64x32 cell plane size
		dc.w vdp_window_x_pos				; $9100 ; window horizontal position
		dc.w vdp_window_y_pos				; $9200 ; window vertical position
		arraysize	VDPSetupArray

; ---------------------------------------------------------------------------
; Subroutine to	clear the screen
; Deletes fg/bg nametables and sprite/hscroll buffers

; input:
;	a5 = vdp_control_port ($C00004)

;	uses d0.l, d1.w, a1
; ---------------------------------------------------------------------------

ClearScreen:
		stopZ80
		waitZ80

		dma_fill	0,$40,vram_start		; clear first $40 bytes of VRAM
		dma_fill	0,sizeof_vram_planetable_64x32,vram_fg ; clear foreground nametable
		dma_fill	0,sizeof_vram_planetable_64x32,vram_bg ; clear background nametable

		tst.w	(f_two_player).w			; is it two-player mode?
		beq.s	.not2P					; if not, branch

		dma_fill	0,sizeof_vram_planetable_64x32,vram_fg_2p ; clear player 2's foreground nametable

	.not2P:
		clr.l	(v_fg_y_pos_vsram).w			; clear VSRAM buffer
		clr.l	(v_unused_ss).w

	if FixBugs
		clear_ram	v_sprite_buffer,v_sprite_buffer_end ; clear the sprite buffer
		clear_ram	hscroll,hscroll_end		; clear the hscroll buffer
	else
		; These '+4's shouldn't be here; clearRAM accidentally clears an additional 4 bytes,
		clear_ram	v_sprite_buffer,v_sprite_buffer_end+4 ; clear the sprite buffer
		clear_ram	hscroll,hscroll_end+4		; clear the hscroll buffer
	endc
		startZ80
		rts
; ===========================================================================

JmpTo_SoundDriverLoad:
		nop
		jmp	(SoundDriverLoad).l
; ===========================================================================

; unused Sonic 1 leftover - subroutine to load the DAC driver
; DacDriverLoadS1:
		stopZ80
		resetZ80_release
		lea	(z80_ram).l,a1
		move.b	#$F3,(a1)+				; di
		move.b	#$F3,(a1)+				; di
		move.b	#$C3,(a1)+				; jp
		move.b	#0,(a1)+				; jp address low byte
		move.b	#0,(a1)+				; jp address high byte
		resetZ80_assert
		nop
		nop
		nop
		nop
		resetZ80_release
		startZ80					; start the Z80
		rts

; ---------------------------------------------------------------------------
; Subroutines to play sounds in various queue slots
; Despite their names, any slot can be used for both music and SFX.

;
; input:
;	d0 = sound to play
; ---------------------------------------------------------------------------

; The original source code called this 'bgmset'.
PlayMusic:
		tst.b	(v_soundqueue+music_0).w		; is there something already in music queue 0?
		bne.s	.queue1					; if so, branch
		move.b	d0,(v_soundqueue+music_0).w		; queue sound in music queue 0
		rts

	.queue1:
		move.b	d0,(v_soundqueue+music_1).w		; queue sound in music queue 1
		rts

; The original source code called this 'sfxset'.
PlaySound:
		move.b	d0,(v_soundqueue+sfx_0).w		; queue sound in SFX queue 0
		rts

; Unfortunately, the original name for this is not known.
PlaySound2:
		move.b	d0,(v_soundqueue+sfx_1).w		; queue sound in SFX queue 1
		rts

; Play a sound if the source is on-screen.
PlaySoundLocal:
		tst.b	ost_render(a0)				; is the object requesting this SFX on-screen?
		bpl.s	.exit					; if not, exit
		move.b	d0,(v_soundqueue+sfx_0).w		; queue sound in SFX queue 0

	.exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	pause the game
; ---------------------------------------------------------------------------

PauseGame:
		nop
		tst.b	(v_lives).w				; dooes player 1 have any lives left?
		beq.w	Unpause					; if not, branch
	if FixBugs
		; The game still lets you pause if player 2 got a Game Over, or if
		; either player got a Time Over. The following code fixes this.
		tst.b	(v_lives_p2).w				; does player 2 have any lives left?
		beq.w	Unpause					; if not, branch
		tst.b	(f_time_over).w				; did player 1 get a time over?
		bne.w	Unpause					; if not, branch
		tst.b   (f_time_over_p2).w			; did player 2 get a time over?
		bne.w   Unpause					; if not, branch
	endc
		tst.w	(f_pause).w				; is game already paused?
		bne.s	.paused					; if yes, branch
		move.b	(v_joypad_press_actual).w,d0		; get joypad states
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#btnStart,d0				; is start button pressed (either player)?
		beq.s	Pause_DoNothing				; if not, branch

	.paused:
		move.w	#1,(f_pause).w				; set pause flag (also stops palette/gfx animations, time)
		move.b	#cmd_Pause,(v_soundqueue+music_0).w	; pause music

Pause_Loop:
		move.b	#id_VBlank_Pause,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		tst.b	(f_slowmotion_cheat).w			; is slow-motion cheat on?
		beq.s	.chk_start				; if not, branch
		btst	#bitA,(v_joypad_press_actual).w		; is button A pressed?
		beq.s	.chk_bc					; if not, branch
		move.b	#id_Title,(v_gamemode).w		; return to title screen
		nop						; ...pointless
		bra.s	Unpause_Music
; ===========================================================================

	.chk_bc:
		btst	#bitB,(v_joypad_hold_actual).w		; is button B held?
		bne.s	Pause_SlowMo				; if so, branch
		btst	#bitC,(v_joypad_press_actual).w		; is button C pressed?
		bne.s	Pause_SlowMo				; if so, branch

	.chk_start:
		move.b	(v_joypad_press_actual).w,d0		; get joypad states
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#btnStart,d0				; is start button pressed (either player)?
		beq.s	Pause_Loop				; if not, branch

	Unpause_Music:
		move.b	#cmd_Unpause,(v_soundqueue+music_0).w	; unpause the music

	Unpause:
		move.w	#0,(f_pause).w				; unpause the game

	Pause_DoNothing:
		rts
; ===========================================================================

Pause_SlowMo:
		move.w	#1,(f_pause).w				; keep game paused
		move.b	#cmd_Unpause,(v_soundqueue+music_0).w	; unpause the music
		rts						; exit. the game will now run for one frame before returning to the pause loop

; ---------------------------------------------------------------------------
; Subroutine to	copy a tile map from RAM to VRAM fg/bg nametable

; input:
;	d0.l = VRAM fg/bg nametable address (as VDP command)
;	d1.w = width-1 (cells)
;	d2.w = height-1 (cells)
;	a1 = tile map address

; output:
;	a6 = vdp_data_port ($C00000)

;	uses d0.l, d2.w, d3.w, d4.l, a1
; ---------------------------------------------------------------------------

;PlaneMapToVRAM_H40:
TilemapToVRAM:
		lea	(vdp_data_port).l,a6
		move.l	#sizeof_vram_row_64<<16,d4		; d4 = $800000

	.loop_row:
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; move d0 to vdp_control_port
		move.w	d1,d3

	.loop_cell:
		move.w	(a1)+,(a6)				; write value to nametable
		dbf	d3,.loop_cell				; next tile
		add.l	d4,d0					; goto next line
		dbf	d2,.loop_row				; next line
		rts

; ---------------------------------------------------------------------------
; Alternate subroutine to transfer a plane map to VRAM
; This code appears twice in the ROM: a duplicate is used for the SEGA screen
; ---------------------------------------------------------------------------

;PlaneMapToVRAM_H80_SpecialStage:
TilemapToVRAM_128_SS:
		lea	(vdp_data_port).l,a6
		move.l	#sizeof_vram_row_128<<16,d4		; d4 = $1000000

	.loop_row:
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; move d0 to vdp_control_port
		move.w	d1,d3

	.loop_cell:
		move.w	(a1)+,(a6)				; write value to nametable
		dbf	d3,.loop_cell				; next tile
		add.l	d4,d0					; goto next line
		dbf	d2,.loop_row				; next line
		rts

; ---------------------------------------------------------------------------
; Subroutine to add an item to the DMA queue

; input:
;	d1.l = source
;	d2.w = destination
;	d3.w = length

;  uses a1
; ---------------------------------------------------------------------------

; sub_144E: DMA_68KtoVRAM: QueueCopyToVRAM: QueueVDPCommand: Add_To_DMA_Queue: QueueDMATransfer
AddDMA:
		movea.l	(v_dma_queue_slot).w,a1
		cmpa.w	#v_dma_queue_slot,a1			; are we at the end of the buffer?
		beq.s	.exit					; if so, exit; there's no more room in the buffer

		move.w	#vdp_dma_length_low,d0			; specify DMA transfer length low byte
		move.b	d3,d0
		move.w	d0,(a1)+

		move.w	#vdp_dma_length_hi,d0			; specify DMA transfer length high byte
		lsr.w	#8,d3
		move.b	d3,d0
		move.w	d0,(a1)+				; store command

		move.w	#vdp_dma_source_low,d0			; specify source address low byte
		lsr.l	#1,d1
		move.b	d1,d0
		move.w	d0,(a1)+				; store command

		move.w	#vdp_dma_source_mid,d0			; specify source address middle byte
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+				; store command

		move.w	#vdp_dma_source_hi,d0			; command to specify source address high byte
		lsr.l	#8,d1
	if FixBugs
		andi.b	#$7F,d1					; this instruction safely allows source to be in RAM; S3K added this
	endc
		move.b	d1,d0
		move.w	d0,(a1)+				; store command

		andi.l	#$FFFF,d2				; specify destination address and start DMA
		lsl.l	#2,d2
		lsr.w	#2,d2
		swap	d2
		vdp_comm.l	oxi,0,vram,dma,d2		; set bits to specify VRAM transfer; oxi = AXM68K mnemonic for ori
		move.l	d2,(a1)+				; store command

		move.l	a1,(v_dma_queue_slot).w			; set the next free slot address
		cmpa.w	#v_dma_queue_slot,a1			; are we at the end of the buffer?
		beq.s	.exit					; if so, exit
		move.w	#0,(a1)					; put a stop token at the end of the used part of the buffer

	.exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to run all DMAs stored in the DMA queue and reset the queue

; output:
;	a5 = vdp_control_port

; 	uses d0.w, a1, a5
; ---------------------------------------------------------------------------

; sub_14AC: CopyToVRAM: IssueVDPCommands: Process_DMA: Process_DMA_Queue: ; ProcessDMAQueue:
ProcessDMA:
		lea	(vdp_control_port).l,a5
		lea	(v_dma_queue).w,a1

	; loc_14B6: ProcessDMAQueue_Loop:
	.process_dma_loop:
		move.w	(a1)+,d0
		beq.s	.done					; exit if we reached a stop token
		move.w	d0,(a5)					; transfer length
		move.w	(a1)+,(a5)				; transfer length
		move.w	(a1)+,(a5)				; source address
		move.w	(a1)+,(a5)				; source address
		move.w	(a1)+,(a5)				; source address
		move.w	(a1)+,(a5)				; destination
		move.w	(a1)+,(a5)				; destination
		cmpa.w	#v_dma_queue_slot,a1			; have we reached the end of the buffer?
		bne.s	.process_dma_loop			; if not, loop

	.done:
		move.w	#0,(v_dma_queue).w
		move.l	#v_dma_queue,(v_dma_queue_slot).w
		rts

; ---------------------------------------------------------------------------
; Nemesis decompression	subroutine, decompresses art directly to VRAM in full
; (used to decompress art not loaded via PLC)

; input:
;	a0 = art source address

; usage:
;	locVRAM	destination
;	lea	(source).l,a0
;	bsr.w	NemDec

; See http://info.sonicretro.org/Nemesis_compression for format explanation
; ---------------------------------------------------------------------------

NemDec:
		pushr.l	d0-a1/a3-a5
		lea	(NemPCD_WriteRowToVDP).l,a3		; write all data to the same location
		lea	(vdp_data_port).l,a4			; specifically, to the VDP data port
		bra.s	NemDecMain

; ---------------------------------------------------------------------------
; Nemesis decompression subroutine, decompresses to RAM

; input:
;	a0 = art source address
;	a4 = destination RAM address
; ---------------------------------------------------------------------------

NemDecToRAM:
		pushr.l	d0-a1/a3-a5
		lea	(NemPCD_WriteRowToRAM).l,a3		; advance to the next location after each write

NemDecMain:
		lea	(v_nem_gfx_buffer).w,a1
		move.w	(a0)+,d2				; get number of patterns
		lsl.w	#1,d2
		bcc.s	.sign_bit_not_set			; branch if the sign bit isn't set
		adda.w	#NemPCD_WriteRowToVDP_XOR-NemPCD_WriteRowToVDP,a3 ; otherwise the file uses XOR mode

	.sign_bit_not_set:
		lsl.w	#2,d2					; get number of 8-pixel rows in the uncompressed data
		movea.w	d2,a5					; and store it in a5 because there aren't any spare data registers
		moveq	#8,d3					; 8 pixels in a pattern row
		moveq	#0,d2
		moveq	#0,d4
		bsr.w	NemDec_BuildCodeTable
		move.b	(a0)+,d5				; get first byte of compressed data
		asl.w	#8,d5					; shift up by a byte
		move.b	(a0)+,d5				; get second byte of compressed data
		move.w	#$10,d6					; set initial shift value
		bsr.s	NemDec_ProcessCompressedData
		popr.l	d0-a1/a3-a5
		rts

; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, processes the actual compressed data
; ---------------------------------------------------------------------------

NemDec_ProcessCompressedData:
		move.w	d6,d7
		subq.w	#8,d7					; get shift value
		move.w	d5,d1
		lsr.w	d7,d1					; shift so that high bit of the code is in bit position 7
		cmpi.b	#$FC,d1					; %11111100; are the high 6 bits set?
		bcc.s	NemPCD_InlineData			; if they are, it signifies inline data
		andi.w	#$FF,d1
		add.w	d1,d1
		move.b	(a1,d1.w),d0				; get the length of the code in bits
		ext.w	d0
		sub.w	d0,d6					; subtract from shift value so that the next code is read next time around
		cmpi.w	#9,d6					; does a new byte need to be read?
		bcc.s	.skip_new_byte				; if not, branch
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5				; read next byte

	.skip_new_byte:
		move.b	1(a1,d1.w),d1
		move.w	d1,d0
		andi.w	#$F,d1					; get palette index for pixel
		andi.w	#$F0,d0

NemPCD_ProcessCompressedData:
		lsr.w	#4,d0					; get repeat count

NemPCD_WritePixel:
		lsl.l	#4,d4					; shift up by a nybble
		or.b	d1,d4					; write pixel
		subq.w	#1,d3					; has an entire 8-pixel row been written?
		bne.s	NemPCD_WritePixel_Loop			; if not, loop
		jmp	(a3)					; otherwise, write the row to its destination, by doing a dynamic jump to NemPCD_WriteRowToVDP, NemDec_WriteAndAdvance, NemPCD_WriteRowToVDP_XOR, or NemDec_WriteAndAdvance_XOR
; ===========================================================================

NemPCD_NewRow:
		moveq	#0,d4					; reset row
		moveq	#8,d3					; reset nybble counter

NemPCD_WritePixel_Loop:
		dbf	d0,NemPCD_WritePixel
		bra.s	NemDec_ProcessCompressedData
; ===========================================================================

NemPCD_InlineData:
		subq.w	#6,d6					; 6 bits needed to signal inline data
		cmpi.w	#9,d6
		bcc.s	loc_14E4
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5

	loc_14E4:
		subq.w	#7,d6					; and 7 bits needed for the inline data itself
		move.w	d5,d1
		lsr.w	d6,d1					; shift so that low bit of the code is in bit position 0
		move.w	d1,d0
		andi.w	#$F,d1					; get palette index for pixel
		andi.w	#$70,d0					; high nybble is repeat count for pixel
		cmpi.w	#9,d6
		bcc.s	NemPCD_ProcessCompressedData
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5
		bra.s	NemPCD_ProcessCompressedData
; ===========================================================================

NemPCD_WriteRowToVDP:
		move.l	d4,(a4)					; write 8-pixel row
		subq.w	#1,a5
		move.w	a5,d4					; have all the 8-pixel rows been written?
		bne.s	NemPCD_NewRow				; if not, branch
		rts						; otherwise the decompression is finished
; ===========================================================================
NemPCD_WriteRowToVDP_XOR:
		eor.l	d4,d2					; XOR the previous row by the current row
		move.l	d2,(a4)					; and write the result
		subq.w	#1,a5
		move.w	a5,d4
		bne.s	NemPCD_NewRow
		rts
; ===========================================================================

NemPCD_WriteRowToRAM:
		move.l	d4,(a4)+
		subq.w	#1,a5
		move.w	a5,d4
		bne.s	NemPCD_NewRow
		rts
; ===========================================================================
NemPCD_WriteRowToRAM_XOR:
		eor.l	d4,d2
		move.l	d2,(a4)+
		subq.w	#1,a5
		move.w	a5,d4
		bne.s	NemPCD_NewRow
		rts

; ---------------------------------------------------------------------------
; Part of the Nemesis decompressor, builds the code table (in RAM)
; ---------------------------------------------------------------------------

NemDec_BuildCodeTable:
		move.b	(a0)+,d0				; read first byte

NemBCT_ChkEnd:
		cmpi.b	#$FF,d0					; has the end of the code table description been reached?
		bne.s	NemBCT_NewPALIndex			; if not, branch
		rts						; otherwise, this subroutine's work is done
; ===========================================================================

NemBCT_NewPALIndex:
		move.w	d0,d7

NemBCT_Loop:
		move.b	(a0)+,d0				; read next byte
		cmpi.b	#$80,d0					; sign bit being set signifies a new palette index
		bcc.s	NemBCT_ChkEnd				; a bmi could have been used instead of a compare and bcc

		move.b	d0,d1
		andi.w	#$F,d7					; get palette index
		andi.w	#$70,d1					; get repeat count for palette index
		or.w	d1,d7					; combine the two
		andi.w	#$F,d0					; get the length of the code in bits
		move.b	d0,d1
		lsl.w	#8,d1
		or.w	d1,d7					; combine with palette index and repeat count to form code table entry
		moveq	#8,d1
		sub.w	d0,d1					; is the code 8 bits long?
		bne.s	NemBCT_ShortCode			; if not, a bit of extra processing is needed
		move.b	(a0)+,d0				; get code
		add.w	d0,d0					; each code gets a word-sized entry in the table
		move.w	d7,(a1,d0.w)				; store the entry for the code
		bra.s	NemBCT_Loop				; repeat

; ---------------------------------------------------------------------------
; The Nemesis decompressor uses prefix-free codes (no valid code is a prefix
; of a longer code);  e.g. if 10 is a valid 2-bit code, 110 is a valid 3-bit
; code but 100 isn't. Also, when the actual compressed data is processed the
; high bit of each code is in bit position 7 so the code needs to be
; bit-shifted appropriately over here before being used as a code table index.
; Additionally, the code needs multiple entries in the table because no
; masking is done during compressed data processing, so if 11000 is a valid
; code, then all indices of the form 11000XXX need to have the same entry.
; ---------------------------------------------------------------------------

NemBCT_ShortCode:
		move.b	(a0)+,d0				; get code
		lsl.w	d1,d0					; get index into code table
		add.w	d0,d0					; shift so that high bit is in bit position 7
		moveq	#1,d5
		lsl.w	d1,d5
		subq.w	#1,d5					; d5 = 2^1

NemBCT_ShortCode_Loop:
		move.w	d7,(a1,d0.w)				; store entry
		addq.w	#2,d0					; increment index
		dbf	d5,NemBCT_ShortCode_Loop		; repeat for required number of entries
		bra.s	NemBCT_Loop

; ---------------------------------------------------------------------------
; WARNING: AddPLC and NewPLC do not check for buffer overruns, and a bug
; in ProcessPLC_Finish leaves the $10th and final slot unsafe to use. Assuming
; you've enabled FixBugs, DO NOT PUT MORE THAN $10 LOAD REQUESTS IN A LIST!
; If FixBugs is NOT enabled, you can only do $F requests; see the bugfix
; in ProcessPLC_Finish.
; ---------------------------------------------------------------------------
; Subroutine to load pattern load cues (to queue pattern load requests)

; input:
;	d0.w = index of PLC list

;	uses d0.w

; usage:
;		moveq	#id_PLC_Explode,d0
;		jsr	AddPLC	; may be optimized to absolute short or bsr.w if possible
; ---------------------------------------------------------------------------
; sub_161E: PLCLoad: LoadPLC:
AddPLC:
		pushr.l	a1-a2,-(sp)				; save a1/a2 to stack
		lea	(PatternLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1				; jump to relevant PLC
		lea	(v_plc_buffer).w,a2			; PLC buffer space in RAM

	.findspace:
		tst.l	(a2)					; is first space available?
		beq.s	.copytoRAM				; if yes, branch
		addq.w	#sizeof_plc,a2				; if not, try next space
		bra.s	.findspace				; repeat until space is found (warning: there are $10 spaces, but it may overflow)
; ===========================================================================

.copytoRAM:
		move.w	(a1)+,d0				; get PLC item count
		bmi.s	.skip					; branch if -1 (i.e. 0 items)

	.loop:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+				; copy PLC to RAM
		dbf	d0,.loop				; repeat for all items in PLC

	.skip:
		popr.l	a1-a2					; restore a1/a2 from stack
		rts

; ---------------------------------------------------------------------------
; Subroutine to load pattern load cues (to queue pattern load requests) and
; clear the PLC buffer

; input:
;	d0 = index of PLC list

; ---------------------------------------------------------------------------
; sub_1650: LoadPLC2:
NewPLC:
		pushr.l	a1-a2					; save a1/a2 to stack
		lea	(PatternLoadCues).l,a1
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1				; jump to relevant PLC
		bsr.s	ClearPLC				; erase any data in PLC buffer space
		lea	(v_plc_buffer).w,a2
		move.w	(a1)+,d0				; get PLC item count
		bmi.s	.skip					; branch if -1 (i.e. 0 items)

	.loop:
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+				; copy PLC to RAM
		dbf	d0,.loop				; repeat for all items in PLC	(warning: there are $10 spaces, but it may overflow)

	.skip:
		popr.l	a1-a2					; restore a1/a2 from stack
		rts

; ---------------------------------------------------------------------------
; Subroutine to	clear the pattern load cue buffer
; Similar to the clear_ram macro, except it uses a2 and clr.l

;	uses d0, a2
; ---------------------------------------------------------------------------

ClearPLC:
		lea	(v_plc_buffer).w,a2			; PLC buffer space in RAM
		moveq	#(((plc_buffer_and_regs_end-plc_buffer_and_regs)/4)-1),d0

	.loop:
		clr.l	(a2)+
		dbf	d0,.loop
		rts

; ---------------------------------------------------------------------------
; Subroutine to	check the PLC buffer and begin decompression if it contains
; anything. ProcessPLC handles the actual decompression during VBlank

;	uses d0.l, d1.w, d2.w, d5.l, d6.l, d7.w, a0, a1, a3
; ---------------------------------------------------------------------------

; sub_168A: RunPLC_RAM:
RunPLC:
		tst.l	(v_plc_buffer).w			; does PLC buffer contain any items?
		beq.s	.exit					; if not, branch
		tst.w	(v_nem_tile_count).w
		bne.s	.exit
		movea.l	(v_plc_buffer).w,a0			; get pointer for Nemesis compressed graphics
		lea_	NemPCD_WriteRowToVDP,a3
		nop
		lea	(v_nem_gfx_buffer).w,a1
		move.w	(a0)+,d2				; get 1st word of Nemesis graphics header
		bpl.s	.normal_mode				; branch if 0-$7FFF
		adda.w	#NemPCD_WriteRowToVDP_XOR-NemPCD_WriteRowToVDP,a3 ; use XOR mode

	.normal_mode:
		andi.w	#$7FFF,d2				; clear highest bit
    if FixBugs=0
		; This is done too early. This variable is also used as a flag to indicate
		; there are PLCs to process, which means that as soon as this
		; variable is set, PLC processing will occur during VBlank or HBlank.
		; If an interrupt occurs between here and the end of this function, then
		; the PLC processor will begin despite it not being fully initialized,
		; causing a crash (as can happen in Sonic 1 at the end of LZ1 & 2).
		; This bug is also present in Sonic CD; S3K fixes it by moving this
		; instruction to the end of the function.
		move.w	d2,(v_nem_tile_count).w			; load tile count
	endc
		bsr.w	NemDec_BuildCodeTable
		move.b	(a0)+,d5				; get next byte of header
		asl.w	#8,d5					; move to high byte of word
		move.b	(a0)+,d5				; get final byte of header
		moveq	#$10,d6
		moveq	#0,d0
		move.l	a0,(v_plc_buffer).w			; save pointer to actual compressed data
		move.l	a3,(v_nem_mode_ptr).w			; save pointer to Nemesis normal/XOR code
		move.l	d0,(v_nem_repeat).w
		move.l	d0,(v_nem_pixel).w
		move.l	d0,(v_nem_d2).w
		move.l	d5,(v_nem_header).w
		move.l	d6,(v_nem_shift).w
	if FixBugs
		; See above.
		move.w	d2,(v_nem_tile_count).w			; load tile count and signal there are PLCs ready to process
	endc

	.exit:
		rts


; ---------------------------------------------------------------------------
; Subroutine to	decompress graphics listed in the PLC buffer

;	uses d0.l, d1.l, d2.l, d3.l, d4.l, d5.l, d6.l, d7.w, a0, a1, a3, a4, a5
; ---------------------------------------------------------------------------

nem_tile_count:	= 6

ProcessPLC:
		tst.w	(v_nem_tile_count).w			; has PLC execution begun?
		beq.w	ProcessPLC_Exit				; if not, branch
		move.w	#nem_tile_count,(v_nem_tile_count_frame).w ; 9 tiles per frame
		moveq	#0,d0
		move.w	(v_plc_buffer_dest).w,d0		; copy VRAM destination to d0
		addi.w	#nem_tile_count*sizeof_cell,(v_plc_buffer_dest).w ; update for next frame
		bra.s	ProcessPLC_Decompress

nem_tile_count:	= 3

ProcessPLC2:
		tst.w	(v_nem_tile_count).w			; has PLC execution begun?
		beq.s	ProcessPLC_Exit				; if not, branch
		move.w	#nem_tile_count,(v_nem_tile_count_frame).w ; 3 tiles per frame
		moveq	#0,d0
		move.w	(v_plc_buffer_dest).w,d0		; copy VRAM destination to d0
		addi.w	#nem_tile_count*sizeof_cell,(v_plc_buffer_dest).w ; update for next frame

ProcessPLC_Decompress:
		lea	(vdp_control_port).l,a4
		lsl.l	#2,d0
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0					; convert VRAM address to VDP format
		move.l	d0,(a4)					; set address via control port
		subq.w	#4,a4					; a4 = vdp_data_port
		movea.l	(v_plc_buffer).w,a0			; load pointer for actual compressed data (sans header)
		movea.l	(v_nem_mode_ptr).w,a3
		move.l	(v_nem_repeat).w,d0
		move.l	(v_nem_pixel).w,d1
		move.l	(v_nem_d2).w,d2
		move.l	(v_nem_header).w,d5
		move.l	(v_nem_shift).w,d6
		lea	(v_nem_gfx_buffer).w,a1

	.loop_tile:
		movea.w	#8,a5
		bsr.w	NemPCD_NewRow
		subq.w	#1,(v_nem_tile_count).w			; decrement tile counter
		beq.s	ProcessPLC_Finish			; branch if 0
		subq.w	#1,(v_nem_tile_count_frame).w		; decrement tile per frame counter
		bne.s	.loop_tile				; branch if not 0

		move.l	a0,(v_plc_buffer).w			; save pointer to latest compressed data
		move.l	a3,(v_nem_mode_ptr).w
		move.l	d0,(v_nem_repeat).w
		move.l	d1,(v_nem_pixel).w
		move.l	d2,(v_nem_d2).w
		move.l	d5,(v_nem_header).w
		move.l	d6,(v_nem_shift).w

ProcessPLC_Exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	shift the PLC buffer contents after an entry is processed
; ---------------------------------------------------------------------------

ProcessPLC_Finish:
		lea	(v_plc_buffer).w,a0

	if FixBugs
		; Shift the PLC buffer by the exact number of bytes in each cue (6)
		; using paired longword and word moves, and clear the last slot
		; when finished, fixing the bugs described below. It is also slightly
		; faster than the original code, requiring just 676 cycles instead of
		; of 758.
		lea sizeof_plc(a0),a1				; start of second slot in the queue
   		moveq   #((sizeof_plc_buffer-sizeof_plc)/sizeof_plc)-1,d0 ; $E, number of loops needed to shift everything

	.loop:
		move.l  (a1)+,(a0)+				; shift the first 4 bytes...
		move.w  (a1)+,(a0)+				; ...then the final 2 bytes of the cue to the next slot
		dbf d0,.loop					; loop until entire buffer has been shifted

    	moveq   #0,d0
    	move.l  d0,(a0)+					; clear the first longword...
    	move.w  d0,(a0)+					; ...and the final word of the last cue to prevent it from being overcopied

	else
		; This shifts the PLC buffer using longword moves alone. However,
		; the total amount of data that needs to be shifted ($5A, the size in
		; bytes of $F PLC slots) is not divisible by a longword.
		; Consequently, only $58 bytes are shifted; the final word
		; (the VRAM offset of the $10th and final cue) is skipped.
		; Additionally, that $10th cue is not cleared, with the result that
		; if it is used, the part that isn't broken will get copied over and over
		; until it fills the entire buffer, causing the PLC processor to get stuck
		; in an infinite loop.
		moveq	#((sizeof_plc_buffer-sizeof_plc)/4)-1,d0 ; $15

	.loop:
		move.l	sizeof_plc(a0),(a0)+			; shift contents of PLC buffer up 6 bytes
		dbf	d0,.loop				; repeat until everything has been shifted (but see the bug above)
	endc
		rts

; ---------------------------------------------------------------------------
; Subroutine to	decompress an entire pattern load cue at once

; input:
;	d0.w = index of PLC list

;	uses d0.l, d1.w, a1
; ---------------------------------------------------------------------------

QuickPLC:
		lea	(PatternLoadCues).l,a1			; load the PLC index
		add.w	d0,d0
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		move.w	(a1)+,d1				; get length of PLC

	.loop:
		movea.l	(a1)+,a0				; get compressed graphics pointer
		moveq	#0,d0
		move.w	(a1)+,d0				; get VRAM address
		lsl.l	#2,d0
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		move.l	d0,(vdp_control_port).l			; converted VRAM address to VDP format
		bsr.w	NemDec					; decompress
		dbf	d1,.loop				; repeat for length of PLC
		rts

; ---------------------------------------------------------------------------
; Enigma decompression algorithm

; input:
;	d0.w = starting art tile (added to each 8x8 before writing to destination)
;	a0 = source address
;	a1 = destination address

;	uses a0

; usage:
;		lea	(source).l,a0
;		lea	(destination).l,a1
;		move.w	#arttile,d0
;		bsr.w	EniDec

; See http://www.segaretro.org/Enigma_compression for format description
; ---------------------------------------------------------------------------

EniDec:
		pushr.l	d0-d7/a1-a5
		movea.w	d0,a3					; store starting art tile
		move.b	(a0)+,d0
		ext.w	d0
		movea.w	d0,a5					; store number of bits in inline copy value
		move.b	(a0)+,d4
		lsl.b	#3,d4					; store PCCVH flags bitfield
		movea.w	(a0)+,a2
		adda.w	a3,a2					; store incremental copy word
		movea.w	(a0)+,a4
		adda.w	a3,a4					; store literal copy word
		move.b	(a0)+,d5
		asl.w	#8,d5
		move.b	(a0)+,d5				; get first word in format list
		moveq	#16,d6					; initial shift value

Eni_Loop:
		moveq	#7,d0					; assume a format list entry is 7 bits
		move.w	d6,d7
		sub.w	d0,d7
		move.w	d5,d1
		lsr.w	d7,d1
		andi.w	#$7F,d1					; get format list entry
		move.w	d1,d2					; and copy it
		cmpi.w	#$40,d1					; is the high bit of the entry set?
		bcc.s	.sevenbitentry
		moveq	#6,d0					; if it isn't, the entry is actually 6 bits
		lsr.w	#1,d2

	.sevenbitentry:
		bsr.w	EniDec_FetchByte
		andi.w	#$F,d2					; get repeat count
		lsr.w	#4,d1
		add.w	d1,d1
		jmp	EniDec_Index(pc,d1.w)

; ===========================================================================

EniDec_00:
	.loop:
		move.w	a2,(a1)+				; copy incremental copy word
		addq.w	#1,a2					; increment it
		dbf	d2,.loop				; repeat
		bra.s	Eni_Loop
; ===========================================================================

EniDec_01:
	.loop:
		move.w	a4,(a1)+				; copy literal copy word
		dbf	d2,.loop				; repeat
		bra.s	Eni_Loop
; ===========================================================================

EniDec_100:
		bsr.w	EniDec_FetchInlineValue

	.loop:
		move.w	d1,(a1)+				; copy inline value
		dbf	d2,.loop				; repeat

		bra.s	Eni_Loop
; ===========================================================================

EniDec_101:
		bsr.w	EniDec_FetchInlineValue

	.loop:
		move.w	d1,(a1)+				; copy inline value
		addq.w	#1,d1					; increment
		dbf	d2,.loop				; repeat

		bra.s	Eni_Loop
; ===========================================================================
EniDec_110:
		bsr.w	EniDec_FetchInlineValue

	.loop:
		move.w	d1,(a1)+				; copy inline value
		subq.w	#1,d1					; decrement
		dbf	d2,.loop				; repeat

		bra.s	Eni_Loop
; ===========================================================================
EniDec_111:
		cmpi.w	#$F,d2
		beq.s	EniDec_Done

	.loop:
		bsr.w	EniDec_FetchInlineValue			; fetch new inline value
		move.w	d1,(a1)+				; copy it
		dbf	d2,.loop				; and repeat

		bra.s	Eni_Loop
; ===========================================================================
EniDec_Index:
		bra.s	EniDec_00
		bra.s	EniDec_00
		bra.s	EniDec_01
		bra.s	EniDec_01
		bra.s	EniDec_100
		bra.s	EniDec_101
		bra.s	EniDec_110
		bra.s	EniDec_111
; ===========================================================================

EniDec_Done:
		subq.w	#1,a0					; go back by one byte
		cmpi.w	#16,d6					; were we going to start on a completely new byte?
		bne.s	.notnewbyte				; if not, branch
		subq.w	#1,a0					; and another one if needed

	.notnewbyte:
		move.w	a0,d0
		lsr.w	#1,d0					; are we on an odd byte?
		bcc.s	.evenbyte				; if not, branch
		addq.w	#1,a0					; ensure we're on an even byte

	.evenbyte:
		popr.l	d0-d7/a1-a5
		rts

; ---------------------------------------------------------------------------
; Part of the Enigma decompressor
; Fetches an inline copy value and stores it in d1
; ---------------------------------------------------------------------------

EniDec_FetchInlineValue:
		move.w	a3,d3					; copy starting art tile
		move.b	d4,d1					; copy PCCVH bitfield
		add.b	d1,d1					; is the priority bit set?
		bcc.s	.skippriority				; if not, branch
		subq.w	#1,d6
		btst	d6,d5					; is the priority bit set in the inline render flags?
		beq.s	.skippriority				; if not, branch
		ori.w	#$8000,d3				; otherwise set priority bit in art tile

	.skippriority:
		add.b	d1,d1					; is the high palette line bit set?
		bcc.s	.skiphighpal				; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.skiphighpal
		addi.w	#$4000,d3				; set second palette line bit

	.skiphighpal:
		add.b	d1,d1					; is the low palette line bit set?
		bcc.s	.skiplowpal				; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.skiplowpal
		addi.w	#$2000,d3				; set first palette line bit

	.skiplowpal:
		add.b	d1,d1					; is the vertical flip flag set?
		bcc.s	.skipyflip				; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.skipyflip
		ori.w	#$1000,d3				; set yflip bit

	.skipyflip:
		add.b	d1,d1					; is the horizontal flip flag set?
		bcc.s	.skipxflip				; if not, branch
		subq.w	#1,d6
		btst	d6,d5
		beq.s	.skipxflip
		ori.w	#$800,d3				; set xflip bit

	.skipxflip:
		move.w	d5,d1
		move.w	d6,d7
		sub.w	a5,d7					; subtract length in bits of inline copy value
		bcc.s	.enoughbits				; branch if a new word doesn't need to be read
		move.w	d7,d6
		addi.w	#16,d6
		neg.w	d7					; calculate bit deficit
		lsl.w	d7,d1					; and make space for that many bits
		move.b	(a0),d5					; get next byte
		rol.b	d7,d5					; and rotate the required bits into the lowest positions
		add.w	d7,d7
		and.w	EniDec_Masks-2(pc,d7.w),d5
		add.w	d5,d1					; combine upper bits with lower bits

.maskvalue:
		move.w	a5,d0					; get length in bits of inline copy value
		add.w	d0,d0
		and.w	EniDec_Masks-2(pc,d0.w),d1		; mask value appropriately
		add.w	d3,d1					; add starting art tile
		move.b	(a0)+,d5
		lsl.w	#8,d5
		move.b	(a0)+,d5				; get next word
		rts
; ===========================================================================

.enoughbits:
		beq.s	.justenough				; if the word has been exactly exhausted, branch
		lsr.w	d7,d1					; get inline copy value
		move.w	a5,d0
		add.w	d0,d0
		and.w	EniDec_Masks-2(pc,d0.w),d1		; and mask it appropriately
		add.w	d3,d1					; add starting art tile
		move.w	a5,d0
		bra.s	EniDec_FetchByte
; ===========================================================================

.justenough:
		moveq	#16,d6					; reset shift value
		bra.s	.maskvalue
; ===========================================================================

EniDec_Masks:
		dc.w	 1,    3,    7,   $F
		dc.w   $1F,  $3F,  $7F,  $FF
		dc.w  $1FF, $3FF, $7FF, $FFF
		dc.w $1FFF,$3FFF,$7FFF,$FFFF
; ===========================================================================

EniDec_FetchByte:
		sub.w	d0,d6					; subtract length of current entry from shift value so that next entry is read next time around
		cmpi.w	#9,d6					; does a new byte need to be read?
		bcc.s	.return					; if not, branch
		addq.w	#8,d6
		asl.w	#8,d5
		move.b	(a0)+,d5

	.return:
		rts

; ---------------------------------------------------------------------------
; Kosinski decompression algorithm

; input:
;	a0 = source address
;	a1 = destination address

;	uses d0.b, d1.w, d2.l, d3.l, d4.l, d5.w, d6.w, a0, a1

; usage:
;		lea	(source).l,a0
;		lea	(destination).l,a1
;		bsr.w	KosDec
; ---------------------------------------------------------------------------

KosDec:
		subq.l	#2,sp					; make space for 2 bytes on the stack
		move.b	(a0)+,1(sp)
		move.b	(a0)+,(sp)
		move.w	(sp),d5					; get first description field
		moveq	#$F,d4					; set to loop for 16 bits

Kos_Loop:
		lsr.w	#1,d5					; shift bit into the c flag
		move	sr,d6
		dbf	d4,.chkbit
		move.b	(a0)+,1(sp)
		move.b	(a0)+,(sp)
		move.w	(sp),d5
		moveq	#$F,d4

	.chkbit:
		move	d6,ccr					; was the bit set?
		bcc.s	Kos_RLE					; if not, branch

		move.b	(a0)+,(a1)+				; copy byte as-is
		bra.s	Kos_Loop
; ===========================================================================

Kos_RLE:
		moveq	#0,d3
		lsr.w	#1,d5					; get next bit
		move	sr,d6
		dbf	d4,.chkbit
		move.b	(a0)+,1(sp)
		move.b	(a0)+,(sp)
		move.w	(sp),d5
		moveq	#$F,d4

	.chkbit:
		move	d6,ccr					; was the bit set?
		bcs.s	Kos_SeparateRLE				; if yes, branch

		lsr.w	#1,d5					; shift bit into the x flag
		dbf	d4,.loop1
		move.b	(a0)+,1(sp)
		move.b	(a0)+,(sp)
		move.w	(sp),d5
		moveq	#$F,d4

	.loop1:
		roxl.w	#1,d3					; get high repeat count bit
		lsr.w	#1,d5
		dbf	d4,.loop2
		move.b	(a0)+,1(sp)
		move.b	(a0)+,(sp)
		move.w	(sp),d5
		moveq	#$F,d4

	.loop2:
		roxl.w	#1,d3					; get low repeat count bit
		addq.w	#1,d3					; increment repeat count
		moveq	#-1,d2
		move.b	(a0)+,d2				; calculate offset
		bra.s	Kos_RLELoop
; ===========================================================================

Kos_SeparateRLE:
		move.b	(a0)+,d0				; get first byte
		move.b	(a0)+,d1				; get second byte
		moveq	#-1,d2
		move.b	d1,d2
		lsl.w	#5,d2
		move.b	d0,d2					; calculate offset
		andi.w	#7,d1					; does a third byte need to be read?
		beq.s	Kos_SeparateRLE2			; if yes, branch
		move.b	d1,d3					; copy repeat count
		addq.w	#1,d3					; increment

Kos_RLELoop:
		move.b	(a1,d2.w),d0				; copy appropriate byte
		move.b	d0,(a1)+				; repeat
		dbf	d3,Kos_RLELoop
		bra.s	Kos_Loop
; ===========================================================================

Kos_SeparateRLE2:
		move.b	(a0)+,d1
		beq.s	Kos_Done				; 0 indicates end of compressed data
		cmpi.b	#1,d1
		beq.w	Kos_Loop				; 1 indicates new description to be read
		move.b	d1,d3					; otherwise, copy repeat count
		bra.s	Kos_RLELoop
; ===========================================================================

Kos_Done:
		addq.l	#2,sp					; restore stack pointer
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

; ===========================================================================


PaletteCycle:
		bsr.w	PCycle_SuperSonic			; Super Sonic's palette cycle is handled seperately
		moveq	#0,d2
		moveq	#0,d0
		move.b	(v_zone).w,d0				; get zone number
		add.w	d0,d0					; (multiply by element size = 2 bytes)
		move.w	PCycle_Index(pc,d0.w),d0		; use zone number as index
		jmp	PCycle_Index(pc,d0.w)			; jump to relevant palette routine
; ===========================================================================

		rts						; a single instruction of dead code
; ===========================================================================

PCycle_Index:	index offset(*)
		ptr PCycle_EHZ					; 0
		ptr PCycle_Null					; 1
		ptr PCycle_WZ					; 2
		ptr PCycle_Null					; 3
		ptr PCycle_MTZ					; 4
		ptr PCycle_MTZ					; 5
		ptr PCycle_WFZ					; 6
		ptr PCycle_HTZ					; 7
		ptr PCycle_HPZ					; 8
		ptr PCycle_Null					; 9
		ptr PCycle_OOZ					; $A
		ptr PCycle_MCZ					; $B
		ptr PCycle_CNZ					; $C
		ptr PCycle_CPZ					; $D
		ptr PCycle_CPZ					; $E
		ptr PCycle_ARZ					; $F
		ptr PCycle_WFZ					; $10
; ===========================================================================

PCycle_Null:
		rts
; ===========================================================================

PCycle_EHZ:
		lea	(Pal_EHZ_ARZWaterCyc).l,a0
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#7,(v_palcycle_time).w			; reset timer to 7 frames
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#1,(v_palcycle_num).w			; increment cycle number
		andi.w	#3,d0					; if greater than 3, reset to 0
		lsl.w	#3,d0					; multiply by 8
		move.l	(a0,d0.w),(v_pal_dry_line2+(3*2)).w	; copy two colors to 2nd line, 3 colors in
		move.l	4(a0,d0.w),(v_pal_dry_line2+(14*2)).w	; copy two colors to 2nd line, 14 colors in

	.exit:
		rts
; ===========================================================================
; Unused beta leftover
PCycle_WZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#2,(v_palcycle_time).w			; reset timer to 2 frames
		lea	(Pal_WoodConveyerCyc).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		subq.w	#2,(v_palcycle_num).w			; decrement cycle number
		bcc.s	.no_reset				; if greater than 0, bramch
		move.w	#6,(v_palcycle_num).w			; reset cycle nummber

	.no_reset:
		lea	(v_pal_dry_line4+(3*2)).w,a1		; 4th line, 3 colors in
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors

	.exit:
		rts
; ===========================================================================

PCycle_MTZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer 1
		bpl.s	.cycle2					; if time remains, branch
		move.w	#$11,(v_palcycle_time).w		; reset timer to 17 frames
		lea	(Pal_MTZCyc1).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num).w			; increment cycle number
		cmpi.w	#$C,(v_palcycle_num).w			; is it greater than 10?
		bcs.s	.no_reset1				; if not, branch
		move.w	#0,(v_palcycle_num).w			; reset cycle number

	.no_reset1:
		lea	(v_pal_dry_line3+(5*2)).w,a1		; 3rd line, 5 colors in
		move.w	(a0,d0.w),(a1)				; copy one color

	.cycle2:
		subq.w	#1,(v_palcycle_time2).w			; decrement timer 2
		bpl.s	.cycle3					; if time remains, branch
		move.w	#2,(v_palcycle_time2).w			; reset timer to 2 frames
		lea	(Pal_MTZCyc2).l,a0
		move.w	(v_palcycle_num2).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num2).w			; increment cycle number
		cmpi.w	#6,(v_palcycle_num2).w			; is it cycle 6?
		bcs.s	.no_reset2				; if not, branch
		move.w	#0,(v_palcycle_num2).w			; reset cycle number

	.no_reset2:
		lea	(v_pal_dry_line3+(1*2)).w,a1		; 3rd line, 1 color in
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.w	4(a0,d0.w),(a1)				; copy one more color

	.cycle3:
		subq.w	#1,(v_palcycle_time3).w			; decrement timer 3
		bpl.s	.exit					; if time remains, exit
		move.w	#9,(v_palcycle_time3).w			; reset timer to 9 frames
		lea	(Pal_MTZCyc3).l,a0
		move.w	(v_palcycle_num3).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num3).w			; increment cycle number
		cmpi.w	#$14,(v_palcycle_num3).w		; is it greater than 20?
		bcs.s	.no_reset3				; if not, branch
		move.w	#0,(v_palcycle_num3).w			; reset cycle number

	.no_reset3:
		lea	(v_pal_dry_line3+(15*2)).w,a1		; 3rd line, 15 colors in
		move.w	(a0,d0.w),(a1)				; copy one color

	.exit:
		rts
; ===========================================================================

PCycle_HTZ:
		lea	(Pal_HTZLavaCyc).l,a0
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#0,(v_palcycle_time).w			; clear timer
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#1,(v_palcycle_num).w			; increment cycle number
		andi.w	#$F,d0					; if greater than 16, reset to 0
		move.b	PCycle_HTZ_LavaDelayData(pc,d0.w),(v_palcycle_time+1).w ; reset timer with new value from table
		lsl.w	#3,d0					; multiply by 8
		move.l	(a0,d0.w),(v_pal_dry_line2+(3*2)).w	; copy 2 colors to 2nd line, 3 colors in
		move.l	4(a0,d0.w),(v_pal_dry_line2+(14*2)).w	; copy 2 colors to 2nd line, 14 colors in

	.exit:
		rts
; ===========================================================================

PCycle_HTZ_LavaDelayData:					; number of frames between changes of the lava palette
		dc.b	$B, $B, $B, $A
		dc.b	 8, $A, $B, $B
		dc.b	$B, $B, $D, $F
		dc.b	$D, $B, $B, $B
		even
; ===========================================================================
; Unused beta leftover
PCycle_HPZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#4,(v_palcycle_time).w			; reset timer to 4 frames
		lea	(Pal_HPZWaterCyc).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		subq.w	#2,(v_palcycle_num).w			; decrement cycle number
		bcc.s	.no_reset				; if greater than 0, branch
		move.w	#6,(v_palcycle_num).w			; reset cycle number

	.no_reset:
		lea	(v_pal_dry_line4+(9*2)).w,a1		; 4th line, 9th color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors
		lea	(Pal_HPZUnderwaterCyc).l,a0
		lea	(v_pal_water_line4+(9*2)).w,a1		; repeat with corrosponding water palette
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)

	.exit:
		rts
; ===========================================================================

PCycle_OOZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#7,(v_palcycle_time).w			; reset timer to 7 frames
		lea	(Pal_OOZOilCyc).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num).w			; decrement cycle number
		andi.w	#6,(v_palcycle_num).w			; if greater than 6, reset to 0
		lea	(v_pal_dry_line3+(10*2)).w,a1		; 3rd line, 10th color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors

	.exit:
		rts
; ===========================================================================

PCycle_MCZ:
		tst.b	(v_current_boss).w			; is the MCZ boss fight in progress?
		bne.s	.exit					; if so, exit
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#1,(v_palcycle_time).w			; reset timer to 1 frame
		lea	(Pal_MCZLanternCyc).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num).w			; increment cycle number
		andi.w	#6,(v_palcycle_num).w			; if greater than 6, reset to 0
		move.w	(a0,d0.w),(v_pal_dry_line2+(11*2)).w	; copy 1 color to 2nd line, 11th color

	.exit:
		rts
; ===========================================================================

PCycle_CNZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.w	.chk_boss				; if time remains, branch
		move.w	#7,(v_palcycle_time).w			; reset timer
		lea	(Pal_CNZCyc1_Cyc2).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num).w			; increment cycle number
		cmpi.w	#6,(v_palcycle_num).w			; is it greater than 6?
		bcs.s	.no_reset1				; if not, branch
		move.w	#0,(v_palcycle_num).w			; reset cycle to 0

	.no_reset1:
		lea	(a0,d0.w),a0
		lea	(v_pal_dry).w,a1
		; copy 6 colors to 3rd line, colors 5-7 and 11-13
		_move.w	0(a0),(v_pal_dry_line3+(5*2))-v_pal_dry(a1)
		move.w	6(a0),(v_pal_dry_line3+(6*2))-v_pal_dry(a1)
		move.w	$C(a0),(v_pal_dry_line3+(7*2))-v_pal_dry(a1)
		move.w	$12(a0),(v_pal_dry_line3+(11*2))-v_pal_dry(a1)
		move.w	$18(a0),(v_pal_dry_line3+(12*2))-v_pal_dry(a1)
		move.w	$1E(a0),(v_pal_dry_line3+(13*2))-v_pal_dry(a1)

		lea	(Pal_CNZCyc3).l,a0
		lea	(a0,d0.w),a0
		; copy 3 colors to 4th line, colors 2-4
		_move.w	0(a0),(v_pal_dry_line4+(2*2))-v_pal_dry(a1)
		move.w	6(a0),(v_pal_dry_line4+(3*2))-v_pal_dry(a1)
		move.w	$C(a0),(v_pal_dry_line4+(4*2))-v_pal_dry(a1)

		lea	(Pal_CNZCyc4).l,a0
		move.w	(v_palcycle_num_cnz).w,d0		; get cycle number
		addq.w	#2,(v_palcycle_num_cnz).w		; increment cycle number
		cmpi.w	#$24,(v_palcycle_num_cnz).w		; is it greater than 36?
		bcs.s	.no_reset2				; if not, branch
		move.w	#0,(v_palcycle_num_cnz).w		; reset cycle to 0

	.no_reset2:
		lea	(v_pal_dry_line4+(9*2)).w,a1		; 4th line, 9th color
		move.w	4(a0,d0.w),(a1)+			; copy two colors
		move.w	2(a0,d0.w),(a1)+			; copy two more colors
		move.w	(a0,d0.w),(a1)+				; copy two final colors

	.chk_boss:
		tst.b	(v_current_boss).w			; is the boss fight in progress?
		beq.w	.exit					; if not, exit
		subq.w	#1,(v_palcycle_time2).w			; decrement timer
		bpl.w	.exit					; if time remains, exit
		move.w	#3,(v_palcycle_time2).w			; reset timer to 3 frames
		move.w	(v_palcycle_num2).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num2).w			; increment cycle number
		cmpi.w	#6,(v_palcycle_num2).w			; is it greater than 6?
		bcs.s	.no_reset3				; if not, branch
		move.w	#0,(v_palcycle_num2).w			; reset cycle to 0

	.no_reset3:
		lea	(Pal_CNZBossCyc1).l,a0
		lea	(a0,d0.w),a0
		lea	(v_pal_dry).w,a1
		; copy 3 colors to 2nd line, colors 2-4
		_move.w	0(a0),(v_pal_dry_line2+(2*2))-v_pal_dry(a1)
		move.w	6(a0),(v_pal_dry_line2+(3*2))-v_pal_dry(a1)
		move.w	$C(a0),(v_pal_dry_line2+(4*2))-v_pal_dry(a1)

		lea	(Pal_CNZBossCyc2).l,a0
		move.w	(v_palcycle_num3).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num3).w			; increment cycle number
		cmpi.w	#$14,(v_palcycle_num3).w		; is it greater than 20?
		bcs.s	.no_reset4				; if not, branch
		move.w	#0,(v_palcycle_num3).w			; reset cycle to 0

	.no_reset4:
		move.w	(a0,d0.w),(v_pal_dry_line2+(14*2))-v_pal_dry(a1) ; copy one color to 2nd line, 14th color
		lea	(Pal_CNZBossCyc3).l,a0
		move.w	(v_palcycle_num2_cnz).w,d0		; get cycle number
		addq.w	#2,(v_palcycle_num2_cnz).w		; increment cycle number
		andi.w	#$E,(v_palcycle_num2_cnz).w		; if cycle 14, reset to 0
		move.w	(a0,d0.w),(v_pal_dry_line2+(15*2))-v_pal_dry(a1) ; copy one color to 2nd line, 15th color

	.exit:
		rts
; ===========================================================================

PCycle_CPZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#7,(v_palcycle_time).w			; reset timer to 7 frames
		lea	(Pal_CPZCyc1).l,a0
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#6,(v_palcycle_num).w			; increment cycle number
		cmpi.w	#$36,(v_palcycle_num).w			; is it greater than 54?
		bcs.s	.no_reset1				; if not, branch
		move.w	#0,(v_palcycle_num).w			; reset cycle number

	.no_reset1:
		lea	(v_pal_dry_line4+(12*2)).w,a1		; 4th line, 12th color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.w	4(a0,d0.w),(a1)				; copy one color

		lea	(Pal_CPZCyc2).l,a0
		move.w	(v_palcycle_num2).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num2).w			; increment cycle number
		cmpi.w	#$2A,(v_palcycle_num2).w		; is it greater than 42?
		bcs.s	.no_reset2				; if not, branch
		move.w	#0,(v_palcycle_num2).w			; reset cycle to 0

	.no_reset2:
		move.w	(a0,d0.w),(v_pal_dry_line4+(15*2)).w	; 4th line, 15th color

		lea	(Pal_CPZCyc3).l,a0
		move.w	(v_palcycle_num3).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num3).w			; increment cycle number
		andi.w	#$1E,(v_palcycle_num3).w		; if greater than 30, reset to 0
		move.w	(a0,d0.w),(v_pal_dry_line3+(15*2)).w	; 3rd line, 15th color

	.exit:
		rts
; ===========================================================================

PCycle_ARZ:
		lea	(Pal_EHZ_ARZWaterCyc).l,a0
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.exit					; branch if time remains
		move.w	#5,(v_palcycle_time).w			; reset timer to 5 frames
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#1,(v_palcycle_num).w			; increment cycle number
		andi.w	#3,d0					; if greater than 3, reset to 0
		lsl.w	#3,d0					; multiply by 8
		lea	(v_pal_dry_line3+(2*2)).w,a1		; 3rd line, 2nd color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two colors

	.exit:
		rts
; ===========================================================================

PCycle_WFZ:
		subq.w	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.cycle2					; if time remains, branch
		move.w	#1,(v_palcycle_time).w			; reset timer to 1 frame
		lea	(Pal_WFZFireCyc).l,a0
		tst.b	(f_wfz_scz_fire_toggle).w		; is WFZ fire flag set?
		beq.s	.fire					; if not, branch
		move.w	#5,(v_palcycle_time).w			; reset timer to 6
		lea	(Pal_WFZConveyerCyc).l,a0

	.fire:
		move.w	(v_palcycle_num).w,d0			; get cycle number
		addq.w	#8,(v_palcycle_num).w			; increment cycle number
		cmpi.w	#$20,(v_palcycle_num).w			; is it greater than 32?
		bcs.s	.no_reset1				; if not, branch
		move.w	#0,(v_palcycle_num).w			; reset cycle to 0

	.no_reset1:
		lea	(v_pal_dry_line3+(7*2)).w,a1		; 3rd line, 7th color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two colors

	.cycle2:
		subq.w	#1,(v_palcycle_time2).w			; decrement timer
		bpl.s	.cycle3					; if time remains, branch
		move.w	#3,(v_palcycle_time2).w			; reset timer to 3 frames
		lea	(Pal_WFZCyc1).l,a0
		move.w	(v_palcycle_num2).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num2).w			; increment cycle number
		cmpi.w	#$44,(v_palcycle_num2).w		; is it greater than 68?
		bcs.s	.no_reset2				; if not, branch
		move.w	#0,(v_palcycle_num2).w			; reset cycle to 0

	.no_reset2:
		move.w	(a0,d0.w),(v_pal_dry_line3+(14*2)).w	; copy one color to 3rd line, 14th color

	.cycle3:
		subq.w	#1,(v_palcycle_time3).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.w	#5,(v_palcycle_time3).w			; reset timer to 5 frames
		lea	(Pal_WFZCyc2).l,a0
		move.w	(v_palcycle_num3).w,d0			; get cycle number
		addq.w	#2,(v_palcycle_num3).w			; increment cycle number
		cmpi.w	#$18,(v_palcycle_num3).w		; is it greater than 24?
		bcs.s	.no_reset3				; if not, branch
		move.w	#0,(v_palcycle_num3).w			; reset cycle to 0

	.no_reset3:
		move.w	(a0,d0.w),(v_pal_dry_line3+(15*2)).w	; copy one color to 3rd line, 15th color

	.exit:
		rts

; ---------------------------------------------------------------------------
; Palette data & routines
; ---------------------------------------------------------------------------
		incfile Pal_S1TitleCyc				; word_1E5A: Pal_S1TitleCyc: ; unused
		incfile Pal_EHZ_ARZWaterCyc			; word_1E7A: CyclingPal_EHZ_ARZ_Water:
		incfile Pal_HTZLavaCyc				; word_1E9A: CyclingPal_Lava:
		incfile	Pal_WoodConveyerCyc			; word_1F1A: CyclingPal_WoodConveyor:
		incfile	Pal_MTZCyc1				; byte_1F2A: CyclingPal_MTZ1:
		incfile Pal_MTZCyc2				; word_1F36: CyclingPal_MTZ2:
		incfile	Pal_MTZCyc3				; word_1F42: CyclingPal_MTZ3:
		incfile Pal_HPZWaterCyc				; word_1F56: CyclingPal_HPZWater:
		incfile Pal_HPZUnderwaterCyc			; word_1F66: CyclingPal_HPZUnderwater:
		incfile	Pal_OOZOilCyc				; word_1F76: CyclingPal_Oil:
		incfile	Pal_MCZLanternCyc			; word_1F86: CyclingPal_Lantern:
		incfile	Pal_CNZCyc1_Cyc2			; word_1F8E: CyclingPal_CNZ1:Cycle 3
		incfile	Pal_CNZCyc3				; word_1FB2: CyclingPal_CNZ3:
		incfile	Pal_CNZCyc4				; word_1FC4: CyclingPal_CNZ4:
		incfile	Pal_CNZBossCyc1				; word_1FEC: CyclingPal_CNZ1_B:
		incfile	Pal_CNZBossCyc2				; word_1FFE: CyclingPal_CNZ2_B:
		incfile	Pal_CNZBossCyc3				; word_2012: CyclingPal_CNZ3_B:
		incfile	Pal_CPZCyc1				; word_2022: CyclingPal_CPZ1:
		incfile	Pal_CPZCyc2				; word_2058: CyclingPal_CPZ2:
		incfile	Pal_CPZCyc3				; word_2082: CyclingPal_CPZ3:
		incfile	Pal_WFZFireCyc				; word_20A2: CyclingPal_WFZFire:
		incfile	Pal_WFZConveyerCyc			; word_20C2: CyclingPal_WFZBelt:
		incfile	Pal_WFZCyc1				; word_20E2: CyclingPal_CPZ4:
		incfile	Pal_WFZCyc2				; word_2126: CyclingPal_WFZ2:

; ===========================================================================

PCycle_SuperSonic:
		move.b	(v_super_sonic_palette).w,d0		; get Super Sonic's palette status
		beq.s	.exit					; if Sonic isn't super, exit
		bmi.w	.normal					; if fade-in is done, branch
		subq.b	#1,d0
		bne.s	.revert					; if greater than 1, branch

;.fade_in:
		subq.b	#1,(v_palette_timer).w			; decinrement timer
		bpl.s	.exit					; if time remains, exit
		move.b	#3,(v_palette_timer).w			; reset timer to 3 frames

		lea	(Pal_SS_TransformationCyc).l,a0
		move.w	(v_palette_frame).w,d0			; get palette frame
		addq.w	#8,(v_palette_frame).w			; increment frame
		cmpi.w	#$30,(v_palette_frame).w		; has the fade-in cycle reached the 6th frame?
	if FixBugs
		; Branch to common palette cycle routine.
		bcs.s	.dopalettes				; if not, branch
	else
		bcs.s	.fadein_not_done			; if not, branch
	endc

		move.b	#-1,(v_super_sonic_palette).w		; mark fade-in as done
		move.b	#0,(v_ost_player1+ost_obj_control).w	; restore Sonic's movement

	if FixBugs
		; While palettes for transforming underwater are in the ROM, they are only used
		; when reverting to normal; there is no code to use them when transforming into
		; Super Sonic. We can fix this by adding code to this section that matches the
		; normal cycle and revert cycles, but we can take it a bit farther and eliminate
		; some duplicate code as well.
		bra.s	.dopalettes
	else
	.fadein_not_done:
		lea	(v_pal_dry_line1+(2*2)).w,a1		; 1st line, 2nd color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors
	endc

	.exit:
		rts
; ===========================================================================

.revert:
		; Run the fade-in transition backwards.
		subq.b	#1,(v_palette_timer).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.b	#3,(v_palette_timer).w			; reset timer to 3 frames
		lea	(Pal_SS_TransformationCyc).l,a0
		move.w	(v_palette_frame).w,d0			; get palette frame
		subq.w	#8,(v_palette_frame).w			; decrement palette frame

	if FixBugs
		; Branch to common palette cycle routine and fix the bug described below.
		bcc.s	.dopalettes				; if we haven't reached the first frame, branch
		clr.w	(v_palette_frame).w			; clear v_palette_frame
	else
		bcc.s	.fadeout_not_done			; if we haven't reached the first frame, branch
		; v_palette_frame is a word, not a byte. This does not clear the full variable,
		; causing this palette cycle to behave incorrectly if it is activated again
		; in the same level.
		move.b	#0,(v_palette_frame).w			; clear only half of v_palette_frame
	endc
		move.b	#0,(v_super_sonic_palette).w		; mark Super Sonic's palette as inactive

	if FixBugs
	; Common palette cycle routine.
	.dopalettes:
	else
	.fadeout_not_done:
	endc
		lea	(v_pal_dry_line1+(2*2)).w,a1		; 1st line, 2nd color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors

		lea	(Pal_SS_CPZUWTransformationCyc).l,a0	; use CPZ underwater transformation
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		beq.s	.do_underwater_revert			; if so, branch
		cmpi.b	#id_ARZ,(v_zone).w			; is it ARZ?
		bne.s	.exit					; if not, exit
		lea	(Pal_SS_ARZUWTransformationCyc).l,a0	; use ARZ underwater transformation

	.do_underwater_revert:
		lea	(v_pal_water_line1+(2*2)).w,a1		; 1st line, 2nd color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors
		rts
; ===========================================================================

.normal:
		subq.b	#1,(v_palette_timer).w			; decrement timer
		bpl.s	.exit					; if time remains, exit
		move.b	#7,(v_palette_timer).w			; reset timer to 7 frames
		lea	(Pal_SS_TransformationCyc).l,a0
		move.w	(v_palette_frame).w,d0			; get current palette frame
		addq.w	#8,(v_palette_frame).w			; increment palette frame
		cmpi.w	#$78,(v_palette_frame).w		; is it the 120th frame?

	if FixBugs
		; Branch to common palette cycle routine and fix bug described below.
		bls.s	.dopalettes				; if so, branch
	else
		; This is the wrong branch condition to use here; it causes the last frame of the cycle
		; to be skipped.
		bcs.s	.no_reset				; if so, branch
	endc
		move.w	#$30,(v_palette_frame).w		; reset frame counter

	if FixBugs
		; Branch to common palette cycle routine.
		bra.s	.dopalettes
	else
	.no_reset:
		lea	(v_pal_dry_line1+(2*2)).w,a1		; 1st line, 2nd color
		move.l	(a0,d0.w),(a1)+				; copy two colors
		move.l	4(a0,d0.w),(a1)				; copy two more colors
		lea	(Pal_SS_CPZUWTransformationCyc).l,a0	; use CPZ underwater transformation
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		beq.s	.do_underwater				; if so, branch
		cmpi.b	#id_ARZ,(v_zone).w			; is it ARZ?
		bne.w	.exit					; if not, exit
		lea	(Pal_SS_ARZUWTransformationCyc).l,a0	; use ARZ underwater transformation

	.do_underwater:
		lea	(v_pal_water_line1+(2*2)).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)
		rts
	endc
; ===========================================================================

		incfile	Pal_SS_TransformationCyc		; Pal_2246: CyclingPal_SSTransformation:
		incfile	Pal_SS_CPZUWTransformationCyc		; Pal_22C6: CyclingPal_CPZUWTransformation:
		incfile	Pal_SS_ARZUWTransformationCyc		; Pal_2346: CyclingPal_ARZUWTransformation:


; ---------------------------------------------------------------------------
; Subroutine to	fade in from black

;	uses d0.l, d1.l, d2.w, d3.w, d4.w, d5.l, d6.l, d7.w, a0, a1, a3
; ---------------------------------------------------------------------------

PaletteFadeIn:
		move.w	#palfade_all,(v_palfade_start).w	; set start position = 0; size = $40 ($3F)

		moveq	#0,d0
		lea	(v_pal_dry).w,a0
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		moveq	#cBlack,d1
		move.b	(v_palfade_size).w,d0

	.fill:
		move.w	d1,(a0)+
		dbf	d0,.fill				; fill palette with black

		move.w	#(7*3),d4				; max number of color changes needed (000 to $EEE)

	.mainloop:
		move.b	#id_VBlank_Fade,(v_vblank_routine).w
		bsr.w	WaitForVBlank				; wait for frame to end
		bsr.s	FadeIn_FromBlack			; update palette
		bsr.w	RunPLC					; decompress gfx if PLC contains anything
		dbf	d4,.mainloop
		rts
; ===========================================================================

FadeIn_FromBlack:
		moveq	#0,d0
		lea	(v_pal_dry).w,a0			; current palette (starts as all black)
		lea	(v_pal_dry_next).w,a1			; target palette
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	(v_palfade_size).w,d0

	.addcolor:
		bsr.s	FadeIn_AddColor				; raise RGB levels (until they match target palette)
		dbf	d0,.addcolor				; repeat for size of palette

		tst.b	(f_water).w				; does level have water?
		beq.s	.exit					; if not, exit

		moveq	#0,d0
		lea	(v_pal_water).w,a0
		lea	(v_pal_water_next).w,a1
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	(v_palfade_size).w,d0

	.addcolor_water:
		bsr.s	FadeIn_AddColor				; raise RGB levels for underwater palette
		dbf	d0,.addcolor_water			; repeat for size of palette

	.exit:
		rts
; ===========================================================================

FadeIn_AddColor:
.addblue:
		move.w	(a1)+,d2				; d2 = target color
		move.w	(a0),d3					; d3 = current color
		cmp.w	d2,d3
		beq.s	.next					; branch if perfect match

		move.w	d3,d1
		addi.w	#$200,d1				; increase blue	value
		cmp.w	d2,d1
		bhi.s	.addgreen				; branch if blue already matched
		move.w	d1,(a0)+				; update blue
		rts
; ===========================================================================

	.addgreen:
		move.w	d3,d1
		addi.w	#$20,d1					; increase green value
		cmp.w	d2,d1
		bhi.s	.addred					; branch if green already matched
		move.w	d1,(a0)+				; update green
		rts
; ===========================================================================

	.addred:
		addq.w	#2,(a0)+				; increase red value
		rts
; ===========================================================================

	.next:
		addq.w	#2,a0					; next color
		rts

; ---------------------------------------------------------------------------
; Subroutine to fade out to black
;
;	uses d0.l, d1.w, d2.w, d4.w, d5.l, d6.l, d7.w, a0, a1, a3
; ---------------------------------------------------------------------------

PaletteFadeOut:
		move.w	#palfade_all,(v_palfade_start).w	; start position = 0; size = $40 ($3F)
		move.w	#(7*3),d4				; max number of color changes needed ($EEE to 000)

	.mainloop:
		move.b	#id_VBlank_Fade,(v_vblank_routine).w
		bsr.w	WaitForVBlank				; wait for frame to end
		bsr.s	FadeOut_ToBlack				; update palette
		bsr.w	RunPLC					; decompress gfx if PLC contains anything
		dbf	d4,.mainloop
		rts
; ===========================================================================

FadeOut_ToBlack:
		moveq	#0,d0
		lea	(v_pal_dry).w,a0			; current palette
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		move.b	(v_palfade_size).w,d0

	.decolor:
		bsr.s	FadeOut_DecColor			; lower RGB levels
		dbf	d0,.decolor				; repeat for size of palette

	if FixBugs
		; Just for the sake of consistency: no need to do this if
		; if not a water level.
		tst.b	(f_water).w				; does level have water?
		beq.s	.exit					; if not, exit
	endc

		moveq	#0,d0
		lea	(v_pal_water).w,a0
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		move.b	(v_palfade_size).w,d0

	.decolor_water:
		bsr.s	FadeOut_DecColor			; lower RGB levels for underwater palette
		dbf	d0,.decolor_water			; repeat for size of palette

	.exit:
		rts
; ===========================================================================

FadeOut_DecColor:
.dered:
		move.w	(a0),d2					; d2 = current color
		beq.s	.next					; branch if already black

		move.w	d2,d1
		andi.w	#$E,d1					; d1 = red value
		beq.s	.degreen				; branch if 0
		subq.w	#2,(a0)+				; decrease red value
		rts
; ===========================================================================

.degreen:
		move.w	d2,d1
		andi.w	#$E0,d1					; d1 = green value
		beq.s	.deblue					; branch if 0
		subi.w	#$20,(a0)+				; decrease green value
		rts
; ===========================================================================

.deblue:
		move.w	d2,d1
		andi.w	#$E00,d1				; d1 = blue value
		beq.s	.next					; branch if 0
		subi.w	#$200,(a0)+				; decrease blue	value
		rts
; ===========================================================================

.next:
		addq.w	#2,a0					; next color
		rts

; ---------------------------------------------------------------------------
; Subroutine to	fade in from white (Special Stage)

;	uses d0.l, d1.w, d2.w, d3.w, d4.w, d5.l, d6.l, d7.w, a0, a1, a3
; ---------------------------------------------------------------------------

PaletteWhiteIn:
		move.w	#palfade_all,(v_palfade_start).w	; start position = 0; size = $40
		moveq	#0,d0
		lea	(v_pal_dry).w,a0
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		move.w	#cWhite,d1
		move.b	(v_palfade_size).w,d0

	.fill:
		move.w	d1,(a0)+
		dbf	d0,.fill				; fill palette with white

		move.w	#(7*3),d4				; max number of color changes needed ($EEE to 0)

.mainloop:
		move.b	#id_VBlank_Fade,(v_vblank_routine).w
		bsr.w	WaitForVBlank				; wait for frame to end
		bsr.s	WhiteIn_FromWhite			; update palette
		bsr.w	RunPLC					; decompress gfx if PLC contains anything
		dbf	d4,.mainloop
		rts
; ===========================================================================

WhiteIn_FromWhite:
		moveq	#0,d0
		lea	(v_pal_dry).w,a0			; current palette (starts as all white)
		lea	(v_pal_dry_next).w,a1			; target palette
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	(v_palfade_size).w,d0

	.decolor:
		bsr.s	WhiteIn_DecColor			; lower RGB levels (until they match target palette)
		dbf	d0,.decolor				; repeat for size of palette

		tst.b	(f_water).w				; does level have water?
		beq.s	.exit					; if not, branch

		moveq	#0,d0
		lea	(v_pal_water).w,a0
		lea	(v_pal_water_next).w,a1
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	(v_palfade_size).w,d0

	.decolor_water:
		bsr.s	WhiteIn_DecColor			; lower RGB levels for underwater palette
		dbf	d0,.decolor_water			; repeat for size of palette

	.exit:
		rts
; ===========================================================================

WhiteIn_DecColor:
.deblue:
		move.w	(a1)+,d2				; d2 = target color
		move.w	(a0),d3					; d3 = current color
		cmp.w	d2,d3
		beq.s	.next					; branch if perfect match

		move.w	d3,d1
		subi.w	#$200,d1				; decrease blue	value
		bcs.s	.degreen				; branch if already 0
		cmp.w	d2,d1
		bcs.s	.degreen				; branch if blue already matched
		move.w	d1,(a0)+				; update blue
		rts
; ===========================================================================

.degreen:
		move.w	d3,d1
		subi.w	#$20,d1					; decrease green value
		bcs.s	.dered					; branch if already 0
		cmp.w	d2,d1
		bcs.s	.dered					; branch if green already matched
		move.w	d1,(a0)+				; update green
		rts
; ===========================================================================

.dered:
		subq.w	#2,(a0)+				; decrease red value
		rts
; ===========================================================================

.next:
		addq.w	#2,a0					; next color
		rts

; ---------------------------------------------------------------------------
; Subroutine to fade to white (Special Stage)

;	uses d0.l, d1.w, d2.w, d4.w, d5.l, d6.l, d7.w, a0, a1, a3
; ---------------------------------------------------------------------------

PaletteWhiteOut:
		move.w	#palfade_all,(v_palfade_start).w	; start position = 0; size = $40 ($3F)
		move.w	#(7*3),d4				; max number of color changes needed (000 to $EEE)

	.mainloop:
		move.b	#id_VBlank_Fade,(v_vblank_routine).w
		bsr.w	WaitForVBlank				; wait for frame to end
		bsr.s	WhiteOut_ToWhite			; update palette
		bsr.w	RunPLC					; decompress gfx if PLC contains anything
		dbf	d4,.mainloop
		rts
; ===========================================================================

WhiteOut_ToWhite:
		moveq	#0,d0
		lea	(v_pal_dry).w,a0			; current palette
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		move.b	(v_palfade_size).w,d0

	.addcolor:
		bsr.s	WhiteOut_AddColor			; raise RGB levels
		dbf	d0,.addcolor				; repeat for size of palette

	if FixBugs
		; Just for the sake of consistency: no need to do this if
		; if not a water level.
		tst.b	(f_water).w				; does level have water?
		beq.s	.exit					; if not, exit
	endc

		moveq	#0,d0
		lea	(v_pal_water).w,a0
		move.b	(v_palfade_start).w,d0
		adda.w	d0,a0
		move.b	(v_palfade_size).w,d0

	.addcolor_water:
		bsr.s	WhiteOut_AddColor			; raise RGB levels for underwater palette
		dbf	d0,.addcolor_water			; repeat for size of palette

	.exit:
		rts
; ===========================================================================

WhiteOut_AddColor:
.addred:
		move.w	(a0),d2					; d2 = current color
		cmpi.w	#cWhite,d2
		beq.s	.next					; branch if already white

		move.w	d2,d1
		andi.w	#$E,d1					; d1 = red value
		cmpi.w	#cRed,d1
		beq.s	.addgreen				; branch if max value
		addq.w	#2,(a0)+				; increase red value
		rts
; ===========================================================================

.addgreen:
		move.w	d2,d1
		andi.w	#$E0,d1					; d1 = green value
		cmpi.w	#cGreen,d1
		beq.s	.addblue				; branch if max value
		addi.w	#$20,(a0)+				; increase green value
		rts
; ===========================================================================

.addblue:
		move.w	d2,d1
		andi.w	#$E00,d1				; d1 = blue value
		cmpi.w	#cBlue,d1
		beq.s	.next					; branch if max value
		addi.w	#$200,(a0)+				; increase blue	value
		rts
; ===========================================================================

.next:
		addq.w	#2,a0					; next color
		rts

; ===========================================================================
; Unused Sonic 1 leftover: Sega Screen palette cycle routine and palettes
;PalCycle_Sega:
;PalCycle_Sega_Stripe:
		tst.b	(v_palcycle_time+1).w
		bne.s	PalCycle_Sega_Full			; branch if stripe animation is finished
		lea	(v_pal_dry_line2).w,a1			; address for 2nd palette line
		lea	(Pal_S1_Sega1).l,a0			; address of blue gradient palette source
		moveq	#6-1,d1					; 6-1
		move.w	(v_palcycle_num).w,d0			; d0 = -$A (initially)

	.loop_findcolor:
		bpl.s	.loop_colors				; branch if d0 = 0
		addq.w	#2,a0					; read next colour from source
		subq.w	#1,d1
		addq.w	#2,d0					; increment d0
		bra.s	.loop_findcolor				; repeat until d0 = 0
; ===========================================================================

.loop_colors:
		move.w	d0,d2					; d0 = position within target palette
		andi.w	#$1E,d2
		bne.s	.no_skip
		addq.w	#2,d0					; skip 1 colour if at the start of a line (1st colour is transparent)

	.no_skip:
		cmpi.w	#sizeof_pal*3,d0
		bcc.s	.end_of_pal				; branch if at the end of the palettes
		move.w	(a0)+,(a1,d0.w)				; copy 1 colour from source to target

	.end_of_pal:
		addq.w	#2,d0
		dbf	d1,.loop_colors

		move.w	(v_palcycle_num).w,d0
		addq.w	#2,d0					; increment counter
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	.no_skip2
		addq.w	#2,d0					; skip 1 colour if at the start of a line

	.no_skip2:
		cmpi.w	#(sizeof_pal*3)+4,d0
		blt.s	.not_at_end				; branch if not at the end
		move.w	#$401,(v_palcycle_time).w		; set timer to 4 and set flag f_sega_pal_next
		moveq	#-(($C/2)*2),d0				; -$C

	.not_at_end:
		move.w	d0,(v_palcycle_num).w
		moveq	#1,d0
		rts
; ===========================================================================

PalCycle_Sega_Full:
		subq.b	#1,(v_palcycle_time).w			; decrement timer
		bpl.s	.wait					; branch if time remains
		move.b	#4,(v_palcycle_time).w
		move.w	(v_palcycle_num).w,d0
		addi.w	#($C/2)*2,d0				; next batch of colours ($C)
		cmpi.w	#($C/2)*2*4,d0				; $30
		bcs.s	.update					; branch if animation is incomplete
		moveq	#0,d0					; set flag when animation is complete
		rts
; ===========================================================================

.update:
		move.w	d0,(v_palcycle_num).w			; update counter
		lea	(Pal_S1_Sega2).l,a0
		lea	(a0,d0.w),a0				; jump to source palette
		lea	(v_pal_dry_line1+(2*2)).w,a1		; start on first palette line, 3rd colour
		move.l	(a0)+,(a1)+
		move.l	(a0)+,(a1)+
		move.w	(a0)+,(a1)				; write 5 colours
		lea	(v_pal_dry_line2).w,a1
		moveq	#0,d0
		moveq	#((countof_color-1)*3)-1,d1		; colors in 3 lines (without transparent), minus 1 ($2C)

	.loop_fill:
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	.no_skip
		addq.w	#2,d0					; skip 1 colour if at the start of a line

	.no_skip:
		move.w	(a0),(a1,d0.w)				; write colour
		addq.w	#2,d0					; next colour
		dbf	d1,.loop_fill				; repeat for lines 2, 3, and 4 (ignoring transparent)

.wait:
		moveq	#1,d0					; set flag for incomplete animation
		rts
; ===========================================================================

		incfile	Pal_S1_Sega1
		incfile	Pal_S1_Sega2

; end of dead code/data

; ---------------------------------------------------------------------------
; Subroutine to load palette that will be used after fading in

; input:
;	d0 = index number for palette

;	uses d0, d7, a1, a2, a3
; ---------------------------------------------------------------------------

; sub_2712: PalLoad1: PalLoad_ForFade:
PalLoad_Next:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2				; get palette data address
		movea.w	(a1)+,a3				; get target RAM address
		adda.w	#v_pal_dry_next-v_pal_dry,a3		; jump to next palette RAM address
		move.w	(a1)+,d7				; get length of palette

	.loop:
		move.l	(a2)+,(a3)+				; move data to RAM
		dbf	d7,.loop
		rts

; ---------------------------------------------------------------------------
; Subroutine to load palette immediately

; input:
;	d0 = index number for palette

;	uses d0, d7, a1, a2, a3
; ---------------------------------------------------------------------------

; sub_272E: PalLoad2:
PalLoad_Now:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2				; get palette data address
		movea.w	(a1)+,a3				; get target RAM address
		move.w	(a1)+,d7				; get length of palette

	.loop:
		move.l	(a2)+,(a3)+				; move data to RAM
		dbf	d7,.loop
		rts

; ---------------------------------------------------------------------------
; Subroutines to load underwater palette immediately

; input:
;	d0 = index number for palette

;	uses d0, d7, a1, a2, a3
; ---------------------------------------------------------------------------

; sub_2746: PalLoad3_Water: PalLoad_Water_Now:
PalLoad_Water:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2				; get palette data address
		movea.w	(a1)+,a3				; get target RAM address
		suba.l	#v_pal_dry-v_pal_water,a3		; jump to underwater palette RAM address
		move.w	(a1)+,d7				; get length of palette

	.loop:
		move.l	(a2)+,(a3)+				; move data to RAM
		dbf	d7,.loop
		rts

; ---------------------------------------------------------------------------
; Subroutines to load underwater palette that will be used after fading in

; input:
;	d0 = index number for palette

;	uses d0, d7, a1, a2, a3
; ---------------------------------------------------------------------------

; sub_2764: PalLoad4_Water: PalLoad_Water_ForFade:
PalLoad_Water_Next:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2				; get palette data address
		movea.w	(a1)+,a3				; get target RAM address
		suba.l	#v_pal_dry-v_pal_water_next,a3		; jump to next underwater palette RAM address
		move.w	(a1)+,d7				; get length of palette

	.loop:
		move.l	(a2)+,(a3)+				; move data to RAM
		dbf	d7,.loop
		rts

;----------------------------------------------------------------------------
; Palette pointers
;----------------------------------------------------------------------------

palp:	macro paladdress,secondpaladdress,alias,ramaddress

	ifarg \alias
		id_\alias:	equ (*-PalPointers)/8		; create alternate ID constant for duplicate pointers (used in empty/unused level load table entries)
	else
		id_\paladdress:	equ (*-PalPointers)/8
	endc
		dc.l \paladdress

	ifarg \secondpaladdress
		dc.w \ramaddress,(sizeof_\paladdress\+sizeof_\secondpaladdress\)/4-1
	else
		dc.w \ramaddress,sizeof_\paladdress\/4-1
	endc
	endm


PalPointers:
		palp Pal_Sega,,,v_pal_dry_line1
		palp Pal_Title,,,v_pal_dry_line2
		palp Pal_MenuB,,,v_pal_dry_line1
		palp Pal_Sonic_Miles_BG1,Pal_Sonic_Miles_BG2,,v_pal_dry_line1

		palp Pal_EHZ,,,v_pal_dry_line2
		palp Pal_EHZ,,Pal_EHZ2,v_pal_dry_line2
		palp Pal_WZ,,,v_pal_dry_line2
		palp Pal_EHZ,,Pal_EHZ3,v_pal_dry_line2
		palp Pal_MTZ,,,v_pal_dry_line2
		palp Pal_MTZ,,Pal_MTZ2,v_pal_dry_line2
		palp Pal_WFZ,,,v_pal_dry_line2
		palp Pal_HTZ,,,v_pal_dry_line2
		palp Pal_HPZ,,,v_pal_dry_line2
		palp Pal_EHZ,,Pal_EHZ4,v_pal_dry_line2
		palp Pal_OOZ,,,v_pal_dry_line2
		palp Pal_MCZ,,,v_pal_dry_line2
		palp Pal_CNZ,,,v_pal_dry_line2
		palp Pal_CPZ,,,v_pal_dry_line2
		palp Pal_DEZ,,,v_pal_dry_line2
		palp Pal_ARZ,,,v_pal_dry_line2
		palp Pal_SCZ,,,v_pal_dry_line2

		palp Pal_HPZ_U,,,v_pal_dry_line1
		palp Pal_CPZ_U,,,v_pal_dry_line1
		palp Pal_ARZ_U,,,v_pal_dry_line1

		palp Pal_SS,,,v_pal_dry_line1
		palp Pal_MCZ_B,,,v_pal_dry_line2
		palp Pal_CNZ_B,,,v_pal_dry_line2
		palp Pal_SS1,,,v_pal_dry_line4
		palp Pal_SS2,,,v_pal_dry_line4
		palp Pal_SS3,,,v_pal_dry_line4
		palp Pal_SS4,,,v_pal_dry_line4
		palp Pal_SS5,,,v_pal_dry_line4
		palp Pal_SS6,,,v_pal_dry_line4
		palp Pal_SS7,,,v_pal_dry_line4

		palp Pal_SS1_2p,,,v_pal_dry_line4
		palp Pal_SS2_2p,,,v_pal_dry_line4
		palp Pal_SS3_2p,,,v_pal_dry_line4

		palp Pal_OOZ_B,,,v_pal_dry_line2
		palp Pal_Menu,,,v_pal_dry_line1
		palp Pal_Result,,,v_pal_dry_line1

		incfile	Pal_Sega
		incfile	Pal_Title
		incfile	Pal_MenuB
		incfile	Pal_Sonic_Miles_BG1
		incfile	Pal_Sonic_Miles_BG2
		incfile	Pal_EHZ
		incfile	Pal_WZ
		incfile	Pal_MTZ
		incfile	Pal_WFZ
		incfile	Pal_HTZ
		incfile	Pal_HPZ
		incfile	Pal_HPZ_U
		incfile	Pal_OOZ
		incfile	Pal_MCZ
		incfile	Pal_CNZ
		incfile	Pal_CPZ
		incfile	Pal_CPZ_U
		incfile	Pal_DEZ
		incfile	Pal_ARZ
		incfile	Pal_ARZ_U
		incfile	Pal_SCZ
		incfile	Pal_MCZ_B
		incfile	Pal_CNZ_B
		incfile	Pal_OOZ_B
		incfile	Pal_Menu
		incfile	Pal_SS
		incfile	Pal_SS1
		incfile	Pal_SS2
		incfile	Pal_SS3
		incfile	Pal_SS4
		incfile	Pal_SS5
		incfile	Pal_SS6
		incfile	Pal_SS7
		incfile	Pal_SS1_2p
		incfile	Pal_SS2_2p
		incfile	Pal_SS3_2p
		incfile	Pal_Result

; ===========================================================================

	if Revision<2
		nop
	endc

; ---------------------------------------------------------------------------
; Subroutine to	wait for VBlank routines to complete
; ---------------------------------------------------------------------------

WaitForVBlank:
		enable_ints

	.wait:
		tst.b	(v_vblank_routine).w			; has VBlank routine finished?
		bne.s	.wait					; if not, branch
		rts

; ---------------------------------------------------------------------------
; Subroutine to generate a pseudo-random number

; output:
;	d0 = pseudo-random number  (RNG & $FFFF0000) | ((RNG*41 & $FFFF) + ((RNG*41 & $FFFF0000) >> 16))
;	d1 = d0 with high/low words swapped
;	RNG = ((RNG*41 + ((RNG*41 & $FFFF) << 16)) & $FFFF0000) | (RNG*41 & $FFFF)
; ---------------------------------------------------------------------------
; sub_3390:
RandomNumber:
		move.l	(v_random).w,d1
		bne.s	.scramble				; if d1 is not 0, branch
		move.l	#$2A6D365A,d1				; if d1 is 0, use this seed number

	.scramble:
		; set the high word of d0 to be the high word of the RNG
		; and multiply the RNG by 41
		move.l	d1,d0
		asl.l	#2,d1
		add.l	d0,d1
		asl.l	#3,d1
		add.l	d0,d1

		; add the low word of the RNG to the high word of the RNG
		; and set the low word of d0 to be the result
		move.w	d1,d0
		swap	d1
		add.w	d1,d0
		move.w	d0,d1
		swap	d1

		move.l	d1,(v_random).w
		rts

; ---------------------------------------------------------------------------
; Subroutine to convert an angle (0 to $FF) to sine and cosine (-$100 to $100)

; input:
;	d0 = angle (360 degrees == 256)

; output:
;	d0 = sine
;	d1 = cosine
; ---------------------------------------------------------------------------

CalcSine:
		andi.w	#$FF,d0					; read low byte of angle only
		add.w	d0,d0
		addi.w	#$80,d0					; start 90 degrees later for cosine
		move.w	Sine_Data(pc,d0.w),d1			; get cosine
		subi.w	#$80,d0					; start at 0 for sine
		move.w	Sine_Data(pc,d0.w),d0			; get sine
		rts
; ===========================================================================

Sine_Data:	incbin "misc/Sine & Cosine Waves.bin"
			incbin "misc/Sine & Cosine Waves.bin",,$80 ; First $80 bytes are duplicated at the end of the table

; ---------------------------------------------------------------------------
; Subroutine to convert x/y distance to an angle

; input:
;	d1.w = x-axis distance
;	d2.w = y-axis distance

; output:
;	d0.w = angle

;	uses d0.l
; ---------------------------------------------------------------------------

CalcAngle:
		pushr.l	d3-d4
		moveq	#0,d3
		moveq	#0,d4
		move.w	d1,d3					; d3 = x distance
		move.w	d2,d4					; d4 = y distance
		or.w	d3,d4
		beq.s	CalcAngle_Both0				; branch if both are 0
		move.w	d2,d4
		tst.w	d3
		bpl.w	.x_positive				; branch if x is positive
		neg.w	d3					; force x positive

	.x_positive:
		tst.w	d4
		bpl.w	.y_positive				; branch if y is positive
		neg.w	d4					; force y positive

	.y_positive:
		cmp.w	d3,d4
		bcc.w	.y_larger				; branch if y is larger or same
		lsl.l	#8,d4
		divu.w	d3,d4					; d4 = (y*$100)/x
		moveq	#0,d0
		move.b	Angle_Data(pc,d4.w),d0
		bra.s	CalcAngle_ChkRotation
; ===========================================================================

	.y_larger:
		lsl.l	#8,d3
		divu.w	d4,d3
		moveq	#$40,d0					; d3 = (x*$100)/y
		sub.b	Angle_Data(pc,d3.w),d0

	CalcAngle_ChkRotation:
		tst.w	d1
		bpl.w	.x_positive				; branch if x is positive
		neg.w	d0
		addi.w	#$80,d0

	.x_positive:
		tst.w	d2
		bpl.w	.y_positive				; branch if x is positive
		neg.w	d0
		addi.w	#$100,d0

	.y_positive:
		popr.l	d3-d4
		rts
; ===========================================================================

CalcAngle_Both0:
		move.w	#$40,d0
		popr.l	d3-d4
		rts

Angle_Data:	incbin "misc/Angle Table.bin"

; ===========================================================================

	if Revision<2
		nop
	endc

; ===========================================================================

GM_Sega:

sega_bg_width:	equ $28
sega_bg_height:	equ $1C
;sega_fg_width:	equ $28						; fg dimensions - white box with logo cutout
;sega_fg_height:	equ $1C

		move.b	#cmd_Stop,d0
		bsr.w	PlayMusic				; stop music
		bsr.w	ClearPLC				; clear the PLC buffer
		bsr.w	PaletteFadeOut				; fade palette to black

		clear_ram misc_variables,misc_variables_end	; clear misc_variables block
		clear_ram ost,ost_end				; clear the OST

		; Configure the VDP for the Sega Screen.
		lea	(vdp_control_port).l,a6
		move.w	#vdp_md_color,(a6)
		move.w	#vdp_fg_nametable+(vram_sega_fg>>10),(a6) ; $8230 ; set fg nametable at $C000
		move.w	#vdp_bg_nametable+(vram_sega_bg>>13),(a6) ; $8405 ; set bg nametable at $A000
		move.w	#vdp_bg_color+0,(a6)			; BG color is Line 0 Color 0
		move.w	#vdp_full_vscroll|vdp_1px_hscroll,(a6)	; vscroll by screen, hscroll by line
		move.w	#vdp_320px_screen_width,(a6)		; H40 mode
		move.w	#vdp_plane_width_128|vdp_plane_height_32,(a6) ; 128x32 plane size
		clr.b	(f_water_pal_full).w
		clr.w	(f_two_player).w
		disable_ints
		disable_display
		bsr.w	ClearScreen				; clear VRAM nametables and sprite, vscroll, and hscroll buffers

		dma_fill	0,sizeof_vram_planetable_128x32,vram_sega_fg ; clear the FG table we just configured

		vdp_comm.l	move,vram_SEGA,vram,write,(vdp_control_port).l
		lea	(Nem_SEGA).l,a0				; load Sega logo patterns
		bsr.w	NemDec

		vdp_comm.l	move,vram_IntroTrails,vram,write,(vdp_control_port).l
		lea	(Nem_IntroTrails).l,a0			; load blue streaks
		bsr.w	NemDec

		; This gets overwritten by the upscaled Sonic sprite. This may have
		; been used to test the Sega screen before the sprite upscaling logic
		; was added.
		vdp_comm.l	move,vram_Giant_Sonic,vram,write,(vdp_control_port).l
		lea	(Nem_MechaSonic).l,a0			; load Mecha Sonic
		bsr.w	NemDec

		lea	(v_128x128_tiles).l,a1
		lea	(Eni_SEGA).l,a0				; load Sega logo mappings
		move.w	#vram_start,d0
		bsr.w	EniDec

		lea	(v_128x128_tiles).l,a1
		vdp_comm.l	move,vram_sega_bg,vram,write,d0
		moveq	#sega_bg_width-1,d1
		moveq	#sega_bg_height-1,d2
		bsr.w	TilemapToVRAM_128_Sega			; copy Sega logo mappings to VRAM

		tst.b	(v_console_region).w			; is this a Japanese Mega Drive or Korean Super Gam*Boy?
		bmi.s	.loadpal				; if so, branch

		lea	(v_ost_sega_hide_tm).w,a1		; load extra sprite to hide TM symbol
		move.b	#id_SegaHideTM,ost_id(a1)		; (slightly faster to do this with two absolute short moves instead)
		move.b	#$4E,ost_subtype(a1)

	.loadpal:
		moveq	#id_Pal_Sega,d0
		bsr.w	PalLoad_Now				; load sega logo palette
		move.w	#$FFF6,(v_palcycle_num).w
		move.w	#0,(v_palcycle_time).w
		move.w	#0,(v_segascr_vblank_sub).w
		move.w	#0,(f_segascr_paldone).w
		lea	(v_ost_sega_screen).w,a1
		move.b	#id_SonicSegaScreen,ost_id(a1)		; load Sega Screen Sonic object
		move.b	#$4C,ost_subtype(a1)
		move.w	#4*60,(v_countdown).w
		enable_display

	.waitpal:
		move.b	#id_VBlank_Sega,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		jsrto	ExecuteObjects,JmpTo_ExecuteObjects
		jsr	(BuildSprites).l
		tst.b	(f_segascr_paldone).w
		beq.s	.waitpal
	if FixBugs=0
		; This is a leftover from Sonic 1: SonicSegaScreen plays the Sega sound now.
		; Normally, you'll only hear one Sega sound, but the game actually tries
		; to play it twice. The only reason it doesn't is because the sound
		; queue only has room for one sound per frame. Some custom sound
		; drivers don't have this limitation, however, and the sound will
		; indeed play twice in those.
		move.b	#cmd_Sega,d0
		bsr.w	PlaySound
	endc
		move.b	#id_VBlank_Sega,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	#3*countof_ntsc_fps,(v_countdown).w	; 3 seconds

	.waitend:
		move.b	#id_VBlank_PCM,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		tst.w	(v_countdown).w				; is there time left?
		beq.s	.goto_title				; if not, go to title screen
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#btnStart,d0				; is start button pressed on either joypad?
		beq.s	.waitend				; if so, go to title screen

	.goto_title:
		clr.w	(f_segascr_paldone).w
		clr.w	(v_segascr_vblank_sub).w
		move.b	#id_Title,(v_gamemode).w		; go to Title Screen
		rts
; ===========================================================================

TilemapToVRAM_128_Sega:
		; Exactly identical to the one used for the Special Stages.
		lea	(vdp_data_port).l,a6
		move.l	#sizeof_vram_row_128<<16,d4		; d4 = $1000000

	.loop_row:
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; move d0 to vdp_control_port
		move.w	d1,d3

	.loop_cell:
		move.w	(a1)+,(a6)				; write value to nametable
		dbf	d3,.loop_cell				; next tile
		add.l	d4,d0					; goto next line
		dbf	d2,.loop_row				; next line
		rts

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_ExecuteObjects:
		jmp	(ExecuteObjects).l

		align 4
	endc

; ===========================================================================

GM_Title:
		move.b	#cmd_Stop,d0
		bsr.w	PlayMusic				; stop music
		bsr.w	ClearPLC				; clear the PLC quque
		bsr.w	PaletteFadeOut				; fade screen to black
		disable_ints

		; Configure the VDP for the Title Screen.
		lea	(vdp_control_port).l,a6
		move.w	#vdp_md_color,(a6)			; disable horizontal interrupts
		move.w	#vdp_fg_nametable+(vram_title_fg>>10),(a6) ; set FG nametable at $C000
		move.w	#vdp_bg_nametable+(vram_title_bg>>13),(a6) ; set BG nametable at $E000
		move.w	#vdp_plane_width_64|vdp_plane_height_32,(a6) ; 64x32 plane size
		move.w	#vdp_window_y_pos,(a6)			; disable window plane
		move.w	#vdp_full_vscroll|vdp_1px_hscroll,(a6)	; vscroll by screen. hscroll by line
		move.w	#vdp_bg_color+32,(a6)			; BG color is Line 2, Color 1
		clr.b	(f_water_pal_full).w
		move.w	#vdp_320px_screen_width,(a6)		; H40 mode

		bsr.w	ClearScreen				; clear VRAM nametables and sprite, vscroll, and hscroll buffers

		clear_ram	v_sprite_queue,v_sprite_queue_end
		clear_ram	ost,ost_end
		clear_ram	misc_variables,misc_variables_end
		clear_ram	camera_ram,camera_ram_end

		vdp_comm.l	move,vram_CreditsFont_Intro,vram,write,(vdp_control_port).l
		lea	(Nem_CreditsFont).l,a0			; load the credits font
		bsr.w	NemDec

		lea	(IntroText_Pointers).l,a1		; load the "SONIC AND MILES 'TAILS' PROWER IN" text
		jsr	(DisplayText).l

		clear_ram	palette_fade_buffer,palette_fade_buffer_end ; clear the palette fade buffer (filling it with black)
		moveq	#id_Pal_Sonic_Miles_BG1,d0		; load Sonic and Tails' palette
		bsr.w	PalLoad_Next
		bsr.w	PaletteFadeIn				; fade in, displaying the text that was just loaded

		disable_ints					; disable interrupts again, as PaletteFadeIn enabled then

		; load title screen assets while above text is displayed
		vdp_comm.l	move,vram_Title,vram,write,(vdp_control_port).l
		lea	(Nem_Title).l,a0
		bsr.w	NemDec

		vdp_comm.l	move,vram_TitleSprites,vram,write,(vdp_control_port).l
		lea	(Nem_TitleSprites).l,a0
		bsr.w	NemDec

		vdp_comm.l	move,vram_MenuJunk,vram,write,(vdp_control_port).l
		lea	(Nem_MenuJunk).l,a0
		bsr.w	NemDec

		vdp_comm.l	move,vram_Player1VS2,vram,write,(vdp_control_port).l
		lea	(Nem_Player1VS2).l,a0
		bsr.w	NemDec

		vdp_comm.l	move,vram_StandardFont_TtlScr,vram,write,(vdp_control_port).l
		lea	(Nem_StandardFont).l,a0
		bsr.w	NemDec

		; Clear some variables (could use a data register for this)
		move.b	#0,(v_last_lamppost).w
		move.b	#0,(v_last_lamppost_p2).w
		move.w	#0,(v_debug_active).w
		move.w	#0,(f_demo_mode).w
		move.w	#0,(v_unknown_titlescrn).w
		move.w	#0,(v_palcycle_time).w
		move.w	#0,(f_two_player).w
		move.b	#0,(f_level_started).w

		; fade out
		bsr.w	PaletteFadeOut

		disable_ints					; disable interrupts again, as PaletteFadeOut enabled them

		; load more title screen assets
		lea	(v_128x128_tiles).l,a1
		lea	(Eni_TitleScreen).l,a0			; title screen background mappings (sky/island)
		move.w	#(vram_Title/sizeof_cell)+tile_pal3,d0
		bsr.w	EniDec

		lea	(v_128x128_tiles).l,a1
		vdp_comm.l	move,vram_title_bg,vram,write,d0
		moveq	#40-1,d1
		moveq	#28-1,d2
		jsrto	TilemapToVRAM,TilemapToVRAM

		lea	(v_128x128_tiles).l,a1
		lea	(Eni_TitleBack).l,a0			; title screen background mappings (horizon/water)
		move.w	#(vram_Title/sizeof_cell)+tile_pal3,d0
		bsr.w	EniDec

		lea	(v_128x128_tiles).l,a1
		vdp_comm.l	move,(vram_title_bg+(2*40)),vram,write,d0 ; VRAM write starting at $E050 (Line 0 Column 40)
		moveq	#24-1,d1
		moveq	#28-1,d2
		jsrto	TilemapToVRAM,TilemapToVRAM

		lea	(v_128x128_tiles).l,a1
		lea	(Eni_TitleLogo).l,a0			; title screen logo mappings
		move.w	#(vram_Title*sizeof_cell)+tile_pal4+tile_hi,d0
		bsr.w	EniDec

		lea	(v_128x128_tiles+((sizeof_vram_row_64*16)+(2*44))).l,a1 ; add the copyright text to logo mappings at row 16, column 44
		lea	(CopyrightText).l,a2
		moveq	#((sizeof_CopyrightText)/2)-1,d6

	.load_copyright_text:
		move.w	(a2)+,(a1)+
		dbf	d6,.load_copyright_text

		lea	(v_128x128_tiles).l,a1
		vdp_comm.l	move,vram_title_fg,vram,write,d0
		moveq	#40-1,d1
		moveq	#28-1,d2
		jsrto	TilemapToVRAM,TilemapToVRAM

		clear_ram	palette_buffer,palette_fade_buffer_end ; clear the entire palette buffer

		moveq	#id_Pal_Title,d0			; load title screen palette
		bsr.w	PalLoad_Next

		; clear more variables
		move.b	#0,(f_debug_enable).w
		move.w	#0,(f_two_player).w

		move.w	#(10*countof_ntsc_fps)+40,(v_countdown).w ; time that the title screen lasts (640 frames)

		clr.w	(v_joypad_hold_actual).w		; clear input to prevent leftover input from skipping the intro

		move.b	#id_TitleIntro,(v_title_sonic+ost_id).w	; load TitleIntro object (manages the entire intro animation)
		move.b	#type_titlintr_sonic,(v_title_sonic+ost_subtype).w ; set to subtype 2

		jsr	(ExecuteObjects).l			; run for a frame to allow it to initialize
		jsr	(BuildSprites).l

		moveq	#id_PLC_Main,d0				; load standard PLCs
		bsr.w	NewPLC

		move.w	#0,(v_correct_cheat_entries).w		; reset cheat inputs
		move.w	#0,(v_correct_cheat_entries_2).w

		rept 6
		nop						; why?
		endr

		move.w	#4,(v_sonic_pos_tracker_num).w		; reset Sonic's position recording buffer
		move.w	#0,(v_sonic_pos_tracker).w

		lea	(v_ehz_results_2p).w,a1			; fill the 2P results data with 1's
		moveq	#((two_player_results_data_end-two_player_results_data)/2)-1,d0 ; $B

	.fill_2P_results:
		move.w	#-1,(a1)+
		dbf	d0,.fill_2P_results

		move.w	#-$280,(v_camera_x_pos).w		; initialize the camera
		enable_display
		bsr.w	PaletteFadeIn				; fade in the palette

Title_MainLoop:
		move.b	#id_VBlank_Title,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		jsr	(ExecuteObjects).l
		jsrto	Deform_TitleScreen,JmpTo_Deform_TitleScreen
		jsr	(BuildSprites).l

		; Find the masking sprite, and move it to the proper location. The
		; sprite is normally at X 128+128, but in order to perform masking,
		; it must be at X 0.
		; The masking sprite is used to stop Sonic and Tails from overlapping
		; the emblem.
		; You might be wondering why it alternates between 0 and 4 for the X
		; position. That's because masking sprites only work if another
		; sprite rendered before them (or if the previous scanline reached
		; its pixel limit). Because of this, a sprite is placed at X 4 before
		; a second one is placed at X 0.

		lea	(v_sprite_buffer+sprite_tile).w,a1
		moveq	#0,d0
		moveq	#((v_sprite_buffer_end-v_sprite_buffer)/8)-1,d6

	.findmask_loop:
		tst.w	(a1)					; the masking sprite has its art-tile set to $0000.
		bne.s	.not_mask				; if this isn't it, branch
		bchg	#2,d0					; alternate between X positions of 0 and 4
		move.w	d0,sprite_x_pos-sprite_tile(a1)

	.not_mask:
		addq.w	#sizeof_sprite,a1			; check the next entry in the sprite buffer
		dbf	d6,.findmask_loop

		bsr.w	RunPLC					; run PLCs
		bsr.w	TailsNameCheat				; check Miles/Tails name cheat

		tst.w	(v_countdown).w				; has counter hit 0?  (started at 640)
		beq.w	PlayDemo				; if so, branch

		tst.b	(v_title_sonic+ost_titlintr_complete).w	; is intro animation still playing?
		beq.w	Title_MainLoop				; if so, branch (don't want start button starting the game)

		move.b	(v_joypad_press_actual).w,d0		; get joypad states
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#btnStart,d0				; is start button pressed on either pad?
		beq.w	Title_MainLoop				; if not, branch

		; If start button was pressed, it's time to enter enter one player mode,
		; two player mode, or the options menu.
		move.b	#id_Level,(v_gamemode).w		; set game mode to $C (1P mode)

		move.b	#3,(v_lives).w				; set lives to 3
		move.b	#3,(v_lives_p2).w			; (both players)

		moveq	#0,d0
		move.w	d0,(v_rings).w				; clear rings
		move.l	d0,(v_time).w				; clear time
		move.l	d0,(v_score).w				; clear score
		move.w	d0,(v_rings_p2).w			; (both players for all three)
		move.l	d0,(v_time_p2).w
		move.l	d0,(v_score_p2).w
		move.b	d0,(v_continues).w			; clear continues

		move.l	#points_for_life,(v_score_next_life).w	; extra life is awarded at 50000 point
		move.l	#points_for_life,(v_score_next_life_p2).w ; (both players)

		move.b	#cmd_Fade,d0				; fade out music
		bsr.w	PlaySound

		moveq	#0,d0
		move.b	(v_title_screen_option).w,d0		; get title screen option selection

		bne.s	Title_ChkSelection			; if not a 1-player game, branch
		moveq	#0,d0
		move.w	d0,(f_two_player_mode_copy).w		; clear 2P mode flags
		move.w	d0,(f_two_player).w
		move.w	d0,(v_zone).w				; set level to Emerald Hill Act 1
		tst.b	(f_levelselect_cheat).w			; has level select cheat been entered?
		beq.s	.nocheat				; if not, branch
		btst	#bitA,(v_joypad_hold_actual).w		; is button A held?
		beq.s	.nocheat				; if not, branch
		move.b	#id_LevelSelectMenu,(v_gamemode).w	; set gamemode to $28 (Level Select Menu)
		rts
; ===========================================================================

	.nocheat:
		move.w	d0,(v_special_stage).w			; clear Special Stage index
		move.w	d0,(f_got_emerald).w			; clear got emerald flag
		move.l	d0,(v_emerald_list).w			; clear the emerald list
		move.l	d0,(v_emerald_list+4).w
		rts
; ===========================================================================

Title_ChkSelection:
		subq.b	#1,d0					; results in 0 if 2P was selected
		bne.s	.chose_options				; if Options was selected, branch

		moveq	#1,d1
		move.w	d1,(f_two_player_mode_copy).w		; set 2P mode flags
		move.w	d1,(f_two_player).w

		moveq	#0,d0
		move.w	d0,(f_got_emerald).w
		move.l	d0,(v_emerald_list).w			; clear got emerald flag
		move.l	d0,(v_emerald_list+4).w			; clear the emerald list
		move.b	#id_LevelSelectMenu2P,(v_gamemode).w	; set gamemode to $1C (2P Level Select)
		move.b	#0,(v_zone_2p).w			; clear 2P zone index
		rts
; ===========================================================================

	.chose_options:
		move.b	#id_OptionsMenu,(v_gamemode).w		; set gamemode to $24 (Options Menu)
		move.b	#0,(v_options_menu_box).w		; clear Options Menu selection
		rts
; ===========================================================================

PlayDemo:
		move.b	#cmd_Fade,d0				; fade out music
		bsr.w	PlaySound
		move.w	(v_demo_num).w,d0			; load demo number
		andi.w	#7,d0
		add.w	d0,d0
		move.w	DemoLevelArray(pc,d0.w),d0		; load level number for	demo
		move.w	d0,(v_zone).w
		addq.w	#1,(v_demo_num).w			; add 1 to demo number
		cmpi.w	#4,(v_demo_num).w			; is demo number less than 4?
		bcs.s	.demo_0_to_3				; if so, branch
		move.w	#0,(v_demo_num).w

	.demo_0_to_3:
		move.w	#1,(f_demo_mode).w			; set demo mode flag
		move.b	#id_Demo,(v_gamemode).w			; set gamemode to 8 (demo)
		cmpi.w	#id_EHZ,(v_zone).w			; is it is the EHZ demo?
		bne.s	demo_level				; if not, branch
		move.w	#1,(f_two_player).w			; set 2P mode flag for EHZ 2P demo

	demo_level:
		move.b	#lives_start,(v_lives).w		; set lives to 3
		move.b	#lives_start,(v_lives_p2).w		; (both players)
		moveq	#0,d0
		move.w	d0,(v_rings).w				; clear rings
		move.l	d0,(v_time).w				; clear time
		move.l	d0,(v_score).w				; clear score
		move.w	d0,(v_rings_p2).w			; (both players for all three)
		move.l	d0,(v_time_p2).w
		move.l	d0,(v_score_p2).w
		move.l	#points_for_life,(v_score_next_life).w
		move.l	#points_for_life,(v_score_next_life_p2).w
		rts
; ===========================================================================

DemoLevelArray:
		dc.w	id_EHZ_act1				; Emerald Hill Zone, Act 1
		dc.w	id_CPZ_act1				; Chemical Plant Zone, Act 1
		dc.w	id_ARZ_act1				; Aquatic Ruin Zone, Act 1
		dc.w	id_CNZ_act1				; Casino Night Zone, Act 1

; ===========================================================================

; sub_3DB4:
TailsNameCheat:
		; If entered successfully, flips console_region_bit between
		; Japan/Korea and international. This affects the presence of
		; trademark symbols, and causes Tails' name to swap between 'Tails' and 'Miles'.

		lea	(TailsNameCode).l,a0			; load cheat button array
		move.w	(v_correct_cheat_entries).w,d0		; get cheat entry counter
		adda.w	d0,a0					; add to address to get position in array
		move.b	(v_joypad_press_actual).w,d0		; get joypad press state
		andi.b	#btnUp|btnDn|btnL|btnR,d0		; only need D-pad presses
		beq.s	.exit					; if D-pad is not pressed, exit
		cmp.b	(a0),d0					; does currently pressed button match current button in array?
		bne.s	.clearcheatentries			; if not, reset cheat entries
		addq.w	#1,(v_correct_cheat_entries).w		; if it does, increment cheat entries
		tst.b	1(a0)					; is next entry the end of the array?
		bne.s	.exit					; if not, exit

	;.success:
		bchg	#console_region_bit,(v_console_region).w ; flip console region bit
		move.b	#sfx_Ring,d0				; play ring sound
		bsr.w	PlaySound

	.clearcheatentries:
		move.w	#0,(v_correct_cheat_entries).w		; clear cheat entry counter

	.exit:
		rts

TailsNameCode:
		dc.b	btnUp,btnDn,btnDn,btnDn,btnUp,0
		even
; ===========================================================================

		incfile	Nem_Player1VS2				; ArtNem_3DF4:

CopyrightText:
		charset	copyright,"@ 1992 SEGA"			; '@' = copyright symbol
		arraysize CopyrightText
; ===========================================================================

	if RemoveJmpTos=0
JmpTo_Deform_TitleScreen:
		jmp	(Deform_TitleScreen).l

		align 4
	endc

;----------------------------------------------------------------------------
; 1P music playlist
;----------------------------------------------------------------------------

MusicList:
		dc.b mus_EHZ					; EHZ
		dc.b mus_EHZ					; unused
		dc.b mus_MTZ					; unused
		dc.b mus_OOZ					; unused
		dc.b mus_MTZ					; MTZ Acts 1 and 2
		dc.b mus_MTZ					; MTZ Act 3
		dc.b mus_WFZ					; WFZ
		dc.b mus_HTZ					; HTZ
		dc.b mus_HPZ					; unused
		dc.b mus_SCZ					; unused
		dc.b mus_OOZ					; OOZ
		dc.b mus_MCZ					; MCZ
		dc.b mus_CNZ					; CNZ
		dc.b mus_CPZ					; CPZ
		dc.b mus_DEZ					; DEZ
		dc.b mus_ARZ					; ARZ
		dc.b mus_SCZ					; SCZ
		zonewarning MusicList,1
		even

;----------------------------------------------------------------------------
; 2P music playlist
;----------------------------------------------------------------------------

MusicList2:
		dc.b mus_EHZ_2P					; EHZ 2P
		dc.b mus_EHZ
		dc.b mus_MTZ
		dc.b mus_OOZ
		dc.b mus_MTZ
		dc.b mus_MTZ
		dc.b mus_WFZ
		dc.b mus_HTZ
		dc.b mus_HPZ
		dc.b mus_SCZ
		dc.b mus_OOZ
		dc.b mus_MCZ_2P					; MCZ 2P
		dc.b mus_CNZ_2P					; CNZ 2P
		dc.b mus_CPZ
		dc.b mus_DEZ
		dc.b mus_ARZ
		dc.b mus_SCZ
		zonewarning MusicList2,1
		even
; ===========================================================================

GM_Level:
		bset	#titlecard_flag_bit,(v_gamemode).w	; add $80 to gamemode (for pre level sequence)
		tst.w	(f_demo_mode).w				; is this an ending demo? (unused Sonic 1 leftover)
		bmi.s	.keep_music				; if by miracle it is, branch
		move.b	#cmd_Fade,d0				; fade out music
		bsr.w	PlaySound

	.keep_music:
		bsr.w	ClearPLC				; clear the PLC buffer
		bsr.w	PaletteFadeOut				; fade out from previous gamemode
		tst.w	(f_demo_mode).w				; is this an ending demo? (unused Sonic 1 leftover)
		bmi.s	.clear_ram				; if by miracle it is, branch
		disable_ints
		bsr.w	ClearScreen
		jsr	(LoadTitleCard).l			; load title card graphics
		enable_ints
		moveq	#0,d0
		move.w	d0,(v_frame_counter).w			; clear frame counter
		move.b	(v_zone).w,d0				; get current zone number

		add.w	d0,d0					; multiply by $12, the size of each level header, to get index
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0

		lea	(LevelHeaders).l,a2
		lea	(a2,d0.w),a2				; get the appropriate level header
		moveq	#0,d0
		move.b	(a2),d0					; get 1st PLC id for level
		beq.s	.no_plc					; if 0, branch
		bsr.w	AddPLC					; load the first PLC over the next few frames

	.no_plc:
		moveq	#id_PLC_Main2,d0
		bsr.w	AddPLC					; load starpost, monitor, power-up, shield, and invincibility star graphics

		bsr.w	Level_SetPlayerMode			; set 1P or 2P mode

		moveq	#id_PLC_Miles1Up,d0			; load Miles 1-Up graphics
		tst.w	(f_two_player).w			; is it 2P mode?
		bne.s	.chk_region				; if it is, branch

		cmpi.w	#tails_alone,(v_player_mode).w		; is it a Tails alone game?
		bne.s	.clear_ram				; if not, branch
		addq.w	#id_PLC_MilesLife-id_PLC_Miles1up,d0	; load Miles Life graphics

	.chk_region:
		tst.b	(v_console_region).w			; is console Japanese/Korean?
		bpl.s	.notJPKR				; if not, branch
		addq.w	#id_PLC_Tails1Up-id_PLC_Miles1up,d0	; load the Tails version of either the 1-Up or Life graphics

	.notJPKR:
	 	bsr.w	AddPLC					; add to PLC queue

	; Level_ClrRam:
	.clear_ram:
		clear_ram	v_sprite_queue,v_sprite_queue_end ; clear the sprite buffer
		clear_ram	ost,ost_level_only_end		; clear all object RAM
		clear_ram	misc_level_variables,misc_level_variables_end ; clear two large blocks of variables
		clear_ram	misc_variables,misc_variables_end
		clear_ram	synctables,synctables_end	; clear oscillating number tables and synchronized animation counters

	if FixBugs
		clear_ram	v_cnz_saucer_data,v_cnz_saucer_data_end ; clear the CNZ saucer bumper data
	else
		; The '+C0' shouldn't be here; v_cnz_saucer_data is only $40 bytes, not $100
		clear_ram	v_cnz_saucer_data,v_cnz_saucer_data_end+$C0 ; clear the CNZ saucer bumper data, plus $C0 unused bytes beyond
	endc

		cmpi.w	#id_CPZ_act2,(v_zone).w			; is it CPZ Act 2?
		beq.s	.init_water				; if so, branch
		cmpi.b	#id_ARZ,(v_zone).w			; is it ARZ?
		beq.s	.init_water				; if so, branch
		cmpi.b	#id_HPZ,(v_zone).w			; is it HPZ? (unused)
		bne.s	.level_vdp_setup			; if not, branch

	; Level_InitWater:
	.init_water:
		move.b	#1,(f_water).w				; set water flag
		move.w	#0,(f_two_player).w

	.level_vdp_setup:
		; Configure the VDP for normal gameplay.
		lea	(vdp_control_port).l,a6
		move.w	#vdp_full_vscroll|vdp_1px_hscroll,(a6)	; full screen vertical scrolling and single pixel horizontal scrolling
		move.w	#vdp_fg_nametable+(vram_fg>>10),(a6)	; foreground nametable at $C000
		move.w	#vdp_bg_nametable+(vram_bg>>13),(a6)	; background nametable at $E000
		move.w	#vdp_sprite_table+(vram_sprites>>9),(a6) ; sprite attribute table at $F800
		move.w	#vdp_plane_width_64|vdp_plane_height_32,(a6) ; 64x32 cell plane size
		move.w	#vdp_md_color,(a6)			; normal color mode, horizontal interrupts disabled
		move.w	#vdp_bg_color+32,(a6)			; BG color is Line 2, Color 1
		move.w	#vdp_320px_screen_width,(a6)		; H40 mode, no interlace

		tst.b	(f_debug_cheat).w			; is debug cheat enabled?
		beq.s	.no_debug				; if not, branch
		btst	#bitC,(v_joypad_hold_actual).w		; is button C being held?
		beq.s	.c_not_held				; if not, branch
		move.w	#vdp_320px_screen_width|vdp_shadow_highlight,(a6) ; H40 mode, no interlace, shadow/highlight enabled

	.c_not_held:
		btst	#bitA,(v_joypad_hold_actual).w		; is button A being held?
		beq.s	.no_debug				; if not, branch
		move.b	#1,(f_debug_enable).w			; enable debug mode

	.no_debug:
		move.w	#vdp_hint_counter+(screen_height-1),(v_vdp_hint_counter).w ; horizontal interrupt every 224th scanline (changed appropriately with water level)
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not_2P					; if not, branch

	;.2P_vdp_setup:
		; Configure VDP for 2P mode.
		move.w	#vdp_hint_counter+(((screen_height/2)-4)-1),(v_vdp_hint_counter).w ; horizontal interrupt every 108th scanline, providing 4 scanlines for HBlank to switch to drawing player 2's half of screen
		move.w	#vdp_md_color|vdp_enable_hint,(a6)	; normal color mode, horizontal interrupts enabled
		move.w	#vdp_320px_screen_width|vdp_interlace_x2,(a6) ; H40 mode, double height interlace

	.not_2P:
		move.w	(v_vdp_hint_counter).w,(a6)
		reset_dma_queue					; clear and reset the DMA queue
		tst.b	(f_water).w				; does level have water?
		beq.s	.skip_water				; if not, branch
	if FixBugs=0
		; Enabling horizontal interrupts here causes HBlank to run during level load. This IS
		; required for 2P mode init, but on water levels this triggers a race condition in DrawRow
		; (which is run as part of DrawTilesAtStart). DrawRow disables interrupts in order to write
		; to VRAM, but the timings are such that the end of a frame is reached while interrupts are
		; disabled. Normally this would cause HBlank and VBlank to be run in that order, but with
		; interrupts disabled, they are queued and processed after interrupts are reenabled.
		; As VBlank has a higher priority than HBlank, it gets run first, ultimately causing the
		; title card to be drawn with the level's water palette for a single frame.

		; This is actually fairly simple to work around: simply delay enabling horizontal interrupts
		; until we are ready to slide away the title card.
		move.w	#vdp_md_color|vdp_enable_hint,(a6)	; normal color mode, horizontal interrupts enabled
	endc
		moveq	#0,d0
		move.w	(v_zone).w,d0				; current zone and act
		subi.w	#id_HPZ_act1,d0
		ror.b	#1,d0
		lsr.w	#6,d0
		andi.w	#$FFFE,d0				; make index
		lea	(WaterHeight).l,a1			; load water height array
		move.w	(a1,d0.w),d0
		move.w	d0,(v_water_height_actual).w		; set water heights
		move.w	d0,(v_water_height_normal).w
		move.w	d0,(v_water_height_next).w
		clr.b	(v_water_routine).w			; clear water routine counter
		clr.b	(f_water_pal_full).w			; clear water state
		move.b	#1,(v_water_direction).w		; enable water

	;Level_LoadPal:
	.skip_water:
		moveq	#id_Pal_Sonic_Miles_BG1,d0
		bsr.w	PalLoad_Now				; load Sonic and Tails' palette
		tst.b	(f_water).w				; does level have water?
		beq.s	.set_bgm				; if not, branch

		moveq	#id_Pal_HPZ_U,d0
		cmpi.b	#id_HPZ,(v_zone).w			; is it HPZ? (unused)
		beq.s	.load_waterpal				; if so, branch
		moveq	#id_Pal_CPZ_U,d0
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		beq.s	.load_waterpal				; if so, branch
		moveq	#id_Pal_ARZ_U,d0			; else, it's ARZ

	; Level_WaterPal:
	.load_waterpal:
		bsr.w	PalLoad_Water				; load the appropriate water palette
		tst.b	(v_last_lamppost).w			; are we starting from a star post?
		beq.s	.set_bgm				; if not, branch
		move.b	(f_water_pal_full_lampcopy).w,(f_water_pal_full).w ; retrieve flag for whole screen being underwater

	; Level_GetBgm:
	.set_bgm:
		tst.w	(f_demo_mode).w				; is this an ending demo? (unused Sonic 1 leftover)
		bmi.s	Level_Skip_TtlCard			; if by miracle it is, branch
		moveq	#0,d0
		move.b	(v_zone).w,d0				; get current zone
		lea_	MusicList,a1				; load 1P music playlist
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not_2P_music				; if not, branch
		lea_	MusicList2,a1				; use 2P mode playlist

	; Level_PlayBgm:
	.not_2P_music:
		move.b	(a1,d0.w),d0				; get entry from playlist
		move.w	d0,(v_level_music).w
		bsr.w	PlayMusic				; play the appropriate music
		move.b	#id_TitleCard,(v_ost_titlecard+ost_id).w ; load title card object

; Level_TtlCard
Level_TtlCardLoop:
		move.b	#id_VBlank_TitleCard,(v_vblank_routine).w ; run title card VBlank routine
		bsr.w	WaitForVBlank
		jsr	(ExecuteObjects).l			; run the title card objects
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		move.w	(v_ost_titlecard_zonename+ost_x_pos).w,d0
		cmp.w	(v_ost_titlecard_zonename+ost_card_x_stop).w,d0 ; has title card sequence finished?
		bne.s	Level_TtlCardLoop			; if not, branch
		tst.l	(v_plc_buffer).w			; are there any items in the pattern load cue?
		bne.s	Level_TtlCardLoop			; if yes, branch
		move.b	#id_VBlank_TitleCard,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		jsr	(HUD_Base).l				; load HUD 'E', 0, and colon graphics

	Level_Skip_TtlCard:
		moveq	#id_Pal_Sonic_Miles_BG1,d0
		bsr.w	PalLoad_Next				; load Sonic and Tails' palette for fading in
		bsr.w	LevelParameterLoad			; load level boundaries, set Sonic's start position, and clear all scroll, redraw, and screen shaking flags
		jsrto	DeformLayers,JmpTo_DeformLayers		; initialize camera, background scrolling, and DLE (including the CNZ slot machines)
		clr.w	(v_fg_y_pos_vsram).w
		move.w	#$FF20,(v_fg_y_pos_vsram_p2).w		; -224

		clear_ram	hscroll,hscroll_end		; clear the h-scroll buffer

		bsr.w	LevelArtLoad				; load level art
		jsrto	LevelBlockMapsLoad,JmpTo_LevelBlockMapsLoad ; load 16x16 block and 128x128 chunk mappings and secondary level PLC
		jsr	(AnimatedBlocksLoad).l			; load animated 16x16 blocks and HTZ's distant background cliffs if applicable
		jsrto DrawTilesAtStart,JmpTo_DrawTilesAtStart	; draw the initial background state
		jsr	(ConvertCollisionArray).l		; unused development leftover
		bsr.w	SetColIndexPtr				; load collision data
		bsr.w	WaterFeatures				; initialize water if applicable
		bsr.w	InitPlayers				; load player objects

		move.w	#0,(v_joypad_hold).w			; clear joypad states
		move.w	#0,(v_joypad2_hold).w
		move.w	#0,(v_joypad_hold_actual).w
		move.w	#0,(v_joypad2_hold_actual).w
		move.b	#1,(f_lock_controls).w			; set control lock flags
		move.b	#1,(f_lock_controls_p2).w
		move.b	#0,(f_level_started).w			; clear level start flag

	;.load_reserved_level_objs:
		tst.b	(f_water).w				; does level have water?
		beq.s	.skip_water_surface			; if not, branch
		move.b	#id_WaterSurface,(v_ost_watersurface1).w ; load water surface objects
		move.w	#$60,(v_ost_watersurface1+ost_x_pos).w	; horizontal offset
		move.b	#id_WaterSurface,(v_ost_watersurface2).w
		move.w	#$120,(v_ost_watersurface2+ost_x_pos).w

	.skip_water_surface:
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		bne.s	.not_CPZ				; if not, branch
		move.b	#id_Pylon,(v_ost_cpzpylon).w		; load CPZ foreground pylon

	.not_CPZ:
		cmpi.b	#id_OOZ,(v_zone).w			; is it OOZ?
		bne.s	.no_reserved_level_objs			; if not, bramch
		move.b	#id_Oil,(v_ost_oil).w			; load the namesake oil ocean

	.no_reserved_level_objs:
		moveq	#0,d0
		tst.b	(v_last_lamppost).w			; are we starting from a starpost?
		bne.s	.skip_clear				; if so, branch
		move.w	d0,(v_rings).w				; clear rings
		move.l	d0,(v_time).w				; clear time
		move.b	d0,(v_ring_reward).w			; clear extra life flags
		move.w	d0,(v_rings_p2).w			; (both players)
		move.l	d0,(v_time_p2).w
		move.b	d0,(v_ring_reward_p2).w

	.skip_clear:
		move.b	d0,(f_time_over).w			; clear time over flags
		move.b	d0,(f_time_over_p2).w			; (both players)
		move.b	d0,(v_slot_routine).w			; clear CNZ slot machine routine counter
		move.w	d0,(f_slot_use).w			; clear CNZ slot machine use flag
		move.w	d0,(v_debug_active).w			; clear debug placement mode flag

		move.w	d0,(f_restart).w			; clear restart flag
		move.b	d0,(v_teleport_timer).w			; clear teleport timer
		move.b	d0,(f_teleport).w			; clear teleport flag
		move.w	d0,(v_rings_collected_p1).w		; clear 2P mode ring and monitor tallies
		move.w	d0,(v_rings_collected_p2).w
		move.w	d0,(v_monitors_broken_p1).w
		move.w	d0,(v_monitors_broken_p2).w
		move.w	d0,(v_loser_time_left).w		; clear 2P mode loser timer
		bsr.w	OscillateNumInit			; initialize oscillating numbers
		move.b	#1,(f_hud_score_update).w		; set all HUD update flags
		move.b	#1,(v_hud_rings_update).w
		move.b	#1,(f_hud_time_update).w
		move.b	#1,(f_hud_time_update_p2).w

		jsr	(ObjPosLoad).l				; load initial level objects
		jsr	(RingsManager).l			; initialize the rings manager and load rings
	if FixBugs
		; The main level loop does this, so why didn't they do the same here?
		cmpi.b	#id_CNZ,(v_zone).w			; is it CNZ?
		bne.s	.notCNZ					; branch if not
		jsr	(SpecialCNZBumpers).l			; initialize the CNZ bumpers if applicable

	.notCNZ:
	else
		jsr	(SpecialCNZBumpers).l			; initialize the CNZ bumpers
	endc
		jsr	(ExecuteObjects).l			; run all objects for one frame to initialize
		jsr	(BuildSprites).l			; render the objects
		jsrto	AnimateLevelGFX,JmpTo_AnimateLevelGFX	; initialize animated level graphics
		bsr.w	SetLevelEndType				; set f_has_signpost according to level/act
		move.w	#0,(v_demo_input_counter).w
		move.w	#0,(v_demo_input_counter_p2).w

		lea	(DemoDataPtr).l,a1			; address of pointers to demo data
		moveq	#0,d0
		move.b	(v_zone).w,d0				; get zone number
		lsl.w	#2,d0					; multiply by 4
		movea.l	(a1,d0.w),a1				; jump to demo data for that zone
		tst.w	(f_demo_mode).w				; is this an ending demo? (unused Sonic 1 leftover)
		bpl.s	.skip_endingdemo			; if not (and it never will be), branch
		lea	(DemoEndDataPtr).l,a1			; if by miracle we made it here, use ending demo data instead
		move.w	(v_s1_ending_demo_num).w,d0
		subq.w	#1,d0
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1				; jump to non-existent ending demo data

	.skip_endingdemo:
		move.b	1(a1),(v_demo_input_time).w		; load button press duration
		tst.b	(v_zone).w				; is it the EHZ demo?
		bne.s	.not_EHZ_demo				; if not, branch
		lea	(Demo_EHZ_P2).l,a1			; Tails' demo script for EHZ
		move.b	1(a1),(v_demo_input_time_p2).w		; load button press duration

	.not_EHZ_demo:
		move.w	#(27*countof_ntsc_fps)+20,(v_countdown).w ; run demo for a little over 27 seconds
		tst.w	(f_demo_mode).w				; is this an ending demo?  (unused Sonic 1 leftover)
		bpl.s	.not_endingdemo				; if not, branch
		move.w	#9*countof_ntsc_fps,(v_countdown).w	; run ending demo for 9 seconds
		cmpi.w	#4,(v_s1_ending_demo_num).w		; is it the SLZ ending demo?
		bne.s	.not_endingdemo				; if not branch
		move.w	#(8*countof_ntsc_fps)+30,(v_countdown).w ; the SLZ ending demo in Sonic 1 only ran for 8.5 seconds

	.not_endingdemo:
		tst.b	(f_water).w				; is this a water level?
		beq.s	.nowater				; if not, branch
		moveq	#id_Pal_HPZ_U,d0			; HPZ's underwater palette
		cmpi.b	#id_HPZ,(v_zone).w			; is it HPZ?
		beq.s	.gotunderwaterpal			; if it is (and it never will be), branch
		moveq	#id_Pal_CPZ_U,d0			; CPZ's underwater palette
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		beq.s	.gotunderwaterpal			; if it is, branch
		moveq	#id_Pal_ARZ_U,d0			; ARZ's underwater palette

	.gotunderwaterpal:
		bsr.w	PalLoad_Water_Next			; load water palette that'll be shown after fading in
	if FixBugs
		; If this is a water level, enable horizontal interrupts here to prevent the title card from being
		; drawn with the water palette. See the bugfix at GM_Level.not_2P for more information.
		move.w	#vdp_md_color|vdp_enable_hint,(vdp_control_port).l ; normal color mode, horizontal interrupts enabled
	endc

	.nowater:
		move.w	#-1,(v_ost_titlecard_zonename+ost_card_leaveflag).w
		move.b	#id_Card_LeftOut,(v_ost_titlecard_left+ost_primary_routine).w ; set title card background to move offscreen
		move.w	#$A,(v_ost_titlecard_left+ost_card_location).w

	.titlecardloop:
		move.b	#id_VBlank_TitleCard,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		tst.b	(v_ost_titlecard_background+ost_id).w	; is titlecard background still loaded?
		bne.s	.titlecardloop				; if so, loop

		lea	(v_ost_titlecard_zonename).w,a1
		move.b	#id_Card_WaitAndGoAway,ost_primary_routine(a1) ; set title card zone name to move offscreen
		move.w	#$2D,ost_anim_time(a1)
		move.b	#id_Card_WaitAndGoAway,v_ost_titlecard_zone-v_ost_titlecard_zonename+ost_primary_routine(a1) ; set title card "zone" to move offscreen
		move.w	#$2D,v_ost_titlecard_zone-v_ost_titlecard_zonename+ost_anim_time(a1)

		tst.b	v_ost_titlecard_actnumber-v_ost_titlecard_zonename+ost_id(a1) ; was the act number loaded?
		beq.s	.no_act_num				; if not, branch

		move.b	#id_Card_WaitAndGoAway,v_ost_titlecard_actnumber-v_ost_titlecard_zonename+ost_primary_routine(a1) ; set act number to move offscreen
		move.w	#$2D,v_ost_titlecard_actnumber-v_ost_titlecard_zonename+ost_anim_time(a1)

	.no_act_num:
		move.b	#0,(f_lock_controls).w			; clear control lock flags
		move.b	#0,(f_lock_controls_p2).w
		move.b	#1,(f_level_started).w			; set level started flag

		bclr	#titlecard_flag_bit,(v_gamemode).w	; subtract $80 from gamemode to end pre-level stuff

; ---------------------------------------------------------------------------
; Main level loop (when	all title card and loading sequences are finished)
; ---------------------------------------------------------------------------

Level_MainLoop:
		bsr.w	PauseGame				; check for pause (enters another loop if paused)
		move.b	#id_VBlank_Level,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		addq.w	#1,(v_frame_counter).w			; increment level timer
		bsr.w	MovePlayersInDemo			; move players if this is a demo
		bsr.w	WaterFeatures				; manage water levels, oil slides, and wind tunnels if required
		jsr	(ExecuteObjects).l			; run all objects except rings
		tst.w	(f_restart).w				; is level restart flag set?
		bne.w	GM_Level				; if yes, branch
		jsrto	DeformLayers,JmpTo_DeformLayers		; run background scrolling and update camera
		bsr.w	UpdateWaterSurface			; update water surface if necessary
		jsr	(RingsManager).l			; run rings that are part of layout (debug mode placed rings are handled as individual objects)
		cmpi.b	#id_CNZ,(v_zone).w			; is it CNZ?
		bne.s	.notCNZ					; if not, branch
		jsr	(SpecialCNZBumpers).l			; run the special CNZ bumpers

	.notCNZ:
		jsrto	AnimateLevelGFX,JmpTo_AnimateLevelGFX	; run dynamic BG/FG animations (EHZ/HT flowers, HTZ clouds and distant background mountains, MTZ rotating cylinders, etc.)
		bsr.w	PaletteCycle				; run all palette cycling
		bsr.w	RunPLC					; load any graphics listed in PLC buffer
		bsr.w	OscillateNumDo				; update oscillatory values for objects
		bsr.w	SynchroAnimate				; update values for synchronised object animations (rings are the only ones)
		bsr.w	SignpostArtLoad				; check for level end, and load signpost graphics if needed
		jsr	(BuildSprites).l			; build the sprite table
		jsr	(ObjPosLoad).l				; load objects/update the OST
		cmpi.b	#id_Demo,(v_gamemode).w			; is it demo mode?
		beq.s	Level_Demo				; if so, branch
		cmpi.b	#id_Level,(v_gamemode).w		; is gamemode still Level?
		beq.w	Level_MainLoop				; if so, loop
		rts
; ===========================================================================

Level_Demo:
		tst.w	(f_restart).w				; is level set to restart?
		bne.s	.end_of_demo				; if so, branch
		tst.w	(v_countdown).w				; is there time left on the demo?
		beq.s	.end_of_demo				; if not, branch
		cmpi.b	#id_Demo,(v_gamemode).w			; is gamemode still demo?
		beq.w	Level_MainLoop				; if so, loop
		move.b	#id_Sega,(v_gamemode).w			; go to Sega screen
		rts
; ===========================================================================

	.end_of_demo:
		cmpi.b	#id_Demo,(v_gamemode).w			; is gamemode still 8 (demo)?
		bne.s	.fade_out				; if not, branch
		move.b	#id_Sega,(v_gamemode).w			; go to Sega screen

	.fade_out:
		move.w	#60,(v_countdown).w			; set timer to 1 second
		move.w	#palfade_all,(v_palfade_start).w	; fade out all four palette lines
		clr.w	(v_palfade_time).w

	.fade_loop:
		move.b	#id_VBlank_Level,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		bsr.w	MovePlayersInDemo			; continue running objects while fading out
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		jsr	(ObjPosLoad).l
		subq.w	#1,(v_palfade_time).w			; decrement time until next palette update
		bpl.s	.wait					; branch if positive
		move.w	#2,(v_palfade_time).w			; set timer to 2 frames
		bsr.w	FadeOut_ToBlack				; update palette

	.wait:
		tst.w	(v_countdown).w				; has main timer reached zero?
		bne.s	.fade_loop				; if not, loop
		rts

; ---------------------------------------------------------------------------
; Subroutine to set the player mode, which is forced to Sonic and Tails in
; demos and in 2P mode
; ---------------------------------------------------------------------------

Level_SetPlayerMode:
		cmpi.b	#titlecard_flag|id_Demo,(v_gamemode).w	; is it a demo?
		beq.s	.demo_or_2P				; if so, branch
		tst.w	(f_two_player).w			; is it two-player mode?
		bne.s	.demo_or_2P				; if so, branch
		move.w	(v_player_option).w,(v_player_mode).w	; use the option chosen in the Options screen
		rts

	.demo_or_2P:
		move.w	#sonic_tails,(v_player_mode).w		; force Sonic and Tails
		rts

; ---------------------------------------------------------------------------
; Subroutine to load the appropriate player objects
; ---------------------------------------------------------------------------

InitPlayers:
		move.w	(v_player_mode).w,d0			; is it a Sonic and Tails game?
		bne.s	InitPlayers_Alone			; if not, branch

		move.b	#id_SonicPlayer,(v_ost_player1+ost_id).w ; load Sonic
		move.b	#id_Splash_SpindashDust,(v_ost_lo_sonic_dust+ost_id).w ; load Sonic's spindash dust

		cmpi.b	#id_WFZ,(v_zone).w
		beq.s	.exit					; skip loading Tails if this is WFZ...
		cmpi.b	#id_DEZ,(v_zone).w
		beq.s	.exit					; ...or DEZ...
		cmpi.b	#id_SCZ,(v_zone).w
		beq.s	.exit					; ...or SCZ

		move.b	#id_TailsPlayer,(v_ost_player2+ost_id).w ; load Tails
		move.w	(v_ost_player1+ost_x_pos).w,(v_ost_player2+ost_x_pos).w ; copy start position from Sonic's OST to Tails' (this was previously set by LevelParameterLoad)
		move.w	(v_ost_player1+ost_y_pos).w,(v_ost_player2+ost_y_pos).w

		subi.w	#$20,(v_ost_player2+ost_x_pos).w	; Tails starts 32 pixels behind Sonic
		addi_.w	#4,(v_ost_player2+ost_y_pos).w		; Tails is 4 pixels shorter than Sonic
		move.b	#id_Splash_SpindashDust,(v_ost_lo_tails_dust+ost_id).w ; load Tails' spindash dust

	.exit:
		rts
; ===========================================================================

InitPlayers_Alone:
		subq.w	#1,d0
		bne.s	.tails_alone				; branch if Tails alone
		move.b	#id_SonicPlayer,(v_ost_player1+ost_id).w ; load Sonic
		move.b	#id_Splash_SpindashDust,(v_ost_lo_sonic_dust+ost_id).w ; load Sonic's spindash dust
		rts
; ===========================================================================

.tails_alone:
		move.b	#id_TailsPlayer,(v_ost_player1+ost_id).w ; load Tails in main character slot
		move.b	#id_Splash_SpindashDust,(v_ost_lo_tails_dust+ost_id).w ; load Tails' spindash dust
		addi_.w	#4,(v_ost_player1+ost_y_pos).w		; Tails is 4 pixels shorter than Sonic
		rts

; ---------------------------------------------------------------------------
; Subroutine to move the water or oil surface sprites to where the screen is at
; (first part is fairly similar to Sonic 1's Surf_Action)

;	uses d0.w, d1.w
; ---------------------------------------------------------------------------

UpdateWaterSurface:
		tst.b	(f_water).w				; does level have water or oil?
		beq.s	.exit					; if not, exit
		move.w	(v_camera_x_pos).w,d1			; get camera x position
	if FixBugs
		; This function can cause the water surface's to be cut off at the
		; left when the game is paused. This is because this function pushes
		; the water surface sprite to the right every frame. To fix this,
		; just avoid pushing the sprite to the right when the game is about
		; to be paused.
		moveq	#0,d0
		move.b	(v_joypad_press_actual).w,d0		; get joypad state
		or.b	(v_joypad2_press_actual).w,d0		; both players
		andi.b	#btnStart,d0				; is game about to pause?
		bne.s	.even					; skip the flicker if so
	endc
		btst	#0,(v_frame_counter+1).w		; is it an even frame?
		beq.s	.even					; if it is, branch
		addi.w	#$20,d1					; add $20 every other frame to create flicker

	.even:
		move.w	d1,d0
		addi.w	#$60,d0
		move.w	d0,(v_ost_watersurface1+ost_x_pos).w	; set x position of water surface objects
		addi.w	#$120,d1
		move.w	d1,(v_ost_watersurface2+ost_x_pos).w	; (both of them)

	.exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to run special water effects in CPZ and ARZ, oil slides in OOZ,
; and wind tunnels in WFZ

;	uses d0.l, d1.l, d2.w, a1, a2
; ---------------------------------------------------------------------------

WaterFeatures:
		tst.b	(f_water).w				; does level have water or oil?
		beq.s	.nowater				; if not, branch
		tst.b	(f_disable_scrolling).w			; is Hscroll disabled?
		bne.s	.set_height				; if so, branch
		cmpi.b	#id_Sonic_Death,(v_ost_player1+ost_primary_routine).w ; has main character just died?
		bcc.s	.set_height				; if so, skip other effects
		bsr.w	DynamicWater				; run dynamic water (only used by CPZ 2)

	.set_height:
		clr.b	(f_water_pal_full).w
		moveq	#0,d0
		cmpi.b	#id_ARZ,(v_zone).w			; is it ARZ?
		beq.s	.notARZ					; if so, branch
		move.b	(v_oscillating_0_to_20).w,d0		; get oscillating value
		lsr.w	#1,d0

	.notARZ:
		add.w	(v_water_height_normal).w,d0		; add to normal water height
		move.w	d0,(v_water_height_actual).w		; set actual water height
		move.w	(v_water_height_actual).w,d0
		sub.w	(v_camera_y_pos).w,d0			; calculate distance between water surface and top of screen
		bcc.s	.isbelow				; if below top of screen, branch
		tst.w	d0
		bpl.s	.isbelow

		move.b	#screen_height-1,(v_vdp_hint_line).w	; HBlank runs at bottom of screen (redundant, as it is set again below)
		move.b	#1,(f_water_pal_full).w			; screen is entirely underwater

	.isbelow:
		cmpi.w	#screen_height-1,d0			; is water within 223 pixels of top of screen?
		bcs.s	.isvisible				; if so, branch
		move.w	#screen_height-1,d0			; HBlank runs at bottom of screen (but why not just disable it instead?)

	.isvisible:
		move.b	d0,(v_vdp_hint_line).w			; HBlank runs at water level on screen

.nowater:
		cmpi.b	#id_OOZ,(v_zone).w			; is it OOZ?
		bne.s	.notOOZ					; if not, branch
		bsr.w	OilSlides				; run oil slides (probably could have been a bra.w)

	.notOOZ:
		cmpi.b	#id_WFZ,(v_zone).w			; is it WFZ?
		bne.s	.exit					; if not, branch
		bsr.w	WindTunnels				; run wind tunnels

	.exit:
		rts

; ---------------------------------------------------------------------------
; Initial water heights
; Only level slots 8-$F are included here
; ---------------------------------------------------------------------------

WaterHeight:
		dc.w  $600, $600				; HPZ
		dc.w  $600, $600				; Zone 9
		dc.w  $600, $600				; OOZ
		dc.w  $600, $600				; MCZ
		dc.w  $600, $600				; CNZ
		dc.w  $600, $710				; CPZ
		dc.w  $600, $600				; DEZ
		dc.w  $410, $510				; ARZ


; ---------------------------------------------------------------------------
; Dynamic water height routines
; Only CPZ 2 has one, so this could be optimized by removing the index
; altogether if there are no plan to add water to other levels.

;	uses d0.l, d1.l, d2.b
; ---------------------------------------------------------------------------

DynamicWater:
		moveq	#0,d0
		move.w	(v_zone).w,d0				; get current zone
		subi.w	#id_HPZ_act1,d0				; only HPZ and higher have entries
		ror.b	#1,d0
		lsr.w	#6,d0
		andi.w	#$FFFE,d0				; make into index
		move.w	DynWater_Index(pc,d0.w),d0
		jsr	DynWater_Index(pc,d0.w)			; jump to appropriate dynamic water routine
		moveq	#0,d1
		move.b	(v_water_direction).w,d1
		move.w	(v_water_height_next).w,d0
		sub.w	(v_water_height_normal).w,d0
		beq.s	.exit					; if water level is correct, branch
		bcc.s	.movewater				; if water level is too high, branch
		neg.w	d1					; set water to move up instead

	.movewater:
		add.w	d1,(v_water_height_normal).w		; move water up or down

	.exit:
		rts

; ===========================================================================
DynWater_Index:	index offset(*)
		ptr DynWater_Null				; HPZ 1
		ptr DynWater_Null				; HPZ 2
		ptr DynWater_Null				; Zone 9 Act 1
		ptr DynWater_Null				; Zone 9 Act 2
		ptr DynWater_Null				; OOZ 1
		ptr DynWater_Null				; OOZ 2
		ptr DynWater_Null				; MCZ 1
		ptr DynWater_Null				; MCZ 2
		ptr DynWater_Null				; CNZ 1
		ptr DynWater_Null				; CNZ 2
		ptr DynWater_Null				; CPZ 1
		ptr DynWater_CPZ2				; CPZ 2
		ptr DynWater_Null				; DEZ 1
		ptr DynWater_Null				; DEZ 2
		ptr DynWater_Null				; ARZ 1
		ptr DynWater_Null				; ARZ 2
; ===========================================================================

DynWater_Null:
		rts
; ===========================================================================

DynWater_CPZ2:
		cmpi.w	#$1DE0,(v_camera_x_pos).w		; has camera reached $1DE0?
		bcs.s	.exit					; if not, exit
		move.w	#$510,(v_water_height_next).w		; raise level of megamack

	.exit:
		rts

; ---------------------------------------------------------------------------
; Wing Fortress Zone "wind tunnels"	subroutine

;	uses d0.l, d1.l, d2.w, a1, a2
; ---------------------------------------------------------------------------

	; Displacements for Wind Tunnel data relative to WindTunnel_Data
		rsreset
	wt_min_x_pos:	rs.w 1					; 0
	wt_min_y_pos:	rs.w 1					; 2
	wt_max_x_pos:	rs.w 1					; 4
	wt_max_y_pos:	rs.w 1					; 6

WindTunnels:
		tst.w	(v_debug_active).w
		bne.w	.exit					; branch if debug mode is currently in use
		lea	(WindTunnel_Data).l,a2			; list of tunnel area boundaries

		moveq	#2-1,d1					; two sets of coordinates to check
		lea	(v_ost_player1).w,a1

.tunnel_loop:
		move.w	ost_x_pos(a1),d0
		cmp.w	wt_min_x_pos(a2),d0
		bcs.w	.chknext				; branch if player is left of tunnel
		cmp.w	wt_max_x_pos(a2),d0
		bcc.w	.chknext				; branch if player is right of tunnel
		move.w	ost_y_pos(a1),d2
		cmp.w	wt_min_y_pos(a2),d2
		bcs.w	.chknext				; branch if player is above tunnel
		cmp.w	wt_max_y_pos(a2),d2
		bcc.s	.chknext				; branch if player is below tunnel
		tst.b	(f_wind_tunnel_disable).w
		bne.w	.exit					; branch if tunnels are disabled
		cmpi.b	#id_Sonic_Hurt,ost_primary_routine(a1)
		bcc.s	.end_tunnel				; branch if player is hurt or dead
		move.b	#1,(f_wind_tunnel_now).w		; set flag indicating that player is in a tunnel (sets animation; in Sonic 1, this also signaled breathing bubbles to move)


		subi_.w	#4,ost_x_pos(a1)
		move.w	#-$400,ost_x_vel(a1)			; move player horizontally
		move.w	#0,ost_y_vel(a1)
		move.b	#$F,ost_anim(a1)			; use floating animation
		bset	#status_air_bit,ost_primary_status(a1)
		btst	#bitUp,(v_joypad_hold_actual).w		; is up pressed?
		beq.s	.down					; if not, branch
		subq.w	#1,ost_y_pos(a1)			; move Sonic up

	.down:
		btst	#bitDn,(v_joypad_hold_actual).w		; is down presseD?
		beq.s	.end					; if not, branch
		addq.w	#1,ost_y_pos(a1)			; move Sonic down

	.end:
		rts
; ===========================================================================
	;WindTunnel_Leave:
	.chknext:
		addq.w	#8,a2					; check the second set of coordinates
		dbf	d1,.tunnel_loop
		tst.b	(f_wind_tunnel_now).w
		beq.s	.exit					; branch if player is still in tunnel
		move.b	#0,ost_anim(a1)				; use walking animation

	;WindTunnel_LeaveHurt:
	.end_tunnel:
		clr.b	(f_wind_tunnel_now).w			; finish tunnel

	;WindTunnel_End
	.exit:
		rts
; ===========================================================================

WindTunnel_Data:
		; min x, min y, max x, max y
		dc.w $1510,$400,$1AF0,$580
		dc.w $20F0,$618,$2500,$680

; ---------------------------------------------------------------------------
; Oil Ocean Zone oil slide subroutine

;	uses d0.w, d1.l, a1, a2
; ---------------------------------------------------------------------------

OilSlides:
	if FixBugs
		; Skip the main character if debug mode is active.
		; Sonic 1 did this, but Sonic 2 doesn't.
		tst.w	(v_debug_active).w
		bne.s	.dosidekick
	endc
		lea	(v_ost_player1).w,a1
		move.b	(v_joypad_hold).w,d2
		bsr.s	.doslide

	.dosidekick:
		lea	(v_ost_player2).w,a1
		move.b	(v_joypad2_hold).w,d2

.doslide:
		btst	#status_air_bit,ost_primary_status(a1)	; is character in the air?
		bne.s	.player_in_air				; if so, branch
		move.w	ost_y_pos(a1),d0
		add.w	d0,d0					; multiply y pos by 2
		andi.w	#$F00,d0				; only need high byte
		move.w	ost_x_pos(a1),d1
		lsr.w	#7,d1					; multiply x pos by 128
		andi.w	#$7F,d1					; only need high byte
		add.w	d1,d0					; combine for position within layout
		lea	(v_level_layout).w,a2
		move.b	(a2,d0.w),d0				; get 128x128 tile number
		lea	OilSlide_Chunks+sizeof_OilSlide_Chunks(pc),a2 ; number of slide tiles

		moveq	#sizeof_oilslide_chunks-1,d1

	.loop:
		cmp.b	-(a2),d0				; compare current 128x128 tile with those in list
		dbeq	d1,.loop				; check every tile in list
		beq.s	OilSlide_Move				; branch when match found

	.player_in_air:
		tst.b	ost_secondary_status(a1)		; is sliding flag set?
		bpl.s	.exit					; if not, exit
		move.w	#lock_time_slide,ost_lock_time(a1)	; lock controls for 5 frames
		andi.b	#(~status_sliding)&$FF,ost_secondary_status(a1) ; clear sliding flag

	.exit:
		rts
; ===========================================================================

OilSlide_Move:
		lea	(OilSlide_Speeds).l,a2			; slide speeds array (could be pc-relative)
		move.b	(a2,d1.w),d0				; d0 = slide speed
		beq.s	OilSlide_Flat				; if it is a flat section, branch
		move.b	ost_inertia(a1),d1			; current inertia of character
		tst.b	d0					; does slide move to the right?
		bpl.s	.slide_right				; if so, branch
		cmp.b	d0,d1					; is character's inertia already to the left?
		ble.s	.set_xflip				; if it is, branch
		subi.w	#$40,ost_inertia(a1)			; set inertia to the left
		bra.s	.set_xflip
; ===========================================================================

	.slide_right:
		cmp.b	d0,d1					; is character's inertia already to the right?
		bge.s	.set_xflip				; if so, branch
		addi.w	#$40,ost_inertia(a1)			; set inertia to the right

	.set_xflip:
		bclr	#status_xflip_bit,ost_primary_status(a1) ; face character right
		tst.b	d1
		bpl.s	.face_right				; branch if inertia is positive
		bset	#status_xflip_bit,ost_primary_status(a1) ; face character left

	.face_right:
		move.b	#$1B,ost_anim(a1)			; use sliding animation
		ori.b	#status_sliding,ost_secondary_status(a1) ; set sliding flag
		move.b	(v_vblank_counter_byte).w,d0		; get byte that increments every frame
		andi.b	#$1F,d0					; read only bits 0-4
		bne.s	.exit					; if any are set, branch
		move.w	#sfx_OilSlide,d0			; play oil slide sound every 32nd frame
		jsr	(PlaySound).l				; (could be a jmp or even a bra.w)

	.exit:
		rts
; ===========================================================================

OilSlide_Flat:
		move.w	#4,d1					; could have been a moveq
		move.w	ost_inertia(a1),d0			; current inertia of character
		btst	#bitL,d2				; is left being held?
		beq.s	.notleft				; if not, branch
		move.b	#0,ost_anim(a1)				; use walk animation
		bset	#status_xflip_bit,ost_primary_status(a1) ; face character left
		sub.w	d1,d0					; subtract 4 from inertia
		tst.w	d0
		bpl.s	.notleft				; branch if interia is positive
		sub.w	d1,d0					; subtract 4 from inertia

	.notleft:
		btst	#bitR,d2				; is right being held?
		beq.s	.notright				; if not, branch
		move.b	#0,ost_anim(a1)				; use walk animation
		bclr	#status_xflip_bit,ost_primary_status(a1) ; face character right
		add.w	d1,d0					; add 4 to inertia
		tst.w	d0
		bmi.s	.notright				; branch if inertia is negative
		add.w	d1,d0					; add 4 to inertia

	.notright:
		move.w	#4,d1					; redundant
		tst.w	d0
		beq.s	.set_inertia				; branch if zero
		bmi.s	.isleft					; branch if negative
		sub.w	d1,d0
		bhi.s	.branchto_set_inertia
		move.w	#0,d0					; could have been a moveq
		move.b	#5,ost_anim(a1)				; waiting animation

	.branchto_set_inertia:
		bra.s	.set_inertia
; ===========================================================================

	.isleft:
		add.w	d1,d0
		bhi.s	.set_inertia
		move.w	#0,d0					; could have been a moveq
		move.b	#5,ost_anim(a1)				; waiting animation

	.set_inertia:
		move.w	d0,ost_inertia(a1)
		ori.b	#status_sliding,status_secondary(a1)	; set sliding flag
		rts

; ---------------------------------------------------------------------------
; Oil slide speeds. These values are not so much speeds as they are indicators
; of which direction they should make the character move: 8 = right, -8 = left
; 0 = level section of slide at the top
; ---------------------------------------------------------------------------

OilSlide_Speeds:
		dc.b  -8, -8, -8,  8,  8,  0,  0,  0, -8, -8,  0,  8,  8,  8,  0,  8
		dc.b   8,  8,  0, -8,  0,  0, -8,  8, -8, -8, -8,  8,  8,  8, -8, -8 ; 16

; ---------------------------------------------------------------------------
; IDs of chunks in OOZ's layout that contain of oil slides
; ---------------------------------------------------------------------------

OilSlide_Chunks:
		dc.b $2F,$30,$31,$33,$35,$38,$3A,$3C,$63,$64,$83,$90,$91,$93,$A1,$A3 ; 32
		dc.b $BD,$C7,$C8,$CE,$D7,$D8,$E6,$EB,$EC,$ED,$F1,$F2,$F3,$F4,$FA,$FD ; 48
		arraysize	OilSlide_Chunks
		even

; ---------------------------------------------------------------------------
; Subroutine to	move Sonic and Tails in demo mode

;	uses d0.l, d1.b, d2.l, a0, a1
; ---------------------------------------------------------------------------

MovePlayersInDemo:
		tst.w	(f_demo_mode).w				; is demo mode on?
		bne.w	MDemo_On				; if so, branch
		rts

; ---------------------------------------------------------------------------
; Unused subroutine for recording a demo

; output:
;	a1 = address last written by recorder for player 2

;	uses d0.w
; ---------------------------------------------------------------------------

DemoRecorder:
		lea	(DemoDataPtr).l,a1			; location to record player 1's inputs
		moveq	#0,d0
		move.b	(v_zone).w,d0				; get current zone
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1				; use as index
		move.w	(v_demo_input_counter).w,d0		; get number of inputs so far
		adda.w	d0,a1					; jump to last position in recorded data
		move.b	(v_joypad_hold_actual).w,d0		; get joypad input state
		cmp.b	(a1),d0					; is joypad input same as last frame?
		bne.s	.recordP1				; if not, branch
		addq.b	#1,1(a1)				; increment time for current input
		cmpi.b	#255,1(a1)				; has input timer hit 255 (maximum)?
		beq.s	.recordP1				; if so, branch
		bra.s	.player2				; continue to player 2

	.recordP1:
		move.b	d0,2(a1)				; write new input state
		move.b	#0,3(a1)				; set time to 0
		addq.w	#2,(v_demo_input_counter).w		; increment counter
		andi.w	#$3FF,(v_demo_input_counter).w		; counter stops at $200 inputs

.player2:
		cmpi.b	#id_EHZ,(v_zone).w			; is it EHZ?
		bne.s	.exit					; if not, exit
		lea	($FEC000).l,a1				; location to record player 2's inputs (possibly aux ram or a port on a development unit?)
		move.w	(v_demo_input_counter_p2).w,d0		; get number of inputs so far
		adda.w	d0,a1					; jump to last position in recorded data
		move.b	(v_joypad2_hold_actual).w,d0		; get joypad input state
		cmp.b	(a1),d0					; is joypad input same as last frame?
		bne.s	.recordP2				; if not, branch
		addq.b	#1,1(a1)				; increment time for current input
		cmpi.b	#-1,1(a1)				; has input timer hit 255 (maximum)?
		beq.s	.recordP2				; if so, branch
		bra.s	.exit

	.recordP2:
		move.b	d0,2(a1)				; write new input state
		move.b	#0,3(a1)				; set time to 0
		addq.w	#2,(v_demo_input_counter_p2).w		; increment counter
		andi.w	#$3FF,(v_demo_input_counter_p2).w	; counter stops at $200 inputs

	.exit:
		rts
; ===========================================================================

MDemo_On:
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#btnStart,d0				; is start button pressed on either joypad?
		beq.s	.dontquit				; if not, branch
		tst.w	(f_demo_mode).w				; is this an ending demo? (unused Sonic 1 leftover)
		bmi.s	.dontquit				; if by miracle it is, branch
		move.b	#id_Title,(v_gamemode).w		; go to title screen

	.dontquit:
		lea	(DemoDataPtr).l,a1			; get address of demo pointer list
		moveq	#0,d0
		move.b	(v_zone).w,d0
		cmpi.b	#id_SpecialStage,(v_gamemode).w		; is this a special stage?  (unused Sonic 1 leftover)
		bne.s	.notspecial				; if not, branch
		moveq	#6,d0					; use demo 6

	.notspecial:
		lsl.w	#2,d0
		movea.l	(a1,d0.w),a1
		move.w	(v_demo_input_counter).w,d0		; get number of inputs so far
		adda.w	d0,a1					; jump to current input
		move.b	(a1),d0					; get joypad state from demo
		lea	(v_joypad_hold_actual).w,a0		; (a0) = actual joypad state
		move.b	d0,d1
    if FixBugs
		; In Revision 0 of Sonic 1, this instruction was 'move.b (a0),d2'. The
		; purpose of this is to XOR the current frame's input with the
		; previous frame's input to determine which inputs had been pressed
		; on the current frame. The usage of '(a0)' for this is a problem
		; because it doesn't hold the *demo* inputs from the previous frame,
		; but rather the *player's* inputs from the *current* frame.
		; This meant that it was possible for the player to influence the
		; demos by pressing buttons on the joypad. In Revision 1 of Sonic 1, this
		; instruction was replaced with a 'moveq #0,d2', effectively
		; dummying-out the process of differentiating newly-pressed inputs
		; from old held inputs, causing every input to be treated as
		; newly-pressed on every frame. While this isn't a problem in this
		; game, it does become a problem if Sonic or Tails is given a
		; double-jump ability, as the ability will constantly be activated
		; when they shouldn't be. While not exactly the intended use for this
		; variable, 'v_joypad_hold' does happen to hold the inputs from
		; the previous frame, so we can use this here instead to fix this bug
		; properly.
		move.b	v_joypad_hold-v_joypad_hold_actual(a0),d2
    else
		moveq	#0,d2
	endc
		eor.b	d2,d0					; determine which buttons differ between this frame and the last
		move.b	d1,(a0)+				; write demo input for held buttons
		and.b	d1,d0					; only keep the buttons that were pressed on this frame
		move.b	d0,(a0)+				; write demo input for pressed buttons
		subq.b	#1,(v_demo_input_time).w		; decrement timer for current input
		bcc.s	.moveplayer2				; branch if 0 or higher
		move.b	3(a1),(v_demo_input_time).w		; get time for next input
		addq.w	#2,(v_demo_input_counter).w		; increment counter

.moveplayer2:
		cmpi.b	#id_EHZ,(v_zone).w			; is it the EHZ demo?
		bne.s	.skip_player2				; if not, exit
		lea	(Demo_EHZ_P2).l,a1			; Tails' demo script
		move.w	(v_demo_input_counter_p2).w,d0		; get number of inputs so far
		adda.w	d0,a1					; jump to current input
		move.b	(a1),d0					; get joypad state from demo
		lea	(v_joypad2_hold_actual).w,a0		; (a0) = actual joypad state
		move.b	d0,d1
	if FixBugs
		; Same fix as above, but for player 2.
		move.b	v_joypad_hold-v_joypad_hold_actual(a0),d2
    else
		moveq	#0,d2
	endc
		eor.b	d2,d0					; determine which buttons differ between this frame and the last
		move.b	d1,(a0)+				; write demo input for held buttons
		and.b	d1,d0					; only keep the buttons that were pressed on this frame
		move.b	d0,(a0)+				; write demo input for pressed buttons
		subq.b	#1,(v_demo_input_time_p2).w		; decrement timer for current input
		bcc.s	.end					; branch if 0 or higher
		move.b	3(a1),(v_demo_input_time_p2).w		; get time for next input
		addq.w	#2,(v_demo_input_counter_p2).w		; increment counter

	.end:
		rts
; ===========================================================================

.skip_player2:
		move.w	#0,(v_joypad2_hold_actual).w		; clear player 2's joypad state
		rts

; ---------------------------------------------------------------------------
; Demo data pointers (these are hardcoded to match zone numbers)
; ---------------------------------------------------------------------------

DemoDataPtr:	index.l 0,,$100					; absolute longword pointers, ids multiplied by $100
		ptr Demo_EHZ					; EHZ (only Sonic's script)
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_EHZ					; unused
		ptr Demo_CNZ					; CNZ
		ptr Demo_CPZ					; CPZ
		ptr Demo_EHZ					; unused
		ptr Demo_ARZ					; ARZ
		ptr Demo_EHZ					; unused

;----------------------------------------------------------------------------
; Unused Sonic 1 leftover: pointers to demo scripts for the ending and credits.
; Here, they just point to random code.
; ---------------------------------------------------------------------------

DemoEndDataPtr:
		dc.l   $8B0837					; 0
		dc.l   $42085C					; 1
		dc.l   $6A085F					; 2
		dc.l   $2F082C					; 3
		dc.l   $210803					; 4
		dc.l $28300808					; 5
		dc.l   $2E0815					; 6
		dc.l	$F0846					; 7
		dc.l   $1A08FF					; 8
		dc.l  $8CA0000					; 9
		dc.l	     0					; 10
		dc.l	     0					; 11

; ---------------------------------------------------------------------------
; Subroutine to set collision index pointers and load collision data for
; current zone

;	uses d0.l, a0, a1
; ---------------------------------------------------------------------------

SetColIndexPtr:
		moveq	#0,d0
		move.b	(v_zone).w,d0				; current zone
		lsl.w	#2,d0
		move.l	#v_primary_collision,(v_collision_index_ptr).w ; points to primary collision data initially
		pushr.w	d0
		movea.l	PrimaryColPointers(pc,d0.w),a0		; get primary collision data for current zone
		lea	(v_primary_collision).w,a1
		bsr.w	KosDec					; decompress primary collision data
		popr.w	d0
		movea.l	SecondaryColPointers(pc,d0.w),a0	; get secondary collision data for current zone
		lea	(v_secondary_collision).w,a1
		bra.w	KosDec					; decompress secondary collision data

; ---------------------------------------------------------------------------
; Pointers to primary collision	indexes
;
; Contains an array of pointers	to the primary collision index data for	each
; level. 1 pointer for each level, pointing the	primary	collision index.
; ---------------------------------------------------------------------------

PrimaryColPointers:
		dc.l ColP_EHZHTZ				; 0
		dc.l LevelIndex					; 1
		dc.l ColP_MTZ					; 2
		dc.l LevelIndex					; 3
		dc.l ColP_MTZ					; 4
		dc.l ColP_MTZ					; 5
		dc.l ColP_WFZSCZ				; 6
		dc.l ColP_EHZHTZ				; 7
		dc.l ColP_OOZ					; 8
		dc.l LevelIndex					; 9
		dc.l ColP_OOZ					; 10
		dc.l ColP_MCZ					; 11
		dc.l ColP_CNZ					; 12
		dc.l ColP_CPZDEZ				; 13
		dc.l ColP_CPZDEZ				; 14
		dc.l ColP_ARZ					; 15
		dc.l ColP_WFZSCZ				; 16

; ---------------------------------------------------------------------------
; Pointers to secondary	collision indexes
;
; Contains an array of pointers	to the secondary collision index data for
; each level. 1	pointer	for each level,	pointing the secondary collision
; index.
; ---------------------------------------------------------------------------

SecondaryColPointers:
		dc.l ColS_EHZHTZ				; 0
		dc.l LevelIndex					; 1
		dc.l ColP_MTZ					; 2
		dc.l LevelIndex					; 3
		dc.l ColP_MTZ					; 4
		dc.l ColP_MTZ					; 5
		dc.l ColS_WFZSCZ				; 6
		dc.l ColS_EHZHTZ				; 7
		dc.l ColP_OOZ					; 8
		dc.l LevelIndex					; 9
		dc.l ColP_OOZ					; 10
		dc.l ColP_MCZ					; 11
		dc.l ColS_CNZ					; 12
		dc.l ColS_CPZDEZ				; 13
		dc.l ColS_CPZDEZ				; 14
		dc.l ColS_ARZ					; 15
		dc.l ColS_WFZSCZ				; 16

; ---------------------------------------------------------------------------
; Subroutine to initialise oscillating numbers

;	uses d1.l, a1, a2
; ---------------------------------------------------------------------------

OscillateNumInit:
		lea	(v_oscillating_direction).w,a1
		lea	(OscillateNum_Baselines).l,a2		; (could be pc-relative)
		moveq	#(sizeof_OscillateNum_Baselines/2)-1,d1

	.loop:
		move.w	(a2)+,(a1)+				; copy baseline values to RAM
		dbf	d1,.loop
		rts


; ===========================================================================

OscillateNum_Baselines:
		dc.w  $7D					; direction bitfield
		; start value, start rate
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $80, 0
		dc.w $3848, $EE
		dc.w $2080, $B4
		dc.w $3080, $10E
		dc.w $5080, $1C2
		dc.w $7080, $276
		dc.w $80, 0
		dc.w $4000, $FE

		arraysize	OscillateNum_Baselines
		even

; ---------------------------------------------------------------------------
; Subroutine to run oscillating numbers

;	uses d0.w, d1.l, d2.w, d3.w, d4.w, a1, a2
; ---------------------------------------------------------------------------


OscillateNumDo:
		tst.w	(f_two_player).w			; is it two-player mode?
		bne.s	.is2P					; if so, branch
		cmpi.b	#id_Death,(v_ost_player1+ost_primary_routine).w ; has player 1 just died?
		bcc.s	.end					; if so, exit

	.is2P:
		lea	(v_oscillating_direction).w,a1
		lea	(OscillateNum_Settings).l,a2
		move.w	(a1)+,d3				; get oscillation direction bitfield
		moveq	#$F,d1					; bit to test/store direction

.loop:
		move.w	(a2)+,d2				; get frequency
		move.w	(a2)+,d4				; get amplitude
		btst	d1,d3					; check oscillation direction
		bne.s	.down					; branch if 1

	;.up:
		move.w	2(a1),d0				; get current rate
		add.w	d2,d0					; add frequency
		move.w	d0,2(a1)				; update rate
		_add.w	d0,0(a1)				; add rate to value
		_cmp.b	0(a1),d4
		bhi.s	.next					; branch if value is below middle value
		bset	d1,d3					; set direction to down
		bra.s	.next

	.down:
		move.w	2(a1),d0				; get current rate
		sub.w	d2,d0					; subtract frequency
		move.w	d0,2(a1)				; update rate
		_add.w	d0,0(a1)				; add rate to value
		_cmp.b	0(a1),d4
		bls.s	.next					; branch if value is above middle value
		bclr	d1,d3					; set direction to up

	.next:
		addq.w	#4,a1					; next value/rate
		dbf	d1,.loop				; repeat for all bits in direction bitfield
		move.w	d3,(v_oscillating_direction).w		; update direction bitfield

.end:
		rts

; ===========================================================================

OscillateNum_Settings:
		; frequency, middle values
		dc.w 2, $10
		dc.w 2, $18
		dc.w 2, $20
		dc.w 2, $30
		dc.w 4, $20
		dc.w 8, 8
		dc.w 8, $40
		dc.w 4, $40
		dc.w 2, $38
		dc.w 2, $38
		dc.w 2, $20
		dc.w 3, $30
		dc.w 5, $50
		dc.w 7, $70
		dc.w 2, $40
		dc.w 2, $40
		even

; ---------------------------------------------------------------------------
; Subroutine to	change synchronised animation variables (rings)

;	uses d0.l
; ---------------------------------------------------------------------------

SynchroAnimate:
		; unused, was used for GHZ log spikes in Sonic 1
		subq.b	#1,(v_syncani_0_time).w			; decrement timer
		bpl.s	.sync2					; branch if time remains
		move.b	#11,(v_syncani_0_time).w		; reset timer
		subq.b	#1,(v_syncani_0_frame).w		; decrement frame
		andi.b	#7,(v_syncani_0_frame).w		; wraps to 7 after 0

	.sync2:
		; used for rings
		subq.b	#1,(v_syncani_1_time).w			; decrement timer
		bpl.s	.sync3					; branch if time remains
		move.b	#7,(v_syncani_1_time).w			; reset timer
		addq.b	#1,(v_syncani_1_frame).w		; increment frame
		andi.b	#3,(v_syncani_1_frame).w		; wraps to 0 after 3

	.sync3:
		; unused in Sonic 1, and unused here as well
		subq.b	#1,(v_syncani_2_time).w			; decrement timer
		bpl.s	.sync4					; branch if time remains
		move.b	#7,(v_syncani_2_time).w			; reset timer
		addq.b	#1,(v_syncani_2_frame).w		; increment frame
		cmpi.b	#6,(v_syncani_2_frame).w
		bcs.s	.sync4					; branch if 0-5
		move.b	#0,(v_syncani_2_frame).w		; wraps to 0 after 5

	.sync4:
		; used for bouncing rings
		tst.b	(v_syncani_3_time).w			; this is set to 255 when Sonic loses rings
		beq.s	.end					; branch if 0
		moveq	#0,d0
		move.b	(v_syncani_3_time).w,d0
		add.w	(v_syncani_3_accumulator).w,d0
		move.w	d0,(v_syncani_3_accumulator).w		; add timer to accumulator
		rol.w	#7,d0
		andi.w	#3,d0					; read only bits $E-$11
		move.b	d0,(v_syncani_3_frame).w		; use those bits as frame (0-3)
		subq.b	#1,(v_syncani_3_time).w			; decrement timer

	.end:
		rts

; ---------------------------------------------------------------------------
; Subroutine to set whether this level has a signpost or not
; ---------------------------------------------------------------------------

; sub_4BD2:
SetLevelEndType:
		move.w	#0,(f_has_signpost).w			; set level type to non-signpost
		tst.w	(f_two_player).w			; is it two-player mode?
		bne.s	.setsignpost				; if so, branch

		cmpi.w	#id_EHZ_act2,(v_zone).w			; is it this level?
		beq.w	.exit					; if so, exit

		cmpi.w	#id_MTZ_act3,(v_zone).w			; repeat for all levels that do not have signposts
		beq.w	.exit

		cmpi.w	#id_WFZ_act1,(v_zone).w
		beq.w	.exit

		cmpi.w	#id_HTZ_act2,(v_zone).w
		beq.w	.exit

		cmpi.w	#id_OOZ_act2,(v_zone).w
		beq.w	.exit

		cmpi.w	#id_MCZ_act2,(v_zone).w
		beq.s	.exit

		cmpi.w	#id_CNZ_act2,(v_zone).w
		beq.s	.exit

		cmpi.w	#id_CPZ_act2,(v_zone).w
		beq.s	.exit

		cmpi.w	#id_DEZ_act1,(v_zone).w
		beq.s	.exit

		cmpi.w	#id_ARZ_act2,(v_zone).w
		beq.s	.exit

		cmpi.w	#id_SCZ_act1,(v_zone).w
		beq.s	.exit

	.setsignpost:
		move.w	#1,(f_has_signpost).w			; set level type to signpost

	.exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to check player's position, lock screen at end of level, and
; load signpost graphics

;	uses d0.l, d1.w
; ---------------------------------------------------------------------------

SignpostArtLoad:
		tst.w	(f_has_signpost).w			; does this level have a signpost?
		beq.s	.exit					; branch if not
		tst.w	(v_debug_active).w			; is debug mode	being used?
		bne.s	.exit					; branch if so
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_boundary_right).w,d1
		subi.w	#$100,d1
		cmp.w	d1,d0					; has player 1 reached the edge of the level?
		blt.s	.chkp2					; branch if not
		tst.b	(f_hud_time_update).w
		beq.s	.chkp2					; branch if their timer is stopped
		cmp.w	(v_boundary_left).w,d1
		beq.s	.chkp2					; branch if screen has already been locked
		move.w	d1,(v_boundary_left).w			; move left boundary to current screen position
		tst.w	(f_two_player).w
		bne.s	.exit					; branch if we're in 2P mode
		moveq	#id_PLC_Signpost,d0			; load signpost GFX
		bra.w	NewPLC
; ===========================================================================

	.chkp2:
		tst.w	(f_two_player).w
		beq.s	.exit					; branch if we're not in 2P mode
		move.w	(v_camera_x_pos_p2).w,d0
		move.w	(v_boundary_right_p2).w,d1
		subi.w	#$100,d1
		cmp.w	d1,d0					; has player 2 reached the end of the level?
		blt.s	.exit					; branch if not
		tst.b	(f_hud_time_update_p2).w
		beq.s	.exit					; branch if their timer is stopped
		cmp.w	(v_boundary_left_p2).w,d1
		beq.s	.exit					; branch if screen has already been locked
		move.w	d1,(v_boundary_left_p2).w		; move left boundary to current screen position

	.exit:
		rts

; ---------------------------------------------------------------------------
; Sonic's EHZ Demo Script
; ---------------------------------------------------------------------------
Demo_EHZ:
		dc.b   0,$4B,  8,$42,$28,  8,  8,$3E,$28,  5,  8,$AF,$28,  9,  8,$45 ; 0
		dc.b   0,$1D,  4, $E,  0,  4,  4,  4,  0,  8,  4,$3E,  0,  4,  8,$66 ; 16
		dc.b   0,$61,  8,$11,  0,$21,  2,  7,$22,  6,  2, $D,  0,$3B,  8,  9 ; 32
		dc.b   0,$1D,  2,  6,$22,  6,  2,  1,  0, $E,  8,$FF,  8,$2E,  0,$22 ; 48
		dc.b $20,  7,$28, $F,  8,  2,  0,$2F,$28,$23,  8,$BD,  0, $B,  4,$13 ; 64
		dc.b   0,$16,  2,  2,$22,  6,  2,  2,  0,$63,$80,  0,$40,  0,  0,  0 ; 80
; ---------------------------------------------------------------------------
; Tails' EHZ Demo Script
; ---------------------------------------------------------------------------
Demo_EHZ_P2:
		dc.b   0,$3B,  8, $F,  9,$43,$29,  6,  9,  6,  8,$C9,  0,$11,  8,  1 ; 0
		dc.b $28,  8,  8,$52,  0,$11,  8, $A,$28, $E,  8,$23,  0, $A,$20,  4 ; 16
		dc.b   0, $D,  8,$55,  0,$1E,  8,$5A,  0,$10,  8,$FF,  8,$C0,  0,$20 ; 32
		dc.b   4, $D,  0, $D,$20,  4,$28, $F,$20,  5,  0, $C,  4,  5,  0,$5E ; 48
		dc.b   8,$73,  0,$18,  4,$44,  0,  8,  2,$30,  0,  8,  8, $D,  0,$23 ; 64
		dc.b   8,$27,  0,  4,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 80
; ---------------------------------------------------------------------------
; CNZ Demo Script
; ---------------------------------------------------------------------------
Demo_CNZ:
		dc.b   0,$48,  8,$10,  9,  0,  8,  1,  9,  6,  8,$60,$28,  5,$20,  1 ; 0
		dc.b   0,  8,  4,  2,  6,  3,  4,  1,  0,$19,  8,$11,$28,$19,$20,  4 ; 16
		dc.b $28,$23,  8,$1A,  0,  7,  4,$10,  0, $E,  8,$77,$28,$16,$20,  0 ; 32
		dc.b   0, $F,  4,$11,  0,  7,  8,$52,  0,$6F,  8,$74,  0,$37,  8,$16 ; 48
		dc.b   0,  4,  4,$26,  0, $C,  4,$12,  0,$69,$20,$10,$28,  2,$2A,  5 ; 64
		dc.b  $A,$14,  8,  5,  0,  5,  4, $C,  0,$48,  4,  9,  0,$1E,  8,  6 ; 80
		dc.b   0,$2F,  4,  1,  0,$FF,  0,$4F,  8,  0,$28, $B,  8,$2A,  0,$5E ; 96
; ---------------------------------------------------------------------------
; CPZ Demo Script
; ---------------------------------------------------------------------------
Demo_CPZ:
		dc.b   0,$46,  8,$1B,$28,  7,  8,  9,  0,$1B,  8, $D,$28,$28,  8,$FF ; 0
		dc.b   8,$E7, $A,  4,  2,  1,  4,$33,  6,$67,  4,  0,  0,$15,$20,  0 ; 16
		dc.b $24,  7,  4, $E,  0,$17,  8,  1, $A,  1,  8, $C,  0,$1F,$28,  6 ; 32
		dc.b   8, $A,  0,$1B,  4, $D,  0,$1C,  4,  6,  0,$FF,  0,$DF,  8, $E ; 48
		dc.b   0,$1C,  4,  2,  0,$25,  8,  6,  0,  6,$20,  4,  0,$28,  4,$11 ; 64
		dc.b   0,$17,  8,$19,  0,$10,  4,$2D,  0,$13,$80,  0,$40,  0,  0,  0 ; 80
; ---------------------------------------------------------------------------
; ARZ Demo Script
; ---------------------------------------------------------------------------
Demo_ARZ:
		dc.b   0,$42,  8,$4A,$28,  8,  8,$4F,$28, $B,  8,  5,  0,$1A,  8,$60 ; 0
		dc.b $28,$14,  8,$54,  0,$40,  8,  4,  9,  0,  8,$5B,  0,$46,  8,$3B ; 16
		dc.b $28,  8,  8,$27,  0, $A,  8,$92,$28,$32,  8,$22,  0,$22,  8,$4C ; 32
		dc.b   0,$1E,  4,  1,  5,  2,  4,  0,  0, $A,  4, $C,  0,$10,  8,  5 ; 48
		dc.b   0,$61,  8,  3,$28,  5,  8,$16,  0,$1B,  8,$56,$28, $A,  8,$16 ; 64
		dc.b   0,$15,  8, $C,  0,$2B,$20,  1,$28,$1A,  8,$82,  0, $B,$80,  0 ; 80

; ---------------------------------------------------------------------------
; Subroutine to decompress Kosinski-compressed level art, and transfer to VRAM
; via DMA in $1000 byte chunks

;	uses d0.l, d1,1, d2.w, d3.w, d7.w, a0, a1, a2
; ---------------------------------------------------------------------------
; sub_4E98: LoadZoneTiles:
LevelArtLoad:
		moveq	#0,d0
		move.b	(v_zone).w,d0				; get current zone
		add.w	d0,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0					; make index into level header array
		lea	(LevelHeaders).l,a2			; load level headers
		lea	(a2,d0.w),a2				; a2 = first longword of target level header
		move.l	(a2)+,d0
		andi.l	#$FFFFFF,d0				; d0 = pointer to compressed level art
		movea.l	d0,a0
		lea	(v_128x128_tiles).l,a1			; 128x128 mappings RAM is used as decompression buffer
		bsr.w	KosDec					; decompress the level art
		move.w	a1,d3					; d3 = size of decompressed tiles

		cmpi.b	#id_HTZ,(v_zone).w			; are we loading HTZ?
		bne.s	.notHTZ					; if not, branch

		lea	(Kos_HTZ).l,a0				; HTZ supplement to EHZ art
		lea	(v_128x128_tiles+tile_HTZ_Patch).l,a1	; start address of HTZ patch
		bsr.w	KosDec					; add the HTZ patch to EHZ's art
		move.w	#tile_HTZ_Patch+sizeof_Kos_HTZ,d3	; end address of HTZ tiles

	.notHTZ:
		cmpi.b	#id_WFZ,(v_zone).w			; are we loading WFZ?
		bne.s	.notWFZ					; if not, branch
		lea	(Kos_WFZ).l,a0				; WFZ supplement to SCZ art
		lea	(v_128x128_tiles+tile_WFZ_Patch).l,a1	; start address of WFZ patch
		bsr.w	KosDec					; add the WFZ patch to SCZ's art
		move.w	#tile_WFZ_Patch+sizeof_Kos_WFZ,d3	; end address of WFZ tiles

	.notWFZ:
		cmpi.b	#id_DEZ,(v_zone).w			; is it DEZ?
		bne.s	.prepare_dma				; if not, branch
		move.w	#sizeof_Kos_CPZ-($3D*sizeof_cell),d3	; DEZ doesn't use the last $3D of CPZ's tiles

.prepare_dma:
		; Transfer the decompressed art to VRAM, starting  with the highest tiles and
		; working backwards in $1000 byte chunks.
		move.w	d3,d7					; d7 = size of decompressed tiles
		andi.w	#$FFF,d3				; divide lower 12 bits by 2
		lsr.w	#1,d3					; d3 = size of first DMA transfer in words
		rol.w	#4,d7					; divide total size by 4
		andi.w	#$F,d7					; d7 = number of DMAs needed to transfer everything-1

	.loop:
		move.w	d7,d2					; d2 = loop counter
		lsl.w	#7,d2					; multiply by $1000
		lsl.w	#5,d2					; destination is nearest multiple of $1000 that does not exceed size
		move.l	#$FFFFFF,d1
		move.w	d2,d1					; d1 = source
		jsr	(AddDMA).l				; queue the DMA transfer (could be absolute short jsr)
		pushr.w	d7					; back up loop counter
		move.b	#id_VBlank_TitleCard,(v_vblank_routine).w
		bsr.w	WaitForVBlank				; wait for VBlank to run DMA
		bsr.w	RunPLC					; process any pending PLCs
		popr.w	d7					; restore loop counter
		move.w	#$800,d3				; all remaining transfers are $1000 bytes in length
		dbf	d7,.loop				; repeat until everything has been transferred
		rts

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_LevelBlockMapsLoad:
		jmp	(LevelBlockMapsLoad).l
JmpTo_DeformLayers:
		jmp	(DeformLayers).l
JmpTo_AnimateLevelGFX:
		jmp	(AnimateLevelGFX).l
JmpTo_DrawTilesAtStart:
		jmp	(DrawTilesAtStart).l
	endc

; ===========================================================================

GM_SpecialStage:
		cmpi.b	#7,(v_special_stage).w
		bcs.s	.not7
		move.b	#0,(v_special_stage).w

	.not7:
		move.w	#sfx_EnterSS,d0				; play warp SFX
		bsr.w	PlaySound
		move.b	#cmd_Fade,d0				; fade out current music
		bsr.w	PlayMusic
		bsr.w	PaletteWhiteOut				; fade to white
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not2P					; if not, branch
		move.w	#0,(f_two_player).w			; clear 2P mode flag
		st.b	(f_ss_2p).w				; set SS 2P flag
		bra.s	.ss_vdp_setup

	.not2P:
		sf.b	(f_ss_2p).w				; clear 2P SS flag

	.ss_vdp_setup:
		; Configure the VDP for Special Stage mode.
		disable_ints					; disable interrupts
		lea	(vdp_control_port).l,a6
		move.w	#vdp_full_vscroll|vdp_1px_hscroll,(a6)	; v-scroll by screen, h-scroll by line
		move.w	#vdp_md_color,(a6)			; md color mode, H-int disabled
		move.w	#vdp_hint_counter+(screen_height-1),(v_vdp_hint_counter).w ; H-int every 224 scanlines
		move.w	#vdp_fg_nametable+(vram_ss_fg1>>10),(a6) ; primary FG plane table at $C000
		move.w	#vdp_bg_nametable+(vram_ss_bg>>13),(a6)	; BG plane table at $A000
		move.w	#vdp_256px_screen_width|vdp_shadow_highlight,(a6) ; H32 mode, no interlace, shadow/highlight mode
		move.w	#vdp_plane_height_32|vdp_plane_width_128,(a6) ; 128x32 plane size
		move.w	#vdp_bg_color+0,(a6)			; BG color = line 0 entry 0
		move.w	#vdp_hscroll_table+(vram_hscroll>>10),(a6) ; H-scroll table at $FC00
		move.w	#vdp_sprite_table+(vram_sprites>>9),(a6) ; sprite attribute table at $F800

		disable_display

		; Clear the VRAM regions we just configured. As this is done via macro, a lot of
		; cycles are wasted setting the control port to a5 and setting and resetting
		; the VDP increment every single time. This could be optimized with a
		; modified macro that only does those tasks if actually required.
		dma_fill	0,sizeof_vram_planetable_128x32,vram_ss_fg2
		dma_fill	0,sizeof_vram_planetable_128x32,vram_ss_fg1
		dma_fill	0,sizeof_vram_planetable_128x32,vram_ss_bg
		dma_fill	0,sizeof_vram_hscroll,vram_hscroll

		; Clear several variables and main RAM regions.
		clr.l	(v_fg_y_pos_vsram).w
		clr.l	(v_unused_ss).w
		clr.b	(f_ss_started).w

	if FixBugs
		clear_ram 	v_sprite_buffer,v_sprite_buffer_end
		clear_ram	v_ss_hscroll_buffer_1,v_ss_hscroll_buffer_1_end
		clear_ram	ss_shared_ram,ss_shared_ram_end
	else
		; These '+4's shouldn't be here; 'clear_ram' accidentally clears an additional 4 bytes.
		clear_ram 	v_sprite_buffer,v_sprite_buffer_end+4
		clear_ram	v_ss_hscroll_buffer_1,v_ss_hscroll_buffer_1_end+4
		clear_ram	ss_shared_ram,ss_shared_ram_end+4
	endc

		clear_ram	v_sprite_queue,v_sprite_queue_end
		clear_ram	ost,ost_end

    if FixBugs
		; The DMA queue needs to be reset here, to prevent the remaining queued DMA transfers from
		; overwriting the special stage's graphics.
		; In a bizarre twist of luck, the above bug actually nullifies this bug: the excessive
		; ss_shared_ram clear sets v_dma_queue to 0, just like the below code.
		; - Clownacy
		reset_dma_queue
    endc

		enable_ints
		lea	(vdp_control_port).l,a6
		move.w	#vdp_auto_inc+2,(a6)			; redundant, this was already done by the last dma_fill
		bsr.w	SS_InitHScroll				; set up initial H-scroll values
		bsr.w	SS_LoadCompressedData			; load halfpipe graphics and layout, perspective, and object location data
		move.w	#0,(v_ss_current_segment).w
		moveq	#id_PLC_SpecialStage,d0			; load special stage PLCs
		bsr.w	QuickPLC
		clr.b	(f_level_started).w
		move.l	#0,(v_camera_x_pos).w
		move.l	#0,(v_camera_y_pos).w
		move.l	#0,(v_camera_x_pos_copy2).w
		move.l	#0,(v_camera_y_pos_copy2).w
		cmpi.w	#sonic_alone,(v_player_mode).w		; is this a Sonic alone game?
		bgt.s	.dont_load_sonic			; if not, branch
		move.b	#id_SonicSpecial,(v_ost_player1+ost_id).w ; load Special Stage Sonic
		tst.w	(v_player_mode).w			; is it a Sonic and Tails game?
		bne.s	.dont_load_tails			; if not, branch

	.dont_load_sonic:
		move.b	#id_TailsSpecial,(v_ost_player2+ost_id).w ; load Special Stage Tails

	.dont_load_tails:
		move.b	#id_HUDSpecial,(v_ss_hud+ost_id).w	; load Special Stage HUD
		move.b	#id_StartBannerSpecial,(v_ss_start_banner+ost_id).w ; load "START" banner
		move.b	#id_RingCountSpecial,(v_ss_number_of_rings+ost_id).w ; load "GET X RINGS" prompt
		move.w	#$80,(v_ss_x_offset).w
		move.w	#$36,(v_ss_y_offset).w
		bsr.w	SS_LoadBackground
		bsr.w	SS_LoadPlayerArt
		bsr.w	SS_LoadPalAndData
		move.l	#$C0000,(v_ss_new_speed_factor).w
		clr.w	(v_joypad_hold).w
		clr.w	(v_joypad2_hold).w

	.draw_initial_1:
		move.b	#id_VBlank_SpecialStage,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.b	(v_ss_track_drawing_index).w,d0
		bne.s	.draw_initial_1

		bsr.w	SS_DrawTrack

	.draw_initial_2:
		move.b	#id_VBlank_SpecialStage,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		bsr.w	SS_DrawTrack
		bsr.w	SS_LoadCurrentPerspective
		bsr.w	SS_ObjectsManager
		move.b	(v_ss_track_duration_timer).w,d0
		subq.w	#1,d0
		bne.s	.draw_initial_2

		jsr	(loc_3561E).l				; Obj5A_CreateRingsToGoText
		bsr.w	SS_ScrollBG
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		move.b	#id_VBlank_DMA,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	#mus_SpecialStage,d0
		bsr.w	PlayMusic
		enable_display
		bsr.w	PaletteWhiteIn

; ---------------------------------------------------------------------------
; Initial Special Stage loop (while START banner is displayed)
; ---------------------------------------------------------------------------

SpecialStage_StartLoop:
		bsr.w	PauseGame
		move.w	(v_joypad_hold_actual).w,(v_joypad_hold).w
		move.w	(v_joypad2_hold_actual).w,(v_joypad2_hold).w
		cmpi.b	#id_SpecialStage,(v_gamemode).w
		bne.w	loc_541A
		move.b	#id_VBlank_SpecialStage,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		bsr.w	SS_DrawTrack
		bsr.w	SS_SetGeoOffsets
		bsr.w	SS_LoadCurrentPerspective
		bsr.w	SS_ObjectsManager
		bsr.w	SS_ScrollBG
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		tst.b	(f_ss_started).w			; is start banner still displayed?
		beq.s	SpecialStage_StartLoop			; if so, loop

		moveq	#id_PLC_SpecialStageBombs,d0		; load SS bomb graphics
		bsr.w	AddPLC

; ---------------------------------------------------------------------------
; Main Special Stage loop (once START banner has unloaded)
; ---------------------------------------------------------------------------

SpecialStage_MainLoop:
		bsr.w	PauseGame
		cmpi.b	#id_SpecialStage,(v_gamemode).w
		bne.w	loc_541A
		move.b	#id_VBlank_SpecialStage,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		bsr.w	SS_DrawTrack
		bsr.w	SS_SetGeoOffsets
		bsr.w	SS_LoadCurrentPerspective
		bsr.w	SS_ObjectsManager
		bsr.w	SS_ScrollBG
		bsr.w	SS_PaletteCycle
		tst.b	(f_ss_pause_only).w
		beq.s	loc_52A0
		move.w	(v_joypad_hold_actual).w,d0
		andi.w	#-$7F80,d0
		move.w	d0,(v_joypad_hold).w
		move.w	(v_joypad2_hold_actual).w,d0
		andi.w	#-$7F80,d0
		move.w	d0,(v_joypad2_hold).w
		bra.s	loc_52AC
; ===========================================================================

loc_52A0:
		move.w	(v_joypad_hold_actual).w,(v_joypad_hold).w
		move.w	(v_joypad2_hold_actual).w,(v_joypad2_hold).w

loc_52AC:
		jsr	(ExecuteObjects).l
		tst.b	(f_ss_chk_rings).w
		bne.s	loc_52C4
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		bra.s	SpecialStage_MainLoop
; ===========================================================================

loc_52C4:
		andi.b	#countof_emeralds,(v_emeralds).w
		tst.b	(f_ss_2p).w
		beq.s	loc_52E2
		lea	(v_ss_2p_ring_buffer).w,a0
		move.w	(a0)+,d0
		rept 5
		add.w	(a0)+,d0
		endr
		bra.s	loc_52EA
; ===========================================================================

loc_52E2:
		move.w	(v_rings).w,d0
		add.w	(v_rings_p2).w,d0

loc_52EA:
		cmp.w	(v_ss_perfect_rings_left).w,d0
		bne.s	loc_52F4
		st.b	(f_ss_perfect).w

loc_52F4:
		bsr.w	PaletteWhiteOut
		tst.w	(f_two_player_mode_copy).w
		bne.w	loc_540C
		disable_ints
		lea	(vdp_control_port).l,a6
		move.w	#vdp_fg_nametable+(vram_menu_fg>>10),(a6)
		move.w	#vdp_bg_nametable+(vram_bg>>13),(a6)
		move.w	#vdp_plane_width_64|vdp_plane_height_32,(a6)
		move.w	#vdp_320px_screen_width,(a6)
		bsr.w	ClearScreen
		jsrto	HUD_Base,JmpTo_HUD_Base
		reset_dma_queue
		enable_ints
		moveq	#$27,d0
		bsr.w	PalLoad_Now
		moveq	#0,d0
		bsr.w	NewPLC
		move.l	#$40400000,d0
		lea	SS_ResultsLetters(pc),a0
		jsrto	LoadTitleCardSS,JmpTo_LoadTitleCardSS
		move.l	#$72000002,(vdp_control_port).l
		lea	(Nem_SpecialStageResults).l,a0
		bsr.w	NemDec
		move.w	(v_player_mode).w,d0
		beq.s	loc_5374
		subq.w	#1,d0
		beq.s	loc_5370
		clr.w	(v_rings).w
		bra.s	loc_5374
; ===========================================================================

loc_5370:
		clr.w	(v_rings_p2).w

loc_5374:
		move.w	(v_rings).w,(v_bonus_count_1).w
		move.w	(v_rings_p2).w,(v_bonus_count_2).w
		clr.w	(v_total_bonus_countdown).w
		tst.b	(f_got_emerald).w
		beq.s	loc_5390
		move.w	#$3E8,(v_total_bonus_countdown).w

loc_5390:
		move.b	#1,(f_hud_score_update).w
		move.b	#1,(f_pass_bonus_update).w
		move.w	#$9A,d0
		jsr	(PlaySound).l
		lea	(v_sprite_queue).w,a1
		moveq	#0,d0
		move.w	#$FF,d1

loc_53B0:
		move.l	d0,(a1)+
		dbf	d1,loc_53B0
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

loc_53C0:
		move.l	d0,(a1)+
		dbf	d1,loc_53C0
		move.b	#$6F,($FFFFB800).w

loc_53CC:
		move.b	#8,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		tst.w	(f_restart).w
		beq.s	loc_53CC
		tst.l	(v_plc_buffer).w
		bne.s	loc_53CC
		move.w	#$CA,d0
		bsr.w	PlaySound
		bsr.w	PaletteWhiteOut
		tst.w	(f_two_player_mode_copy).w
		bne.s	loc_540C
		move.b	#$C,(v_gamemode).w
		rts
; ===========================================================================

loc_540C:
		move.w	#3,(v_results_screen_2p).w
		move.b	#$18,(v_gamemode).w
		rts
; ===========================================================================

loc_541A:
		move.b	#-1,($FFFFFFE0).w
		move.b	#8,(v_vblank_routine).w
		bra.w	WaitForVBlank
; ===========================================================================

		incfile	Pal_SpecialStageStars			; loc_542A: Pal_UNK8:

; ===========================================================================

SS_PaletteCycle:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#3,d0
		bne.s	loc_5470
		move.b	(v_ss_star_color_1).w,d0
		addi_.b	#1,(v_ss_star_color_1).w
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Pal_SpecialStageStars(pc,d0.w),($FFFFFB1C).w
		move.b	(v_ss_star_color_2).w,d0
		addi_.b	#1,(v_ss_star_color_2).w
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Pal_SpecialStageStars(pc,d0.w),($FFFFFB1E).w

loc_5470:
		cmpi.b	#6,(v_special_stage).w
		bne.s	loc_5482
		cmpi.b	#3,(v_special_act).w
		beq.w	loc_54DC

loc_5482:
		tst.b	(f_ss_checkpoint_rainbow).w
		beq.s	locret_54BA
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#7,d0
		bne.s	locret_54BA
		move.b	(v_ss_rainbow_palette).w,d0
		addi_.b	#1,(v_ss_rainbow_palette).w
		andi.b	#3,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.w	word_54C4(pc,d0.w),($FFFFFB76).w
		move.w	word_54C6(pc,d0.w),($FFFFFB78).w
		move.w	word_54C8(pc,d0.w),($FFFFFB7A).w

locret_54BA:
		rts
; ===========================================================================
word_54BC:	dc.w   $EE,  $C0,  $EE,	 $C0			; 0
word_54C4:	dc.w   $EE					; 0
word_54C6:	dc.w   $CC					; 0
word_54C8:	dc.w   $88,  $E0,  $C0,	 $80, $EE0, $CC0, $880,	$E0E, $C0C, $808 ; 0
; ===========================================================================

loc_54DC:
		tst.b	(f_ss_pause_only).w
		beq.s	loc_5482
		moveq	#0,d0
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#1,d0
		bne.w	loc_5482
		move.w	(v_rings).w,d2
		add.w	(v_rings_p2).w,d2
		cmp.w	(v_ss_ring_requirement).w,d2
		blt.w	loc_5482
		lea	($FFFFFB02).w,a0
		movea.l	a0,a1
		move.w	(a0)+,d0
		moveq	#$B,d1

loc_550A:
		move.w	(a0)+,(a1)+
		dbf	d1,loc_550A
		move.w	d0,(a1)
		rts
; ===========================================================================

SS_LoadCurrentPerspective:
		cmpi.b	#4,(v_ss_track_drawing_index).w
		bne.s	locret_5532
		movea.l	#v_ss_perspective_data,a0
		moveq	#0,d0
		move.b	(v_ss_track_mapping_frame).w,d0
		add.w	d0,d0
		adda.w	(a0,d0.w),a0
		move.l	a0,(v_ss_ctrl_record_buffer_end).w

locret_5532:
		rts
; ===========================================================================

SS_ObjectsManager:
		cmpi.b	#4,(v_ss_track_drawing_index).w
		bne.w	locret_55DC
		moveq	#0,d0
		move.b	(v_ss_current_segment).w,d0
		cmp.b	(v_ss_last_segment_2).w,d0
		beq.w	locret_55DC
		move.b	d0,(v_ss_last_segment_2).w
		movea.l	(v_ss_current_layout).w,a1
		move.b	(a1,d0.w),d3
		andi.w	#$7F,d3
		lea	(byte_55FE).l,a0
		move.b	(a0,d3.w),d3
		add.w	d3,d3
		add.w	d3,d3
		movea.l	(v_ss_current_obj_locations).w,a0

loc_556E:
		bsr.w	FindFreeObjSpecial
		bne.s	locret_55DC
		moveq	#0,d0
		move.b	(a0)+,d0
		bmi.s	loc_55B2
		move.b	d0,d1
		andi.b	#$40,d1
		bne.s	loc_559A
		addq.w	#1,(v_ss_perfect_rings_left).w
		move.b	#id_RingsSpecial,ost_id(a1)
		add.w	d0,d0
		add.w	d0,d0
		add.w	d3,d0
		move.w	d0,$30(a1)
		move.b	(a0)+,ost_angle(a1)
		bra.s	loc_556E
; ===========================================================================

loc_559A:
		andi.w	#$3F,d0
		move.b	#id_BombSpecial,ost_id(a1)
		add.w	d0,d0
		add.w	d0,d0
		add.w	d3,d0
		move.w	d0,$30(a1)
		move.b	(a0)+,ost_angle(a1)
		bra.s	loc_556E
; ===========================================================================

loc_55B2:
		move.l	a0,(v_ss_current_obj_locations).w
		addq.b	#1,d0
		beq.s	locret_55DC
		addq.b	#1,d0
		beq.s	loc_55D8
		addq.b	#1,d0
		beq.s	loc_55CC
		st.b	(f_ss_no_checkpoint).w
		sf.b	(f_ss_no_checkpoint_msg).w
		bra.s	loc_55D8
; ===========================================================================

loc_55CC:
		tst.b	(f_ss_2p).w
		bne.s	loc_55D8
		move.b	#id_EmeraldSpecial,ost_id(a1)
		rts
; ===========================================================================

loc_55D8:
		move.b	#id_MessageSpecial,ost_id(a1)

locret_55DC:
		rts

; ===========================================================================
dword_55DE:
		dc.l $40000002					; 0
		dc.l $47000002					; 1
		dc.l $4E000002					; 2
		dc.l $55000002					; 3
		dc.l $40000003					; 4
		dc.l $47000003					; 5
		dc.l $4E000003					; 6
		dc.l $55000003					; 7
byte_55FE:
		dc.b $18					; 0
		dc.b $18					; 1
		dc.b  $C					; 2
		dc.b $10					; 3
		dc.b  $B					; 4
		dc.b   0					; 5

; ===========================================================================

SS_DrawTrack:
		moveq	#0,d0
		move.b	(v_ss_track_drawing_index).w,d0
		cmpi.b	#4,d0
		bge.w	loc_6C0A
		add.w	d0,d0
		add.w	d0,d0
		bne.w	loc_56D2
		move.l	(v_ss_track_last_mappings).w,(v_ss_track_last_mappings_copy).w
		move.b	(v_ss_track_mapping_frame).w,(v_ss_track_last_mapping_frame).w
		moveq	#0,d1
		moveq	#0,d2
		moveq	#0,d3
		moveq	#0,d4
		move.b	(v_ss_current_segment).w,d1
		move.b	(v_ss_track_anim_frame).w,d2
		movea.l	(v_ss_current_layout).w,a1
		move.b	(a1,d1.w),d3
		andi.b	#$7F,d3
		move.b	d3,(v_ss_track_anim).w
		move.w	d3,d1
		add.w	d3,d3
		lea	(Ani_SpecialStageTrack).l,a1
		adda.w	(a1,d3.w),a1
		adda.w	d2,a1
		moveq	#0,d4
		move.b	(a1),d4
		move.b	d4,(v_ss_track_mapping_frame).w
		lsl.w	#2,d4
		lea	(off_643E).l,a1
		movea.l	(a1,d4.w),a0
		movea.l	a0,a1
		moveq	#0,d2
		move.b	(a0)+,d2
		move.b	(a0)+,d2
		move.b	(a0)+,d2
		lsl.w	#8,d2
		move.b	(a0)+,d2
		addq.w	#4,d2
		adda.w	d2,a1
		movea.l	a1,a2
		moveq	#0,d2
		move.b	(a1)+,d2
		move.b	(a1)+,d2
		move.b	(a1)+,d2
		lsl.w	#8,d2
		move.b	(a1)+,d2
		addq.w	#4,d2
		adda.w	d2,a2
		move.b	(a2)+,d2
		move.b	(a2)+,d2
		move.b	(a2)+,d2
		move.b	(a2)+,d2
		move.l	a0,(v_ss_track_mappings_bitflags).w
		move.l	a0,(v_ss_track_last_mappings).w
		move.l	a1,(v_ss_track_mappings_uncompressed).w
		move.l	a2,(v_ss_track_mappings_rle).w
		lea_	byte_55FE,a4
		move.b	(a4,d1.w),d2
		move.b	(v_ss_track_anim_frame).w,(v_ss_track_last_anim_frame).w
		addi_.b	#1,(v_ss_track_anim_frame).w
		cmp.b	(v_ss_track_anim_frame).w,d2
		bne.s	loc_56D2
		move.b	#0,(v_ss_track_anim_frame).w
		move.b	(v_ss_current_segment).w,(v_ss_last_segment).w
		addi_.b	#1,(v_ss_current_segment).w

loc_56D2:
		tst.b	(f_ss_alternate_fg_table).w
		beq.s	loc_56DC
		addi.w	#$10,d0

loc_56DC:
		lea_	dword_55DE,a3
		movea.l	(a3,d0.w),a3
		move.l	a3,(vdp_control_port).l
		lea	(vdp_data_port).l,a6
		bsr.w	loc_6C0A
		movea.l	(v_ss_track_mappings_bitflags).w,a0
		movea.l	(v_ss_track_mappings_uncompressed).w,a1
		movea.l	(v_ss_track_mappings_rle).w,a2
		lea	(v_ss_draw_reg_buffer).w,a3
		movem.w	(a3)+,d2-d7
		lea	(word_651E).l,a3
		lea	(byte_69E6).l,a4
		movea.w	#$FFF8,a5
		moveq	#0,d0
		tst.b	(v_ss_track_orientation).w
		bne.w	loc_5D8A

loc_5722:
		adda_.w	#1,a5
		cmpa.w	#0,a5
		beq.w	loc_5D58

loc_572E:
		moveq	#0,d1
		subq.w	#1,d7
		bpl.s	loc_5738
		move.b	(a0)+,d6
		moveq	#7,d7

loc_5738:
		add.b	d6,d6
		bcc.s	loc_5788
		subq.b	#1,d5
		bpl.s	loc_5744
		move.b	(a1)+,d4
		moveq	#7,d5

loc_5744:
		add.b	d4,d4
		bcc.s	loc_5768
		moveq	#$A,d0
		sub.b	d5,d0
		subq.b	#3,d0
		add.w	d0,d0
		move.w	off_5758(pc,d0.w),d0
		jmp	off_5758(pc,d0.w)
; ===========================================================================
off_5758:	index offset(*)
		ptr loc_58FE					; 0
		ptr loc_58D4					; 1
		ptr loc_58AA					; 2
		ptr loc_5880					; 3
		ptr loc_5856					; 4
		ptr loc_5836					; 5
		ptr loc_5806					; 6
		ptr loc_57DE					; 7
; ===========================================================================

loc_5768:
		moveq	#6,d0
		sub.b	d5,d0
		addq.b	#1,d0
		add.w	d0,d0
		move.w	off_5778(pc,d0.w),d0
		jmp	off_5778(pc,d0.w)
; ===========================================================================
off_5778:	index offset(*)
		ptr loc_5A1A					; 0
		ptr loc_5A02					; 1
		ptr loc_59DC					; 2
		ptr loc_59B6					; 3
		ptr loc_5990					; 4
		ptr loc_596A					; 5
		ptr loc_5944					; 6
		ptr loc_5928					; 7
; ===========================================================================
; SSTrackDrawUnc_Read10LUT:
loc_5788:
		subq.b	#1,d3
		bpl.s	loc_579C
		move.b	(a2)+,d2
		cmpi.b	#-1,d2
		bne.s	loc_579A
		moveq	#0,d3
		bra.w	loc_5722
; ===========================================================================

loc_579A:
		moveq	#7,d3

loc_579C:
		add.b	d2,d2
		bcc.s	loc_57BE
		moveq	#7,d0
		sub.b	d3,d0
		add.b	d0,d0
		move.w	off_57AE(pc,d0.w),d0
		jmp	off_57AE(pc,d0.w)
; ===========================================================================
; SSTrackDrawUnc_Read6LUT:
off_57AE:	index offset(*)
		ptr loc_5BCE					; 0
		ptr loc_5B92					; 1
		ptr loc_5B56					; 2
		ptr loc_5B1A					; 3
		ptr loc_5ADE					; 4
		ptr loc_5AA2					; 5
		ptr loc_5A66					; 6
		ptr loc_5A34					; 7
; ===========================================================================

loc_57BE:
		moveq	#6,d0
		sub.b	d3,d0
		addq.b	#1,d0
		add.b	d0,d0
		move.w	off_57CE(pc,d0.w),d0
		jmp	off_57CE(pc,d0.w)
; ===========================================================================
; SSTrackDrawRLE_Read7LUT:
off_57CE:	index offset(*)
		ptr loc_5D34					; 0
		ptr loc_5D12					; 1
		ptr loc_5CE2					; 2
		ptr loc_5CB2					; 3
		ptr loc_5C82					; 4
		ptr loc_5C52					; 5
		ptr loc_5C22					; 6
		ptr loc_5BFC					; 7
; ===========================================================================

loc_57DE:
		moveq	#0,d0
		move.b	(a1)+,d0
		lsl.w	#2,d0
		move.b	(a1)+,d4
		rol.b	#2,d4
		move.b	d4,d1
		andi.b	#3,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#6,d5
		bra.w	loc_572E
; ===========================================================================

loc_5806:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$200,d0
		move.b	(a1)+,d1
		lsl.w	#1,d1
		or.w	d1,d0
		move.b	(a1)+,d4
		rol.b	#1,d4
		move.b	d4,d1
		andi.b	#1,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#7,d5
		bra.w	loc_572E
; ===========================================================================

loc_5836:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$300,d0
		move.b	(a1)+,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#0,d5
		bra.w	loc_572E
; ===========================================================================

loc_5856:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$380,d0
		move.b	(a1)+,d4
		ror.b	#1,d4
		move.b	d4,d1
		andi.b	#$7F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#1,d5
		bra.w	loc_572E
; ===========================================================================

loc_5880:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3C0,d0
		move.b	(a1)+,d4
		ror.b	#2,d4
		move.b	d4,d1
		andi.b	#$3F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#2,d5
		bra.w	loc_572E
; ===========================================================================

loc_58AA:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3E0,d0
		move.b	(a1)+,d4
		ror.b	#3,d4
		move.b	d4,d1
		andi.b	#$1F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#3,d5
		bra.w	loc_572E
; ===========================================================================

loc_58D4:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3F0,d0
		move.b	(a1)+,d4
		ror.b	#4,d4
		move.b	d4,d1
		andi.b	#$F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#4,d5
		bra.w	loc_572E
; ===========================================================================

loc_58FE:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3F8,d0
		move.b	(a1)+,d4
		rol.b	#3,d4
		move.b	d4,d1
		andi.b	#7,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#5,d5
		bra.w	loc_572E
; ===========================================================================

loc_5928:
		move.b	(a1)+,d4
		ror.b	#2,d4
		move.b	d4,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#$6000,d0
		move.w	d0,(a6)
		moveq	#2,d5
		bra.w	loc_572E
; ===========================================================================

loc_5944:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$20,d0
		move.b	(a1)+,d4
		ror.b	#3,d4
		move.b	d4,d1
		andi.b	#$1F,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#3,d5
		bra.w	loc_572E
; ===========================================================================

loc_596A:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$30,d0
		move.b	(a1)+,d4
		ror.b	#4,d4
		move.b	d4,d1
		andi.b	#$F,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#4,d5
		bra.w	loc_572E
; ===========================================================================

loc_5990:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$38,d0
		move.b	(a1)+,d4
		rol.b	#3,d4
		move.b	d4,d1
		andi.b	#7,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#5,d5
		bra.w	loc_572E
; ===========================================================================

loc_59B6:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$3C,d0
		move.b	(a1)+,d4
		rol.b	#2,d4
		move.b	d4,d1
		andi.b	#3,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#6,d5
		bra.w	loc_572E
; ===========================================================================

loc_59DC:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$3E,d0
		move.b	(a1)+,d4
		rol.b	#1,d4
		move.b	d4,d1
		andi.b	#1,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#7,d5
		bra.w	loc_572E
; ===========================================================================

loc_5A02:
		lsr.b	#2,d4
		andi.w	#$3F,d4
		add.w	d4,d4
		move.w	(a3,d4.w),d4
		ori.w	#tile_pal4,d4
		move.w	d4,(a6)
		moveq	#0,d5
		bra.w	loc_572E
; ===========================================================================

loc_5A1A:
		ror.b	#2,d4
		move.b	d4,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		ori.w	#tile_pal4,d0
		move.w	d0,(a6)
		moveq	#1,d5
		bra.w	loc_572E
; ===========================================================================

loc_5A34:
		move.b	(a2)+,d2
		ror.b	#1,d2
		move.b	d2,d0
		andi.w	#$7F,d0
		moveq	#1,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5A5C:
		move.w	d1,(a6)
		dbf	d0,loc_5A5C
		bra.w	loc_572E
; ===========================================================================

loc_5A66:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$40,d1
		move.b	(a2)+,d2
		ror.b	#2,d2
		move.b	d2,d0
		andi.w	#$3F,d0
		or.b	d1,d0
		moveq	#2,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5A98:
		move.w	d1,(a6)
		dbf	d0,loc_5A98
		bra.w	loc_572E
; ===========================================================================

loc_5AA2:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$60,d1
		move.b	(a2)+,d2
		ror.b	#3,d2
		move.b	d2,d0
		andi.w	#$1F,d0
		or.b	d1,d0
		moveq	#3,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5AD4:
		move.w	d1,(a6)
		dbf	d0,loc_5AD4
		bra.w	loc_572E
; ===========================================================================

loc_5ADE:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$70,d1
		move.b	(a2)+,d2
		ror.b	#4,d2
		move.b	d2,d0
		andi.w	#$F,d0
		or.b	d1,d0
		moveq	#4,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5B10:
		move.w	d1,(a6)
		dbf	d0,loc_5B10
		bra.w	loc_572E
; ===========================================================================

loc_5B1A:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$78,d1
		move.b	(a2)+,d2
		rol.b	#3,d2
		move.b	d2,d0
		andi.w	#7,d0
		or.b	d1,d0
		moveq	#5,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5B4C:
		move.w	d1,(a6)
		dbf	d0,loc_5B4C
		bra.w	loc_572E
; ===========================================================================

loc_5B56:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$7C,d1
		move.b	(a2)+,d2
		rol.b	#2,d2
		move.b	d2,d0
		andi.w	#3,d0
		or.b	d1,d0
		moveq	#6,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5B88:
		move.w	d1,(a6)
		dbf	d0,loc_5B88
		bra.w	loc_572E
; ===========================================================================

loc_5B92:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$7E,d1
		move.b	(a2)+,d2
		rol.b	#1,d2
		move.b	d2,d0
		andi.w	#1,d0
		or.b	d1,d0
		moveq	#7,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5722
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5BC4:
		move.w	d1,(a6)
		dbf	d0,loc_5BC4
		bra.w	loc_572E
; ===========================================================================

loc_5BCE:
		lsr.b	#1,d2
		andi.w	#$7F,d2
		moveq	#0,d3
		cmpi.b	#$7F,d2
		beq.w	loc_5722
		addi.w	#$40,d2
		add.w	d2,d2
		add.w	d2,d2
		move.w	(a4,d2.w),d1
		move.w	2(a4,d2.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5BF2:
		move.w	d1,(a6)
		dbf	d0,loc_5BF2
		bra.w	loc_572E
; ===========================================================================

loc_5BFC:
		move.b	(a2)+,d2
		ror.b	#2,d2
		move.b	d2,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#2,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5C18:
		move.w	d1,(a6)
		dbf	d0,loc_5C18
		bra.w	loc_572E
; ===========================================================================

loc_5C22:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$20,d0
		move.b	(a2)+,d2
		ror.b	#3,d2
		move.b	d2,d1
		andi.b	#$1F,d1
		or.b	d1,d0
		moveq	#3,d3
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5C48:
		move.w	d1,(a6)
		dbf	d0,loc_5C48
		bra.w	loc_572E
; ===========================================================================

loc_5C52:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$30,d0
		move.b	(a2)+,d2
		ror.b	#4,d2
		move.b	d2,d1
		andi.b	#$F,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#4,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5C78:
		move.w	d1,(a6)
		dbf	d0,loc_5C78
		bra.w	loc_572E
; ===========================================================================

loc_5C82:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$38,d0
		move.b	(a2)+,d2
		rol.b	#3,d2
		move.b	d2,d1
		andi.b	#7,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#5,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5CA8:
		move.w	d1,(a6)
		dbf	d0,loc_5CA8
		bra.w	loc_572E
; ===========================================================================

loc_5CB2:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$3C,d0
		move.b	(a2)+,d2
		rol.b	#2,d2
		move.b	d2,d1
		andi.b	#3,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#6,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5CD8:
		move.w	d1,(a6)
		dbf	d0,loc_5CD8
		bra.w	loc_572E
; ===========================================================================

loc_5CE2:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$3E,d0
		move.b	(a2)+,d2
		rol.b	#1,d2
		move.b	d2,d1
		andi.b	#1,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#7,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5D08:
		move.w	d1,(a6)
		dbf	d0,loc_5D08
		bra.w	loc_572E
; ===========================================================================

loc_5D12:
		lsr.b	#2,d2
		andi.w	#$3F,d2
		add.w	d2,d2
		add.w	d2,d2
		moveq	#0,d3
		move.w	(a4,d2.w),d1
		move.w	2(a4,d2.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5D2A:
		move.w	d1,(a6)
		dbf	d0,loc_5D2A
		bra.w	loc_572E
; ===========================================================================

loc_5D34:
		ror.b	#2,d2
		move.b	d2,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#1,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#tile_pal4|tile_hi,d1

loc_5D4E:
		move.w	d1,(a6)
		dbf	d0,loc_5D4E
		bra.w	loc_572E
; ===========================================================================

loc_5D58:
		cmpi.b	#3,(v_ss_track_drawing_index).w
		beq.s	loc_5D76
		move.l	a0,(v_ss_track_mappings_bitflags).w
		move.l	a1,(v_ss_track_mappings_uncompressed).w
		move.l	a2,(v_ss_track_mappings_rle).w
		lea	(v_ss_draw_reg_buffer_end).w,a3
		movem.w	d2-d7,-(a3)
		rts
; ===========================================================================

loc_5D76:
		lea	(v_ss_draw_reg_buffer).w,a2
		moveq	#0,d0
		rept 6
		move.w	d0,(a2)+
		endr
		rts
; ===========================================================================

loc_5D8A:
		adda_.w	#1,a5
		cmpa.w	#0,a5
		beq.w	loc_5D58
		lea	($FFFFD000).w,a6
		swap	d0
		addi.w	#$100,d0
		andi.w	#$F00,d0
		adda.w	d0,a6
		swap	d0

loc_5DA8:
		moveq	#0,d1
		subq.w	#1,d7
		bpl.s	loc_5DB2
		move.b	(a0)+,d6
		moveq	#7,d7

loc_5DB2:
		add.b	d6,d6
		bcc.s	loc_5E06
		subq.b	#1,d5
		bpl.s	loc_5DBE
		move.b	(a1)+,d4
		moveq	#7,d5

loc_5DBE:
		add.b	d4,d4
		bcc.s	loc_5DE4
		move.w	#$A,d0
		sub.b	d5,d0
		subq.b	#3,d0
		add.w	d0,d0
		move.w	off_5DD4(pc,d0.w),d0
		jmp	off_5DD4(pc,d0.w)
; ===========================================================================
off_5DD4:	index offset(*)
		ptr loc_5F82					; 0
		ptr loc_5F58					; 1
		ptr loc_5F2E					; 2
		ptr loc_5F04					; 3
		ptr loc_5EDA					; 4
		ptr loc_5EBA					; 5
		ptr loc_5E8A					; 6
		ptr loc_5E60					; 7
; ===========================================================================

loc_5DE4:
		move.w	#6,d0
		sub.b	d5,d0
		addq.b	#1,d0
		add.w	d0,d0
		move.w	off_5DF6(pc,d0.w),d0
		jmp	off_5DF6(pc,d0.w)
; ===========================================================================
off_5DF6:	index offset(*)
		ptr loc_609E					; 0
		ptr loc_6086					; 1
		ptr loc_6060					; 2
		ptr loc_603A					; 3
		ptr loc_6014					; 4
		ptr loc_5FEE					; 5
		ptr loc_5FC8					; 6
		ptr loc_5FAC					; 7
; ===========================================================================

loc_5E06:
		subq.b	#1,d3
		bpl.s	loc_5E1A
		move.b	(a2)+,d2
		cmpi.b	#-1,d2
		bne.s	loc_5E18
		moveq	#0,d3
		bra.w	loc_5D8A
; ===========================================================================

loc_5E18:
		moveq	#7,d3

loc_5E1A:
		add.b	d2,d2
		bcc.s	loc_5E3E
		move.w	#7,d0
		sub.b	d3,d0
		add.b	d0,d0
		move.w	off_5E2E(pc,d0.w),d0
		jmp	off_5E2E(pc,d0.w)
; ===========================================================================
off_5E2E:	index offset(*)
		ptr	loc_6252				; 0
		ptr loc_6216					; 1
		ptr loc_61DA					; 2
		ptr loc_619E					; 3
		ptr loc_6162					; 4
		ptr loc_6126					; 5
		ptr loc_60EA					; 6
		ptr loc_60B8					; 7
; ===========================================================================

loc_5E3E:
		move.w	#6,d0
		sub.b	d3,d0
		addq.b	#1,d0
		add.b	d0,d0
		move.w	off_5E50(pc,d0.w),d0
		jmp	off_5E50(pc,d0.w)
; ===========================================================================
off_5E50:	index offset(*)
		ptr loc_63B8					; 0
		ptr loc_6396					; 1
		ptr loc_6366					; 2
		ptr loc_6336					; 3
		ptr loc_6306					; 4
		ptr loc_62D6					; 5
		ptr loc_62A6					; 6
		ptr loc_6280					; 7
; ===========================================================================

loc_5E60:
		move.w	#0,d0
		move.b	(a1)+,d0
		lsl.w	#2,d0
		move.b	(a1)+,d4
		rol.b	#2,d4
		move.b	d4,d1
		andi.b	#3,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#6,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5E8A:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$200,d0
		move.b	(a1)+,d1
		lsl.w	#1,d1
		or.w	d1,d0
		move.b	(a1)+,d4
		rol.b	#1,d4
		move.b	d4,d1
		andi.b	#1,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#7,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5EBA:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$300,d0
		move.b	(a1)+,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#0,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5EDA:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$380,d0
		move.b	(a1)+,d4
		ror.b	#1,d4
		move.b	d4,d1
		andi.b	#$7F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#1,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5F04:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3C0,d0
		move.b	(a1)+,d4
		ror.b	#2,d4
		move.b	d4,d1
		andi.b	#$3F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#2,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5F2E:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3E0,d0
		move.b	(a1)+,d4
		ror.b	#3,d4
		move.b	d4,d1
		andi.b	#$1F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#3,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5F58:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3F0,d0
		move.b	(a1)+,d4
		ror.b	#4,d4
		move.b	d4,d1
		andi.b	#$F,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#4,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5F82:
		move.b	d4,d0
		lsl.w	#2,d0
		andi.w	#$3F8,d0
		move.b	(a1)+,d4
		rol.b	#3,d4
		move.b	d4,d1
		andi.b	#7,d1
		or.b	d1,d0
		addi.w	#$40,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#5,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5FAC:
		move.b	(a1)+,d4
		ror.b	#2,d4
		move.b	d4,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#2,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5FC8:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$20,d0
		move.b	(a1)+,d4
		ror.b	#3,d4
		move.b	d4,d1
		andi.b	#$1F,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#3,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_5FEE:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$30,d0
		move.b	(a1)+,d4
		ror.b	#4,d4
		move.b	d4,d1
		andi.b	#$F,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#4,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_6014:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$38,d0
		move.b	(a1)+,d4
		rol.b	#3,d4
		move.b	d4,d1
		andi.b	#7,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#5,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_603A:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$3C,d0
		move.b	(a1)+,d4
		rol.b	#2,d4
		move.b	d4,d1
		andi.b	#3,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#6,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_6060:
		move.b	d4,d0
		lsr.b	#2,d0
		andi.w	#$3E,d0
		move.b	(a1)+,d4
		rol.b	#1,d4
		move.b	d4,d1
		andi.b	#1,d1
		or.b	d1,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#7,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_6086:
		lsr.b	#2,d4
		andi.w	#$3F,d4
		add.w	d4,d4
		move.w	(a3,d4.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#0,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_609E:
		ror.b	#2,d4
		move.b	d4,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		move.w	(a3,d0.w),d0
		eori.w	#$6800,d0
		move.w	d0,-(a6)
		moveq	#1,d5
		bra.w	loc_5DA8
; ===========================================================================

loc_60B8:
		move.b	(a2)+,d2
		ror.b	#1,d2
		move.b	d2,d0
		andi.w	#$7F,d0
		moveq	#1,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_60E0:
		move.w	d1,-(a6)
		dbf	d0,loc_60E0
		bra.w	loc_5DA8
; ===========================================================================

loc_60EA:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$40,d1
		move.b	(a2)+,d2
		ror.b	#2,d2
		move.b	d2,d0
		andi.w	#$3F,d0
		or.b	d1,d0
		moveq	#2,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_611C:
		move.w	d1,-(a6)
		dbf	d0,loc_611C
		bra.w	loc_5DA8
; ===========================================================================

loc_6126:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$60,d1
		move.b	(a2)+,d2
		ror.b	#3,d2
		move.b	d2,d0
		andi.w	#$1F,d0
		or.b	d1,d0
		moveq	#3,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_6158:
		move.w	d1,-(a6)
		dbf	d0,loc_6158
		bra.w	loc_5DA8
; ===========================================================================

loc_6162:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$70,d1
		move.b	(a2)+,d2
		ror.b	#4,d2
		move.b	d2,d0
		andi.w	#$F,d0
		or.b	d1,d0
		moveq	#4,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_6194:
		move.w	d1,-(a6)
		dbf	d0,loc_6194
		bra.w	loc_5DA8
; ===========================================================================

loc_619E:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$78,d1
		move.b	(a2)+,d2
		rol.b	#3,d2
		move.b	d2,d0
		andi.w	#7,d0
		or.b	d1,d0
		moveq	#5,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_61D0:
		move.w	d1,-(a6)
		dbf	d0,loc_61D0
		bra.w	loc_5DA8
; ===========================================================================

loc_61DA:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$7C,d1
		move.b	(a2)+,d2
		rol.b	#2,d2
		move.b	d2,d0
		andi.w	#3,d0
		or.b	d1,d0
		moveq	#6,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_620C:
		move.w	d1,-(a6)
		dbf	d0,loc_620C
		bra.w	loc_5DA8
; ===========================================================================

loc_6216:
		move.b	d2,d1
		lsr.b	#1,d1
		andi.b	#$7E,d1
		move.b	(a2)+,d2
		rol.b	#1,d2
		move.b	d2,d0
		andi.w	#1,d0
		or.b	d1,d0
		moveq	#7,d3
		cmpi.b	#$7F,d0
		beq.w	loc_5D8A
		addi.w	#$40,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_6248:
		move.w	d1,-(a6)
		dbf	d0,loc_6248
		bra.w	loc_5DA8
; ===========================================================================

loc_6252:
		lsr.b	#1,d2
		andi.w	#$7F,d2
		moveq	#0,d3
		cmpi.b	#$7F,d2
		beq.w	loc_5D8A
		addi.w	#$40,d2
		add.w	d2,d2
		add.w	d2,d2
		move.w	(a4,d2.w),d1
		move.w	2(a4,d2.w),d0
		ori.w	#-$2000,d1

loc_6276:
		move.w	d1,-(a6)
		dbf	d0,loc_6276
		bra.w	loc_5DA8
; ===========================================================================

loc_6280:
		move.b	(a2)+,d2
		ror.b	#2,d2
		move.b	d2,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#2,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_629C:
		move.w	d1,-(a6)
		dbf	d0,loc_629C
		bra.w	loc_5DA8
; ===========================================================================

loc_62A6:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$20,d0
		move.b	(a2)+,d2
		ror.b	#3,d2
		move.b	d2,d1
		andi.b	#$1F,d1
		or.b	d1,d0
		moveq	#3,d3
		add.w	d0,d0
		add.w	d0,d0
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_62CC:
		move.w	d1,-(a6)
		dbf	d0,loc_62CC
		bra.w	loc_5DA8
; ===========================================================================

loc_62D6:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$30,d0
		move.b	(a2)+,d2
		ror.b	#4,d2
		move.b	d2,d1
		andi.b	#$F,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#4,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_62FC:
		move.w	d1,-(a6)
		dbf	d0,loc_62FC
		bra.w	loc_5DA8
; ===========================================================================

loc_6306:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$38,d0
		move.b	(a2)+,d2
		rol.b	#3,d2
		move.b	d2,d1
		andi.b	#7,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#5,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_632C:
		move.w	d1,-(a6)
		dbf	d0,loc_632C
		bra.w	loc_5DA8
; ===========================================================================

loc_6336:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$3C,d0
		move.b	(a2)+,d2
		rol.b	#2,d2
		move.b	d2,d1
		andi.b	#3,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#6,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_635C:
		move.w	d1,-(a6)
		dbf	d0,loc_635C
		bra.w	loc_5DA8
; ===========================================================================

loc_6366:
		move.b	d2,d0
		lsr.b	#2,d0
		andi.w	#$3E,d0
		move.b	(a2)+,d2
		rol.b	#1,d2
		move.b	d2,d1
		andi.b	#1,d1
		or.b	d1,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#7,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_638C:
		move.w	d1,-(a6)
		dbf	d0,loc_638C
		bra.w	loc_5DA8
; ===========================================================================

loc_6396:
		lsr.b	#2,d2
		andi.w	#$3F,d2
		add.w	d2,d2
		add.w	d2,d2
		moveq	#0,d3
		move.w	(a4,d2.w),d1
		move.w	2(a4,d2.w),d0
		ori.w	#-$2000,d1

loc_63AE:
		move.w	d1,-(a6)
		dbf	d0,loc_63AE
		bra.w	loc_5DA8
; ===========================================================================

loc_63B8:
		ror.b	#2,d2
		move.b	d2,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		add.w	d0,d0
		moveq	#1,d3
		move.w	(a4,d0.w),d1
		move.w	2(a4,d0.w),d0
		ori.w	#-$2000,d1

loc_63D2:
		move.w	d1,-(a6)
		dbf	d0,loc_63D2
		bra.w	loc_5DA8
; ===========================================================================

Ani_SpecialStageTrack:	index offset(*)
		ptr byte_63E6					; 0
		ptr byte_63FE					; 1
		ptr byte_6416					; 2
		ptr byte_6422					; 3
		ptr byte_6432					; 4

byte_63E6:
		dc.b $26,$27,$28,$29,$2A,$2B,$26		; turning
		dc.b   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, $A, $B, $C, $D, $E, $F,$10 ; rise
		arraysize	byte_63E6

byte_63FE:
		dc.b $26,$27,$28,$29,$2A,$2B,$26		; turning
		dc.b $15,$16,$17,$18,$19,$1A,$1B,$1C,$1D,$1E,$1F,$20,$21,$22,$23,$24,$25 ; drop
		arraysize	byte_63FE

byte_6416:
		dc.b $26,$27,$28,$29,$2A,$2B,$26		; turning
		dc.b $2C,$2D,$2E,$2F,$30			; exit turn
		arraysize	byte_6416

byte_6422:
		dc.b $11,$12,$13,$14,$11,$12,$13,$14		; straight
		dc.b $11,$12,$13,$14,$11,$12,$13,$14		; straight
		arraysize	byte_6422
byte_6432:
		dc.b $11,$12,$13,$14				; straight
		dc.b $31,$32,$33,$34,$35,$36,$37		; enter turn
		arraysize	byte_6432
		even

off_643E:
		dc.l MapSpec_Rise1				; 0
		dc.l MapSpec_Rise2				; 1
		dc.l MapSpec_Rise3				; 2
		dc.l MapSpec_Rise4				; 3
		dc.l MapSpec_Rise5				; 4
		dc.l MapSpec_Rise6				; 5
		dc.l MapSpec_Rise7				; 6
		dc.l MapSpec_Rise8				; 7
		dc.l MapSpec_Rise9				; 8
		dc.l MapSpec_Rise10				; 9
		dc.l MapSpec_Rise11				; 10
		dc.l MapSpec_Rise12				; 11
		dc.l MapSpec_Rise13				; 12
		dc.l MapSpec_Rise14				; 13
		dc.l MapSpec_Rise15				; 14
		dc.l MapSpec_Rise16				; 15
		dc.l MapSpec_Rise17				; 16
		dc.l MapSpec_Straight1				; 17
		dc.l MapSpec_Straight2				; 18
		dc.l MapSpec_Straight3				; 19
		dc.l MapSpec_Straight4				; 20
		dc.l MapSpec_Drop1				; 21
		dc.l MapSpec_Drop2				; 22
		dc.l MapSpec_Drop3				; 23
		dc.l MapSpec_Drop4				; 24
		dc.l MapSpec_Drop5				; 25
		dc.l MapSpec_Drop6				; 26
		dc.l MapSpec_Drop7				; 27
		dc.l MapSpec_Drop8				; 28
		dc.l MapSpec_Drop9				; 29
		dc.l MapSpec_Drop10				; 30
		dc.l MapSpec_Drop11				; 31
		dc.l MapSpec_Drop12				; 32
		dc.l MapSpec_Drop13				; 33
		dc.l MapSpec_Drop14				; 34
		dc.l MapSpec_Drop15				; 35
		dc.l MapSpec_Drop16				; 36
		dc.l MapSpec_Drop17				; 37
		dc.l MapSpec_Turning1				; 38
		dc.l MapSpec_Turning2				; 39
		dc.l MapSpec_Turning3				; 40
		dc.l MapSpec_Turning4				; 41
		dc.l MapSpec_Turning5				; 42
		dc.l MapSpec_Turning6				; 43
		dc.l MapSpec_Unturn1				; 44
		dc.l MapSpec_Unturn2				; 45
		dc.l MapSpec_Unturn3				; 46
		dc.l MapSpec_Unturn4				; 47
		dc.l MapSpec_Unturn5				; 48
		dc.l MapSpec_Turn1				; 49
		dc.l MapSpec_Turn2				; 50
		dc.l MapSpec_Turn3				; 51
		dc.l MapSpec_Turn4				; 52
		dc.l MapSpec_Turn5				; 53
		dc.l MapSpec_Turn6				; 54
		dc.l MapSpec_Turn7				; 55

word_651E:
		dc.w $8001,$8007,$802C,$800B,$8024,$8824,$8039,$882B ; 0
		dc.w $805D,$885D,$802B,$804A,$8049,$8037,$8849,$8045 ; 8
		dc.w $8845,$883A,$8048,$8850,$8036,$8837,$803A,$8050 ; 16
		dc.w $8842,$8042,$8815,$801D,$804B,$8817,$8848,$8836 ; 24
		dc.w $8038,$884B,$8015,$8021,$8017,$8033,$801A,$802A ; 32
		dc.w $805E,$8028,$8030,$8821,$8838,$881A,$8025,$885E ; 40
		dc.w $8825,$8833,$8003,$8814,$8014,$8004,$804E,$8803 ; 48
		dc.w $800C,$882A,$8002,$8051,$8040,$803D,$8019,$8052 ; 56
		dc.w $8009,$805A,$8830,$884E,$8852,$8851,$8809,$8840 ; 64
		dc.w $802F,$885A,$8818,$8034,$8819,$882F,$883D,$803E ; 72
		dc.w $8018,$880C,$8012,$8804,$8026,$8834,$8805,$803B ; 80
		dc.w $883E,$883B,$8000,$8802,$8005,$800D,$8055,$80AF ; 88
		dc.w $801C,$801B,$880D,$8016,$8812,$801F,$8832,$8013 ; 96
		dc.w $8092,$8826,$8010,$804D,$8047,$8892,$8800,$8062 ; 104
		dc.w $8066,$8090,$8008,$887C,$8867,$88F7,$800E,$8060 ; 112
		dc.w $8032,$8094,$881C,$8905,$88B0,$8059,$800F,$8067 ; 120
		dc.w $8068,$8894,$807C,$80B0,$80B1,$8006,$8841,$8087 ; 128
		dc.w $8093,$80CC,$881F,$8868,$8041,$808F,$8890,$80C2 ; 136
		dc.w $8813,$88C2,$805C,$8064,$80D8,$881B,$88CC,$8811 ; 144
		dc.w $8855,$88E2,$88F3,$8044,$88D8,$8085,$80A1,$80C1 ; 152
		dc.w $8119,$8889,$880A,$8822			; 160

		dc.w $803F,$805B,$807F,$8886,$8808,$8080,$8866,$88E0 ; 0
		dc.w $88C1,$8020,$8022,$8054,$80D2,$8859,$88B1,$8860 ; 8
		dc.w $8919,$88A4,$888F,$800A,$8061,$8075,$8095,$80B6 ; 16
		dc.w $80E0,$8810,$8898,$885B,$88D2,$8816,$8053,$8091 ; 24
		dc.w $8096,$80A4,$80DD,$80E6,$887A,$884D,$88E6,$8011 ; 32
		dc.w $8057,$807A,$8086,$809E,$80DA,$8058,$80DC,$80E3 ; 40
		dc.w $8863,$803C,$8056,$8069,$807E,$80AE,$80B5,$80B8 ; 48
		dc.w $80CD,$80FB,$80FF,$885C,$88CD,$8874,$88EA,$88FF ; 56
		dc.w $88B5,$8043,$806C,$8074,$8077,$8089,$8097,$809F ; 64
		dc.w $80A0,$8113,$811B,$8878,$880F,$88E1,$88FB,$8928 ; 72
		dc.w $8063,$8084,$808D,$80CB,$80D7,$80E9,$8128,$8138 ; 80
		dc.w $88AE,$88EC,$8031,$804C,$80E2,$80EA,$8864,$8029 ; 88
		dc.w $802D,$806D,$8078,$8088,$80B4,$80BE,$80CF,$80E1 ; 96
		dc.w $80E4,$8854,$88D6,$88D7,$8861,$892B,$8847,$8035 ; 104
		dc.w $806A,$8072,$8073,$8098,$80D5,$80D6,$8116,$811E ; 112
		dc.w $8126,$8127,$812F,$815D,$8869,$8888,$8875,$8897 ; 120
		dc.w $88B4,$88D1,$88D4,$88D5,$88CB,$88E4,$8891,$8862 ; 128
		dc.w $8806,$88B8,$8065,$806E,$8071,$807D,$80D1,$80E7 ; 136
		dc.w $80F9,$8108,$812E,$814B,$8881,$8885,$8877,$887E ; 144
		dc.w $8895,$88DF,$8887,$886C,$88F5,$8908,$8879,$886D ; 152
		dc.w $892A,$88AA,$801E,$8027,$8046,$805F,$8070,$8079 ; 160
		dc.w $809A,$80AA,$80C3,$80D3,$80D4,$80DE,$80DF,$80F8 ; 168
		dc.w $8100,$8101,$812B,$8133,$8136,$8143,$8151,$882E ; 176
		dc.w $889E,$8899,$88D3,$88DD,$88DE,$88E9,$88EF,$88F0 ; 184
		dc.w $88F8,$8927,$88BE,$8896,$804F,$806F,$8081,$808B ; 192
		dc.w $808E,$809C,$80A3,$80B3,$80C0,$80CE,$80F0,$80F1 ; 200
		dc.w $80F5,$80F7,$8102,$8104,$8105,$8109,$810C,$8114 ; 208
		dc.w $8118,$8120,$8124,$8125,$812A,$8130,$8132,$8137 ; 216
		dc.w $8159,$8165,$883F,$886B,$8880,$8853,$88C6,$88CF ; 224
		dc.w $88D9,$88DC,$8856,$88B6,$88F9,$8902,$8904,$8915 ; 232
		dc.w $886A,$8913,$8872,$8835,$8938,$895D,$8943,$8023 ; 240
		dc.w $8076,$807B,$808A,$809D,$80A6,$80A8,$80AC,$80B2 ; 248
		dc.w $80B7,$80BB,$80BC,$80BD,$80C6,$80E5,$80E8,$80EE ; 256
		dc.w $80F4,$810A,$810D,$8111,$8115,$811A,$811F,$8122 ; 264
		dc.w $8123,$8139,$813A,$813C,$8142,$8144,$8147,$8148 ; 272
		dc.w $815E,$815F,$8163,$8168,$816A,$816C,$8170,$88E5 ; 280
		dc.w $88CE,$88EE,$88F1,$8884,$88FD,$8900,$88B9,$8917 ; 288
		dc.w $8871,$8909,$890D,$8865,$8925,$8922,$8831,$883C ; 296
		dc.w $890F,$88C5,$8933,$8937,$891F,$802E,$806B,$8082 ; 304
		dc.w $8083,$808C,$8099,$809B,$80A2,$80A5,$80A7,$80A9 ; 312
		dc.w $80AB,$80AD,$80B9,$80BA,$80BF,$80C4,$80C5,$80C7 ; 320
		dc.w $80C8,$80C9,$80CA,$80D0,$80D9,$80DB,$80EB,$80EC ; 328
		dc.w $80ED,$80EF,$80F2,$80F3,$80F6,$80FA,$80FC,$80FD ; 336
		dc.w $80FE,$8103,$8106,$8107,$810B,$810E,$810F,$8110 ; 344
		dc.w $8112,$8117,$811C,$811D,$8121,$8129,$812C,$812D ; 352
		dc.w $8131,$8134,$8135,$813B,$813D,$813E,$813F,$8140 ; 360
		dc.w $8141,$8145,$8146,$8149,$814A,$814C,$814D,$814E ; 368
		dc.w $814F,$8150,$8152,$8153,$8154,$8155,$8156,$8157 ; 376
		dc.w $8158,$815A,$815B,$815C,$8160,$8161,$8162,$8164 ; 384
		dc.w $8166,$8167,$8169,$816B,$816D,$816E,$816F,$8171 ; 392
		dc.w $8172,$8173,$886E,$887D,$88C3,$88DB,$88E7,$88E8 ; 400
		dc.w $88EB,$88ED,$88F2,$88F6,$88FA,$88FC,$88FE,$882D ; 408
		dc.w $8903,$8906,$8907,$890B,$8873,$889A,$8929,$892C ; 416
		dc.w $892D,$8911,$893C,$8920,$8946,$88A9,$889C,$8916 ; 424
		dc.w $894F,$894C,$886F,$8958,$8956,$8959,$895A,$8961 ; 432
		dc.w $887B,$8966,$891C,$8918,$88A0,$88A3,$8967,$88A1 ; 440

byte_69E6:
		dc.b   0,  7,  0,  1,  0,  1,  0,  1,  0,$4A,  0,  1,  0,$39,  0,  3 ; 0
		dc.b   0,  1,  0,  5,  0,$28,  0,  7,  0,$2C,  0,  1,  0,  1,  0,  2 ; 16
		dc.b   0,$28,  0,  5,  0,$39,  0,  1,  0,$28,  0,  9,  0,  1,  0,  4 ; 32
		dc.b   0,$28,  0,  6,  0,$28,  0,  3,  0,$4A,  0,  2,  0,  1,  0,  3 ; 48
		dc.b   0,$28,  0,  4,  0,$39,  0,  2,  0,$39,  0,  4,  0,  1,  0,  6 ; 64
		dc.b   0,  7,  0,  2,  0,$2C,  0,  2,  0,$28,  0,  1,  0,$1D,  0,  1 ; 80
		dc.b   0,$28,  0,  8,  0,$28,  0,  2,  0,  7,  0,  3,  0,  1,  0,  7 ; 96
		dc.b   0,$28,  0, $B,  0,$39,  0,  5,  0,$1D,  0,  3,  0,$1D,  0,  4 ; 112
		dc.b   0,$1D,  0,  2,  0,$1D,  0,  5,  0,$28,  0, $D,  0, $B,  0,  1 ; 128
		dc.b   0,$28,  0, $A,  0,$39,  0,  6,  0,$39,  0,  7,  0,$2C,  0,  3 ; 144
		dc.b   0,$1D,  0,  9,  0,$4A,  0,  3,  0,$1D,  0,  7,  0,$28,  0, $F ; 160
		dc.b   0,$1D,  0, $B,  0,$1D,  0,$11,  0,$1D,  0, $D,  0,$1D,  0,  8 ; 176
		dc.b   0,$28,  0,$11,  0,$1D,  0,  6,  0, $B,  0,  2,  0,$1D,  0,$15 ; 192
		dc.b   0,$28,  0, $C,  0,$1D,  0, $A,  0,$28,  0, $E,  0,  1,  0,  8 ; 208
		dc.b   0,$1D,  0, $F,  0,$28,  0,$10,  0,  7,  0,  6,  0,$1D,  0,$13 ; 224
		dc.b   0,$4A,  0,  4,  0,$1D,  0,$17,  0,  7,  0,  4,  0, $B,  0,  3 ; 240
		dc.b   0,$1D,  0,$1B,  0,$4A,  0,  6,  0,$1D,  0,$1D,  0,$4A,  0,  5 ; 256
		dc.b   0,  1,  0,  9,  0,  7,  0,  5,  0,$1D,  0,$1E,  0,$1D,  0,$19 ; 272
		dc.b   0,  1,  0,$11,  0,$1D,  0, $C,  0,$1D,  0,$7F,  0,$2C,  0,  4 ; 288
		dc.b   0,$1D,  0, $E,  0,$1D,  0,$1C,  0,$4A,  0, $A,  0,$1D,  0,$1A ; 304
		dc.b   0,$4A,  0,  7,  0,$1D,  0,$18,  0, $B,  0,  4,  0,$1D,  0,$12 ; 320
		dc.b   0,$1D,  0,$10,  0,  1,  0, $F,  0, $B,  0,  5,  0,  1,  0, $D ; 336
		dc.b   0,  1,  0,$13,  0,$4A,  0,  9,  0,$4A,  0, $B,  0,$4A,  0, $C ; 352
		dc.b   0,$2C,  0,  5,  0,$1D,  0,$14,  0, $B,  0,  7,  0,$1D,  0,$16 ; 368
		dc.b   0,  1,  0, $C,  0,  1,  0, $E,  0,$4A,  0,  8,  0,$1D,  0,$5F ; 384
		dc.b   0,  1,  0, $A,  0, $B,  0,  6,  0, $B,  0,  8,  0, $B,  0, $A ; 400
		dc.b   0,$39,  0,  8,  0, $B,  0,  9,  0,$2C,  0,  6,  0,  1,  0,$10 ; 416
		dc.b   0, $B,  0, $C,  0,  1,  0, $B,  0,  1,  0,$12,  0,  7,  0,  7 ; 432
		dc.b   0,$1D,  0,$1F,  0,$28,  0,$12,  0, $B,  0, $B,  0,$2C,  0,  7 ; 448
		dc.b   0,$2C,  0, $B,  0,$1D,  0,$23,  0,  1,  0,$15,  0,$2C,  0,  8 ; 464
		dc.b   0,$1D,  0,$2E,  0,$1D,  0,$3F,  0,  1,  0,$14,  0, $B,  0, $D ; 480
		dc.b   0,$2C,  0,  9,  0,$2C,  0, $A,  0,$1D,  0,$25,  0,$1D,  0,$55 ; 496
		dc.b   0,$1D,  0,$71,  0,$1D,  0,$7C,  0,$4A,  0, $D,  0,$2C,  0, $C ; 512
		dc.b   0,$2C,  0, $F,  0,$2C,  0,$10,$FF,$FB,$FF,$FB,$FF,$FA,$FF,$FA ; 528
		dc.b $FF,$FA,$FF,$FA				; 544
		even

loc_6C0A:
		move.b	(v_ss_alt_hscroll_buffer).w,(v_ss_last_alt_hscroll_buffer).w
		moveq	#0,d1
		movea.l	(v_ss_track_mappings_bitflags).w,a0
		cmpa.l	#MapSpec_Straight2,a0
		blt.s	loc_6C4A
		cmpa.l	#MapSpec_Straight3,a0
		bge.s	loc_6C4A
		movea.l	(v_ss_current_layout).w,a5
		move.b	(v_ss_current_segment).w,d1
		move.b	(a5,d1.w),d1
		bpl.s	loc_6C88

loc_6C34:
		st.b	(v_ss_track_orientation).w
		move.b	(v_ss_track_drawing_index).w,d0
		cmp.b	(v_ss_player_anim_frame_timer).w,d0
		blt.w	locret_6C9A
		st.b	(v_ss_alt_hscroll_buffer).w
		rts
; ===========================================================================

loc_6C4A:
		cmpa.l	#MapSpec_Rise14,a0
		blt.s	loc_6C6A
		cmpa.l	#MapSpec_Rise15,a0
		bge.s	loc_6C6A
		movea.l	(v_ss_current_layout).w,a5
		move.b	(v_ss_current_segment).w,d1
		move.b	(a5,d1.w),d1
		bpl.s	loc_6C88
		bra.s	loc_6C34
; ===========================================================================

loc_6C6A:
		cmpa.l	#MapSpec_Drop6,a0
		blt.s	locret_6C9A
		cmpa.l	#MapSpec_Drop7,a0
		bge.s	locret_6C9A
		movea.l	(v_ss_current_layout).w,a5
		move.b	(v_ss_current_segment).w,d1
		move.b	(a5,d1.w),d1
		bmi.s	loc_6C34

loc_6C88:
		sf.b	(v_ss_track_orientation).w
		move.b	(v_ss_track_drawing_index).w,d0
		cmp.b	(v_ss_player_anim_frame_timer).w,d0
		blt.s	locret_6C9A
		sf.b	(v_ss_alt_hscroll_buffer).w

locret_6C9A:
		rts
; ===========================================================================

SS_InitHScroll:
		lea	(v_hscroll_buffer).w,a1
		lea	(v_ss_hscroll_buffer_2).w,a2
		moveq	#0,d0					; scroll of 0 for fg & bg on lines 0 & 1 (normal) or lines 6 & 7 (flipped)
		moveq	#0,d1					; scroll of 0 for bg on lines 2 & 3 (normal) or lines 4 & 5 (flipped)
		moveq	#0,d2					; scroll of 0 for bg on lines 4 & 5 (normal) or lines 2 & 3 (flipped)
		moveq	#0,d3					; scroll of 0 for bg on lines 6 & 7 (normal) or lines 0 & 1 (flipped)
		move.w	#-$100,d1				; scroll of 3 screens for fg on lines 2 & 3 (normal) or lines 4 & 5 (flipped)
		move.w	#-$200,d2				; scroll of 2 screens for fg on lines 4 & 5 (normal) or lines 2 & 3 (flipped)
		move.w	#-$300,d3				; scroll of 1 screen for fg on lines 6 & 7 (normal) or lines 0 & 1 (flipped)
		swap	d1
		swap	d2
		swap	d3
		moveq	#(((v_ss_hscroll_buffer_1_end-v_ss_hscroll_buffer_1)/4)/8)-1,d4 ; 8 longwords per table per loop, $100 longwords total per table, $1F loops

	.loop:
		move.l	d0,(a1)+
		move.l	d0,(a1)+
		move.l	d1,(a1)+
		move.l	d1,(a1)+
		move.l	d2,(a1)+
		move.l	d2,(a1)+
		move.l	d3,(a1)+
		move.l	d3,(a1)+

		move.l	d3,(a2)+
		move.l	d3,(a2)+
		move.l	d2,(a2)+
		move.l	d2,(a2)+
		move.l	d1,(a2)+
		move.l	d1,(a2)+
		move.l	d0,(a2)+
		move.l	d0,(a2)+
		dbf	d4,.loop
		rts

; ===========================================================================

SS_LoadCompressedData:
		lea	(Kos_Special).l,a0
		lea	(v_128x128_tiles).l,a1
		bsr.w	KosDec

		vdp_comm.l	move,vram_start,vram,write,(vdp_control_port).l
		lea	(vdp_data_port).l,a1
		movea.l	#v_128x128_tiles,a0
		move.w	(a0)+,d0
		subq.w	#1,d0

	.loop:
		rept 7
		move.l	(a0),(a1)
		endr
		move.l	(a0)+,(a1)
		dbf	d0,.loop

		lea	(Kos_SpecialPerspective).l,a0
		lea	(v_ss_perspective_data).l,a1
		bsr.w	KosDec

		lea	(Nem_SpecialLevelLayouts).l,a0
		lea	(v_ss_level_layout).w,a4
		bsr.w	NemDecToRAM

		lea	(Koz_SpecialObjectLocations).l,a0
		lea	(v_ss_object_locations).w,a1
		bsr.w	KosDec
		rts
; ===========================================================================
SS_LoadBackground:
		disable_ints
		movea.l	#v_128x128_tiles,a1
		lea	(Eni_SpecialBackBottom).l,a0
		move.w	#$700,d0
		bsr.w	EniDec
		movea.l	#v_128x128_tiles+$400,a1
		lea	(Eni_SpecialBack).l,a0
		move.w	#$700,d0
		bsr.w	EniDec
		lea	(v_128x128_tiles).l,a1
		move.l	#$60000002,d0
		moveq	#$1F,d1
		moveq	#$1F,d2
		bsr.w	TilemapToVRAM_128_SS
		lea	(v_128x128_tiles).l,a1
		move.l	#$60400002,d0
		moveq	#$1F,d1
		moveq	#$1F,d2
		bsr.w	TilemapToVRAM_128_SS
		lea	(v_128x128_tiles).l,a1
		move.l	#$60800002,d0
		moveq	#$1F,d1
		moveq	#$1F,d2
		bsr.w	TilemapToVRAM_128_SS
		lea	(v_128x128_tiles).l,a1
		move.l	#$60C00002,d0
		moveq	#$1F,d1
		moveq	#$1F,d2
		bsr.w	TilemapToVRAM_128_SS
		enable_ints
		rts
; ===========================================================================

SS_LoadPlayerArt:
		lea	(Nem_SpecialSonicAndTails).l,a0
		lea	(v_ss_character_art&$FFFFFF).l,a4
		bra.w	NemDecToRAM
; ===========================================================================

SS_ScrollBG:
		bsr.w	sub_6E3C
		bsr.w	sub_6EE0
		rts
; ===========================================================================
; special stage background vertical and horizontal scroll offsets
off_6DEE:	index offset(*)
		ptr byte_6E04					; 0
		ptr byte_6E09					; 2
		ptr byte_6E0E					; 4
		ptr byte_6E13					; 6
		ptr byte_6E18					; 8
		ptr byte_6E1D					; $A
		ptr byte_6E22					; $C
		ptr byte_6E27					; $E
		ptr byte_6E2C					; $10
		ptr byte_6E31					; $12
		ptr byte_6E36					; $14

byte_6E04:	dc.b   2,  2,  2,  2,  2
byte_6E09:	dc.b   4,  4,  5,  4,  5
byte_6E0E:	dc.b  $B, $B, $B, $B, $C
byte_6E13:	dc.b   0,  0,  1,  0,  0
byte_6E18:	dc.b   1,  1,  1,  1,  1
byte_6E1D:	dc.b   9,  9,  8,  9,  9
byte_6E22:	dc.b   9,  9,  9,  9, $A
byte_6E27:	dc.b   7,  7,  6,  7,  7
byte_6E2C:	dc.b   0,  1,  1,  1,  0
byte_6E31:	dc.b   4,  3,  3,  3,  4
byte_6E36:	dc.b   0,  0,$FF,  0,  0
		even
; ===========================================================================

sub_6E3C:
		moveq	#0,d7
		moveq	#0,d6
		moveq	#0,d0
		move.b	(v_ss_track_last_anim_frame).w,d2
		move.b	(v_ss_track_anim).w,d0
		add.w	d0,d0
		move.w	off_6E54(pc,d0.w),d0
		jmp	off_6E54(pc,d0.w)
; ===========================================================================

off_6E54:	index offset(*)
		ptr loc_6E5E					; 0
		ptr loc_6E5E					; 2
		ptr loc_6E5E					; 4
		ptr locret_6E86					; 6
		ptr locret_6E86					; 8
; ===========================================================================

loc_6E5E:
		moveq	#0,d1
		cmpi.b	#1,d2
		blt.s	loc_6E88
		moveq	#2,d1
		cmpi.b	#2,d2
		blt.s	loc_6E88
		moveq	#4,d1
		cmpi.b	#$A,d2
		blt.s	loc_6E88
		moveq	#2,d1
		cmpi.b	#$B,d2
		blt.s	loc_6E88
		moveq	#0,d1
		cmpi.b	#$C,d2
		blt.s	loc_6E88

locret_6E86:
		rts
; ===========================================================================

loc_6E88:
		moveq	#0,d0
		moveq	#0,d2
		move.b	(v_ss_track_drawing_index).w,d0
		lea_	off_6DEE,a0
		adda.w	(a0,d1.w),a0
		move.b	(a0,d0.w),d2
		tst.b	(v_ss_last_alt_hscroll_buffer).w
		bne.s	loc_6EAA
		tst.b	(v_ss_alt_hscroll_buffer).w
		beq.s	loc_6EBE
		bra.s	loc_6EB6
; ===========================================================================

loc_6EAA:
		tst.b	(v_ss_alt_hscroll_buffer).w
		bne.s	loc_6EBE
		lea	($FFFFE002).w,a1
		bra.s	loc_6ECE
; ===========================================================================

loc_6EB6:
		lea	($FFFFD702).w,a1
		neg.w	d2
		bra.s	loc_6ECE
; ===========================================================================

loc_6EBE:
		lea	($FFFFE002).w,a1
		tst.b	(v_ss_alt_hscroll_buffer).w
		beq.s	loc_6ECE
		lea	($FFFFD702).w,a1
		neg.w	d2

loc_6ECE:
		move.w	#$FF,d0

loc_6ED2:
		sub.w	d2,(a1)+
		adda_.l	#2,a1
		dbf	d0,loc_6ED2
		rts
; ===========================================================================

sub_6EE0:
		move.w	(v_bg_y_pos_vsram).w,(v_ss_track_last_vscroll).w
		moveq	#0,d7
		moveq	#0,d0
		moveq	#0,d2
		move.b	(v_ss_track_last_anim_frame).w,d2
		move.b	(v_ss_track_anim).w,d0
		add.w	d0,d0
		move.w	off_6EFE(pc,d0.w),d0
		jmp	off_6EFE(pc,d0.w)
; ===========================================================================

off_6EFE:	index offset(*)
		ptr loc_6F0A					; 0
		ptr loc_6F2A					; 1
		ptr locret_6F08					; 2
		ptr loc_6F4C					; 3
		ptr locret_6F08					; 4
; ===========================================================================

locret_6F08:
		rts
; ===========================================================================

loc_6F0A:
		move.b	byte_6F12(pc,d2.w),d1
		bpl.s	loc_6F6A
		rts
; ===========================================================================
byte_6F12:
		dc.b $FF					; 0
		dc.b $FF					; 1
		dc.b $FF					; 2
		dc.b $FF					; 3
		dc.b $FF					; 4
		dc.b $FF					; 5
		dc.b $FF					; 6
		dc.b $FF					; 7
		dc.b $FF					; 8
		dc.b $FF					; 9
		dc.b   8					; 10
		dc.b   8					; 11
		dc.b   2					; 12
		dc.b   4					; 13
		dc.b   4					; 14
		dc.b   4					; 15
		dc.b   4					; 16
		dc.b   4					; 17
		dc.b   4					; 18
		dc.b  $A					; 19
		dc.b  $C					; 20
		dc.b  $E					; 21
		dc.b $12					; 22
		dc.b $10					; 23
; ===========================================================================

loc_6F2A:
		st.b	d7
		move.b	byte_6F34(pc,d2.w),d1
		bpl.s	loc_6F6A
		rts
; ===========================================================================

byte_6F34:
		dc.b $FF					; 0
		dc.b $FF					; 1
		dc.b $FF					; 2
		dc.b $FF					; 3
		dc.b $FF					; 4
		dc.b $FF					; 5
		dc.b $FF					; 6
		dc.b $FF					; 7
		dc.b $FF					; 8
		dc.b $FF					; 9
		dc.b $FF					; 10
		dc.b $10					; 11
		dc.b $12					; 12
		dc.b  $E					; 13
		dc.b  $C					; 14
		dc.b  $A					; 15
		dc.b   4					; 16
		dc.b   4					; 17
		dc.b   4					; 18
		dc.b   4					; 19
		dc.b   4					; 20
		dc.b   4					; 21
		dc.b   2					; 22
		dc.b   0					; 23
; ===========================================================================

loc_6F4C:
		tst.b	(f_ss_pause_only).w
		bne.s	locret_6F58
		move.b	byte_6F5A(pc,d2.w),d1
		bpl.s	loc_6F6A

locret_6F58:
		rts
; ===========================================================================

byte_6F5A:
		dc.b   6					; 0
		dc.b   6					; 1
		dc.b $14					; 2
		dc.b $14					; 3
		dc.b   6					; 4
		dc.b   6					; 5
		dc.b $14					; 6
		dc.b $14					; 7
		dc.b   6					; 8
		dc.b   6					; 9
		dc.b $14					; 10
		dc.b $14					; 11
		dc.b   6					; 12
		dc.b   6					; 13
		dc.b $14					; 14
		dc.b $14					; 15
; ===========================================================================

loc_6F6A:
		moveq	#0,d0
		moveq	#0,d2
		move.b	(v_ss_track_drawing_index).w,d0
		lea_	off_6DEE,a0
		adda.w	(a0,d1.w),a0
		move.b	(a0,d0.w),d2
		tst.b	d7
		bpl.s	loc_6F88
		add.w	d2,(v_bg_y_pos_vsram).w
		rts
; ===========================================================================

loc_6F88:
		sub.w	d2,(v_bg_y_pos_vsram).w
		rts
; ===========================================================================


FindFreeObjSpecial:
		lea	(v_ss_dynamic_object_ram).w,a1
		move.w	#(sizeof_v_ss_dynamic_object_ram/sizeof_ost)-1,d5

	.loop:
		tst.b	ost_id(a1)				; is this slot empty?
		beq.s	.return					; if so, exit
		lea	sizeof_ost(a1),a1			; check the next slot
		dbf	d5,.loop

	.return:
		rts
; ===========================================================================

FindNextFreeObjSpecial:
		movea.l	a0,a1
		move.w	#v_ss_dynamic_object_ram_end,d5
		sub.w	a0,d5
		lsr.w	#6,d5
		subq.w	#1,d5
		bcs.s	.return

	.loop:
		tst.b	ost_id(a1)
		beq.s	.return
		lea	$40(a1),a1
		dbf	d5,.loop

	.return:
		rts

; ----------------------------------------------------------------------------
; Object 5E - HUD from Special Stage
; ----------------------------------------------------------------------------

HUDSpecial:
		move.b	ost_primary_routine(a0),d0
	if FixBugs
		; See below.
		beq.s	.skip_display
		move.w	#sizeof_priority*0,d0
		jmp	(DisplaySprite3).l
	.skip_display:
	else
		bne.w	JmpTo_DisplaySprite
	endc
		move.l	#Map_SpecialHUD,ost_mappings(a0)
		move.w	#tile_Nem_SpecialHUD,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
	if FixBugs=0
		; Multi-sprite objects cannot use 'ost_priority' as it is
		; overwritten by 'ost_subspr3_y_pos'.
		move.b	#0,ost_priority(a0)
	endc
		move.b	#1,ost_primary_routine(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		moveq	#0,d1
		tst.b	(f_ss_2p).w
		beq.s	loc_7002
		addq.w	#6,d1
		tst.b	(v_console_region).w
		bpl.s	loc_7012
		addq.w	#1,d1
		bra.s	loc_7012
; ===========================================================================

loc_7002:
		move.w	(v_player_mode).w,d1
		andi.w	#3,d1
		tst.b	(v_console_region).w
		bpl.s	loc_7012
		addq.w	#3,d1

loc_7012:
		add.w	d1,d1
		moveq	#0,d2
		moveq	#0,d3
		lea	(off_7042).l,a1
		lea	ost_subspr2_x_pos(a0),a2
		adda.w	(a1,d1.w),a1
		move.b	(a1)+,d3
		move.b	d3,ost_mainspr_childsprites(a0)
		subq.w	#1,d3
		moveq	#0,d0
		move.b	(a1)+,d0

loc_7032:
		move.w	d0,(a2,d2.w)
		move.b	(a1)+,ost_subspr2_frame-ost_subspr2_x_pos(a2,d2.w)
		addq.w	#next_subspr,d2
		dbf	d3,loc_7032
		rts
; ===========================================================================
off_7042:	index offset(*)
		ptr byte_7052					; 0
		ptr byte_7057					; 1
		ptr byte_705A					; 2
		ptr byte_705D					; 3
		ptr byte_7062					; 4
		ptr byte_7065					; 5
		ptr byte_7068					; 6
		ptr byte_706C					; 7

byte_7052:	dc.b   3,$80,  0,  1,  3			; 0
byte_7057:	dc.b   1,$D4,  0				; 0
byte_705A:	dc.b   1,$38,  1				; 0
byte_705D:	dc.b   3,$80,  0,  2,  3			; 0
byte_7062:	dc.b   1,$D4,  0				; 0
byte_7065:	dc.b   1,$38,  2				; 0
byte_7068:	dc.b   2,$80,  0,  1				; 0
byte_706C:	dc.b   2,$80,  0,  2				; 0

		include "mappings/sprite/Special HUD.asm"

; ----------------------------------------------------------------------------
; Object 5F - Start banner/"Ending controller" from Special Stage
; ----------------------------------------------------------------------------
; Sprite_70F0:
StartBannerSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SS_StartBan_Index(pc,d0.w),d1
		jmp	SS_StartBan_Index(pc,d1.w)
; ===========================================================================
SS_StartBan_Index:	index offset(*),,2
		ptr loc_714A					; 0
		ptr loc_718A					; 2
		ptr loc_71B4					; 4
		ptr loc_710A					; 6
		ptr locret_723E					; 8
		ptr loc_7218					; $10
; ===========================================================================

loc_710A:
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		bsr.w	CalcSine
		muls.w	$14(a0),d0
		muls.w	$14(a0),d1
		asr.w	#8,d0
		asr.w	#8,d1
		add.w	d1,ost_x_pos(a0)
		add.w	d0,ost_y_pos(a0)
		cmpi.w	#0,ost_x_pos(a0)			; could be tst.w
		blt.w	JmpTo_DeleteObject
		cmpi.w	#$100,ost_x_pos(a0)
		bgt.w	JmpTo_DeleteObject
		cmpi.w	#0,ost_y_pos(a0)
		blt.w	JmpTo_DeleteObject

    if RemoveJmpTos
JmpTo_DisplaySprite:
    endc

		jmpto	DisplaySprite,JmpTo_DisplaySprite
; ===========================================================================

loc_714A:
		tst.b	(f_ss_2p).w
		beq.s	loc_7158
		move.w	#8,d0
		jsrto	loc_35DAA,JmpTo_loc_35DAA

loc_7158:
		move.w	#$80,ost_x_pos(a0)
		move.w	#-$40,ost_y_pos(a0)
		move.w	#$100,ost_y_vel(a0)
		move.l	#Map_SpecStartBan,ost_mappings(a0)
		move.w	#tile_Nem_SpecialStart,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#1,ost_priority(a0)
		move.b	#2,ost_primary_routine(a0)

loc_718A:
		jsrto	SpeedToPos,JmpTo_SpeedToPos
		cmpi.w	#$48,ost_y_pos(a0)
		blt.w	JmpTo_DisplaySprite
		move.w	#0,ost_y_vel(a0)
		move.w	#$48,ost_y_pos(a0)
		move.b	#4,ost_primary_routine(a0)
		move.b	#$F,$2A(a0)
		jmpto	DisplaySprite,JmpTo_DisplaySprite
; ===========================================================================

loc_71B4:
		subi_.b	#1,$2A(a0)
	if RemoveJmpTos
		bne.s	JmpTo_DisplaySprite
	else
		bne.w	JmpTo_DisplaySprite
	endc
		moveq	#6,d6
		lea	(Frame_SpecStartBan_FlagLeft).l,a2	; could be PC-relative
		moveq	#2,d3
		move.w	#8,$14(a0)
		move.b	#6,ost_primary_routine(a0)

loc_71D4:
		bsr.w	FindFreeObjSpecial
		bne.s	loc_7206
		moveq	#0,d0

		move.w	#(sizeof_ost/4)-1,d1

loc_71E0:
		move.l	(a0,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_71E0
		move.b	d3,ost_frame(a1)
		addq.w	#1,d3
		move.w	#$FFD8,d2
		move.w	8(a2),d1
		bsr.w	CalcAngle
		move.b	d0,ost_angle(a1)
		lea	$A(a2),a2

loc_7206:
		dbf	d6,loc_71D4
		move.b	#$A,ost_primary_routine(a0)
		move.w	#$1E,$2A(a0)
		rts
; ===========================================================================

loc_7218:
		subi_.w	#1,$2A(a0)
		bpl.s	locret_723C
		tst.b	(f_ss_2p).w
		beq.s	loc_7230
		move.w	#$A,d0
		jsrto	loc_35DAA,JmpTo_loc_35DAA
		bra.s	loc_7234
; ===========================================================================

loc_7230:
		jsrto	loc_35CE2,JmpTo_loc_35CE2

loc_7234:
		st.b	(f_ss_started).w
		jmpto	DeleteObject,JmpTo_DeleteObject
; ===========================================================================

locret_723C:
		rts
; ===========================================================================

   	if RemoveJmpTos
JmpTo_DeleteObject
		jmp	(DeleteObject).l
    endc

; ===========================================================================

locret_723E:
		rts
; ===========================================================================

		include "mappings/sprite/Special Stage Start Banner.asm"
		include "mappings/sprite/Special Stage Numbers.asm"

; ----------------------------------------------------------------------------
; Object 87 - Number of rings in Special Stage
; ----------------------------------------------------------------------------

RingCountSpecial:
		moveq	#0,d0
		move.b	ost_rcs_routine(a0),d0
		move.w	off_7364(pc,d0.w),d1
		jmp	off_7364(pc,d1.w)
; ===========================================================================
off_7364:	index offset(*),,2
		ptr loc_736C					; 0
		ptr loc_7480					; 2
		ptr loc_753E					; 4
		ptr loc_75DE					; 6

		;rsobj	RingCountSpecial,$A
		ost_rcs_routine: equ $A
; ===========================================================================

loc_736C:
		move.b	#2,ost_rcs_routine(a0)
		move.l	#Map_SpecialNum,ost_mappings(a0)
		move.w	#tile_Nem_SpecialHUD+tile_pal3,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		bset	#render_subsprites_bit,ost_render(a0)	; these two instructions could instead be "move.b render_rel|render_subsprites,ost_render(a0)
		move.b	#2,ost_mainspr_childsprites(a0)
		move.w	#$20,d0
		moveq	#0,d1
		lea	ost_subspr2_x_pos(a0),a1
		move.w	#$48,(a1)
		move.w	d0,ost_subspr2_y_pos-ost_subspr2_x_pos(a1)
		move.w	d1,ost_mainspr_height-ost_subspr2_x_pos(a1)
		move.w	#$E0,ost_subspr3_x_pos-ost_subspr2_x_pos(a1)
		move.w	d0,ost_subspr3_y_pos-ost_subspr2_x_pos(a1)
		move.w	d1,ost_frame-ost_subspr2_x_pos(a1)
		move.w	d0,ost_subspr4_y_pos-ost_subspr2_x_pos(a1)
		move.w	d0,ost_subspr5_y_pos-ost_subspr2_x_pos(a1)
		move.w	d0,ost_subspr6_y_pos-ost_subspr2_x_pos(a1)
		move.w	d0,ost_subspr7_y_pos-ost_subspr2_x_pos(a1)
		tst.b	(f_ss_2p).w
		bne.s	loc_742A
		cmpi.w	#sonic_tails,(v_player_mode).w		; could be optimized to tst.w
		beq.s	loc_73E0
		subi_.b	#1,ost_mainspr_childsprites(a0)
		move.w	#$94,(a1)
		rts
; ===========================================================================

loc_73E0:
		bsr.w	FindFreeObjSpecial
		bne.s	locret_7428
		move.b	#id_RingCountSpecial,ost_id(a1)
		move.b	#4,ost_rcs_routine(a1)
		move.l	#Map_SpecialNum,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHUD+tile_pal3,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)	; these two instructions could instead be "move.b render_rel|render_subsprites,ost_render(a0)
		move.b	#1,ost_mainspr_childsprites(a1)
		lea	ost_subspr2_x_pos(a1),a2
		move.w	#$80,(a2)
		move.w	d0,ost_subspr2_y_pos-ost_subspr2_x_pos(a2)
		move.w	d1,ost_mainspr_height-ost_subspr2_x_pos(a2)
		move.w	d0,ost_subspr3_y_pos-ost_subspr2_x_pos(a2)
		move.w	d0,ost_subspr4_y_pos-ost_subspr2_x_pos(a2)

locret_7428:
		rts
; ===========================================================================

loc_742A:
		bsr.w	FindFreeObjSpecial
		bne.s	locret_7428
		move.b	#id_RingCountSpecial,ost_id(a1)
		move.b	#6,ost_rcs_routine(a1)
		move.l	#Map_SpecialNum,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHUD+tile_pal3,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)	; these two instructions could instead be "move.b render_rel|render_subsprites,ost_render(a0)
		move.b	#0,ost_mainspr_childsprites(a1)
		lea	ost_subspr2_x_pos(a1),a2
		move.w	#$2C,d0
		move.w	#$A,d1
		move.w	d0,ost_subspr2_y_pos-ost_subspr2_x_pos(a2)
		move.w	d1,ost_mainspr_height-ost_subspr2_x_pos(a2)
		move.w	d0,ost_subspr3_y_pos-ost_subspr2_x_pos(a2)
		move.w	d1,ost_frame-ost_subspr2_x_pos(a2)
		move.w	d0,ost_subspr4_y_pos-ost_subspr2_x_pos(a2)
		move.w	d1,ost_subspr4_frame-1-ost_subspr2_x_pos(a2)
		rts
; ===========================================================================

loc_7480:
		moveq	#0,d0
		moveq	#0,d3
		moveq	#0,d5
		lea	ost_subspr2_x_pos(a0),a1
		movea.l	a1,a2
		addq.w	#5,a2
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	loc_74EA
		move.b	(v_ost_player1+ost_ss_rings_hundreds).w,d0
		beq.s	loc_74A4
		addq.w	#1,d3
		move.b	d0,(a2)
		lea	next_subspr(a2),a2

loc_74A4:
		move.b	(v_ost_player1+ost_ss_rings_tens).w,d0
		tst.b	d3
		bne.s	loc_74B0
		tst.b	d0
		beq.s	loc_74B8

loc_74B0:
		addq.w	#1,d3
		move.b	d0,(a2)
		lea	next_subspr(a2),a2

loc_74B8:
		addq.w	#1,d3
		move.b	(v_ost_player1+ost_ss_rings_units).w,(a2)
		lea	next_subspr(a2),a2
		move.w	d3,d4
		subq.w	#1,d4
		move.w	#$48,d1
		tst.w	(v_player_mode).w
		beq.s	loc_74D4
		addi.w	#$54,d1

loc_74D4:
		move.w	d1,(a1,d5.w)
		addi_.w	#8,d1
		addq.w	#6,d5
		dbf	d4,loc_74D4
		cmpi.w	#sonic_alone,(v_player_mode).w
		beq.s	loc_7536

loc_74EA:
		moveq	#0,d0
		moveq	#0,d4
		move.b	(v_ost_player2+ost_ss_rings_hundreds).w,d0
		beq.s	loc_74FC
		addq.w	#1,d4
		move.b	d0,(a2)
		lea	next_subspr(a2),a2

loc_74FC:
		move.b	(v_ost_player2+ost_ss_rings_tens).w,d0
		tst.b	d4
		bne.s	loc_7508
		tst.b	d0
		beq.s	loc_7510

loc_7508:
		addq.w	#1,d4
		move.b	d0,(a2)
		lea	next_subspr(a2),a2

loc_7510:
		move.b	(v_ost_player2+ost_ss_rings_units).w,(a2)
		addq.w	#1,d4
		add.w	d4,d3
		subq.w	#1,d4
		move.w	#$E0,d1
		tst.w	(v_player_mode).w
		beq.s	loc_7528
		subi.w	#$44,d1

loc_7528:
		move.w	d1,(a1,d5.w)
		addi_.w	#8,d1
		addq.w	#6,d5
		dbf	d4,loc_7528

loc_7536:
		move.b	d3,ost_mainspr_childsprites(a0)
	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*0,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo_DisplaySprite
	endc
; ===========================================================================

loc_753E:
		moveq	#0,d0
		moveq	#0,d1
		moveq	#0,d2
		moveq	#1,d3
		move.b	(v_ost_player1+ost_ss_rings_units).w,d0
		add.b	(v_ost_player2+ost_ss_rings_units).w,d0
		move.b	(v_ost_player1+ost_ss_rings_tens).w,d1
		add.b	(v_ost_player2+ost_ss_rings_tens).w,d1
		move.b	(v_ost_player1+ost_ss_rings_hundreds).w,d2
		add.b	(v_ost_player2+ost_ss_rings_hundreds).w,d2
		cmpi.b	#$A,d0
		bcs.s	loc_756A
		addq.w	#1,d1
		subi.b	#$A,d0

loc_756A:
		tst.b	d1
		beq.s	loc_7586
		cmpi.b	#$A,d1
		bcs.s	loc_757C
		addi_.b	#1,d2
		subi.b	#$A,d1

loc_757C:
		addq.w	#1,d3
		tst.b	d2
		beq.s	loc_758C
		addq.w	#1,d3
		bra.s	loc_758C
; ===========================================================================

loc_7586:
		tst.b	d2
		beq.s	loc_758C
		addq.w	#2,d3

loc_758C:
		lea	ost_subspr2_x_pos(a0),a1
		move.b	d3,ost_mainspr_childsprites(a0)
		cmpi.b	#2,d3
		blt.s	loc_75BC
		beq.s	loc_75C8
		move.w	#$78,(a1)				; sub2_x_pos
		move.b	d2,ost_subspr2_frame-ost_subspr2_x_pos(a1) ; sub2_mapframe
		move.w	#$80,ost_subspr3_x_pos-ost_subspr2_x_pos(a1) ; sub3_x_pos
		move.b	d1,ost_subspr3_frame-ost_subspr2_x_pos(a1) ; sub3_mapframe
		move.w	#$88,ost_subspr4_x_pos-ost_subspr2_x_pos(a1) ; sub4_x_pos
		move.b	d0,ost_subspr4_frame-ost_subspr2_x_pos(a1) ; sub4_mapframe
    if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*0,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo_DisplaySprite
	endc
; ===========================================================================

loc_75BC:
		move.w	#$80,(a1)
		move.b	d0,ost_subspr2_frame-ost_subspr2_x_pos(a1)
    if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer..
		move.w	#sizeof_priority*0,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo_DisplaySprite
	endc
; ===========================================================================

loc_75C8:
		move.w	#$7C,(a1)
		move.b	d1,ost_subspr2_frame-ost_subspr2_x_pos(a1)
		move.w	#$84,ost_subspr3_x_pos-ost_subspr2_x_pos(a1)
		move.b	d0,ost_subspr3_frame-ost_subspr2_x_pos(a1)
    if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*0,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo_DisplaySprite
	endc
; ===========================================================================

loc_75DE:
		move.b	(v_ss_2p_bcd_score).w,d0
		bne.s	loc_75E6
		rts
; ===========================================================================

loc_75E6:
		lea	ost_subspr2_x_pos(a0),a1
		moveq	#0,d2
		move.b	d0,d1
		andi.b	#-$10,d0
		beq.s	loc_761C
		addq.w	#1,d2
		move.w	#$20,(a1)
		lea	next_subspr(a1),a1
		subi.b	#$10,d0
		beq.s	loc_761C
		addq.w	#1,d2
		move.w	#$30,(a1)
		lea	next_subspr(a1),a1
		subi.b	#$10,d0
		beq.s	loc_761C
		addq.w	#1,d2
		move.w	#$40,(a1)
		bra.s	loc_7648
; ===========================================================================

loc_761C:
		andi.b	#$F,d1
		beq.s	loc_7648
		addq.w	#1,d2
		move.w	#$B8,(a1)
		lea	next_subspr(a1),a1
		subi_.b	#1,d1
		beq.s	loc_7648
		addq.w	#1,d2
		move.w	#$C8,(a1)
		lea	next_subspr(a1),a1
		subi_.b	#1,d1
		beq.s	loc_7648
		addq.w	#1,d2
		move.w	#$D8,(a1)

loc_7648:
		move.b	d2,ost_mainspr_childsprites(a0)
    if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*0,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo_DisplaySprite
	endc
; ===========================================================================


SS_SetGeoOffsets:
		move.b	(v_ss_track_drawing_index).w,d0
		cmp.b	(v_ss_player_anim_frame_timer).w,d0
		beq.s	loc_765C
		rts
; ===========================================================================

loc_765C:
		moveq	#0,d0
		move.b	(v_ss_track_mapping_frame).w,d0
		add.w	d0,d0
		lea	SS_CurveOffsets(pc,d0.w),a2
		move.b	(a2)+,d0
		tst.b	(v_ss_track_orientation).w
		beq.s	loc_7672
		neg.b	d0

loc_7672:
		ext.w	d0
		addi.w	#$80,d0
		move.w	d0,(v_ss_x_offset).w
		move.b	(a2),d0
		ext.w	d0
		addi.w	#$36,d0
		move.w	d0,(v_ss_y_offset).w
		rts

; ===========================================================================
SS_CurveOffsets:
		dc.b $13,   0,   $13,   0,   $13,   0,   $13,   0 ; $00
		dc.b   9, -$A,     0,-$1C,     0,-$1C,     0,-$20 ; $04
		dc.b   0,-$24,     0,-$2A,     0,-$10,     0,   6 ; $08
		dc.b   0,  $E,     0, $10,     0, $12,     0, $12 ; $0C
		dc.b   9, $12					; $10; upward curve
		dc.b   0,   0,     0,   0,     0,   0,     0,   0 ; $11; straight
		dc.b $13,   0,   $13,   0,   $13,   0,   $13,   0 ; $15
		dc.b  $B,  $C,     0,  $C,     0, $12,     0,  $A ; $19
		dc.b   0,   8,     0,   2,     0, $10,     0,-$20 ; $1D
		dc.b   0,-$1F,     0,-$1E,     0,-$1B,     0,-$18 ; $21
		dc.b   0, -$E					; $25; downward curve
		dc.b $13,   0,   $13,   0,   $13,   0,   $13,   0 ; $26
		dc.b $13,   0,   $13,   0			; $2B; turning
		dc.b $13,   0,   $13,   0,   $13,   0,   $13,   0 ; $2C
		dc.b  $B,   0					; $30; exit turn
		dc.b   0,   0,     0,   0,     0,   0,     0,   0 ; $31
		dc.b   0,   0,     0,   0,     3,   0		; $35; straight
; ===========================================================================

SS_StartNewAct:
		moveq	#0,d1
		moveq	#1,d2
		move.w	(v_special_stage).w,d0
		move.b	d0,d1
		lsr.w	#8,d0
		add.w	d0,d0
		add.w	d0,d0
		add.w	d1,d0
		tst.w	(v_player_mode).w
		bne.s	loc_7718
		move.b	SS_RingReq_Team(pc,d0.w),d1
		bra.s	loc_771C
; ===========================================================================

loc_7718:
		move.b	SS_RingReq_Alone(pc,d0.w),d1

loc_771C:
		move.w	d1,(v_ss_ring_requirement).w
		moveq	#0,d0
		cmpi.w	#100,d1
		blt.s	loc_7740
		addq.w	#1,d2

	if FixBugs
		; The following code does a more complete binary coded decimal conversion:
	.loop:
		addi.w	#$100,d0
		subi.w	#100,d1
		cmpi.w	#100,d1
		bge.s	.loop
	else
		; This code (the original) is limited to 299 rings:
		subi.w	#100,d1
		move.w	#$100,d0
		cmpi.w	#100,d1
		blt.s	loc_7740
		subi.w	#100,d1
		addi.w	#$100,d0
	endc

	loc_7740:
		divu.w	#10,d1
		lsl.w	#4,d1
		or.b	d1,d0
		swap	d1
		or.b	d1,d0
		move.w	d0,d1
		addi_.w	#1,(v_special_stage).w
		rts

; ----------------------------------------------------------------------------
; Ring requirement values for Sonic and	Tails games
;
; This array stores the	number of rings	you need to get	to complete each round
; of each special stage, while playing with both sonic and tails. 4 bytes per
; stage, corresponding to the four possible parts of the level.	Last part is
; unused.
; ----------------------------------------------------------------------------

SS_RingReq_Team:
		dc.b  40, 80,140,120				; 4
		dc.b  50,100,140,150				; 8
		dc.b  60,110,160,170				; 12
		dc.b  40,100,150,160				; 16
		dc.b  55,110,200,200				; 20
		dc.b  80,140,220,220				; 24
		dc.b 100,190,210,210				; 28
		even

; ----------------------------------------------------------------------------
; Ring requirement values for Sonic/Tails alone	games
;
; This array stores the	number of rings	you need to get	to complete each round
; of each special stage, while playing with either sonic or tails. 4 bytes per
; stage, corresponding to the four possible parts of the level.	Last part is
; unused.
; ----------------------------------------------------------------------------

SS_RingReq_Alone:
		dc.b  30, 70,130,110				; 4
		dc.b  50,100,140,140				; 8
		dc.b  50,110,160,160				; 12
		dc.b  40,110,150,150				; 16
		dc.b  50, 90,160,160				; 20
		dc.b  80,140,210,210				; 24
		dc.b 100,150,190,190				; 28
		even
; ===========================================================================

SS_PaletteTable:
		dc.w   id_Pal_SS1
		dc.w   id_Pal_SS2
		dc.w   id_Pal_SS3
		dc.w   id_Pal_SS4
		dc.w   id_Pal_SS5
		dc.w   id_Pal_SS6
		dc.w   id_Pal_SS7
		dc.w   id_Pal_SS1_2p
		dc.w   id_Pal_SS2_2p
		dc.w   id_Pal_SS3_2p

; ===========================================================================

SS_LoadPalAndData:
		clr.b	(v_special_act).w
		move.b	#-1,(v_ss_last_segment_2).w
		move.w	#0,(v_rings).w
		move.w	#0,(v_rings_p2).w
		move.b	#0,(f_ss_perfect).w
		move.b	#0,(f_got_emerald).w
		move.b	#4,(v_ss_star_color_2).w
		lea	(v_ss_2p_ring_buffer).w,a2
		moveq	#0,d0
		rept 6
		move.w	d0,(a2)+
		endr
		moveq	#id_Pal_SS,d0				; load common SS palette
		bsr.w	PalLoad_Next
		lea_	SS_PaletteTable,a1
		moveq	#0,d0
		move.b	(v_special_stage).w,d0			; get current Special Stage
		add.w	d0,d0
		move.w	d0,d1
		tst.b	(f_ss_2p).w				; is it 2P mode?
		beq.s	.not2P					; if not, branch
		cmpi.b	#4,d0					; is it stage 1-3?
		bcs.s	.not2P					; if not, branch
		addi_.w	#6,d0					; add 6 to get pointer to 2P SS palette

	.not2P:
		move.w	(a1,d0.w),d0
		bsr.w	PalLoad_Next				; load the appropriate palette
		lea	(v_ss_object_locations).w,a0
		adda.w	(a0,d1.w),a0
		move.l	a0,(v_ss_current_obj_locations).w	; set pointer to object locations for current stage
		lea	(v_ss_level_layout).w,a0
		adda.w	(a0,d1.w),a0
		move.l	a0,(v_ss_current_layout).w		; set pointer to layout data for current stage
		rts

; ===========================================================================

SS_ResultsLetters:	charset titlecard,"ACDGHILMPRSTUW."

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo_LoadTitleCardSS:
		jmp	(LoadTitleCardSS).l
JmpTo_DeleteObject:
		jmp	(DeleteObject).l
JmpTo_loc_35CE2:
		jmp	(loc_35CE2).l
JmpTo_loc_35DAA:
		jmp	(loc_35DAA).l
JmpTo_SpeedToPos:
		jmp	(SpeedToPos).l
JmpTo_HUD_Base:
		jmp	(HUD_Base).l

		align 4
	endc

; ===========================================================================

GM_Continue:
		bsr.w	PaletteFadeOut
		disable_ints
		disable_display
		lea	(vdp_control_port).l,a6
		move.w	#vdp_md_color,(a6)
		move.w	#vdp_bg_color+0,(a6)
		bsr.w	ClearScreen
		clear_ram	ost,ost_end

   	if FixBugs
		; Clear the DMA queue. This fixes the bug where, if you get a
		; Game Over in Hill Top Zone, then Tails' graphics will be corrupted
		; on the Continue screen.
		; This is caused by HTZ's transforming cloud art being loaded over
		; Tails' Continue art: 'Dynamic_HTZ' is responsible for queueing the
		; art to be transferred with 'AddDMA', which takes effect
		; around the next frame. The problem here is, the art is queued, you
		; die, get a Game Over, advance to the Continue screen, and then
		; finally the art is loaded.
		reset_dma_queue
    endc

		bsr.w	LoadContinueText
		vdp_comm.l	move,vram_ContinueTails,vram,write,(vdp_control_port).l
		lea	(Nem_ContinueTails).l,a0
		bsr.w	NemDec
		vdp_comm.l	move,vram_MiniContinue,vram,write,(vdp_control_port).l
		lea	(Nem_MiniSonic).l,a0
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_78DE
		lea	(Nem_MiniTails).l,a0

loc_78DE:
		bsr.w	NemDec
		moveq	#$A,d1
		jsr	(ContScrCounter).l
		moveq	#$1B,d0
		bsr.w	PalLoad_Next
		move.w	#0,(v_pal_dry_next).w
		move.b	#-$64,d0
		bsr.w	PlayMusic
		move.w	#$293,(v_countdown).w
		clr.b	(f_level_started).w
		clr.l	(v_camera_x_pos_copy2).w
		move.l	#$1000000,(v_camera_y_pos_copy2).w
		move.b	#-$25,(v_ost_player1+ost_id).w
		move.b	#-$25,(v_ost_player2+ost_id).w
		move.b	#6,(v_ost_player2+ost_primary_routine).w
		move.b	#-$26,(v_continue_text+ost_id).w
		move.b	#-$26,(v_continue_icons+ost_id).w
		move.b	#4,(v_continue_icons+ost_primary_routine).w
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		enable_display
		bsr.w	PaletteFadeIn

loc_7960:
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		cmpi.b	#4,($FFFFB024).w
		bcc.s	loc_798E
		disable_ints
		move.w	(v_countdown).w,d1
		divu.w	#$3C,d1
		andi.l	#$F,d1
		jsr	(ContScrCounter).l
		enable_ints

loc_798E:
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		cmpi.w	#$180,($FFFFB048).w
		bcc.s	loc_79BA
		cmpi.b	#4,($FFFFB024).w
		bcc.s	loc_7960
		tst.w	(v_countdown).w
		bne.w	loc_7960
		move.b	#0,(v_gamemode).w
		rts
; ===========================================================================

loc_79BA:
		move.b	#id_Level,(v_gamemode).w
		move.b	#lives_start,(v_lives).w
		move.b	#lives_start,(v_lives_p2).w
		moveq	#0,d0
		move.w	d0,(v_rings).w
		move.l	d0,(v_time).w
		move.l	d0,(v_score).w
		move.b	d0,(v_last_lamppost).w
		move.w	d0,(v_rings_p2).w
		move.l	d0,(v_time_p2).w
		move.l	d0,(v_score_p2).w
		move.b	d0,(v_last_lamppost_p2).w
		move.l	#points_for_life,(v_score_next_life).w
		move.l	#points_for_life,(v_score_next_life_p2).w
		subq.b	#1,(v_continues).w
		rts

; ===========================================================================


LoadContinueText:
		vdp_comm.l	move,vram_TitleCard,vram,write,(vdp_control_port).l
		lea	(Nem_TitleCard).l,a0
		bsr.w	NemDec
		lea	(v_level_layout).w,a4
		lea	(Nem_TitleCardFont).l,a0
		bsr.w	NemDecToRAM
		lea	(ContinueText_AdditionalLetters).l,a0
		vdp_comm.l	move,vram_ContinueText_Additional,vram,write,(vdp_control_port).l
		lea	(v_level_layout).w,a1
		lea	(vdp_data_port).l,a6

loc_7A40:
		moveq	#0,d0
		move.b	(a0)+,d0
		bmi.s	locret_7A5C
		lsl.w	#5,d0
		lea	(a1,d0.w),a2
		moveq	#0,d1
		move.b	(a0)+,d1
		lsl.w	#3,d1
		subq.w	#1,d1

loc_7A54:
		move.l	(a2)+,(a6)
		dbf	d1,loc_7A54
		bra.s	loc_7A40
; ===========================================================================

locret_7A5C:
		rts

; ===========================================================================
ContinueText_AdditionalLetters:
		charset titlecard,"CONTINUE"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object DA - Continue text
; ----------------------------------------------------------------------------

ContScrItem:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ContScrItem_Index(pc,d0.w),d1
		jmp	ContScrItem_Index(pc,d1.w)
; ===========================================================================
ContScrItem_Index:	index offset(*),,2
		ptr loc_7A7E					; 0
		ptr loc_7AAC					; 2
		ptr loc_7AD0					; 4
		ptr loc_7B46					; 6
; ===========================================================================

loc_7A7E:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_ContinueScreenItems,ost_mappings(a0)
		move.w	#(vram_ContinueText/sizeof_cell)+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo_AdjustVRAM2P
		move.b	#render_abs,ost_render(a0)
		move.b	#$3C,ost_displaywidth(a0)
		move.w	#screen_left+160,ost_x_screen(a0)
		move.w	#screen_top+64,ost_y_screen(a0)

loc_7AAC:
		jmp	(DisplaySprite).l
; ===========================================================================
word_7AB2:
		dc.w	screen_left+150, screen_left+170, screen_left+130, screen_left+190
		dc.w	screen_left+110, screen_left+210, screen_left+90,  screen_left+230
		dc.w 	screen_left+70,  screen_left+250, screen_left+50,  screen_left+270
		dc.w	screen_left+30,  screen_left+290, screen_left+10
; ===========================================================================

loc_7AD0:
		movea.l	a0,a1
		lea_	word_7AB2,a2
		moveq	#0,d1
		move.b	(v_continues).w,d1
		subq.b	#2,d1
		bcc.s	loc_7AE6
		jmp	(DeleteObject).l
; ===========================================================================

loc_7AE6:
		moveq	#1,d3
		cmpi.b	#$E,d1
		bcs.s	loc_7AF2
		moveq	#0,d3
		moveq	#$E,d1

loc_7AF2:
		move.b	d1,d2
		andi.b	#1,d2

loc_7AF8:
		_move.b	#id_ContScrItem,ost_id(a1)
		move.w	(a2)+,ost_x_screen(a1)
		tst.b	d2
		beq.s	loc_7B0C
		subi.w	#$A,ost_x_screen(a1)

loc_7B0C:
		move.w	#screen_top+80,ost_y_screen(a1)
		move.b	#4,ost_frame(a1)
		move.b	#6,ost_primary_routine(a1)
		move.l	#Map_ContinueScreenItems,ost_mappings(a1)
		move.w	#(vram_ContinueText_2/sizeof_cell)+tile_hi,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo_AdjustVRAM2P2
		move.b	#render_abs,ost_render(a1)
		lea	$40(a1),a1
		dbf	d1,loc_7AF8
		lea	-$40(a1),a1
		move.b	d3,ost_subtype(a1)

loc_7B46:
		tst.b	ost_subtype(a0)
		beq.s	loc_7B66
		cmpi.b	#4,($FFFFB024).w
		bcs.s	loc_7B66
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#1,d0
		bne.s	loc_7B66
		tst.w	($FFFFB010).w
		bne.s	loc_7B7C
		rts
; ===========================================================================

loc_7B66:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$F,d0
		bne.s	loc_7B76
		bchg	#0,ost_frame(a0)

loc_7B76:
		jmp	(DisplaySprite).l
; ===========================================================================

loc_7B7C:
		jmp	(DeleteObject).l

; ----------------------------------------------------------------------------
; Object DB - Sonic and Tails on the continue screen
; ----------------------------------------------------------------------------

ContinueCharacters:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ContChar_Index(pc,d0.w),d1
		jsr	ContChar_Index(pc,d1.w)
		jmp	(DisplaySprite).l
; ===========================================================================
ContChar_Index:	index offset(*),,2
		ptr loc_7BA2					; 0
		ptr loc_7BD2					; 2
		ptr loc_7BFA					; 4
		ptr loc_7C22					; 6
		ptr loc_7C52					; 8
		ptr loc_7C88					; $A
; ===========================================================================

loc_7BA2:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$9C,ost_x_pos(a0)
		move.w	#$19C,ost_y_pos(a0)
		move.l	#Map_Sonic,ost_mappings(a0)
		move.w	#tile_Sonic,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#2,ost_priority(a0)
		move.b	#$20,ost_anim(a0)

loc_7BD2:
		tst.b	(v_joypad_press_actual).w
		bmi.s	loc_7BE4
		jsr	(Sonic_Animate).l
		jmp	(Sonic_LoadGFX).l
; ===========================================================================

loc_7BE4:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$21,ost_anim(a0)
		clr.w	ost_inertia(a0)
		move.b	#-$20,d0
		bsr.w	PlaySound

loc_7BFA:
		cmpi.w	#$800,ost_inertia(a0)
		bne.s	loc_7C0A
		move.w	#$1000,ost_x_vel(a0)
		bra.s	loc_7C10
; ===========================================================================

loc_7C0A:
		addi.w	#$20,ost_inertia(a0)

loc_7C10:
		jsr	(SpeedToPos).l
		jsr	(Sonic_Animate).l
		jmp	(Sonic_LoadGFX).l
; ===========================================================================

loc_7C22:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$B8,ost_x_pos(a0)
		move.w	#$1A0,ost_y_pos(a0)
		move.l	#Map_ContinueScreenItems,ost_mappings(a0)
		move.w	#vram_ContinueTails/sizeof_cell,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#2,ost_priority(a0)
		move.b	#0,ost_anim(a0)

loc_7C52:
		tst.b	(v_joypad_press_actual).w
		bmi.s	loc_7C64
		lea	(Ani_ContinueScreenTails).l,a1
		jmp	(AnimateSprite).l
; ===========================================================================

loc_7C64:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Tails,ost_mappings(a0)
		move.w	#tile_Tails,ost_tile(a0)
		move.b	#0,ost_anim(a0)
		clr.w	ost_inertia(a0)
		move.b	#-$20,d0
		bsr.w	PlaySound

loc_7C88:
		cmpi.w	#$720,ost_inertia(a0)
		bne.s	loc_7C98
		move.w	#$1000,ost_x_vel(a0)
		bra.s	loc_7C9E
; ===========================================================================

loc_7C98:
		addi.w	#$18,ost_inertia(a0)

loc_7C9E:
		jsr	(SpeedToPos).l
		jsr	(Tails_Animate).l
		jmp	(Tails_LoadGFX).l
; ===========================================================================
Ani_ContinueScreenTails:	index offset(*)
		ptr byte_7CB2					; 0

byte_7CB2:	dc.b   9,  2,  3,$FF				; 0

		include	"mappings/sprite/Continue Screen Items.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================

GM_TwoPlayerResults:
		bsr.w	PaletteFadeOut
		disable_ints
		disable_display
		bsr.w	ClearScreen
		lea	(vdp_control_port).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$8230,(a6)
		move.w	#$8700,(a6)
		move.w	#$8C81,(a6)
		move.w	#$9001,(a6)
		lea	(v_sprite_queue).w,a1
		moveq	#0,d0
		move.w	#$FF,d1

loc_7D96:
		move.l	d0,(a1)+
		dbf	d1,loc_7D96
		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1

loc_7DA6:
		move.l	d0,(a1)+
		dbf	d1,loc_7DA6
		move.l	#$42000000,(vdp_control_port).l
		lea	(Nem_StandardFont).l,a0
		bsr.w	NemDec
		move.l	#$4E000000,(vdp_control_port).l
		lea	(Nem_1P2PWins).l,a0
		bsr.w	NemDec
		lea	(v_128x128_tiles).l,a1
		lea	(Eni_MenuBack).l,a0
		move.w	#$6000,d0
		bsr.w	EniDec
		lea	(v_128x128_tiles).l,a1
		move.l	#$60000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		bsr.w	TilemapToVRAM
		move.w	(v_results_screen_2p).w,d0
		add.w	d0,d0
		add.w	d0,d0
		add.w	d0,d0
		lea	off_87DC(pc),a2
		movea.l	(a2,d0.w),a0
		movea.l	4(a2,d0.w),a2
		lea	(v_128x128_tiles).l,a1
		move.w	#0,d0
		bsr.w	EniDec
		jsr	(a2)
		lea	(v_128x128_tiles).l,a1
		move.l	#$40000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		bsr.w	TilemapToVRAM
		clr.w	(v_dma_queue).w
		move.l	#-$2400,(v_dma_queue_slot).w
		clr.b	(f_level_started).w
		clr.w	(v_anim_counters).w
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo_Dynamic_Normal
		moveq	#0,d0
		bsr.w	NewPLC
		moveq	#$26,d0
		bsr.w	PalLoad_Next
		moveq	#0,d0
		move.b	#-$7F,d0
		cmp.w	(v_level_music).w,d0
		beq.s	loc_7E74
		move.w	d0,(v_level_music).w
		bsr.w	PlayMusic

loc_7E74:
		move.w	#$707,(v_countdown).w
		clr.w	(f_two_player).w
		clr.l	(v_camera_x_pos).w
		clr.l	(v_camera_y_pos).w
		clr.l	(v_fg_y_pos_vsram).w
		clr.l	(v_fg_y_pos_vsram_p2).w
		clr.l	(v_hblank_fg_y_pos_vsram_p2).w
		move.b	#id_TwoPlayerResultsDisplay,(v_vs_results_hud).w
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	(v_vdp_mode_buffer).w,d0
		ori.b	#$40,d0
		move.w	d0,(vdp_control_port).l
		bsr.w	PaletteFadeIn

loc_7EB4:
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo_Dynamic_Normal
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		bsr.w	RunPLC
		tst.l	(v_plc_buffer).w
		bne.s	loc_7EB4
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#-$80,d0
		beq.s	loc_7EB4
		move.w	(v_results_screen_2p).w,d0
		bne.w	loc_7FB2
		tst.b	(v_act).w
		bne.s	loc_7F3C
		addq.b	#1,(v_act).w
		move.b	#1,(v_act_2p).w
		move.b	#$C,(v_gamemode).w
		move.b	#0,(v_last_lamppost).w
		move.b	#0,(v_last_lamppost_p2).w
		moveq	#1,d0
		move.w	d0,(f_two_player).w
		move.w	d0,(f_two_player_mode_copy).w
		moveq	#0,d0
		move.l	d0,(v_score).w
		move.l	d0,(v_score_p2).w
		move.l	#$1388,(v_score_next_life).w
		move.l	#$1388,(v_score_next_life_p2).w
		rts
; ===========================================================================

loc_7F3C:
		move.b	#2,(v_act_2p).w
		bsr.w	sub_84A4
		lea	(v_ss_total_won).w,a4
		clr.w	(a4)
		bsr.s	sub_7F9A
		bsr.s	sub_7F9A
		move.b	(a4),d1
		sub.b	1(a4),d1
		beq.s	loc_7F66
		move.w	#1,(v_results_screen_2p).w
		move.b	#$18,(v_gamemode).w
		rts
; ===========================================================================

loc_7F66:
		move.b	(v_zone_2p).w,d0
		addq.b	#1,d0
		move.b	d0,(v_special_stage).w
		move.w	#3,(v_results_screen_2p).w
		move.b	#1,(f_unused_ss_flag).w
		move.b	#$10,(v_gamemode).w
		moveq	#1,d0
		move.w	d0,(f_two_player).w
		move.w	d0,(f_two_player_mode_copy).w
		move.b	#0,(v_last_lamppost).w
		move.b	#0,(v_last_lamppost_p2).w
		rts

; ===========================================================================


sub_7F9A:
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		beq.s	loc_7FAE
		bcs.s	loc_7FAA
		addq.b	#1,(a4)
		bra.s	loc_7FAE
; ===========================================================================

loc_7FAA:
		addq.b	#1,1(a4)

loc_7FAE:
		addq.w	#2,a5
		rts

; ===========================================================================

loc_7FB2:
		subq.w	#1,d0
		bne.s	loc_8020

loc_7FB6:
		lea	(v_ehz_results_2p).w,a4
		moveq	#0,d0
		moveq	#0,d1
		move.w	(a4)+,d0
		add.l	d0,d1
		move.w	(a4)+,d0
		add.l	d0,d1
		addq.w	#2,a4
		move.w	(a4)+,d0
		add.l	d0,d1
		move.w	(a4)+,d0
		add.l	d0,d1
		addq.w	#2,a4
		move.w	(a4)+,d0
		add.l	d0,d1
		move.w	(a4)+,d0
		add.l	d0,d1
		addq.w	#2,a4
		move.w	(a4)+,d0
		add.l	d0,d1
		move.w	(a4)+,d0
		add.l	d0,d1
		swap	d1
		tst.w	d1
		bne.s	loc_7FF8
		move.w	#2,(v_results_screen_2p).w
		move.b	#$18,(v_gamemode).w
		rts
; ===========================================================================

loc_7FF8:
		tst.w	(v_game_over_2p).w
		beq.s	loc_8018
		lea	(v_ehz_results_2p).w,a1
		moveq	#$B,d0

loc_8004:
		move.w	#-1,(a1)+
		dbf	d0,loc_8004
		move.b	#3,(v_lives).w
		move.b	#3,(v_lives_p2).w

loc_8018:
		move.b	#$1C,(v_gamemode).w
		rts
; ===========================================================================

loc_8020:
		subq.w	#1,d0
		bne.s	loc_802C
		move.b	#0,(v_gamemode).w
		rts
; ===========================================================================

loc_802C:
		subq.w	#1,d0
		bne.w	loc_80BA
		cmpi.b	#3,(v_zone_2p).w
		beq.s	loc_8048
		move.w	#1,(v_results_screen_2p).w
		move.b	#$18,(v_gamemode).w
		rts
; ===========================================================================

loc_8048:
		tst.b	(v_act_2p).w
		beq.s	loc_806C
		cmpi.b	#2,(v_act_2p).w
		beq.s	loc_80AC
		bsr.w	sub_84A4
		lea	(v_ss_total_won).w,a4
		clr.w	(a4)
		bsr.s	sub_8094
		bsr.s	sub_8094
		move.b	(a4),d1
		sub.b	1(a4),d1
		bne.s	loc_80AC

loc_806C:
		addq.b	#1,(v_act_2p).w
		addq.b	#1,(v_special_stage).w
		move.w	#3,(v_results_screen_2p).w
		move.b	#1,(f_unused_ss_flag).w
		move.b	#$10,(v_gamemode).w
		move.w	#1,(f_two_player).w
		move.w	#0,(v_level_music).w
		rts

; ===========================================================================


sub_8094:
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		beq.s	loc_80A8
		bcs.s	loc_80A4
		addq.b	#1,(a4)
		bra.s	loc_80A8
; ===========================================================================

loc_80A4:
		addq.b	#1,1(a4)

loc_80A8:
		addq.w	#2,a5
		rts

; ===========================================================================

loc_80AC:
		move.w	#4,(v_results_screen_2p).w
		move.b	#$18,(v_gamemode).w
		rts
; ===========================================================================

loc_80BA:
		bra.w	loc_7FB6
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 21 - Score/Rings/Time display on 2P results screen
; ----------------------------------------------------------------------------

TwoPlayerResultsDisplay:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TwoPlayerResults_Index(pc,d0.w),d1
		jmp	TwoPlayerResults_Index(pc,d1.w)
; ===========================================================================
TwoPlayerResults_Index:	index offset(*),,2
		ptr loc_80E4					; 0
		ptr loc_812C					; 2

TwoPlayerResults_PosData:
		;      x,    y
		dc.w screen_left+112, screen_top+200
		dc.w screen_left+112, screen_top+176
		dc.w screen_left+96, screen_top+200
		dc.w screen_left+112, screen_top+200
		dc.w screen_left+112, screen_top+200

loc_80E4:
		addq.b	#2,ost_primary_routine(a0)
		move.w	(v_results_screen_2p).w,d0
		add.w	d0,d0
		add.w	d0,d0
		move.l	TwoPlayerResults_PosData(pc,d0.w),ost_x_screen(a0) ; and ost_y_screen(a0)
		move.l	#Map_2P_Results_Text,ost_mappings(a0)
		move.w	#vram_1P2PWins/sizeof_cell,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo2_AdjustVRAM2P
		move.b	#render_abs,ost_render(a0)
		move.b	#0,ost_priority(a0)
		moveq	#2,d1
		move.b	(v_ss_total_won).w,d0
		sub.b	(v_ss_total_won+1).w,d0
		beq.s	loc_8128
		bcs.s	loc_8126
		moveq	#0,d1
		bra.s	loc_8128
; ===========================================================================

loc_8126:
		moveq	#1,d1

loc_8128:
		move.b	d1,ost_frame(a0)

loc_812C:
		andi.w	#tile_vram,ost_tile(a0)
		btst	#3,(v_vblank_counter_byte).w
		beq.s	JmpTo4_DisplaySprite
		ori.w	#tile_pal2,ost_tile(a0)

JmpTo4_DisplaySprite:
		jmp	(DisplaySprite).l
; ===========================================================================

		include "mappings/sprite/2P Results Text.asm"

; ===========================================================================

loc_819A:
		move.w	#$1F2,d2
		moveq	#0,d0
		bsr.w	sub_8672
		move.w	#$216,d2
		moveq	#0,d1

loc_81AA:
		move.b	(v_act_2p).w,d1
		addq.b	#1,d1
		bsr.w	sub_86B0
		move.w	#$33E,d2
		move.l	(v_score).w,d1

loc_81BC:
		bsr.w	sub_86F6
		move.w	#$352,d2
		move.l	(v_score_p2).w,d1
		bsr.w	sub_86F6
		move.w	#$3DA,d2
		moveq	#0,d0
		move.w	(v_time).w,d1
		bsr.w	sub_86B0
		move.w	#$3E0,d2
		moveq	#0,d1
		move.b	(v_time_sec).w,d1
		bsr.w	sub_86B0
		move.w	#$3E6,d2
		moveq	#0,d1
		move.b	(v_time_frames).w,d1
		mulu.w	#$1B0,d1
		lsr.l	#8,d1
		bsr.w	sub_86B0

loc_81FC:
		move.w	#$3EE,d2
		moveq	#0,d0
		move.w	(v_time_p2).w,d1
		bsr.w	sub_86B0
		move.w	#$3F4,d2
		moveq	#0,d1
		move.b	(v_time_sec_p2).w,d1

loc_8214:
		bsr.w	sub_86B0
		move.w	#$3FA,d2
		moveq	#0,d1
		move.b	(v_time_frames_p2).w,d1
		mulu.w	#$1B0,d1
		lsr.l	#8,d1
		bsr.w	sub_86B0
		move.w	#$486,d2
		moveq	#0,d0
		move.w	(v_rings).w,d1
		bsr.w	sub_86B0
		move.w	#$49A,d2
		move.w	(v_rings_p2).w,d1
		bsr.w	sub_86B0
		move.w	#$526,d2
		moveq	#0,d0
		move.w	(v_rings_collected_p1).w,d1
		bsr.w	sub_86B0
		move.w	#$53A,d2
		move.w	(v_rings_collected_p2).w,d1
		bsr.w	sub_86B0
		move.w	#$5C6,d2
		moveq	#0,d0
		move.w	(v_monitors_broken_p1).w,d1
		bsr.w	sub_86B0
		move.w	#$5DA,d2
		move.w	(v_monitors_broken_p2).w,d1
		bsr.w	sub_86B0
		bsr.w	sub_8476
		move.w	#$364,d2
		move.w	#$6000,d0
		move.l	(v_score).w,d1
		sub.l	(v_score_p2).w,d1
		bsr.w	sub_8652
		move.w	#$404,d2
		move.l	(v_time_p2).w,d1
		sub.l	(v_time).w,d1
		bsr.w	sub_8652
		move.w	#$4A4,d2
		moveq	#0,d1
		move.w	(v_rings).w,d1
		sub.w	(v_rings_p2).w,d1
		bsr.w	sub_8652
		move.w	#$544,d2
		moveq	#0,d1
		move.w	(v_rings_collected_p1).w,d1
		sub.w	(v_rings_collected_p2).w,d1
		bsr.w	sub_8652
		move.w	#$5E4,d2
		moveq	#0,d1
		move.w	(v_monitors_broken_p1).w,d1
		sub.w	(v_monitors_broken_p2).w,d1
		bsr.w	sub_8652
		move.w	#$706,d2
		moveq	#0,d0
		moveq	#0,d1
		move.b	(a4),d1
		bsr.w	sub_86B0
		move.w	#$70E,d2
		moveq	#0,d1
		move.b	1(a4),d1
		bsr.w	sub_86B0
		move.w	(a4),(v_ss_total_won).w
		rts
; ===========================================================================

loc_82FA:
		move.w	#$242,d2
		moveq	#0,d0
		bsr.w	sub_8672
		bsr.w	sub_84A4
		lea	(v_ss_total_won).w,a4
		clr.w	(a4)
		move.w	#$398,d6
		bsr.w	sub_854A
		move.w	#$488,d6
		bsr.w	sub_854A
		move.w	#$618,d6
		bsr.w	sub_854A
		rts
; ===========================================================================

loc_8328:
		lea	(v_ehz_results_2p).w,a5
		lea	(v_ss_total_won).w,a4
		clr.w	(a4)
		move.w	#$208,d6
		bsr.w	sub_84C4
		move.w	#$258,d6
		bsr.w	sub_84C4
		move.w	#$2A8,d6
		bsr.w	sub_84C4
		move.w	#$348,d6
		bsr.w	sub_84C4
		move.w	#$398,d6
		bsr.w	sub_84C4
		move.w	#$3E8,d6
		bsr.w	sub_84C4
		move.w	#$488,d6
		bsr.w	sub_84C4
		move.w	#$4D8,d6
		bsr.w	sub_84C4
		move.w	#$528,d6
		bsr.w	sub_84C4
		move.w	#$5C8,d6
		bsr.w	sub_84C4
		move.w	#$618,d6
		bsr.w	sub_84C4
		move.w	#$668,d6
		bsr.w	sub_84C4
		move.w	#$70A,d2
		moveq	#0,d0
		moveq	#0,d1
		move.b	(a4),d1
		bsr.w	sub_86B0
		move.w	#$710,d2
		moveq	#0,d1
		move.b	1(a4),d1
		bsr.w	sub_86B0
		rts
; ===========================================================================

loc_83B0:
		move.w	#$266,d2
		moveq	#0,d1
		move.b	(v_act_2p).w,d1
		addq.b	#1,d1
		bsr.w	sub_86B0
		move.w	#$4D6,d2
		moveq	#0,d0
		move.w	(v_ss_2p_ring_buffer).w,d1
		bsr.w	sub_86B0
		move.w	#$4E6,d2
		move.w	($FFFFFFA2).w,d1
		bsr.w	sub_86B0
		move.w	#$576,d2
		moveq	#0,d0
		move.w	($FFFFFFA4).w,d1
		bsr.w	sub_86B0
		move.w	#$586,d2
		move.w	($FFFFFFA6).w,d1
		bsr.w	sub_86B0
		move.w	#$616,d2
		moveq	#0,d0
		move.w	($FFFFFFA8).w,d1
		bsr.w	sub_86B0
		move.w	#$626,d2
		move.w	($FFFFFFAA).w,d1
		bsr.w	sub_86B0
		bsr.w	sub_8476
		move.w	#$6000,d0
		move.w	#$4F0,d2
		moveq	#0,d1
		move.w	(v_ss_2p_ring_buffer).w,d1
		sub.w	($FFFFFFA2).w,d1
		bsr.w	sub_8652
		move.w	#$590,d2
		moveq	#0,d1
		move.w	($FFFFFFA4).w,d1
		sub.w	($FFFFFFA6).w,d1
		bsr.w	sub_8652
		move.w	#$630,d2
		moveq	#0,d1
		move.w	($FFFFFFA8).w,d1
		sub.w	($FFFFFFAA).w,d1
		bsr.w	sub_8652
		move.w	(a4),(v_ss_total_won).w
		rts
; ===========================================================================

loc_8452:
		bsr.w	sub_84A4
		lea	(v_ss_total_won).w,a4
		clr.w	(a4)
		move.w	#$4D4,d6
		bsr.w	sub_85CE
		move.w	#$574,d6
		bsr.w	sub_85CE
		move.w	#$614,d6
		bsr.w	sub_85CE
		rts

; ===========================================================================


sub_8476:
		lea	(v_ehz_results_2p).w,a4
		move.b	(v_zone_2p).w,d0
		beq.s	loc_8494
		lea	(v_mcz_results_2p).w,a4
		subq.b	#1,d0
		beq.s	loc_8494
		lea	(v_cnz_results_2p).w,a4
		subq.b	#1,d0
		beq.s	loc_8494
		lea	(v_ss_results_2p).w,a4

loc_8494:
		moveq	#0,d0
		move.b	(v_act_2p).w,d0
		add.w	d0,d0
		lea	(a4,d0.w),a4
		clr.w	(a4)
		rts


; ===========================================================================


sub_84A4:
		lea	(v_ehz_results_2p).w,a5
		move.b	(v_zone_2p).w,d0
		beq.s	locret_84C2
		lea	(v_mcz_results_2p).w,a5
		subq.b	#1,d0
		beq.s	locret_84C2
		lea	(v_cnz_results_2p).w,a5
		subq.b	#1,d0
		beq.s	locret_84C2
		lea	(v_ss_results_2p).w,a5

locret_84C2:
		rts


; ===========================================================================


sub_84C4:
		move.w	(a5),d0
		bmi.s	loc_84FC
		move.w	d6,d2
		moveq	#0,d0
		moveq	#0,d1
		move.b	(a5),d1
		bsr.w	sub_86B0
		addq.w	#8,d6
		move.w	d6,d2
		moveq	#0,d1
		move.b	1(a5),d1
		bsr.w	sub_86B0
		addi.w	#$12,d6
		move.w	d6,d2
		move.w	#$6000,d0
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		bsr.w	sub_8652
		addq.w	#2,a5
		rts
; ===========================================================================

loc_84FC:
		addq.w	#4,d6
		not.w	d0
		bne.s	loc_8522
		lea	(Text2P_NoGame).l,a1
		move.w	d6,d2
		bsr.w	loc_8698
		addi.w	#$16,d6
		move.w	d6,d2
		lea	(Text2P_Blank).l,a1
		bsr.w	loc_8698
		addq.w	#2,a5
		rts
; ===========================================================================

loc_8522:
		moveq	#0,d0
		lea	(Text2P_GameOver).l,a1
		move.w	d6,d2
		bsr.w	loc_8698
		addi.w	#$16,d6
		move.w	d6,d2
		move.w	#$6000,d0
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		bsr.w	sub_8652
		addq.w	#2,a5
		rts


; ===========================================================================

sub_854A:
		move.w	(a5),d0
		bmi.s	loc_8582
		move.w	d6,d2
		moveq	#0,d0
		moveq	#0,d1
		move.b	(a5),d1
		bsr.w	sub_86B0
		addq.w	#8,d6
		move.w	d6,d2
		moveq	#0,d1
		move.b	1(a5),d1
		bsr.w	sub_86B0
		addi.w	#$C,d6
		move.w	d6,d2
		move.w	#$6000,d0
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		bsr.w	sub_8652
		addq.w	#2,a5
		rts
; ===========================================================================

loc_8582:
		not.w	d0
		bne.s	loc_85A6
		lea	(Text2P_NoGame).l,a1
		move.w	d6,d2
		bsr.w	loc_8698
		addi.w	#$14,d6
		move.w	d6,d2
		lea	(Text2P_Blank).l,a1
		bsr.w	loc_8698
		addq.w	#2,a5
		rts
; ===========================================================================

loc_85A6:
		moveq	#0,d0
		lea	(Text2P_GameOver).l,a1
		move.w	d6,d2
		bsr.w	loc_8698
		addi.w	#$14,d6
		move.w	d6,d2
		move.w	#$6000,d0
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		bsr.w	sub_8652
		addq.w	#2,a5
		rts


; ===========================================================================


sub_85CE:
		move.w	(a5),d0
		bmi.s	loc_8608
		move.w	d6,d2
		moveq	#0,d0
		moveq	#0,d1
		move.b	(a5),d1
		bsr.w	sub_86B0
		addi.w	#$C,d6
		move.w	d6,d2
		moveq	#0,d1
		move.b	1(a5),d1
		bsr.w	sub_86B0
		addi.w	#$10,d6
		move.w	d6,d2
		move.w	#$6000,d0
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		bsr.w	sub_8652
		addq.w	#2,a5
		rts
; ===========================================================================

loc_8608:
		not.w	d0
		bne.s	loc_862C
		lea	(Text2P_NoGame).l,a1
		move.w	d6,d2
		addq.w	#4,d2
		bsr.w	loc_8698
		addi.w	#$14,d6
		move.w	d6,d2
		lea	(Text2P_Blank).l,a1
		bsr.s	loc_8698
		addq.w	#2,a5
		rts
; ===========================================================================

loc_862C:
		moveq	#0,d0
		lea	(Text2P_GameOver).l,a1
		move.w	d6,d2
		bsr.s	loc_8698
		addi.w	#$14,d6
		move.w	d6,d2
		move.w	#$6000,d0
		moveq	#0,d1
		move.b	(a5),d1
		sub.b	1(a5),d1
		bsr.w	sub_8652
		addq.w	#2,a5
		rts


; ===========================================================================


sub_8652:
		lea	(Text2P_Tied).l,a1
		beq.s	loc_8670
		bcs.s	loc_8666
		lea	(Text2P_1P).l,a1
		addq.b	#1,(a4)
		bra.s	loc_8670
; ===========================================================================

loc_8666:
		lea	(Text2P_2P).l,a1
		addq.b	#1,1(a4)

loc_8670:
		bra.s	loc_8698


; ===========================================================================


sub_8672:
		lea	(Text2P_EmeraldHill).l,a1
		move.b	(v_zone_2p).w,d1
		beq.s	loc_8698
		lea	(Text2P_MysticCave).l,a1
		subq.b	#1,d1
		beq.s	loc_8698
		lea	(Text2P_CasinoNight).l,a1
		subq.b	#1,d1
		beq.s	loc_8698
		lea	(Text2P_SpecialStage).l,a1

loc_8698:
		lea	(v_128x128_tiles).l,a2
		lea	(a2,d2.w),a2
		moveq	#0,d1
		move.b	(a1)+,d1

loc_86A6:
		move.b	(a1)+,d0
		move.w	d0,(a2)+
		dbf	d1,loc_86A6
		rts


; ===========================================================================


sub_86B0:
		lea	(v_128x128_tiles).l,a2
		lea	(a2,d2.w),a2
		lea	(word_86F0).l,a3
		moveq	#0,d2
		moveq	#2,d5

loc_86C4:
		moveq	#0,d3
		move.w	(a3)+,d4

loc_86C8:
		sub.w	d4,d1
		bcs.s	loc_86D0
		addq.w	#1,d3
		bra.s	loc_86C8
; ===========================================================================

loc_86D0:
		add.w	d4,d1
		tst.w	d5
		beq.s	loc_86E0
		tst.w	d3
		beq.s	loc_86DC
		moveq	#1,d2

loc_86DC:
		tst.w	d2
		beq.s	loc_86E8

loc_86E0:
		addi.b	#$10,d3
		move.b	d3,d0
		move.w	d0,(a2)

loc_86E8:
		addq.w	#2,a2
		dbf	d5,loc_86C4
		rts

; ===========================================================================
word_86F0:
		dc.w   $64					; 0
		dc.w	$A					; 1
		dc.w	 1					; 2

; ===========================================================================


sub_86F6:
		lea	(v_128x128_tiles).l,a2
		lea	(a2,d2.w),a2
		lea	(word_8732).l,a3
		moveq	#0,d2
		moveq	#5,d5

loc_870A:
		moveq	#0,d3
		move.l	(a3)+,d4

loc_870E:
		sub.l	d4,d1
		bcs.s	loc_8716
		addq.w	#1,d3
		bra.s	loc_870E
; ===========================================================================

loc_8716:
		add.l	d4,d1
		tst.w	d3
		beq.s	loc_871E
		moveq	#1,d2

loc_871E:
		tst.w	d2
		beq.s	loc_872A
		addi.b	#$10,d3
		move.b	d3,d0
		move.w	d0,(a2)

loc_872A:
		addq.w	#2,a2
		dbf	d5,loc_870A
		rts

; ===========================================================================
word_8732:
		dc.l 100000
		dc.l  10000
		dc.l   1000
		dc.l    100
		dc.l     10
		dc.l      1


Text2P_EmeraldHill:		charset	menu,"EMERALD HILL"
		rev02even
Text2P_MysticCave:		charset	menu," MYSTIC CAVE"
		rev02even
Text2P_CasinoNight:		charset	menu,"CASINO NIGHT"
		rev02even
Text2P_SpecialStage:	charset	menu,"SPECIAL STAGE"
		rev02even
Text2P_Special:			charset	menu,"   SPECIAL  "
		rev02even
Text2P_Zone:			charset	menu,"ZONE "
		rev02even
Text2P_Stage:			charset	menu,"STAGE"
		rev02even
Text2P_GameOver:		charset	menu,"GAME OVER"
		rev02even
Text2P_TimeOver:		charset	menu,"TIME OVER"
		rev02even
Text2P_NoGame:			charset	menu,"NO GAME"
		rev02even
Text2P_Tied:			charset	menu,"TIED"
		rev02even
Text2P_1P:				charset	menu," 1P"
		rev02even
Text2P_2P:				charset	menu," 2P"
		rev02even
Text2P_Blank:			charset	menu,"    "
		rev02even

; ------------------------------------------------------------------------
; Menu Animation Script
; ------------------------------------------------------------------------
word_87C6:	dc.w   0					; 0

; Sonic/Miles animated background
		dc.l $FF000000+Art_MenuBack
		dc.w $20
		dc.b 6
		dc.b $A
		dc.b   0,$C7					; 0
		dc.b  $A,  5					; 2
		dc.b $14,  5					; 4
		dc.b $1E,$C7					; 6
		dc.b $14,  5					; 8
		dc.b  $A,  5					; 10

off_87DC:
		dc.l Eni_2PActResults
		dc.l loc_819A
		dc.l Eni_2PZoneResults
		dc.l loc_82FA
		dc.l Eni_2PGameResults
		dc.l loc_8328
		dc.l Eni_2PSpecialStageActResults
		dc.l loc_83B0
		dc.l Eni_2PSpecialStageZoneResults
		dc.l loc_8452


		incfile	Eni_2PActResults			; byte_8804: Map_2PActResults:
		incfile	Eni_2PZoneResults			; byte_88CE: Map_2PZoneResults:
		incfile	Eni_2PGameResults			; byte_8960: Map_2PGameResults:
		incfile	Eni_2PSpecialStageActResults		; byte_8AA4: Map_2PSpecialStageActResults:
		incfile	Eni_2PSpecialStageZoneResults		; byte_8B30: Map_2PSpecialStageZoneResults:

; ===========================================================================

	if RemoveJmpTos=0
JmpTo2_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_Dynamic_Normal:
		jmp	(Dynamic_Normal).l
	endc

; ===========================================================================

MenuScreen:
		bsr.w	PaletteFadeOut
		disable_ints
		disable_display
		bsr.w	ClearScreen
		lea	(vdp_control_port).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$8230,(a6)
		move.w	#$8700,(a6)
		move.w	#$8C81,(a6)
		move.w	#$9001,(a6)

		clear_ram	v_sprite_queue,v_sprite_queue_end
		clear_ram	ost,ost_end
		reset_dma_queue

		move.l	#$42000000,(vdp_control_port).l
		lea	(Nem_StandardFont).l,a0
		bsr.w	NemDec
		move.l	#$4E000000,(vdp_control_port).l
		lea	(Nem_MenuBox).l,a0
		bsr.w	NemDec
		move.l	#$52000000,(vdp_control_port).l
		lea	(Nem_LevelSelectPics).l,a0
		bsr.w	NemDec
		lea	(v_128x128_tiles).l,a1
		lea	(Eni_MenuBack).l,a0
		move.w	#$6000,d0
		bsr.w	EniDec
		lea	(v_128x128_tiles).l,a1
		move.l	#$60000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		jsrto	TilemapToVRAM,JmpTo_TilemapToVRAM
		cmpi.b	#$24,(v_gamemode).w
		beq.w	loc_8FCC
		cmpi.b	#$28,(v_gamemode).w
		beq.w	loc_92F6
		lea	(v_128x128_tiles).l,a1
		lea	(Eni_LevelSelect2P).l,a0
		move.w	#$70,d0
		bsr.w	EniDec
		lea	($FFFF0198).l,a1
		lea	(Eni_LevelSelect2P).l,a0
		move.w	#$2070,d0
		bsr.w	EniDec
		lea	($FFFF0330).l,a1
		lea	(Eni_LevelSelectIcons).l,a0
		move.w	#$90,d0
		bsr.w	EniDec
		lea	($FFFF0498).l,a2
		moveq	#$F,d1

loc_8CF8:
		move.w	#$207B,(a2)+
		dbf	d1,loc_8CF8
		bsr.w	sub_8E7E
		addq.b	#1,(v_zone_2p).w
		andi.b	#3,(v_zone_2p).w
		bsr.w	sub_8F1C
		addq.b	#1,(v_zone_2p).w
		andi.b	#3,(v_zone_2p).w
		bsr.w	sub_8F1C
		addq.b	#1,(v_zone_2p).w
		andi.b	#3,(v_zone_2p).w
		bsr.w	sub_8F1C
		addq.b	#1,(v_zone_2p).w
		andi.b	#3,(v_zone_2p).w
		clr.w	(v_player_mode).w
		clr.b	(v_act_2p).w
		clr.w	(v_results_screen_2p).w
		clr.b	(f_level_started).w
		clr.w	(v_anim_counters).w
		clr.w	(v_game_over_2p).w
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo2_Dynamic_Normal
		moveq	#$26,d0
		bsr.w	PalLoad_Next
		lea	(v_pal_dry_line3).w,a1
		lea	($FFFFFBC0).w,a2
		moveq	#7,d1

loc_8D6A:
		move.l	(a1),(a2)+
		clr.l	(a1)+
		dbf	d1,loc_8D6A
		move.b	#-$6F,d0
		jsrto	PlayMusic,JmpTo_PlayMusic
		move.w	#$707,(v_countdown).w
		clr.w	(f_two_player).w
		clr.l	(v_camera_x_pos).w
		clr.l	(v_camera_y_pos).w
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	(v_vdp_mode_buffer).w,d0
		ori.b	#$40,d0
		move.w	d0,(vdp_control_port).l
		bsr.w	PaletteFadeIn

loc_8DA8:
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		disable_ints
		bsr.w	sub_8F1C
		bsr.w	sub_8E5A
		bsr.w	sub_8E7E
		enable_ints
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo2_Dynamic_Normal
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#-$80,d0
		bne.s	loc_8DE2
		bra.w	loc_8DA8
; ===========================================================================

loc_8DE2:
		bsr.w	sub_8EFE
		bmi.s	loc_8DF4
		move.w	#$ED,d0
		jsrto	PlaySound,JmpTo_PlaySound
		bra.w	loc_8DA8
; ===========================================================================

loc_8DF4:
		moveq	#0,d0
		move.b	(v_zone_2p).w,d0
		add.w	d0,d0
		move.w	word_8E52(pc,d0.w),d0
		bmi.s	loc_8E3A
		move.w	d0,(v_zone).w
		move.w	#1,(f_two_player).w
		move.b	#$C,(v_gamemode).w
		move.b	#0,(v_last_lamppost).w
		move.b	#0,(v_last_lamppost_p2).w
		moveq	#0,d0
		move.l	d0,(v_score).w
		move.l	d0,(v_score_p2).w
		move.l	#$1388,(v_score_next_life).w
		move.l	#$1388,(v_score_next_life_p2).w
		rts
; ===========================================================================

loc_8E3A:
		move.b	#4,(v_special_stage).w
		move.b	#$10,(v_gamemode).w
		moveq	#1,d0
		move.w	d0,(f_two_player).w
		move.w	d0,(f_two_player_mode_copy).w
		rts
; ===========================================================================
word_8E52:
		dc.w	id_EHZ_act1				; 0
		dc.w	id_MCZ_act1				; 2
		dc.w	id_CNZ_act1				; 4
		dc.w	$FFFF					; 6
; ===========================================================================

sub_8E5A:
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		move.b	d0,d1
		andi.b	#3,d0
		beq.s	loc_8E70
		bchg	#1,(v_zone_2p).w

loc_8E70:
		andi.b	#$C,d1
		beq.s	locret_8E7C
		bchg	#0,(v_zone_2p).w

locret_8E7C:
		rts
; ===========================================================================

sub_8E7E:
		moveq	#0,d0
		move.b	(v_zone_2p).w,d0
		lsl.w	#4,d0
		lea	(off_8F7E).l,a3
		lea	(a3,d0.w),a3
		move.w	#$6000,d0
		lea	($FFFF0048).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF0094).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF00D8).l,a2
		movea.l	4(a3),a1
		bsr.w	sub_8EFE
		bmi.s	loc_8EC2
		lea	($FFFF0468).l,a1

loc_8EC2:
		moveq	#2,d1

loc_8EC4:
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		lea	$1A(a2),a2
		dbf	d1,loc_8EC4
		lea	(v_128x128_tiles).l,a1
		move.l	(a3)+,d0
		moveq	#$10,d1
		moveq	#$B,d2
		jsrto	TilemapToVRAM,JmpTo_TilemapToVRAM
		lea	(Pal_LevelSelectIcons).l,a1
		moveq	#0,d0
		move.b	(a3),d0
		lsl.w	#5,d0
		lea	(a1,d0.w),a1
		lea	(v_pal_dry_line3).w,a2
		moveq	#7,d1

loc_8EF6:
		move.l	(a1)+,(a2)+
		dbf	d1,loc_8EF6
		rts
; ===========================================================================


sub_8EFE:
		moveq	#0,d0
		move.b	(v_zone_2p).w,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		add.w	d0,d0
		lea	(v_ehz_results_2p).w,a5
		lea	(a5,d0.w),a5
		move.w	(a5),d0
		add.w	2(a5),d0
		rts
; ===========================================================================

sub_8F1C:
		moveq	#0,d0
		move.b	(v_zone_2p).w,d0
		lsl.w	#4,d0
		lea	(off_8F7E).l,a3
		lea	(a3,d0.w),a3
		moveq	#0,d0
		lea	($FFFF01E0).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF022C).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF0270).l,a2
		lea	($FFFF0498).l,a1
		bsr.w	sub_8EFE
		bmi.s	loc_8F60
		lea	($FFFF0468).l,a1

loc_8F60:
		moveq	#2,d1

loc_8F62:
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		lea	$1A(a2),a2
		dbf	d1,loc_8F62
		lea	($FFFF0198).l,a1
		move.l	(a3)+,d0
		moveq	#$10,d1
		moveq	#$B,d2
		jmpto	TilemapToVRAM,JmpTo_TilemapToVRAM
; ===========================================================================

off_8F7E:
		dc.l Text2P_EmeraldHill
		dc.l Text2P_Zone
		dc.w $4104
		dc.w 3
		dc.w $FF
		dc.w $330
		dc.l Text2P_MysticCave
		dc.l Text2P_Zone
		dc.w $412C
		dc.w 3
		dc.w $5FF
		dc.w $3A8
		dc.l Text2P_CasinoNight
		dc.l Text2P_Zone
		dc.w $4784
		dc.w 3
		dc.w $6FF
		dc.w $3C0
		dc.l Text2P_Special
		dc.l Text2P_Stage
		dc.w $47AC
		dc.w 3
		dc.w $CFF
		dc.w $450
; ===========================================================================

sub_8FBE:
		moveq	#0,d1
		move.b	(a1)+,d1

loc_8FC2:
		move.b	(a1)+,d0
		move.w	d0,(a2)+
		dbf	d1,loc_8FC2
		rts
; ===========================================================================

loc_8FCC:
		lea	(v_128x128_tiles).l,a1
		lea	(Eni_Options).l,a0
		move.w	#$70,d0
		bsr.w	EniDec
		lea	($FFFF0160).l,a1
		lea	(Eni_Options).l,a0
		move.w	#$2070,d0
		bsr.w	EniDec
		clr.b	(v_options_menu_box).w
		bsr.w	sub_9186
		addq.b	#1,(v_options_menu_box).w
		bsr.w	loc_91F8
		addq.b	#1,(v_options_menu_box).w
		bsr.w	loc_91F8
		clr.b	(v_options_menu_box).w
		clr.b	(f_level_started).w
		clr.w	(v_anim_counters).w
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo2_Dynamic_Normal
		moveq	#$26,d0
		bsr.w	PalLoad_Next
		move.b	#-$6F,d0
		jsrto	PlayMusic,JmpTo_PlayMusic
		clr.w	(f_two_player).w
		clr.l	(v_camera_x_pos).w
		clr.l	(v_camera_y_pos).w
		clr.w	(v_correct_cheat_entries).w
		clr.w	(v_correct_cheat_entries_2).w
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	(v_vdp_mode_buffer).w,d0
		ori.b	#$40,d0
		move.w	d0,(vdp_control_port).l
		bsr.w	PaletteFadeIn

loc_9060:
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		disable_ints
		bsr.w	loc_91F8
		bsr.w	sub_90E0
		bsr.w	sub_9186
		enable_ints
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo2_Dynamic_Normal
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#-$80,d0
		bne.s	loc_909A
		bra.w	loc_9060
; ===========================================================================

loc_909A:
		move.b	(v_options_menu_box).w,d0
		bne.s	loc_90B6
		moveq	#0,d0
		move.w	d0,(f_two_player).w
		move.w	d0,(f_two_player_mode_copy).w
		move.w	d0,(v_zone).w
	if FixBugs
		; The game forgets to reset these variables here, making it possible
		; for the player to repeatedly soft-reset and play Emerald Hill Zone
		; over and over again, collecting all of the emeralds within the
		; first act. This code is borrowed from similar logic in the title
		; screen, which doesn't make this mistake.
		move.w	d0,(v_special_stage).w			; reset special stage index
		move.w	d0,(f_got_emerald).w			; clear got emerald flag
		move.l	d0,(v_emerald_list).w			; clear the emerald list
		move.l	d0,(v_emerald_list+4).w
	endc
		move.b	#id_Level,(v_gamemode).w
		rts
; ===========================================================================

loc_90B6:
		subq.b	#1,d0
		bne.s	loc_90D8
		moveq	#1,d0
		move.w	d0,(f_two_player).w
		move.w	d0,(f_two_player_mode_copy).w
	if FixBugs
		; The game forgets to reset these variables here, making it possible
		; for the player to repeatedly soft-reset and play Emerald Hill Zone
		; over and over again, collecting all of the emeralds within the
		; first act. This code is borrowed from similar logic in the title
		; screen, which doesn't make this mistake.
		moveq	#0,d0
		move.w	d0,(f_got_emerald).w			; clear got emerald flag
		move.l	d0,(v_emerald_list).w			; clear the emerald list
		move.l	d0,(v_emerald_list+4).w
	endc
		move.b	#id_LevelSelectMenu2P,(v_gamemode).w
		move.b	#0,(v_zone_2p).w
		move.w	#sonic_tails,(v_player_mode).w
		rts
; ===========================================================================

loc_90D8:
		move.b	#id_Sega,(v_gamemode).w
		rts
; ===========================================================================

sub_90E0:
		moveq	#0,d2
		move.b	(v_options_menu_box).w,d2
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		btst	#0,d0
		beq.s	loc_90FC
		subq.b	#1,d2
		bcc.s	loc_90FC
		move.b	#2,d2

loc_90FC:
		btst	#1,d0
		beq.s	loc_910C
		addq.b	#1,d2
		cmpi.b	#3,d2
		bcs.s	loc_910C
		moveq	#0,d2

loc_910C:
		move.b	d2,(v_options_menu_box).w
		lsl.w	#2,d2
		move.b	word_917A(pc,d2.w),d3
		movea.l	word_917A(pc,d2.w),a1
		move.w	(a1),d2
		btst	#2,d0
		beq.s	loc_9128
		subq.b	#1,d2
		bcc.s	loc_9128
		move.b	d3,d2

loc_9128:
		btst	#3,d0
		beq.s	loc_9136
		addq.b	#1,d2
		cmp.b	d3,d2
		bls.s	loc_9136
		moveq	#0,d2

loc_9136:
		btst	#6,d0
		beq.s	loc_9146
		addi.b	#$10,d2
		cmp.b	d3,d2
		bls.s	loc_9146
		moveq	#0,d2

loc_9146:
		move.w	d2,(a1)
		cmpi.b	#2,(v_options_menu_box).w
		bne.s	locret_9178
		andi.w	#$30,d0
		beq.s	locret_9178
		move.w	($FFFFFF84).w,d0
		addi.w	#$80,d0
		jsrto	PlayMusic,JmpTo_PlayMusic
		lea	(LevSelCode).l,a0
		lea	(ContinuesCode).l,a2
		lea	(f_levelselect_cheat).w,a1
		moveq	#0,d2
		bsr.w	loc_9746

locret_9178:
		rts
; ===========================================================================

word_917A:
		dc.w  $2FF					; 0
		dc.w $FF72					; 1
		dc.w  $1FF					; 2
		dc.w $FF74					; 3
		dc.w $7FFF					; 4
		dc.w $FF84					; 5
; ===========================================================================

sub_9186:
		bsr.w	loc_9268
		moveq	#0,d1
		move.b	(v_options_menu_box).w,d1
		lsl.w	#3,d1
		lea	(off_92BA).l,a3
		lea	(a3,d1.w),a3
		move.w	#$6000,d0
		lea	($FFFF0030).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF00B6).l,a2
		moveq	#0,d1
		cmpi.b	#2,(v_options_menu_box).w
		beq.s	loc_91CE
		move.b	(v_options_menu_box).w,d1
		lsl.w	#2,d1
		lea	word_917A(pc),a1
		movea.l	(a1,d1.w),a1
		move.w	(a1),d1
		lsl.w	#2,d1

loc_91CE:
		movea.l	(a4,d1.w),a1
		bsr.w	sub_8FBE
		cmpi.b	#2,(v_options_menu_box).w
		bne.s	loc_91E8
		lea	($FFFF00C2).l,a2
		bsr.w	loc_9296

loc_91E8:
		lea	(v_128x128_tiles).l,a1
		move.l	(a3)+,d0
		moveq	#$15,d1
		moveq	#7,d2
		jmpto	TilemapToVRAM,JmpTo_TilemapToVRAM
; ===========================================================================

loc_91F8:
		bsr.w	loc_9268
		moveq	#0,d1
		move.b	(v_options_menu_box).w,d1
		lsl.w	#3,d1
		lea	(off_92BA).l,a3
		lea	(a3,d1.w),a3
		moveq	#0,d0
		lea	($FFFF0190).l,a2
		movea.l	(a3)+,a1
		bsr.w	sub_8FBE
		lea	($FFFF0216).l,a2
		moveq	#0,d1
		cmpi.b	#2,(v_options_menu_box).w
		beq.s	loc_923E
		move.b	(v_options_menu_box).w,d1
		lsl.w	#2,d1
		lea	word_917A(pc),a1
		movea.l	(a1,d1.w),a1
		move.w	(a1),d1
		lsl.w	#2,d1

loc_923E:
		movea.l	(a4,d1.w),a1
		bsr.w	sub_8FBE
		cmpi.b	#2,(v_options_menu_box).w
		bne.s	loc_9258
		lea	($FFFF0222).l,a2
		bsr.w	loc_9296

loc_9258:
		lea	($FFFF0160).l,a1
		move.l	(a3)+,d0
		moveq	#$15,d1
		moveq	#7,d2
		jmpto	TilemapToVRAM,JmpTo_TilemapToVRAM
; ===========================================================================

loc_9268:
		lea	(off_92D2).l,a4
		tst.b	(v_console_region).w
		bpl.s	loc_927A
		lea	(off_92DE).l,a4

loc_927A:
		tst.b	(v_options_menu_box).w
		beq.s	loc_9286
		lea	(off_92EA).l,a4

loc_9286:
		cmpi.b	#2,(v_options_menu_box).w
		bne.s	locret_9294
		lea	(off_92F2).l,a4

locret_9294:
		rts
; ===========================================================================

loc_9296:
		move.w	($FFFFFF84).w,d1
		move.b	d1,d2
		lsr.b	#4,d1
		bsr.s	loc_92A2
		move.b	d2,d1

loc_92A2:
		andi.w	#$F,d1
		cmpi.b	#$A,d1
		bcs.s	loc_92B0
		addi.b	#4,d1

loc_92B0:
		addi.b	#$10,d1
		move.b	d1,d0
		move.w	d0,(a2)+
		rts
; ===========================================================================
off_92BA:
		dc.l TextOptScr_PlayerSelect
		dc.w $4192
		dc.w 3
		dc.l TextOptScr_VsModeItems
		dc.w $4592
		dc.w 3
		dc.l TextOptScr_SoundTest
		dc.w $4992
		dc.w 3
off_92D2:
		dc.l TextOptScr_SonicAndMiles
		dc.l TextOptScr_SonicAlone
		dc.l TextOptScr_MilesAlone
off_92DE:
		dc.l TextOptScr_SonicAndTails
		dc.l TextOptScr_SonicAlone
		dc.l TextOptScr_TailsAlone
off_92EA:
		dc.l TextOptScr_AllKindsItems
		dc.l TextOptScr_TeleportOnly
off_92F2:
		dc.l TextOptScr_0
; ===========================================================================

loc_92F6:
		lea	(v_128x128_tiles).l,a1
		lea	(Eni_LevelSelect).l,a0
		move.w	#0,d0
		bsr.w	EniDec
		lea	(v_128x128_tiles).l,a1
		move.l	#$40000003,d0
		moveq	#$27,d1
		moveq	#$1B,d2
		jsrto	TilemapToVRAM,JmpTo_TilemapToVRAM
		moveq	#0,d3
		bsr.w	loc_965A
		lea	($FFFF08C0).l,a1
		lea	(Eni_LevelSelectIcons).l,a0
		move.w	#$90,d0
		bsr.w	EniDec
		bsr.w	loc_9688
		clr.w	(v_player_mode).w
		clr.w	(v_results_screen_2p).w
		clr.b	(f_level_started).w
		clr.w	(v_anim_counters).w
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo2_Dynamic_Normal
		moveq	#$26,d0
		bsr.w	PalLoad_Next
		lea	(v_pal_dry_line3).w,a1
		lea	($FFFFFBC0).w,a2
		moveq	#7,d1

loc_9366:
		move.l	(a1),(a2)+
		clr.l	(a1)+
		dbf	d1,loc_9366
		move.b	#-$6F,d0
		jsrto	PlayMusic,JmpTo_PlayMusic
		move.w	#$707,(v_countdown).w
		clr.w	(f_two_player).w
		clr.l	(v_camera_x_pos).w
		clr.l	(v_camera_y_pos).w
		clr.w	(v_correct_cheat_entries).w
		clr.w	(v_correct_cheat_entries_2).w
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	(v_vdp_mode_buffer).w,d0
		ori.b	#$40,d0
		move.w	d0,(vdp_control_port).l
		bsr.w	PaletteFadeIn

loc_93AC:
		move.b	#$16,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		disable_ints
		moveq	#0,d3
		bsr.w	loc_95B8
		bsr.w	loc_94DC
		move.w	#$6000,d3
		bsr.w	loc_95B8
		bsr.w	loc_9688
		enable_ints
		lea	(word_87C6).l,a2
		jsrto	Dynamic_Normal,JmpTo2_Dynamic_Normal
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#-$80,d0
		bne.s	loc_93F0
		bra.w	loc_93AC
; ===========================================================================

loc_93F0:
		move.w	(v_level_select_zone).w,d0
		add.w	d0,d0
		move.w	Misc_9454(pc,d0.w),d0
		bmi.w	loc_944C
		cmpi.w	#$4000,d0
		bne.s	loc_9480
		move.b	#$10,(v_gamemode).w
		clr.w	(v_zone).w
		move.b	#3,(v_lives).w
		move.b	#3,(v_lives_p2).w
		moveq	#0,d0
		move.w	d0,(v_rings).w
		move.l	d0,(v_time).w
		move.l	d0,(v_score).w
		move.w	d0,(v_rings_p2).w
		move.l	d0,(v_time_p2).w
		move.l	d0,(v_score_p2).w
		move.l	#$1388,(v_score_next_life).w
		move.l	#$1388,(v_score_next_life_p2).w
		move.w	(v_player_option).w,(v_player_mode).w
		rts
; ===========================================================================

loc_944C:
		move.b	#0,(v_gamemode).w
		rts
; ===========================================================================
; -----------------------------------------------------------------------------
; Level	Select Level Order
;
; One entry per	item in	the level select menu. Just set	the value for the item
; you want to link to the level/act number of the level	you want to load when
; the player selects that item.
; -----------------------------------------------------------------------------
Misc_9454:
		dc.w	 0					; 0
		dc.w	 1					; 1
		dc.w  $D00					; 2
		dc.w  $D01					; 3
		dc.w  $F00					; 4
		dc.w  $F01					; 5
		dc.w  $C00					; 6
		dc.w  $C01					; 7
		dc.w  $700					; 8
		dc.w  $701					; 9
		dc.w  $B00					; 10
		dc.w  $B01					; 11
		dc.w  $A00					; 12
		dc.w  $A01					; 13
		dc.w  $400					; 14
		dc.w  $401					; 15
		dc.w  $500					; 16
		dc.w $1000					; 17
		dc.w  $600					; 18
		dc.w  $E00					; 19
		dc.w $4000					; 20
		dc.w $FFFF					; 21
; ===========================================================================

loc_9480:
		andi.w	#$3FFF,d0
		move.w	d0,(v_zone).w
		move.b	#$C,(v_gamemode).w
		move.b	#3,(v_lives).w
		move.b	#3,(v_lives_p2).w
		moveq	#0,d0
		move.w	d0,(v_rings).w
		move.l	d0,(v_time).w
		move.l	d0,(v_score).w
		move.w	d0,(v_rings_p2).w
		move.l	d0,(v_time_p2).w
		move.l	d0,(v_score_p2).w
		move.b	d0,(v_continues).w
		move.l	#$1388,(v_score_next_life).w
		move.l	#$1388,(v_score_next_life_p2).w
		move.b	#-7,d0
		jsrto	PlaySound,JmpTo_PlaySound
		moveq	#0,d0
		move.w	d0,(f_two_player_mode_copy).w
		move.w	d0,(f_two_player).w
		rts
; ===========================================================================

loc_94DC:
		move.b	(v_joypad_press_actual).w,d1
		andi.b	#3,d1
		bne.s	loc_94EC
		subq.w	#1,(v_levelselect_hold_delay).w
		bpl.s	loc_9522

loc_94EC:
		move.w	#$B,(v_levelselect_hold_delay).w
		move.b	(v_joypad_hold_actual).w,d1
		andi.b	#3,d1
		beq.s	loc_9522
		move.w	(v_level_select_zone).w,d0
		btst	#0,d1
		beq.s	loc_950C
		subq.w	#1,d0
		bcc.s	loc_950C
		moveq	#$15,d0

loc_950C:
		btst	#1,d1
		beq.s	loc_951C
		addq.w	#1,d0
		cmpi.w	#$16,d0
		bcs.s	loc_951C
		moveq	#0,d0

loc_951C:
		move.w	d0,(v_level_select_zone).w
		rts
; ===========================================================================

loc_9522:
		cmpi.w	#$15,(v_level_select_zone).w
		bne.s	loc_958A
		move.w	($FFFFFF84).w,d0
		move.b	(v_joypad_press_actual).w,d1
		btst	#2,d1
		beq.s	loc_953E
		subq.b	#1,d0
		bcc.s	loc_953E
		moveq	#$7F,d0

loc_953E:
		btst	#3,d1
		beq.s	loc_954E
		addq.b	#1,d0
		cmpi.w	#$80,d0
		bcs.s	loc_954E
		moveq	#0,d0

loc_954E:
		btst	#6,d1
		beq.s	loc_955C
		addi.b	#$10,d0
		andi.b	#$7F,d0

loc_955C:
		move.w	d0,($FFFFFF84).w
		andi.w	#$30,d1
		beq.s	locret_9588
		move.w	($FFFFFF84).w,d0
		addi.w	#$80,d0
		jsrto	PlayMusic,JmpTo_PlayMusic
		lea	(DebugCode).l,a0
		lea	(SuperSonicCode).l,a2
		lea	(f_debug_cheat).w,a1
		moveq	#1,d2
		bsr.w	loc_9746

locret_9588:
		rts
; ===========================================================================

loc_958A:
		move.b	(v_joypad_press_actual).w,d1
		andi.b	#$C,d1
		beq.s	locret_95A0
		move.w	(v_level_select_zone).w,d0
		move.b	byte_95A2(pc,d0.w),d0
		move.w	d0,(v_level_select_zone).w

locret_95A0:
		rts
; ===========================================================================
byte_95A2:
		dc.b $E						; 0
		dc.b $F						; 1
		dc.b $11					; 2
		dc.b $11					; 3
		dc.b $12					; 4
		dc.b $12					; 5
		dc.b $13					; 6
		dc.b $13					; 7
		dc.b $14					; 8
		dc.b $14					; 9
		dc.b $15					; 10
		dc.b $15					; 11
		dc.b $C						; 12
		dc.b $D						; 13
		dc.b 0						; 14
		dc.b 1						; 15
		dc.b 1						; 16
		dc.b 2						; 17
		dc.b 4						; 18
		dc.b 6						; 19
		dc.b 8						; 20
		dc.b $A						; 21
; ===========================================================================

loc_95B8:
		lea	(v_128x128_tiles).l,a4
		lea	(byte_96EE).l,a5
		lea	(vdp_data_port).l,a6
		moveq	#0,d0
		move.w	(v_level_select_zone).w,d0
		lsl.w	#2,d0
		lea	(a5,d0.w),a3
		moveq	#0,d0
		move.b	(a3),d0
		mulu.w	#$50,d0
		moveq	#0,d1
		move.b	1(a3),d1
		add.w	d1,d0
		lea	(a4,d0.w),a1
		moveq	#0,d1
		move.b	(a3),d1
		lsl.w	#7,d1
		add.b	1(a3),d1
		addi.w	#-$4000,d1
		lsl.l	#2,d1
		lsr.w	#2,d1
		ori.w	#$4000,d1
		swap	d1
		move.l	d1,vdp_control_port-vdp_data_port(a6)
		moveq	#$D,d2

loc_9608:
		move.w	(a1)+,d0
		add.w	d3,d0
		move.w	d0,(a6)
		dbf	d2,loc_9608
		addq.w	#2,a3
		moveq	#0,d0
		move.b	(a3),d0
		beq.s	loc_964C
		mulu.w	#$50,d0
		moveq	#0,d1
		move.b	1(a3),d1
		add.w	d1,d0
		lea	(a4,d0.w),a1
		moveq	#0,d1
		move.b	(a3),d1
		lsl.w	#7,d1
		add.b	1(a3),d1
		addi.w	#-$4000,d1
		lsl.l	#2,d1
		lsr.w	#2,d1
		ori.w	#$4000,d1
		swap	d1
		move.l	d1,vdp_control_port-vdp_data_port(a6)
		move.w	(a1)+,d0
		add.w	d3,d0
		move.w	d0,(a6)

loc_964C:
		cmpi.w	#$15,(v_level_select_zone).w
		bne.s	locret_9658
		bsr.w	loc_965A

locret_9658:
		rts
; ===========================================================================

loc_965A:
		move.l	#$49440003,(vdp_control_port).l
		move.w	($FFFFFF84).w,d0
		move.b	d0,d2
		lsr.b	#4,d0
		bsr.s	loc_9670
		move.b	d2,d0

loc_9670:
		andi.w	#$F,d0
		cmpi.b	#$A,d0
		bcs.s	loc_967E
		addi.b	#4,d0

loc_967E:
		addi.b	#$10,d0
		add.w	d3,d0
		move.w	d0,(a6)
		rts
; ===========================================================================

loc_9688:
		move.w	(v_level_select_zone).w,d0		; get zone selection
		lea	(LevSel_Icons).l,a3
		lea	(a3,d0.w),a3				; a3 = offset to icon map relative to v_128x128_tiles+$8C0, divided by $18
		lea	(v_128x128_tiles+$8C0).l,a1
		moveq	#0,d0
		move.b	(a3),d0					; get icon map offset
		lsl.w	#3,d0					; multiply by $18
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	(a1,d0.w),a1				; a1 = pointer to icon map
		vdp_comm.l	move,(vram_fg+((sizeof_vram_row_64*22)+(2*27))),vram,write,d0 ; set VDP to VRAM write at $CB36 (row 22, column 27)
		moveq	#3,d1
		moveq	#2,d2
		jsrto	TilemapToVRAM,JmpTo_TilemapToVRAM	; update the icon tilemap
		lea	(Pal_LevelSelectIcons).l,a1		; a1 = palettes for level select icon
		moveq	#0,d0
		move.b	(a3),d0
		lsl.w	#5,d0					; multiply by 32
		lea	(a1,d0.w),a1				; a1 = palette for this icon
		lea	(v_pal_dry_line3).w,a2			; palette buffer
		moveq	#(sizeof_pal/4)-1,d1

	 if FixBugs
		; When the icon changes, the colours are briefly incorrect. This is
		; because there's a delay between the icon being updated and the
		; colors being updated, due to the colors being uploaded to the VDP
		; during V-Int. To avoid this we can upload the colors ourselves right
		; here.
		; Prepare the VDP for data transfer.
		vdp_comm.l	move,sizeof_pal*2,cram,write,vdp_control_port-vdp_data_port(a6) ; set VDP to CRAM write at start of third palete line
    endc

	.loop:
	if FixBugs
		; Part of above bugfix.
		move.l	(a1),(a6)				; upload new color to VDP
	endc
		move.l	(a1)+,(a2)+				; copy new color to palette buffer
		dbf	d1,.loop
		rts
; ===========================================================================
LevSel_Icons:
		dc.b   0,0					;0	EHZ
		dc.b   7,7					;2	CPZ
		dc.b   8,8					;4	ARZ
		dc.b   6,6					;6	CNZ
		dc.b   2,2					;8	HTZ
		dc.b   5,5					;$A	MCZ
		dc.b   4,4					;$C	OOZ
		dc.b   1,1,1					;$E	MTZ
		dc.b   9					;$11	SCZ
		dc.b  $A					;$12	WFZ
		dc.b  $B					;$13	DEZ
		dc.b  $C					;$14	Special Stage
		dc.b  $E					;$15	Sound Test
		even

byte_96EE:
		dc.b   3,  6,  3,$24,  3,  6,  4,$24,  6,  6,  6,$24,  6,  6,  7,$24 ; 0
		dc.b   9,  6,  9,$24,  9,  6, $A,$24, $C,  6, $C,$24, $C,  6, $D,$24 ; 16
		dc.b  $F,  6, $F,$24, $F,  6,$10,$24,$12,  6,$12,$24,$12,  6,$13,$24 ; 32
		dc.b $15,  6,$15,$24,$15,  6,$16,$24,  3,$2C,  3,$48,  3,$2C,  4,$48 ; 48
		dc.b   3,$2C,  5,$48,  6,$2C,  0,  0,  9,$2C,  0,  0, $C,$2C,  0,  0 ; 64
		dc.b  $F,$2C,  0,  0,$12,$2C,$12,$48		; 80
; ===========================================================================

loc_9746:
		move.w	(v_correct_cheat_entries).w,d0
		adda.w	d0,a0
		move.w	(v_sound_test_sound).w,d0
		cmp.b	(a0),d0
		bne.s	loc_976A
		addq.w	#1,(v_correct_cheat_entries).w
		tst.b	1(a0)
		bne.s	loc_9770
		move.w	#$101,(a1)
		move.b	#sfx_Ring,d0
		jsrto	PlaySound,JmpTo_PlaySound

loc_976A:
		move.w	#0,(v_correct_cheat_entries).w

loc_9770:
		move.w	(v_correct_cheat_entries_2).w,d0
		adda.w	d0,a2
		move.w	(v_sound_test_sound).w,d0
		cmp.b	(a2),d0
		bne.s	loc_97AA
		addq.w	#1,(v_correct_cheat_entries_2).w
		tst.b	1(a2)
		bne.s	locret_97B0
		tst.w	d2
		bne.s	loc_979C
		move.b	#15,(v_continues).w
	if FixBugs
		move.b	#sfx_ContinueJingle,d0
	else
		; This is invalid input, and causes the driver to get stuck playing OOZ's
		; music forever.
		move.b	#sfx_ContinueJingle&$7F,d0
	endc
		jsrto	PlayMusic,JmpTo_PlayMusic
		bra.s	loc_97AA
; ===========================================================================

loc_979C:
		move.w	#7,(f_got_emerald).w
		move.b	#mus_Emerald,d0
		jsrto	PlayMusic,JmpTo_PlayMusic

loc_97AA:
		move.w	#0,(v_correct_cheat_entries_2).w

locret_97B0:
		rts
; ===========================================================================

LevSelCode:
		; 17th September 1965, the birthdate of Sonic 2's lead programmer,
		; Yuji Naka.
		dc.b $19, $65,  9, $17,  0
		rev02even

ContinuesCode:
		; November 24th, which was Sonic 2's release date outside of Japan.
		dc.b   1,  1,  2,  4,  0
		rev02even

DebugCode:
		; 24th November 1992 (also known as "Sonic 2sday"), which was
		; Sonic 2's release date outside of Japan
		dc.b   1,  9,  9,  2,  1,  1,  2,  4,  0
		rev02even

SuperSonicCode:
		; A Hebrew Bible verse: Genesis 41:26, which makes frequent reference to the
		; number 7. 7 happens to be the number of Chaos Emeralds.
		; (The Mega Drive is known as the Genesis in North America).
		dc.b   4,  1,  2,  6,  0
		rev02even

TextOptScr_PlayerSelect:	charset	menu,"* PLAYER SELECT *"
TextOptScr_SonicAndMiles:	charset	menu,"SONIC AND MILES"
TextOptScr_SonicAndTails:	charset	menu,"SONIC AND TAILS"
TextOptScr_SonicAlone:		charset	menu,"SONIC ALONE    "
TextOptScr_MilesAlone:		charset	menu,"MILES ALONE    "
TextOptScr_TailsAlone:		charset	menu,"TAILS ALONE    "
TextOptScr_VsModeItems:		charset	menu,"* VS MODE ITEMS *"
TextOptScr_AllKindsItems:	charset	menu,"ALL KINDS ITEMS"
TextOptScr_TeleportOnly:	charset	menu,"TELEPORT ONLY  "
TextOptScr_SoundTest:		charset	menu,"*  SOUND TEST   *"
TextOptScr_0:				charset	menu,"      00       "
; ===========================================================================

		incfile	Pal_LevelSelectIcons			; byte_9880:  Pal_LevelIcons:
		incfile	Eni_LevelSelect2P			; byte_9A60: MapEng_LevSel2P:
		incfile	Eni_Options				; byte_9AB2: MapEng_Options:
		incfile	Eni_LevelSelect				; byte_9ADE: MapEng_LevSel:
		incfile	Eni_LevelSelectIcons			; byte_9C32: MapEng_LevSelIcon:

; ===========================================================================

	if RemoveJmpTos=0
JmpTo_PlaySound:
		jmp	(PlaySound).l
JmpTo_PlayMusic:
		jmp	(PlayMusic).l
JmpTo_TilemapToVRAM:
		jmp	(TilemapToVRAM).l
JmpTo2_Dynamic_Normal:
		jmp	(Dynamic_Normal).l

		align 4
	endc

; ===========================================================================
; loc_9C7C:
EndingSequence:
		clear_ram	ost,ost_end
		clear_ram	misc_variables,misc_variables_end
		clear_ram	camera_ram,camera_ram_end
		disable_ints
		disable_display
		stopZ80
		waitZ80

		dma_fill	0,sizeof_vram_planetable_64x32,vram_fg
		clr.l	(v_fg_y_pos_vsram).w
		clr.l	(v_unused_ss).w

		startZ80
		lea	(vdp_control_port).l,a6
		move.w	#-$74FD,(a6)
		move.w	#-$7DD0,(a6)
		move.w	#-$7BF9,(a6)
		move.w	#-$7A84,(a6)
		move.w	#-$6FFF,(a6)
		move.w	#-$7FFC,(a6)
		move.w	#-$78E0,(a6)
		move.w	#-$7521,(v_vdp_hint_counter).w
		move.w	(v_vdp_hint_counter).w,(a6)
		clr.b	(f_super).w
		cmpi.b	#countof_emeralds,(v_emeralds).w
		bne.s	loc_9D64
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	loc_9D64
		st.b	(f_super).w
		move.b	#-1,(v_super_sonic_palette).w
		move.b	#$F,(v_palette_timer).w
		move.w	#$30,(v_palette_frame).w

loc_9D64:
		moveq	#0,d0
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	loc_9D78
		tst.b	(f_super).w
		bne.s	loc_9D7A
		bra.w	EndSeq_LoadArt
; ===========================================================================

loc_9D78:
		addq.w	#2,d0

loc_9D7A:
		addq.w	#2,d0

EndSeq_LoadArt:
		move.w	d0,(v_ending_routine).w
		bsr.w	EndSeq_LoadCharacterArt
		bsr.w	EndSeq_LoadBirdArt

		vdp_comm.l	move,vram_EndingFinalTornado,vram,write,(vdp_control_port).l
		lea	(Nem_EndingFinalTornado).l,a0
		jsrto	NemDec,JmpTo_NemDec

		vdp_comm.l	move,vram_EndingPics,vram,write,(vdp_control_port).l
		lea	(Nem_EndingStills).l,a0
		jsrto	NemDec,JmpTo_NemDec

		vdp_comm.l	move,vram_EndingMiniTornado,vram,write,(vdp_control_port).l
		lea	(Nem_EndingMiniTornado).l,a0
		jsrto	NemDec,JmpTo_NemDec

		vdp_comm.l	move,vram_Tornado,vram,write,(vdp_control_port).l
		lea	(Nem_Tornado).l,a0
		jsrto	NemDec,JmpTo_NemDec

		vdp_comm.l	move,vram_Clouds,vram,write,(vdp_control_port).l
		lea	(Nem_Clouds).l,a0
		jsrto	NemDec,JmpTo_NemDec

		move.w	#id_DEZ_act1,(v_zone).w
		enable_ints
		moveq_	mus_Ending,d0				; play ending music
		jsrto	PlayMusic,JmpTo2_PlayMusic
		move.l	#cWhite<<16|cWhite,d1			; two consecutive palette entries of white

		lea	(v_pal_dry).w,a1
		moveq	#(sizeof_pal_all/4)-1,d0

	.fillwhite:
		move.l	d1,(a1)+				; fill entire CRAM with white
		dbf	d0,.fillwhite

		lea	(Pal_EndingSonic).l,a1
		lea	(v_pal_dry_next).w,a2
		moveq	#(sizeof_pal_all/4)-1,d0

	.loadpal:
		move.l	(a1)+,(a2)+
		dbf	d0,.loadpal

		clr.b	(f_screen_shake).w
		moveq	#0,d0
		move.w	d0,(v_debug_active).w
		move.w	d0,(f_restart).w
		move.w	d0,(v_frame_counter).w
		move.w	d0,(v_camera_x_pos).w
		move.w	d0,(v_camera_y_pos).w
		move.w	d0,(v_camera_x_pos_copy2).w
		move.w	d0,(v_camera_y_pos_copy2).w
		move.w	d0,(v_bg1_x_pos).w
		move.w	#$C8,(v_bg1_y_pos).w
		move.l	d0,(v_fg_y_pos_vsram).w
		move.b	d0,(v_bg1_x_redraw_flag).w
		move.b	d0,(v_bg1_y_redraw_flag).w
		move.w	d0,(v_ending_vblank_sub).w
		move.w	d0,(f_credits_trigger).w

	if FixBugs
		clear_ram	hscroll,hscroll_end
	else
		; The '+4' shouldn't be here; clearRAM accidentally clears an additional 4 bytes.
		clear_ram	hscroll,hscroll_end+4
	endc

		move.w	#$7FFF,(v_palcycle_time).w
		lea	($FFFFB100).w,a1
		move.b	#id_Cutscene,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.w	#$60,$3C(a1)
		move.w	#1,$30(a1)
		cmpi.w	#4,($FFFFF750).w
		bne.s	loc_9EA4
		move.w	#$10,$2E(a1)
		move.w	#$100,$3C(a1)

loc_9EA4:
		move.b	#$18,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		move.w	(v_vdp_mode_buffer).w,d0
		ori.b	#$40,d0
		move.w	d0,(vdp_control_port).l

loc_9EBC:
		move.b	#$18,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		addq.w	#1,(v_frame_counter).w
		jsr	(RandomNumber).l
		jsr	(ExecuteObjects).l
		jsr	(BuildSprites).l
		tst.b	(f_ending_palcycle).w
		beq.s	loc_9EE6
		jsrto	PaletteCycle,JmpTo_PaletteCycle

loc_9EE6:
		bsr.w	sub_9EF4
		tst.w	(f_restart).w
		beq.w	loc_9EBC
		rts

; ===========================================================================


sub_9EF4:
		tst.b	($FFFFF660).w
		beq.w	locret_A0BE
		bsr.w	PaletteFadeOut
		lea	(vdp_control_port).l,a6
		move.w	#-$7FFC,(a6)
		move.w	#-$7DD0,(a6)
		move.w	#-$7BF9,(a6)
		move.w	#-$6FFF,(a6)
		move.w	#-$6E00,(a6)
		move.w	#-$74FD,(a6)
		move.w	#-$7900,(a6)
		clr.b	(f_water_pal_full).w
		move.w	#-$737F,(a6)
		jsrto	ClearScreen,JmpTo_ClearScreen

		lea	(v_sprite_queue).w,a1
		moveq	#0,d0
		move.w	#$FF,d1
loc_9F38:
		move.l	d0,(a1)+
		dbf	d1,loc_9F38

		lea	($FFFFB000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1
loc_9F48:
		move.l	d0,(a1)+
		dbf	d1,loc_9F48

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1
loc_9F58:
		move.l	d0,(a1)+
		dbf	d1,loc_9F58

		lea	(v_camera_x_pos).w,a1
		moveq	#0,d0
		move.w	#$3F,d1
loc_9F68:
		move.l	d0,(a1)+
		dbf	d1,loc_9F68

		clr.b	(f_screen_shake).w
		moveq	#0,d0
		move.w	d0,(f_restart).w
		move.w	d0,(v_frame_counter).w
		move.w	d0,(v_camera_x_pos).w
		move.w	d0,(v_camera_y_pos).w
		move.w	d0,(v_camera_x_pos_copy2).w
		move.w	d0,(v_camera_y_pos_copy2).w
		move.w	d0,(v_bg1_x_pos).w
		move.w	d0,(v_bg1_y_pos).w
		move.l	d0,(v_fg_y_pos_vsram).w
		move.b	d0,(v_bg1_x_redraw_flag).w
		move.b	d0,(v_bg1_y_redraw_flag).w
		move.w	d0,(v_ending_vblank_sub).w
		move.w	d0,(f_credits_trigger).w

	if FixBugs
		clear_ram	hscroll,hscroll_end
	else
		; The '+4' shouldn't be here; clearRAM accidentally clears an additional 4 bytes.
		clear_ram	hscroll,hscroll_end+4
	endc

		moveq	#-$62,d0
		jsrto	PlaySound,JmpTo2_PlaySound
		clr.w	(v_pal_dry_next).w
		move.w	#$EEE,($FFFFFB8C).w
		move.w	#$EE,($FFFFFBAC).w
		move.l	#$40200000,(vdp_control_port).l
		lea	(Nem_CreditsFont).l,a0
		jsrto	NemDec,JmpTo_NemDec
		clr.w	($FFFFFF4C).w

loc_9FE6:
		jsrto	ClearScreen,JmpTo_ClearScreen
		bsr.w	sub_B262
		bsr.w	PaletteFadeIn

		; The expressions in these move.w instructions automatically calculate the duration
		; value for each frame of the credits. The values are calculated thusly: total number
		; of frames for entire credits in terms of NTSC or PAL FPS, divided by the the number
		; of slides in the credits, minus $16*2 for fade in and fade out of each slide.
		move.w	#(((154*countof_ntsc_fps)+42)/(sizeof_Credits_Pointers/4))-($16+$16),d0 ; $18E
		btst	#console_speed_bit,(v_console_region).w
		beq.s	loc_A002
		move.w	#(((154*countof_pal_fps)+28)/(sizeof_Credits_Pointers/4))-($16+$16),d0 ; $144

loc_A002:
		move.b	#$18,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		dbf	d0,loc_A002
		bsr.w	PaletteFadeOut
		lea	(Credits_Pointers).l,a1
		addq.w	#1,($FFFFFF4C).w
		move.w	($FFFFFF4C).w,d0
		lsl.w	#2,d0
		move.l	(a1,d0.w),d0
		bpl.s	loc_9FE6
		bsr.w	PaletteFadeOut
		jsrto	ClearScreen,JmpTo_ClearScreen
		move.l	#$40000000,(vdp_control_port).l
		lea	(Nem_EndingLogo).l,a0
		jsrto	NemDec,JmpTo_NemDec
		lea	(Eni_EndGameLogo).l,a0
		lea	(v_128x128_tiles).l,a1
		move.w	#0,d0
		jsrto	EniDec,JmpTo_EniDec
		lea	(v_128x128_tiles).l,a1
		move.l	#$45980003,d0
		moveq	#$F,d1
		moveq	#5,d2
		jsrto	TilemapToVRAM,JmpTo2_TilemapToVRAM
		clr.w	($FFFFFF4C).w
		bsr.w	sub_A0C0
		move.w	#$3B,d0

loc_A07A:
		move.b	#$18,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		dbf	d0,loc_A07A
		move.w	#$257,d6

loc_A08C:
		move.b	#$18,(v_vblank_routine).w
		bsr.w	WaitForVBlank
		addq.w	#1,($FFFFFF4C).w
		bsr.w	sub_A0C0
		cmpi.w	#$5E,($FFFFFF4C).w
		bcs.s	loc_A08C
		move.b	(v_joypad_press_actual).w,d1
		andi.b	#-$10,d1
		bne.s	loc_A0B4
		dbf	d6,loc_A08C

loc_A0B4:
		st.b	(f_restart).w
		move.b	#0,(v_gamemode).w

locret_A0BE:
		rts

; ===========================================================================


sub_A0C0:
		lea	($FFFFFB02).w,a2
		move.w	($FFFFFF4C).w,d0
		cmpi.w	#$24,d0
		bcc.s	locret_A0BE
		btst	#0,d0
		bne.s	locret_A0BE
		lsr.w	#1,d0
		move.b	byte_A0EC(pc,d0.w),d0
		mulu.w	#$18,d0
		lea	Pal_EndingLogoCyc(pc,d0.w),a1
		moveq	#5,d0

loc_A0E4:
		move.l	(a1)+,(a2)+
		dbf	d0,loc_A0E4
		rts

; ===========================================================================
byte_A0EC:
		dc.b   0					; 0
		dc.b   1					; 1
		dc.b   2					; 2
		dc.b   3					; 3
		dc.b   4					; 4
		dc.b   3					; 5
		dc.b   2					; 6
		dc.b   1					; 7
		dc.b   0					; 8
		dc.b   5					; 9
		dc.b   6					; 10
		dc.b   7					; 11
		dc.b   8					; 12
		dc.b   7					; 13
		dc.b   6					; 14
		dc.b   5					; 15
		dc.b   0					; 16
		dc.b   0					; 17

		incfile	Pal_EndingLogoCyc			; pal_A0FE:

; ===========================================================================
; ----------------------------------------------------------------------------
; Object CA - Ending cutscene manager
; ----------------------------------------------------------------------------

Cutscene:
		addq.w	#1,$32(a0)
		cmpi.w	#4,($FFFFF750).w
		beq.s	loc_A1FA
		cmpi.w	#2,($FFFFF750).w
		bne.s	loc_A1FA
		st.b	(f_super).w
		move.w	#$100,(v_rings).w
		move.b	#-1,(v_super_sonic_palette).w

loc_A1FA:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_A208(pc,d0.w),d1
		jmp	off_A208(pc,d1.w)
; ===========================================================================
off_A208:	index offset(*),,2
		ptr loc_A218					; 0
		ptr loc_A240					; 2
		ptr loc_A24E					; 4
		ptr loc_A240					; 6
		ptr loc_A256					; 8
		ptr loc_A30A					; $A
		ptr loc_A34C					; $C
		ptr loc_A38E					; $E
; ===========================================================================

loc_A218:
		moveq	#4,d0
		move.w	#$180,d1
		btst	#console_speed_bit,(v_console_region).w
		beq.s	sub_A22A
		move.w	#$100,d1

sub_A22A:
		lea	($FFFFB0C0).w,a1
		move.b	#id_PalChanger,ost_id(a1)
		move.b	d0,ost_subtype(a1)
		addq.b	#2,ost_primary_routine(a0)
		move.w	d1,$3C(a0)
		rts

; ===========================================================================

loc_A240:
		subq.w	#1,$3C(a0)
		bmi.s	loc_A248
		rts
; ===========================================================================

loc_A248:
		addq.b	#2,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_A24E:
		moveq	#6,d0
		move.w	#$80,d1
		bra.s	sub_A22A
; ===========================================================================

loc_A256:
		move.w	$2E(a0),d0
		cmpi.w	#$10,d0
		bcc.s	loc_A2AC
		addq.w	#4,$2E(a0)
		clr.b	ost_primary_routine(a0)
		move.l	a0,-(sp)
		movea.l	off_A29C(pc,d0.w),a0
		lea	(v_128x128_tiles).l,a1
		move.w	#$328,d0
		jsrto	EniDec,JmpTo_EniDec
		disable_ints
		lea	(v_128x128_tiles).l,a1
		move.l	#$441C0003,d0
		moveq	#$B,d1
		moveq	#8,d2
		jsrto	TilemapToVRAM,JmpTo2_TilemapToVRAM
		enable_ints
		movea.l	(sp)+,a0
		rts
; ===========================================================================
off_A29C:
		dc.l Eni_Ending1
		dc.l Eni_Ending2
		dc.l Eni_Ending3
		dc.l Eni_Ending4
; ===========================================================================

loc_A2AC:
		move.w	#2,($FFFFF662).w
		st.b	(f_lock_controls).w
		st.b	(f_ending_palcycle).w
		lea	($FFFFB000).w,a1
		move.w	($FFFFF750).w,d0
		move.w	off_A2DA(pc,d0.w),d0
		jsr	off_A2DA(pc,d0.w)
		move.w	#$80,d1
		bsr.w	sub_A22A
		move.w	#$40,$3C(a0)
		rts
; ===========================================================================
off_A2DA:	index offset(*),,2
		ptr loc_A2E0					; 0
		ptr loc_A2EE					; 2
		ptr loc_A2F2					; 4
; ===========================================================================

loc_A2E0:
		moveq	#8,d0

loc_A2E2:
		move.b	#id_SonicPlayer,ost_id(a1)
		move.b	#-$7F,$2A(a1)
		rts
; ===========================================================================

loc_A2EE:
		moveq	#$C,d0
		bra.s	loc_A2E2
; ===========================================================================

loc_A2F2:
		moveq	#$E,d0
		move.b	#id_TailsPlayer,ost_id(a1)
		move.b	#-$7F,$2A(a1)
		move.b	#5,($FFFFB080).w
		move.w	a1,($FFFFB0BE).w
		rts
; ===========================================================================

loc_A30A:
		subq.w	#1,$3C(a0)
		bpl.s	loc_A320
		moveq	#$A,d0
		move.w	#$80,d1
		bsr.w	sub_A22A
		move.w	#$C0,$3C(a0)

loc_A320:
		lea	($FFFFB000).w,a1
		move.b	#$F,ost_anim(a1)
		move.w	#$A0,ost_x_pos(a1)
		move.w	#$50,ost_y_pos(a1)
		cmpi.w	#2,($FFFFF750).w
		bne.s	locret_A34A
		move.b	#0,ost_anim(a1)
		move.w	#$1000,ost_inertia(a1)

locret_A34A:
		rts
; ===========================================================================

loc_A34C:
		subq.w	#1,$3C(a0)
		bmi.s	loc_A366
		moveq	#0,d4
		moveq	#0,d5
		move.w	#0,(v_camera_x_diff).w
		move.w	#$100,(v_camera_y_diff).w
		bra.w	Deform_DEZ
; ===========================================================================

loc_A366:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$100,$3C(a0)
		cmpi.w	#4,($FFFFF750).w
		bne.s	locret_A38C
		move.w	#$880,$3C(a0)
		btst	#console_speed_bit,(v_console_region).w
		beq.s	locret_A38C
		move.w	#$660,$3C(a0)

locret_A38C:
		rts
; ===========================================================================

loc_A38E:
		btst	#console_speed_bit,(v_console_region).w
		beq.s	loc_A3A2
		cmpi.w	#$E40,$32(a0)
		beq.s	loc_A3BE
		bra.w	loc_A3AA
; ===========================================================================

loc_A3A2:
		cmpi.w	#$1140,$32(a0)
		beq.s	loc_A3BE

loc_A3AA:
		subq.w	#1,$3C(a0)
		bne.s	loc_A3BA
		lea	(dword_AD62).l,a2
		jsrto	LoadChild,JmpTo_LoadChild

loc_A3BA:
		bra.w	loc_AB9C
; ===========================================================================

loc_A3BE:
		addq.b	#2,ost_primary_routine(a0)
		st.b	($FFFFF660).w
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object CC - Trigger for Tornado rescue and birds in ending cutscene
; ----------------------------------------------------------------------------

EndingTrigger:
		jsrto	loc_3AF58,JmpTo_loc_3AF58
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	loc_A3DA(pc,d0.w),d1
		jmp	loc_A3DA(pc,d1.w)
; ===========================================================================

loc_A3DA:
		ori.b	#$7C,d4
		lea	(off_3AFC8).l,a1
		jsrto	LoadSubObjData3,JmpTo_LoadSubObjData3
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_A3FC
		move.b	#4,ost_frame(a0)
		move.b	#1,ost_anim(a0)

loc_A3FC:
		move.w	#-$10,ost_x_pos(a0)
		move.w	#$C0,ost_y_pos(a0)
		move.w	#$100,ost_x_vel(a0)
		move.w	#-$80,ost_y_vel(a0)
		move.b	#$14,$35(a0)
		move.b	#3,ost_priority(a0)
		move.w	#4,($FFFFF662).w
		move.l	a0,-(sp)
		lea	(Eni_EndingTailsPlane).l,a0
		cmpi.w	#4,($FFFFF750).w
		bne.s	loc_A43C
		lea	(Eni_EndingSonicPlane).l,a0

loc_A43C:
		lea	(v_128x128_tiles).l,a1
		move.w	#-$7EAA,d0
		jsrto	EniDec,JmpTo_EniDec
		movea.l	(sp)+,a0
		move.w	#$C00,(v_pal_dry_line3).w
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_A468(pc,d0.w),d1
		jsr	off_A468(pc,d1.w)
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================
off_A468:	index offset(*),,2
		ptr loc_A474					; 0
		ptr loc_A4B6					; 2
		ptr loc_A5A6					; 4
		ptr loc_A6C6					; 6
		ptr loc_A7DE					; 8
		ptr loc_A83E					; $A
; ===========================================================================

loc_A474:
		cmpi.w	#$A0,ost_x_pos(a0)
		beq.s	loc_A48A
		jsrto	SpeedToPos,JmpTo2_SpeedToPos

loc_A480:
		lea	(Ani_3AFDC).l,a1
		jmpto	AnimateSprite,JmpTo_AnimateSprite
; ===========================================================================

loc_A48A:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$480,$3C(a0)
		btst	#console_speed_bit,(v_console_region).w
		beq.s	loc_A4A2
		move.w	#$3D0,$3C(a0)

loc_A4A2:
		move.w	#$40,$32(a0)
		st.b	($FFFFB134).w
		clr.w	ost_x_vel(a0)
		clr.w	ost_y_vel(a0)
		bra.s	loc_A480
; ===========================================================================

loc_A4B6:
		bsr.w	sub_ABBA
		bsr.w	sub_A524
		subq.w	#1,$3C(a0)
		bmi.s	loc_A4C6
		bra.s	loc_A480
; ===========================================================================

loc_A4C6:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#2,$3C(a0)
		clr.w	$32(a0)
		clr.b	ost_frame(a0)
		cmpi.w	#2,($FFFFF750).w
		beq.s	loc_A4F4
		move.b	#7,ost_frame(a0)
		cmpi.w	#4,($FFFFF750).w
		bne.s	loc_A4F4
		move.b	#$18,ost_frame(a0)

loc_A4F4:
		clr.b	ost_anim(a0)
		clr.b	ost_anim_frame(a0)
		clr.b	ost_anim_time(a0)
		move.l	#Map_TornadoHelices,ost_mappings(a0)
		move.w	#0,ost_tile(a0)				; level art
		jsr	(AdjustVRAM2P).l
		subi.w	#$14,ost_x_pos(a0)
		addi.w	#$14,ost_y_pos(a0)
		bra.w	sub_A58C

; ===========================================================================


sub_A524:
		lea	($FFFFB000).w,a1
		move.w	($FFFFF750).w,d0
		move.w	off_A534(pc,d0.w),d0
		jmp	off_A534(pc,d0.w)

; ===========================================================================
off_A534:	index offset(*)
		ptr	loc_A53A				; 0
		ptr loc_A55C					; 2
		ptr loc_A582					; 4
; ===========================================================================

loc_A53A:
		move.w	ost_y_pos(a0),d0
		subi.w	#$1C,d0

loc_A542:
		move.w	d0,ost_y_pos(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.l	#$1000505,ost_frame(a1)
		move.w	#$100,ost_anim_time(a1)
		rts
; ===========================================================================

loc_A55C:
		tst.w	$32(a0)
		beq.s	loc_A574
		subq.w	#1,$32(a0)
		addi.l	#$8000,ost_x_pos(a1)
		addq.w	#1,ost_y_pos(a1)
		rts
; ===========================================================================

loc_A574:
		move.w	#$C0,ost_x_pos(a1)
		move.w	#$90,ost_y_pos(a1)
		rts
; ===========================================================================

loc_A582:
		move.w	ost_y_pos(a0),d0
		subi.w	#$18,d0
		bra.s	loc_A542

; ===========================================================================


sub_A58C:
		tst.b	(f_super).w
		bne.w	locret_A38C

loc_A594:
		lea	(v_ost_player1).w,a1
		move.w	#$200,ost_x_pos(a1)
		move.w	#0,ost_y_pos(a1)
		rts

; ===========================================================================

loc_A5A6:
		bsr.s	sub_A58C
		subq.w	#1,$3C(a0)
		bpl.s	locret_A5E6
		move.w	#2,$3C(a0)
		move.w	$32(a0),d0
		cmpi.w	#$1C,d0
		bcc.s	loc_A5E8
		addq.w	#1,$32(a0)
		move.w	($FFFFF750).w,d1
		move.w	off_A5FC(pc,d1.w),d1
		lea	off_A5FC(pc,d1.w),a1
		move.b	(a1,d0.w),ost_frame(a0)
		add.w	d0,d0
		add.w	d0,d0
		move.l	word_A656(pc,d0.w),d1
		move.w	d1,ost_y_pos(a0)
		swap	d1
		move.w	d1,ost_x_pos(a0)

locret_A5E6:
		rts
; ===========================================================================

loc_A5E8:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$60,$3C(a0)
		clr.b	$31(a0)
		clr.w	$32(a0)
		rts
; ===========================================================================
off_A5FC:	index offset(*)
		ptr byte_A602					; 0
		ptr byte_A61E					; 2
		ptr byte_A63A					; 4

byte_A602:
		dc.b   7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9, $A, $A ; 0
		dc.b  $A, $B, $B, $B, $B, $B, $B, $B, $B, $B, $B, $B ; 16
byte_A61E:
		dc.b   0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  3,  3 ; 0
		dc.b   3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4 ; 16
byte_A63A:
		dc.b $18,$18,$18,$18,$19,$19,$19,$19,$19,$19,$19,  9,  9,  9, $A, $A ; 0
		dc.b  $A, $B, $B, $B, $B, $B, $B, $B, $B, $B, $B, $B ; 16

word_A656:
		dc.w   $A0,  $70,  $B0,	 $70,  $B6,  $71,  $BC,	 $72 ; 0
		dc.w   $C4,  $74,  $C8,	 $75,  $CA,  $76,  $CC,	 $77 ; 8
		dc.w   $CE,  $78,  $D0,	 $79,  $D2,  $7A,  $D4,	 $7B ; 16
		dc.w   $D6,  $7C,  $D9,	 $7E,  $DC,  $81,  $DE,	 $84 ; 24
		dc.w   $E1,  $87,  $E4,	 $8B,  $E7,  $8F,  $EC,	 $94 ; 32
		dc.w   $F0,  $99,  $F5,	 $9D,  $F9,  $A4, $100,	 $AC ; 40
		dc.w  $108,  $B8, $112,	 $C4, $11F,  $D3, $12C,	 $FA ; 48
; ===========================================================================

loc_A6C6:
		subq.w	#1,$3C(a0)
		bmi.s	loc_A720
		tst.b	(f_super).w
		beq.s	locret_A70A
		subq.b	#1,$31(a0)
		bpl.s	locret_A70A
		addq.b	#3,$31(a0)
		move.w	$32(a0),d0
		addq.w	#4,$32(a0)
		cmpi.w	#$78,d0
		bcc.s	locret_A70A
		cmpi.w	#$C,d0
		bcs.s	loc_A70C
		bsr.w	loc_A594
		move.l	word_A766(pc,d0.w),d1
		move.w	d1,ost_y_pos(a0)
		swap	d1
		move.w	d1,ost_x_pos(a0)
		lsr.w	#2,d0
		move.b	byte_A748(pc,d0.w),ost_frame(a0)

locret_A70A:
		rts
; ===========================================================================

loc_A70C:
		move.l	word_A766(pc,d0.w),d0
		lea	($FFFFB000).w,a1
		move.w	d0,ost_y_pos(a1)
		swap	d0
		move.w	d0,ost_x_pos(a1)
		rts
; ===========================================================================

loc_A720:
		addq.b	#2,ost_secondary_routine(a0)
		clr.w	$3C(a0)
		clr.w	$32(a0)
		lea	(dword_AD6E).l,a2
		jsrto	LoadChild,JmpTo_LoadChild
		tst.b	(f_super).w
		bne.w	locret_A38C
		lea	(dword_AD6A).l,a2
		jmpto	LoadChild,JmpTo_LoadChild
; ===========================================================================
byte_A748:
		dc.b $12,$12,$12,$12,$12,$12,$12,$13,$13,$13,$13,$13,$13,$14,$14,$14 ; 0
		dc.b $14,$15,$15,$15,$16,$16,$16,$16,$16,$16,$16,$16,$16,  0 ; 16

word_A766:
		dc.w   $C0					; 0
		dc.w   $90					; 1
		dc.w   $B0					; 2
		dc.w   $91					; 3
		dc.w   $A8					; 4
		dc.w   $92					; 5
		dc.w   $9B					; 6
		dc.w   $96					; 7
		dc.w   $99					; 8
		dc.w   $98					; 9
		dc.w   $98					; 10
		dc.w   $99					; 11
		dc.w   $99					; 12
		dc.w   $9A					; 13
		dc.w   $9B					; 14
		dc.w   $9C					; 15
		dc.w   $9F					; 16
		dc.w   $9E					; 17
		dc.w   $A4					; 18
		dc.w   $A0					; 19
		dc.w   $AC					; 20
		dc.w   $A2					; 21
		dc.w   $B7					; 22
		dc.w   $A5					; 23
		dc.w   $C4					; 24
		dc.w   $A8					; 25
		dc.w   $D3					; 26
		dc.w   $AB					; 27
		dc.w   $DE					; 28
		dc.w   $AE					; 29
		dc.w   $E8					; 30
		dc.w   $B0					; 31
		dc.w   $EF					; 32
		dc.w   $B2					; 33
		dc.w   $F4					; 34
		dc.w   $B5					; 35
		dc.w   $F9					; 36
		dc.w   $B8					; 37
		dc.w   $FC					; 38
		dc.w   $BB					; 39
		dc.w   $FE					; 40
		dc.w   $BE					; 41
		dc.w   $FF					; 42
		dc.w   $C0					; 43
		dc.w  $100					; 44
		dc.w   $C2					; 45
		dc.w  $101					; 46
		dc.w   $C5					; 47
		dc.w  $102					; 48
		dc.w   $C8					; 49
		dc.w  $102					; 50
		dc.w   $CC					; 51
		dc.w  $101					; 52
		dc.w   $D1					; 53
		dc.w   $FD					; 54
		dc.w   $D7					; 55
		dc.w   $F9					; 56
		dc.w   $DE					; 57
		dc.w   $F9					; 58
		dc.w  $118					; 59
; ===========================================================================

loc_A7DE:
		bsr.w	loc_A594
		subq.w	#1,$3C(a0)
		bpl.s	locret_A80C
		move.w	#2,$3C(a0)
		move.w	$32(a0),d0
		cmpi.w	#$1C,d0
		bcc.s	loc_A80E
		addq.w	#4,$32(a0)
		lea	word_A822(pc,d0.w),a1
		move.w	(a1)+,d0
		add.w	d0,(v_hscroll_buffer).w
		move.w	(a1)+,d0
		add.w	d0,(v_fg_y_pos_vsram).w

locret_A80C:
		rts
; ===========================================================================

loc_A80E:
		addq.b	#2,ost_secondary_routine(a0)
		bset	#3,ost_primary_status(a0)
		clr.b	$31(a0)
		clr.w	$32(a0)
		rts
; ===========================================================================
word_A822:
		dc.w  -$3A					; 0
		dc.w   $88					; 1
		dc.w   -$C					; 2
		dc.w   $22					; 3
		dc.w	-8					; 4
		dc.w   $10					; 5
		dc.w	-4					; 6
		dc.w	 8					; 7
		dc.w	-2					; 8
		dc.w	 4					; 9
		dc.w	-1					; 10
		dc.w	 2					; 11
		dc.w	-1					; 12
		dc.w	 2					; 13
; ===========================================================================

loc_A83E:
		tst.b	(f_super).w
		beq.w	locret_A38C
		move.b	#$17,ost_frame(a0)
		subq.b	#1,$31(a0)
		bpl.s	locret_A872
		addq.b	#3,$31(a0)
		move.w	$32(a0),d0
		cmpi.w	#$20,d0
		bcc.s	locret_A872
		addq.w	#4,$32(a0)
		move.l	word_A874(pc,d0.w),d1
		move.w	d1,ost_y_pos(a0)
		swap	d1
		move.w	d1,ost_x_pos(a0)

locret_A872:
		rts
; ===========================================================================
word_A874:
		dc.w   $60					; 0
		dc.w   $88					; 1
		dc.w   $50					; 2
		dc.w   $68					; 3
		dc.w   $44					; 4
		dc.w   $46					; 5
		dc.w   $3C					; 6
		dc.w   $36					; 7
		dc.w   $36					; 8
		dc.w   $2A					; 9
		dc.w   $33					; 10
		dc.w   $24					; 11
		dc.w   $31					; 12
		dc.w   $20					; 13
		dc.w   $30					; 14
		dc.w   $1E					; 15
; ===========================================================================
; ----------------------------------------------------------------------------
; Object CE - Sonic or Tails jumping off Tornado in ending cutscene?
; ----------------------------------------------------------------------------

EndingSonicTails:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_A8A2(pc,d0.w),d1
		jmp	off_A8A2(pc,d1.w)
; ===========================================================================
off_A8A2:	index offset(*),,2
		ptr loc_A8AA					; 0
		ptr loc_A902					; 2
		ptr loc_A936					; 4
		ptr loc_A926					; 6
; ===========================================================================

loc_A8AA:
		lea	(SubData_Cloud).l,a1
		jsrto	LoadSubObjData3,JmpTo_LoadSubObjData3
		move.l	#Map_TornadoHelices,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_hi,ost_tile(a0)
		move.b	#1,ost_priority(a0)
		jsr	(AdjustVRAM2P).l
		move.b	#$C,ost_frame(a0)
		cmpi.w	#4,($FFFFF750).w
		bne.s	loc_A8E8
		move.b	#$F,ost_frame(a0)
		move.w	#tile_LevelArt+tile_pal2+tile_hi,ost_tile(a0)

loc_A8E8:
		move.w	#$E8,d0
		move.w	d0,ost_x_pos(a0)
		move.w	d0,$30(a0)
		move.w	#$118,d0
		move.w	d0,ost_y_pos(a0)
		move.w	d0,$32(a0)
		rts
; ===========================================================================

loc_A902:
		movea.w	$2C(a0),a1
		btst	#3,ost_primary_status(a1)
		bne.s	loc_A92A

loc_A90E:
		move.w	$30(a0),d0
		add.w	(v_hscroll_buffer).w,d0
		move.w	d0,ost_x_pos(a0)
		move.w	$32(a0),d0
		sub.w	(v_fg_y_pos_vsram).w,d0
		move.w	d0,ost_y_pos(a0)

loc_A926:
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================

loc_A92A:
		addq.b	#2,ost_primary_routine(a0)
		clr.w	$3C(a0)
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================

loc_A936:
		subq.w	#1,$3C(a0)
		bpl.s	loc_A974
		move.w	#4,$3C(a0)
		move.w	$34(a0),d0
		cmpi.w	#4,d0
		bcc.s	loc_A978
		addq.w	#2,$34(a0)
		lea	byte_A980(pc,d0.w),a1
		cmpi.w	#2,($FFFFF750).w
		bne.s	loc_A960
		lea	byte_A984(pc,d0.w),a1

loc_A960:
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d0,ost_x_pos(a0)
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d0,ost_y_pos(a0)
		addq.b	#1,ost_frame(a0)

loc_A974:
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================

loc_A978:
		addq.b	#2,ost_primary_routine(a0)
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================
byte_A980:
		dc.b $F8					; 0
		dc.b   0					; 1
		dc.b $BC					; 2
		dc.b $C8					; 3

byte_A984:
		dc.b $F8					; 0
		dc.b   0					; 1
		dc.b $B0					; 2
		dc.b $C0					; 3
; ===========================================================================
; ----------------------------------------------------------------------------
; Object CF - Tornado's propeller in ending cutscene?
; ----------------------------------------------------------------------------

TornadoHelicies:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_A996(pc,d0.w),d1
		jmp	off_A996(pc,d1.w)
; ===========================================================================
off_A996:	index offset(*),,2
		ptr loc_A99A					; 0
		ptr loc_A9E4					; 2
; ===========================================================================

loc_A99A:
		lea	(SubData_Cloud).l,a1
		jsrto	LoadSubObjData3,JmpTo_LoadSubObjData3
		move.l	#Map_TornadoHelices,ost_mappings(a0)
		move.w	#tile_hi,ost_tile(a0)
		move.b	#3,ost_priority(a0)
		jsr	(AdjustVRAM2P).l
		move.b	#5,ost_frame(a0)
		move.b	#2,ost_anim(a0)
		move.w	#$10F,d0
		move.w	d0,ost_x_pos(a0)
		move.w	d0,$30(a0)
		move.w	#$15E,d0
		move.w	d0,ost_y_pos(a0)
		move.w	d0,$32(a0)
		rts
; ===========================================================================

loc_A9E4:
		lea	(off_AD82).l,a1
		jsrto	AnimateSprite,JmpTo_AnimateSprite
		bra.w	loc_A90E
; ===========================================================================
; ----------------------------------------------------------------------------
; Object CB - Clouds in ending cutscene
; ----------------------------------------------------------------------------

EndingClouds:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_AA00(pc,d0.w),d1
		jmp	off_AA00(pc,d1.w)
; ===========================================================================
off_AA00:	index offset(*),,2
		ptr loc_AA06					; 0
		ptr loc_AA76					; 2
		ptr loc_AA8A					; 4
; ===========================================================================

loc_AA06:
		lea	(SubData_Cloud).l,a1
		jsrto	LoadSubObjData3,JmpTo_LoadSubObjData3
		move.w	ost_tile(a0),d0
		andi.w	#$1FFF,d0
		ori.w	#$6000,d0
		move.w	d0,ost_tile(a0)
		move.b	#$30,ost_displaywidth(a0)
		move.l	(v_random).w,d0
		ror.l	#1,d0
		move.l	d0,(v_random).w
		move.w	d0,d1
		andi.w	#3,d0
		move.b	byte_AA6A(pc,d0.w),ost_frame(a0)
		add.w	d0,d0
		move.w	word_AA6E(pc,d0.w),ost_y_vel(a0)
		tst.b	($FFFFB134).w
		beq.s	loc_AA5A
		andi.w	#$FF,d1
		move.w	d1,ost_y_pos(a0)
		move.w	#$150,ost_x_pos(a0)
		rts
; ===========================================================================

loc_AA5A:
		andi.w	#$1FF,d1
		move.w	d1,ost_x_pos(a0)
		move.w	#$100,ost_y_pos(a0)
		rts
; ===========================================================================
byte_AA6A:
		dc.b   0					; 0
		dc.b   1					; 1
		dc.b   2					; 2
		dc.b   0					; 3

word_AA6E:
		dc.w $FD00					; 0
		dc.w $FE00					; 1
		dc.w $FF00					; 2
		dc.w $FD00					; 3
; ===========================================================================

loc_AA76:
		tst.b	($FFFFB134).w
		beq.s	loc_AA8A
		addq.b	#2,ost_primary_routine(a0)
		move.w	ost_y_vel(a0),ost_x_vel(a0)
		clr.w	ost_y_vel(a0)

loc_AA8A:
		jsrto	SpeedToPos,JmpTo2_SpeedToPos
		tst.b	($FFFFB134).w
		beq.s	loc_AAA2
		cmpi.w	#-$20,ost_x_pos(a0)
		blt.w	JmpTo3_DeleteObject
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================

loc_AAA2:
		tst.w	ost_y_pos(a0)
		bmi.w	JmpTo3_DeleteObject
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object CD - Birds in ending cutscene
; ----------------------------------------------------------------------------

EndingFlickies:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_AABC(pc,d0.w),d1
		jmp	off_AABC(pc,d1.w)
; ===========================================================================
off_AABC:	index offset(*),,2
		ptr loc_AAC0					; 0
		ptr loc_AB0E					; 2
; ===========================================================================

loc_AAC0:
		lea	(off_AD72).l,a1
		jsrto	LoadSubObjData3,JmpTo_LoadSubObjData3
		move.l	(v_random).w,d0
		ror.l	#3,d0
		move.l	d0,(v_random).w
		move.l	d0,d1
		andi.w	#$7F,d0
		move.w	#-$A0,d2
		add.w	d0,d2
		move.w	d2,ost_x_pos(a0)
		ror.l	#3,d1
		andi.w	#$FF,d1
		moveq	#8,d2
		add.w	d1,d2
		move.w	d2,ost_y_pos(a0)
		move.w	#$100,ost_x_vel(a0)
		moveq	#$20,d0
		cmpi.w	#$20,d1
		bcs.s	loc_AB02
		neg.w	d0

loc_AB02:
		move.w	d0,ost_y_vel(a0)
		move.w	#$C0,$3C(a0)
		rts
; ===========================================================================

loc_AB0E:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_AB2E(pc,d0.w),d1
		jsr	off_AB2E(pc,d1.w)
		jsrto	SpeedToPos,JmpTo2_SpeedToPos
		lea	(byte_AD7C).l,a1
		jsrto	AnimateSprite,JmpTo_AnimateSprite
		jmpto	DisplaySprite,JmpTo5_DisplaySprite
; ===========================================================================
off_AB2E:		index offset(*),,2
		ptr loc_AB34					; 0
		ptr loc_AB5C					; 2
		ptr loc_AB8E					; 4
; ===========================================================================

loc_AB34:
		subq.w	#1,$3C(a0)
		bpl.s	locret_AB5A
		addq.b	#2,ost_secondary_routine(a0)
		move.w	ost_y_vel(a0),$2E(a0)
		clr.w	ost_x_vel(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.w	#$80,ost_y_vel(a0)
		move.w	#$180,$3C(a0)

locret_AB5A:
		rts
; ===========================================================================

loc_AB5C:
		subq.w	#1,$3C(a0)
		bmi.s	loc_AB76
		move.w	ost_y_pos(a0),d0
		moveq	#-4,d1
		cmp.w	$32(a0),d0
		bcc.s	loc_AB70
		neg.w	d1

loc_AB70:
		add.w	d1,ost_y_vel(a0)
		rts
; ===========================================================================

loc_AB76:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#-$100,ost_x_vel(a0)
		move.w	$2E(a0),ost_y_vel(a0)
		move.w	#$C0,$3C(a0)
		rts
; ===========================================================================

loc_AB8E:
		subq.w	#1,$3C(a0)
		bmi.s	loc_AB96
		rts
; ===========================================================================

loc_AB96:
		addq.w	#4,sp

	if RemoveJmpTos
JmpTo3_DeleteObject:
	endc
		jmpto	DeleteObject,JmpTo3_DeleteObject
; ===========================================================================

loc_AB9C:
		subq.w	#1,$30(a0)
		bpl.s	locret_ABB8
		move.l	(v_random).w,d0
		andi.w	#$1F,d0
		move.w	d0,$30(a0)
		lea	(dword_AD5E).l,a2
		jsrto	LoadChild,JmpTo_LoadChild

locret_ABB8:
		rts

; ===========================================================================


sub_ABBA:
		subq.w	#1,$30(a0)
		bpl.s	locret_ABE0
		tst.b	$35(a0)
		beq.s	locret_ABE0
		subq.b	#1,$35(a0)
		move.l	(v_random).w,d0
		andi.w	#$F,d0
		move.w	d0,$30(a0)
		lea	(dword_AD66).l,a2
		jsrto	LoadChild,JmpTo_LoadChild

locret_ABE0:
		rts

; ===========================================================================
; EndSeq_LoadCharacterArt could be optimized down to this:

;EndSeq_LoadCharacterArt:
;		vdp_comm.l	move,vram_EndingCharacter,vram,write,(vdp_control_port).l
;		move.w	(v_ending_routine).w,d0
;		add.w	d0,d0
;		movea.l	EndSeq_LoadCharacterArt_Ptrs(pc,d0.w),a0
;		jmpto	NemDec,JmpTo_NemDec


;EndSeq_LoadCharacterArt_Ptrs:
;		dc.l Nem_EndingSonic			; 0
;		dc.l Nem_EndingSuperSonic		; 4
;		dc.l Nem_EndingTails			; 8


EndSeq_LoadCharacterArt:
		move.w	(v_ending_routine).w,d0
		move.w	EndSeq_LoadCharacterArt_Index(pc,d0.w),d0
		jmp	EndSeq_LoadCharacterArt_Index(pc,d0.w)

; ===========================================================================
EndSeq_LoadCharacterArt_Index:	index offset(*),,2
		ptr EndSeq_LoadCharacterArt_Sonic		; 0
		ptr EndSeq_LoadCharacterArt_SuperSonic		; 2
		ptr EndSeq_LoadCharacterArt_Tails		; 4
; ===========================================================================

EndSeq_LoadCharacterArt_Sonic:
		vdp_comm.l	move,vram_EndingCharacter,vram,write,(vdp_control_port).l
		lea	(Nem_EndingSonic).l,a0
		jmpto	NemDec,JmpTo_NemDec
; ===========================================================================

EndSeq_LoadCharacterArt_SuperSonic:
		vdp_comm.l	move,vram_EndingCharacter,vram,write,(vdp_control_port).l
		lea	(Nem_EndingSuperSonic).l,a0
		jmpto	NemDec,JmpTo_NemDec
; ===========================================================================

EndSeq_LoadCharacterArt_Tails:
		vdp_comm.l	move,vram_EndingCharacter,vram,write,(vdp_control_port).l
		lea	(Nem_EndingTails).l,a0
		jmpto	NemDec,JmpTo_NemDec

; ===========================================================================


EndSeq_LoadBirdArt:
		move.w	(v_ending_routine).w,d0
		move.w	EndSeq_LoadBirdArt_Index(pc,d0.w),d0
		jmp	EndSeq_LoadBirdArt_Index(pc,d0.w)

; ===========================================================================
EndSeq_LoadBirdArt_Index:	index offset(*),,2
		ptr	EndSeq_LoadBirdArt_Flicky		; 0
		ptr EndSeq_LoadBirdArt_Eagle			; 2
		ptr	EndSeq_LoadBirdArt_Chicken		; 4
; ===========================================================================

EndSeq_LoadBirdArt_Flicky:
		vdp_comm.l	move,vram_animal_2,vram,write,(vdp_control_port).l
		lea	(Nem_Flicky).l,a0
		jmpto	NemDec,JmpTo_NemDec
; ===========================================================================

EndSeq_LoadBirdArt_Eagle:
		vdp_comm.l	move,vram_animal_2,vram,write,(vdp_control_port).l
		lea	(Nem_Eagle).l,a0
		jmpto	NemDec,JmpTo_NemDec
; ===========================================================================

EndSeq_LoadBirdArt_Chicken:
		vdp_comm.l	move,vram_animal_2,vram,write,(vdp_control_port).l
		lea	(Nem_Chicken).l,a0
		jmpto	NemDec,JmpTo_NemDec
; ===========================================================================

		incfile	Pal_EndingSonic				; Pal_AC7E:
		incfile	Pal_EndingSonicFar			; Pal_AC9E:
		incfile	Pal_EndingBG				; Pal_ACDE:
		incfile	Pal_EndingStills			; Pal_AD1E:
		incfile	Pal_EndingSuperSonic			; Pal_AD3E

dword_AD5E:
		childobjdata $3E,id_EndingClouds,0

dword_AD62:
		childobjdata $3E,id_EndingTrigger,0

dword_AD66:
		childobjdata $3E,id_EndingFlickies,0

dword_AD6A:
		childobjdata $3E,id_EndingSonicTails,0

dword_AD6E:
		childobjdata $3E,id_TornadoHelicies,0

off_AD72:
		subobjdata Map_Animal1,tile_Nem_Animal_2,render_rel,2,8,id_col_null

byte_AD7C:	index offset(*)
		ptr byte_AD7E

byte_AD7E:
		dc.b   5
		dc.b   0
		dc.b   1
		dc.b afEnd
		even

off_AD82:	index offset(*)
		ptr byte_AD88					; 0
		ptr byte_AD8E					; 2
		ptr byte_AD9E					; 4

byte_AD88:
		dc.b 3
		dc.b 0
		dc.b 0
		dc.b 1
		dc.b af2ndRoutine
		even

byte_AD8E:
		dc.b 3
		dc.b 1
		dc.b 1
		dc.b 1
		dc.b 1
		dc.b 1
		dc.b 2
		dc.b 2
		dc.b 2
		dc.b 2
		dc.b 2
		dc.b 3
		dc.b 3
		dc.b 4
		dc.b af2ndRoutine
		even

byte_AD9E:
		dc.b 1
		dc.b 5
		dc.b 6
		dc.b afEnd
		even


		include "mappings/sprite/Tornado Helices.asm"
		incfile	Eni_EndGameLogo

; ===========================================================================


sub_B262:
		lea	Credits_Pointers(pc),a1
		move.w	($FFFFFF4C).w,d0
		lsl.w	#2,d0
		move.l	(a1,d0.w),d0
		movea.l	d0,a1

DisplayText:
		disable_ints
		lea	(vdp_data_port).l,a6

loc_B27C:
		move.l	(a1)+,d0
		bmi.s	loc_B298
		movea.l	d0,a2
		move.w	(a1)+,d0
		bsr.s	ConvertVRAMAddToWriteCmd
		move.l	d0,vdp_control_port-vdp_data_port(a6)
		move.b	(a2)+,d0
		lsl.w	#8,d0

loc_B28E:
		move.b	(a2)+,d0
		bmi.s	loc_B296
		move.w	d0,(a6)
		bra.s	loc_B28E
; ===========================================================================

loc_B296:
		bra.s	loc_B27C
; ===========================================================================

loc_B298:
		enable_ints
		rts
; ===========================================================================

ConvertVRAMAddToWriteCmd:
		andi.l	#$FFFF,d0
		lsl.l	#2,d0
		lsr.w	#2,d0
		vdp_comm.w	oxi,0,vram,write,d0,>>16	; oxi = AXM68K ori
		swap	d0
		rts

; ----------------------------------------------------------------------------
; Credits and intro text pointers
; ----------------------------------------------------------------------------

creditsptr:	macro	addr,line,col
		rept narg/3
		dc.l \addr					; address of text
		dc.w vram_ptr+((sizeof_vram_row_64*\line)+(2*\col)) ; location in VRAM where text will be drawn
		shift						; next line
		shift
		shift
		endr
		dc.w -1						; terminator
		endm

vram_ptr: = vram_title_fg

IntroText_Pointers:
		; "SONIC"
		; "AND"
		; "MILES 'TAILS' PROWER"
		; "IN"
		creditsptr	&
		IntroText_Line1,9,$F,&
		IntroText_Line2,$C,$11,&
		IntroText_Line3,$F,3,&
		IntroText_Line4,$12,$12

Credits_Pointers:
		dc.l Credits_Slide1				; 0
		dc.l Credits_Slide2				; 1
		dc.l Credits_Slide3				; 2
		dc.l Credits_Slide4				; 3
		dc.l Credits_Slide5				; 4
		dc.l Credits_Slide6				; 5
		dc.l Credits_Slide7				; 6
		dc.l Credits_Slide8				; 7
		dc.l Credits_Slide9				; 8
		dc.l Credits_Slide10				; 9
		dc.l Credits_Slide11				; 10
		dc.l Credits_Slide12				; 11
		dc.l Credits_Slide13				; 12
		dc.l Credits_Slide14				; 13
		dc.l Credits_Slide15				; 14
		dc.l Credits_Slide16				; 15
		dc.l Credits_Slide17				; 16
		dc.l Credits_Slide18				; 17
		dc.l Credits_Slide19				; 18
		dc.l Credits_Slide20				; 19
		dc.l Credits_Slide21				; 20
		arraysize	Credits_Pointers		; used to calculate the per-slide duration
		dc.l -1						; terminator

vram_ptr: = vram_ending_fg

Credits_Slide1:
		; "SONIC"
		; "2"
		; "CAST OF CHARACTERS"
		creditsptr	&
		Cred_Slide1_Line1,11,14,&
		Cred_Slide1_Line2,11,24,&
		Cred_Slide1_Line3,15,2

Credits_Slide2:
		; "EXECUTIVE"
		; "PRODUCER"
		; "HAYAO  NAKAYAMA"
		creditsptr	&
		Cred_Slide2_Line1,11,3,&
		Cred_Slide2_Line2,11,22,&
		Cred_Slide2_Line3,15,6

Credits_Slide3:
		; "PRODUCER"
		; "SHINOBU  TOYODA"
		creditsptr	&
		Cred_Slide3_Line1,11,12,&
		Cred_Slide3_Line2,15,7

Credits_Slide4:
		; "DIRECTOR"
		; "MASAHARU  YOSHII"
		creditsptr	&
		Cred_Slide4_Line1,11,12,&
		Cred_Slide4_Line2,15,6

Credits_Slide5:
		; "CHIEF  PROGRAMMER"
		; "YUJI  NAKA (YU2)"
		creditsptr	&
		Cred_Slide5_Line1,11,5,&
		Cred_Slide5_Line2,15,7

Credits_Slide6:
		; "GAME  PLANNER"
		; "HIROKAZU  YASUHARA"
		; "(CAROL  YAS)"
		creditsptr	&
		Cred_Slide6_Line1,10,8,&
		Cred_Slide6_Line2,14,4,&
		Cred_Slide6_Line3,16,10

Credits_Slide7:
		; "CHARACTER  DESIGN"
		; "AND"
		; "CHIEF  ARTIST"
		; "YASUSHI  YAMAGUCHI"
		; "(JUDY  TOTOYA)"
		creditsptr	&
		Cred_Slide7_Line1,8,4,&
		Cred_Slide7_Line2,10,17,&
		Cred_Slide7_Line3,12,9,&
		Cred_Slide7_Line4,16,4,&
		Cred_Slide7_Line5,18,8

Credits_Slide8:
		; "ASSISTANT"
		; "PROGRAMMERS"
		; "BILL  WILLIS"
		; "MASANOBU  YAMAMOTO"
		creditsptr	&
		Cred_Slide8_Line1,9,11,&
		Cred_Slide8_Line2,11,9,&
		Cred_Slide8_Line3,15,10,&
		Cred_Slide8_Line4,17,3

Credits_Slide9:
		; "OBJECT  PLACEMENT"
		; "HIROKAZU  YASUHARA"
		; "TAKAHIRO  ANTO"
		; "YUTAKA  SUGANO"
		creditsptr	&
		Cred_Slide9_Line1,9,4,&
		Cred_Slide9_Line2,13,4,&
		Cred_Slide9_Line3,15,7,&
		Cred_Slide9_Line4,17,7

Credits_Slide10:
		; "SPECIALSTAGE"
		; "OBJECT  PLACEMENT"
		; "YUTAKA  SUGANO"
		creditsptr	&
		Cred_Slide10_Line1,10,8,&
		Cred_Slide10_Line2,12,4,&
		Cred_Slide10_Line3,16,7

Credits_Slide11:
		; "ZONE  ARTISTS"
		; "YASUSHI  YAMAGUCHI"
		; "CRAIG  STITT"
		; "BRENDA  ROSS"
		; "JINA  ISHIWATARI"
		; "TOM  PAYNE"
		; "PHENIX  RIE"
		creditsptr	&
		Cred_Slide11_Line1,6,9,&
		Cred_Slide11_Line2,10,4,&
		Cred_Slide11_Line3,12,10,&
		Cred_Slide11_Line4,14,9,&
		Cred_Slide11_Line5,16,7,&
		Cred_Slide11_Line6,18,11,&
		Cred_Slide11_Line7,20,11

Credits_Slide12:
		; "SPECIALSTAGE"
		; "ART  AND  CG"
		; "TIM  SKELLY"
		; "PETER  MORAWIEC"
		creditsptr	&
		Cred_Slide12_Line1,9,9,&
		Cred_Slide12_Line2,11,10,&
		Cred_Slide12_Line3,15,11,&
		Cred_Slide12_Line4,17,7

Credits_Slide13:
		; "MUSIC  COMPOSER"
		; "MASATO  NAKAMURA"
		; "( @1992"
		; "DREAMS  COME  TRUE)"
		creditsptr	&
		Cred_Slide13_Line1,9,6,&
		Cred_Slide13_Line2,13,5,&
		Cred_Slide13_Line3,15,3,&
		Cred_Slide13_Line4,17,4

Credits_Slide14:
		; "SOUND  PROGRAMMER"
		; "TOMOYUKI  SHIMADA"
		creditsptr	&
		Cred_Slide14_Line1,11,4,&
		Cred_Slide14_Line2,15,5

Credits_Slide15:
		; "SOUND  ASSISTANTS"
		; "MACKY"
		; "JIMITA"
		; "MILPO"
		; "IPPO"
		; "S.O"
		; "OYZ"
		; "N.GEE"
		creditsptr	&
		Cred_Slide15_Line1,5,4,&
		Cred_Slide15_Line2,9,15,&
		Cred_Slide15_Line3,11,15,&
		Cred_Slide15_Line4,13,15,&
		Cred_Slide15_Line5,15,16,&
		Cred_Slide15_Line6,17,17,&
		Cred_Slide15_Line7,19,17,&
		Cred_Slide15_Line8,21,15

Credits_Slide16:
		; "PROJECT  ASSISTANTS"
		; "SYUICHI  KATAGI"
		; "TAKAHIRO  HAMANO"
		; "YOSHIKI  OOKA"
		; "STEVE  WOITA"
		creditsptr	&
		Cred_Slide16_Line1,8,3,&
		Cred_Slide16_Line2,12,8,&
		Cred_Slide16_Line3,14,6,&
		Cred_Slide16_Line4,16,9,&
		Cred_Slide16_Line5,18,10

Credits_Slide17:
		; "GAME  MANUAL"
		; "YOUICHI  TAKAHASHI"
		; "CAROL  ANN  HANSHAW"
		creditsptr	&
		Cred_Slide17_Line1,10,9,&
		Cred_Slide17_Line2,14,5,&
		Cred_Slide17_Line3,16,3

Credits_Slide18:
		; "EXECUTIVE"
		; "SUPPORTERS"
		; "DAIZABUROU  SAKURAI"
		; "HISASHI  SUZUKI"
		; "THOMAS  KALINSKE"
		; "FUJIO  MINEGISHI"
		; "TAKAHARU UTSUNOMIYA"
		creditsptr	&
		Cred_Slide18_Line1,6,11,&
		Cred_Slide18_Line2,8,10,&
		Cred_Slide18_Line3,12,3,&
		Cred_Slide18_Line4,14,7,&
		Cred_Slide18_Line5,16,5,&
		Cred_Slide18_Line6,18,7,&
		Cred_Slide18_Line7,20,2

Credits_Slide19:
		; "SPECIAL  THANKS"
		; "TO"
		; "CINDY  CLAVERAN"
		; "FRANCE  TANTIADO"
		; "DAISUKE  SAITO"
		; "KUNITAKE  AOKI"
		; "TSUNEKO  AOKI"
		creditsptr	&
		Cred_Slide19_Line1,6,6,&
		Cred_Slide19_Line2,8,18,&
		Cred_Slide19_Line3,12,6,&
		Cred_Slide19_Line4,14,5,&
		Cred_Slide19_Line5,16,8,&
		Cred_Slide19_Line6,18,8,&
		Cred_Slide19_Line7,20,9

Credits_Slide20:
		; "SPECIAL  THANKS"
		; "TO"
		; "DEBORAH  MCCRACKEN"
		; "TATSUO  YAMADA"
		; "RICK  MACARAEG"
		; "LOCKY  P"
		; "MASAAKI  KAWAMURA"
		creditsptr	&
		Cred_Slide20_Line1,6,6,&
		Cred_Slide20_Line2,8,18,&
		Cred_Slide20_Line3,12,3,&
		Cred_Slide20_Line4,14,7,&
		Cred_Slide20_Line5,16,7,&
		Cred_Slide20_Line6,18,13,&
		Cred_Slide20_Line7,20,4

Credits_Slide21:
		; "PRESENTED"
		; "BY"
		; "SEGA"
		creditsptr	&
		Cred_Slide21_Line1,9,11,&
		Cred_Slide21_Line2,13,18,&
		Cred_Slide21_Line3,17,16

; ----------------------------------------------------------------------------
; Macro to define credit and intro text in conjunction with the charset macro
; ----------------------------------------------------------------------------

credtxt:	macro	chset,pal,txt
		if (((vram_src/sizeof_cell)&$FF)<>0)&(((vram_src/sizeof_cell)&$FF)<>1)
			inform 2,"The low byte of vram_src was $%h, but it must be 0 or 1.",vram_src&$FF
		endc
		dc.b ((vram_src/sizeof_cell+\pal)&$FF00)>>8	; palette index
		charset	\chset,\txt				; generate the text
		rev02even
		endm

; ----------------------------------------------------------------------------
; Credits strings
; ----------------------------------------------------------------------------

vram_src: = vram_CreditsFont_Credits				; VRAM for end credits

Cred_Slide2_Line1:
Cred_Slide18_Line1:	credtxt	credits,tile_pal2,"EXECUTIVE"
Cred_Slide2_Line2:
Cred_Slide3_Line1:	credtxt	credits,tile_pal2,"PRODUCER"
Cred_Slide2_Line3:	credtxt credits,tile_pal1,"HAYAO  NAKAYAMA"
Cred_Slide3_Line2:	credtxt credits,tile_pal1,"SHINOBU  TOYODA"
Cred_Slide4_Line1:	credtxt credits,tile_pal2,"DIRECTOR"
Cred_Slide4_Line2:	credtxt credits,tile_pal1,"MASAHARU  YOSHII"
Cred_Slide5_Line1:	credtxt credits,tile_pal2,"CHIEF  PROGRAMMER"
Cred_Slide5_Line2:	credtxt credits,tile_pal1,"YUJI  NAKA (YU2)"
Cred_Slide6_Line1:	credtxt credits,tile_pal2,"GAME  PLANNER"
Cred_Slide6_Line2:
Cred_Slide9_Line2:	credtxt credits,tile_pal1,"HIROKAZU  YASUHARA"
Cred_Slide6_Line3:	credtxt credits,tile_pal1,"(CAROL  YAS)"
Cred_Slide7_Line1:	credtxt credits,tile_pal2,"CHARACTER  DESIGN"
Cred_Slide7_Line2:	credtxt credits,tile_pal2,"AND"
Cred_Slide7_Line3:	credtxt credits,tile_pal2,"CHIEF  ARTIST"
Cred_Slide7_Line4:
Cred_Slide11_Line2:	credtxt credits,tile_pal1,"YASUSHI  YAMAGUCHI"
Cred_Slide7_Line5:	credtxt credits,tile_pal1,"(JUDY  TOTOYA)"
Cred_Slide8_Line1:	credtxt credits,tile_pal2,"ASSISTANT"
Cred_Slide8_Line2:	credtxt credits,tile_pal2,"PROGRAMMERS"
Cred_Slide8_Line3:	credtxt credits,tile_pal1,"BILL  WILLIS"
Cred_Slide8_Line4:	credtxt credits,tile_pal1,"MASANOBU  YAMAMOTO"
Cred_Slide9_Line1:
Cred_Slide10_Line2: credtxt	credits,tile_pal2,"OBJECT  PLACEMENT"
Cred_Slide9_Line3:	credtxt	credits,tile_pal1,"TAKAHIRO  ANTO"
Cred_Slide9_Line4:
Cred_Slide10_Line3:	credtxt	credits,tile_pal1,"YUTAKA  SUGANO"
Cred_Slide10_Line1:
Cred_Slide12_Line1:	credtxt	credits,tile_pal2,"SPECIALSTAGE"
Cred_Slide17_Line3:	credtxt	credits,tile_pal1,"CAROL  ANN  HANSHAW"
Cred_Slide11_Line1:	credtxt	credits,tile_pal2,"ZONE  ARTISTS"
Cred_Slide11_Line3:	credtxt	credits,tile_pal1,"CRAIG  STITT"
Cred_Slide11_Line4:	credtxt	credits,tile_pal1,"BRENDA  ROSS"
Cred_Slide11_Line5:	credtxt	credits,tile_pal1,"JINA  ISHIWATARI"
Cred_Slide11_Line6:	credtxt	credits,tile_pal1,"TOM  PAYNE"
Cred_Slide11_Line7:	credtxt	credits,tile_pal1,"PHENIX  RIE"
Cred_Slide12_Line2:	credtxt	credits,tile_pal2,"ART  AND  CG"
Cred_Slide12_Line3:	credtxt	credits,tile_pal1,"TIM  SKELLY"
Cred_Slide12_Line4:	credtxt	credits,tile_pal1,"PETER  MORAWIEC"
Cred_Slide13_Line1:	credtxt	credits,tile_pal2,"MUSIC  COMPOSER"
Cred_Slide13_Line2:	credtxt	credits,tile_pal1,"MASATO  NAKAMURA"
Cred_Slide13_Line3:	credtxt	credits,tile_pal1,"( @1992"
Cred_Slide13_Line4:	credtxt	credits,tile_pal1,"DREAMS  COME  TRUE)"
Cred_Slide14_Line1:	credtxt	credits,tile_pal2,"SOUND  PROGRAMMER"
Cred_Slide14_Line2:	credtxt	credits,tile_pal1,"TOMOYUKI  SHIMADA"
Cred_Slide15_Line1:	credtxt	credits,tile_pal2,"SOUND  ASSISTANTS"
Cred_Slide15_Line2:	credtxt	credits,tile_pal1,"MACKY"
Cred_Slide15_Line3:	credtxt	credits,tile_pal1,"JIMITA"
Cred_Slide15_Line4:	credtxt	credits,tile_pal1,"MILPO"
Cred_Slide15_Line5:	credtxt	credits,tile_pal1,"IPPO"
Cred_Slide15_Line6:	credtxt	credits,tile_pal1,"S.O"
Cred_Slide15_Line7:	credtxt	credits,tile_pal1,"OYZ"
Cred_Slide15_Line8:	credtxt	credits,tile_pal1,"N.GEE"
Cred_Slide16_Line1:	credtxt	credits,tile_pal2,"PROJECT  ASSISTANTS"
Cred_Slide16_Line2:	credtxt	credits,tile_pal1,"SYUICHI  KATAGI"
Cred_Slide16_Line3:	credtxt	credits,tile_pal1,"TAKAHIRO  HAMANO"
Cred_Slide16_Line4:	credtxt	credits,tile_pal1,"YOSHIKI  OOKA"
Cred_Slide16_Line5:	credtxt	credits,tile_pal1,"STEVE  WOITA"
Cred_Slide17_Line1:	credtxt	credits,tile_pal2,"GAME  MANUAL"
Cred_Slide17_Line2:	credtxt	credits,tile_pal1,"YOUICHI  TAKAHASHI"
Cred_Slide18_Line2:	credtxt	credits,tile_pal2,"SUPPORTERS"
Cred_Slide18_Line3:	credtxt	credits,tile_pal1,"DAIZABUROU  SAKURAI"
Cred_Slide18_Line4:	credtxt	credits,tile_pal1,"HISASHI  SUZUKI"

    if (Revision=0)&(FixBugs=0)
Cred_Slide18_Line5:	credtxt	credits,tile_pal1,"TOHMAS  KALINSKE" ; typo
    else
Cred_Slide18_Line5:	credtxt	credits,tile_pal1,"THOMAS  KALINSKE"
    endc

Cred_Slide18_Line6:	credtxt	credits,tile_pal1,"FUJIO  MINEGISHI"
Cred_Slide18_Line7:	credtxt	credits,tile_pal1,"TAKAHARU UTSUNOMIYA"
Cred_Slide19_Line1:
Cred_Slide20_Line1:	credtxt	credits,tile_pal2,"SPECIAL  THANKS"
Cred_Slide19_Line2:
Cred_Slide20_Line2:	credtxt	credits,tile_pal2,"TO"
Cred_Slide19_Line3:	credtxt	credits,tile_pal1,"CINDY  CLAVERAN"
Cred_Slide20_Line3:	credtxt	credits,tile_pal1,"DEBORAH  MCCRACKEN"
Cred_Slide20_Line4:	credtxt	credits,tile_pal1,"TATSUO  YAMADA"
Cred_Slide19_Line5:	credtxt	credits,tile_pal1,"DAISUKE  SAITO"
Cred_Slide19_Line6:	credtxt	credits,tile_pal1,"KUNITAKE  AOKI"
Cred_Slide19_Line7:	credtxt	credits,tile_pal1,"TSUNEKO  AOKI"
Cred_Slide20_Line7:	credtxt	credits,tile_pal1,"MASAAKI  KAWAMURA"
Cred_Slide1_Line1:	credtxt	credits,tile_pal1,"SONIC"
Cred_Slide1_Line2:	credtxt	credits,tile_pal2,"2"
Cred_Slide1_Line3:	credtxt	credits,tile_pal1,"CAST  OF  CHARACTERS"
Cred_Slide21_Line1:	credtxt	credits,tile_pal1,"PRESENTED"
Cred_Slide21_Line2:	credtxt	credits,tile_pal1,"BY"
Cred_Slide21_Line3:	credtxt	credits,tile_pal1,"SEGA"
Cred_Slide19_Line4:	credtxt	credits,tile_pal1,"FRANCE  TANTIADO"
Cred_Slide20_Line5:	credtxt	credits,tile_pal1,"RICK  MACARAEG"
Cred_Slide20_Line6:	credtxt	credits,tile_pal1,"LOCKY  P"

; ----------------------------------------------------------------------------
; Intro strings
; ----------------------------------------------------------------------------

vram_src: = vram_CreditsFont_Intro

IntroText_Line4:	credtxt	intro,tile_pal1,"IN"
IntroText_Line2:	credtxt	intro,tile_pal1,"AND"
IntroText_Line3:	credtxt	intro,tile_pal1,"MILES 'TAILS' PROWER"
IntroText_Line1:	credtxt	intro,tile_pal1,"SONIC"
		even
; ===========================================================================

		incfile	Nem_CreditsFont

; ===========================================================================

	if RemoveJmpTos=0
JmpTo5_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo3_DeleteObject:
		jmp	(DeleteObject).l
JmpTo2_PlaySound:
		jmp	(PlaySound).l
JmpTo_loc_3AF58:
		jmp	(loc_3AF58).l				; Tornado_AnimatePilot
JmpTo_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo_NemDec:
		jmp	(NemDec).l
JmpTo_EniDec:
		jmp	(EniDec).l
JmpTo_ClearScreen:
		jmp	(ClearScreen).l
JmpTo2_PlayMusic:
		jmp	(PlayMusic).l
JmpTo_LoadChild:
		jmp	(LoadChild).l
JmpTo2_TilemapToVRAM:
		jmp	(TilemapToVRAM).l
JmpTo2_SpeedToPos:
		jmp	(SpeedToPos).l
JmpTo_PaletteCycle:
		jmp	(PaletteCycle).l
JmpTo_LoadSubObjData3:
		jmp	(LoadSubObjData3).l

		align 4
	endc

; ===========================================================================

LevelParameterLoad:
		clr.w	(v_fg_redraw_direction).w		; clear all redraw, scroll, and screen shaking flags
		clr.w	(v_bg1_redraw_direction).w
		clr.w	(v_bg2_redraw_direction).w
		clr.w	(v_bg3_redraw_direction).w
		clr.w	(v_fg_redraw_direction_p2).w
		clr.w	(v_bg1_redraw_direction_p2).w
		clr.w	(v_bg2_redraw_direction_p2).w
		clr.w	(v_bg3_redraw_direction_p2).w
		clr.w	(v_fg_redraw_direction_copy).w
		clr.w	(v_bg1_redraw_direction_copy).w
		clr.w	(v_bg2_redraw_direction_copy).w
		clr.w	(v_bg3_redraw_direction_copy).w
		clr.w	(v_fg_redraw_direction_p2_copy).w
		clr.w	(v_bg1_redraw_direction_p2_copy).w
		clr.w	(v_bg2_redraw_direction_p2_copy).w
		clr.w	(v_bg3_redraw_direction_p2_copy).w
		clr.b	(f_disable_scrolling).w
		clr.b	(f_screen_shake_htz).w
		clr.b	(f_screen_shake).w
		clr.b	(f_disable_scroll_p1).w
		clr.b	(f_disable_scroll_p2).w
		moveq	#0,d0
		move.b	d0,(v_dle_routine).w			; clear DynamicLevelEvents routine counter
	if Revision=2
		; Clear camera offset variables and and WFZ DLE routine counter.
		move.w	d0,(v_wfz_dle_subrout).w
		move.w	d0,(v_wfz_bg_y_speed).w
		move.w	d0,(v_camera_x_pos_offset).w
		move.w	d0,(v_camera_y_pos_offset).w
    endc
		move.w	(v_zone).w,d0				; get zone/act number
		ror.b	#1,d0					; move act number next to zone number
		lsr.w	#4,d0					; move both into low byte
		lea	LevelBoundaryList(pc,d0.w),a0		; load level boundaries
		move.l	(a0)+,d0				; get x boundaries
		move.l	d0,(v_boundary_left).w			; set x boundaries (including unused variable)
		move.l	d0,(v_boundary_unused1).w		; x boundaries are also written to this unused variable
		move.l	d0,(v_boundary_left_p2).w
		move.l	(a0)+,d0				; get y boundaries
		move.l	d0,(v_boundary_top).w			; set y-boundaries
		move.l	d0,(v_boundary_unused2).w		; (this also writes v_boundary_bottom_next)
		move.l	d0,(v_boundary_top_p2).w
		move.w	#$1010,(v_fg_x_redraw_flag).w		; set fg redraw flag
		move.w	#camera_y_shift_default,(v_camera_y_shift).w ; default camera shift = $60 (changes when Sonic or Tails look up/down)
		move.w	#camera_y_shift_default,(v_camera_y_shift_p2).w
		bra.w	LPL_StartPos

; ----------------------------------------------------------------------------
; Level boundary list - 4 values per act:

; v_boundary_left, v_boundary_right, v_boundary_top, v_boundary_bottom
; ----------------------------------------------------------------------------

LevelBoundaryList:
		dc.w	 0,$29A0,    0,	$320			; 0
		dc.w	 0,$2940,    0,	$420			; 4
		dc.w	 0,$3FFF,    0,	$720			; 8
		dc.w	 0,$3FFF,    0,	$720			; 12
		dc.w	 0,$3FFF,    0,	$720			; 16
		dc.w	 0,$3FFF,    0,	$720			; 20
		dc.w	 0,$3FFF,    0,	$720			; 24
		dc.w	 0,$3FFF,    0,	$720			; 28
		dc.w	 0,$2280,$FF00,	$800			; 32
		dc.w	 0,$1E80,$FF00,	$800			; 36
		dc.w	 0,$2A80,$FF00,	$800			; 40
		dc.w	 0,$3FFF,$FF00,	$800			; 44
		dc.w	 0,$3FFF,    0,	$720			; 48
		dc.w	 0,$3FFF,    0,	$720			; 52
		dc.w	 0,$2800,    0,	$720			; 56
		dc.w	 0,$3280,    0,	$720			; 60
		dc.w	 0,$3FFF,    0,	$720			; 64
		dc.w	 0,$3FFF,    0,	$720			; 68
		dc.w	 0,$3FFF,    0,	$720			; 72
		dc.w	 0,$3FFF,    0,	$720			; 76
		dc.w	 0,$2F80,    0,	$680			; 80
		dc.w	 0,$2D00,    0,	$680			; 84
		dc.w	 0,$2380, $3C0,	$720			; 88
		dc.w	 0,$3FFF,  $60,	$720			; 92
		dc.w	 0,$27A0,    0,	$720			; 96
		dc.w	 0,$2A80,    0,	$720			; 100
		dc.w	 0,$2780,    0,	$720			; 104
		dc.w	 0,$2A80,    0,	$720			; 108
		dc.w	 0,$1000,  $C8,	 $C8			; 112
		dc.w	 0,$1000,  $C8,	 $C8			; 116
		dc.w	 0,$28C0, $200,	$600			; 120
		dc.w	 0,$3FFF, $180,	$710			; 124
		dc.w	 0,$3FFF,    0,	   0			; 128
		dc.w	 0,$3FFF,    0,	$720			; 132
		zonewarning LevelBoundaryList,$10
; ===========================================================================

LPL_StartPos:
		tst.b	(v_last_lamppost).w			; have any starposts been hit?
		beq.s	.nostarpost				; if not, branch
		jsr	(Starpost_LoadInfo).l			; load starpost variables
		move.w	(v_ost_player1+ost_x_pos).w,d1		; use saved x and y pos for setting camera
		move.w	(v_ost_player1+ost_y_pos).w,d0
		bra.s	LPL_Camera
; ===========================================================================

	.nostarpost:
		move.w	(v_zone).w,d0				; get zone/act number
		ror.b	#1,d0
		lsr.w	#5,d0					; convert to 1-byte index with stride of 2
		lea	StartPosList(pc,d0.w),a1		; load player 1's start position

		moveq	#0,d1
		move.w	(a1)+,d1
		move.w	d1,(v_ost_player1+ost_x_pos).w		; set player 1's x position
		moveq	#0,d0
		move.w	(a1),d0
		move.w	d0,(v_ost_player1+ost_y_pos).w		; set player 1's y position

LPL_Camera:
		subi.w	#160,d1					; is player 1 more than 160px from left edge?
		bcc.s	.chk_right				; if so, branch
		moveq	#0,d1

	.chk_right:
		move.w	(v_boundary_right).w,d2
		cmp.w	d2,d1					; is player 1 inside the right edge?
		bcs.s	.set_camera_x				; if so, branch
		move.w	d2,d1

	.set_camera_x:
		move.w	d1,(v_camera_x_pos).w			; set camera x position
		move.w	d1,(v_camera_x_pos_p2).w		; (both players)

		subi.w	#96,d0					; is player 1 within 96px of upper edge?
		bcc.s	.chk_bottom				; branch if so
		moveq	#0,d0

.chk_bottom:
		cmp.w	(v_boundary_bottom).w,d0		; is player 1 above the bottom edge?
		blt.s	.set_camera_y				; branch if so
		move.w	(v_boundary_bottom).w,d0

.set_camera_y:
		move.w	d0,(v_camera_y_pos).w			; set camera y pos
		move.w	d0,(v_camera_y_pos_p2).w		; (both players)
		bsr.w	LPL_InitBG
		rts

; --------------------------------------------------------------------------------------
; Character start location array
;
; 2 entries per	act, corresponding to the X and	Y locations that you want the player to
; appear at when the level starts.
; --------------------------------------------------------------------------------------

StartPosList:
		dc.w   $60, $28F				; 0
		dc.w   $60, $2AF				; 2
		dc.w   $60, $28F				; 4
		dc.w   $60, $2AF				; 6
		dc.w   $60, $1AC				; 8
		dc.w   $60, $1AC				; 10
		dc.w   $60, $28F				; 12
		dc.w   $60, $2AF				; 14
		dc.w   $60, $28C				; 16
		dc.w   $60, $5EC				; 18
		dc.w   $60, $20C				; 20
		dc.w   $60, $2AF				; 22
		dc.w   $60, $4CC				; 24
		dc.w  $1E0, $4CC				; 26
		dc.w   $60, $3EF				; 28
		dc.w   $60, $6AF				; 30
		dc.w  $230, $1AC				; 32
		dc.w  $230, $1AC				; 34
		dc.w   $60, $28F				; 36
		dc.w   $60, $2AF				; 38
		dc.w   $60, $6AC				; 40
		dc.w   $60, $56C				; 42
		dc.w   $60, $6AC				; 44
		dc.w   $60, $5AC				; 46
		dc.w   $60, $2AC				; 48
		dc.w   $60, $58C				; 50
		dc.w   $60, $1EC				; 52
		dc.w   $60, $12C				; 54
		dc.w   $60, $12D				; 56
		dc.w   $60, $12D				; 58
		dc.w   $60, $37E				; 60
		dc.w   $60, $37E				; 62
		dc.w  $120,  $70				; 64
		dc.w  $140,  $70				; 66

; ---------------------------------------------------------------------------
; Subroutine to	initialize background position and scrolling

; input:
;	d0.w = v_camera_y_pos
;	d1.w = v_camera_x_pos

;	uses d0.l, d1.w, d2.l, a2
; ---------------------------------------------------------------------------

LPL_InitBG:
		tst.b	(v_last_lamppost).w			; have any starposts been hit?
		bne.s	.starpost				; branch if so
		move.w	d0,(v_bg1_y_pos).w			; use same x/y pos for fg and bg
		move.w	d0,(v_bg2_y_pos).w
		move.w	d1,(v_bg1_x_pos).w
		move.w	d1,(v_bg2_x_pos).w
		move.w	d1,(v_bg3_x_pos).w
		move.w	d0,(v_bg1_y_pos_p2).w
		move.w	d0,(v_bg2_y_pos_p2).w
		move.w	d1,(v_bg1_x_pos_p2).w
		move.w	d1,(v_bg2_x_pos_p2).w
		move.w	d1,(v_bg3_x_pos_p2).w

	.starpost:
		moveq	#0,d2
		move.b	(v_zone).w,d2
		add.w	d2,d2
		move.w	LPL_InitBG_Index(pc,d2.w),d2
		jmp	LPL_InitBG_Index(pc,d2.w)		; run custom background initialization code if there is any

; ===========================================================================
LPL_InitBG_Index:	index offset(*),,2
		ptr LPL_InitBG_EHZ				; 0
		ptr LPL_InitBG_Null0				; 1
		ptr LPL_InitBG_WZ				; 2
		ptr LPL_InitBG_Null0				; 3
		ptr LPL_InitBG_MTZ				; 4
		ptr LPL_InitBG_MTZ				; 5
		ptr LPL_InitBG_Null1				; 6
		ptr LPL_InitBG_HTZ				; 7
		ptr LPL_InitBG_Null2				; 8
		ptr LPL_InitBG_Null2				; 9
		ptr LPL_InitBG_OOZ				; $A
		ptr LPL_InitBG_MCZ				; $B
		ptr LPL_InitBG_CNZ				; $C
		ptr LPL_InitBG_CPZ				; $D
		ptr LPL_InitBG_Null3				; $E
		ptr LPL_InitBG_ARZ				; $F
		ptr LPL_InitBG_SCZ				; $10
		zonewarning	LPL_InitBG_Index,2
; ===========================================================================

LPL_InitBG_EHZ:
		clr.l	(v_bg1_x_pos).w				; clear both background 1 positions
		clr.l	(v_bg1_y_pos).w
		clr.l	(v_bg2_y_pos).w				; clear background 2 and 3 y pos
		clr.l	(v_bg3_y_pos).w
		lea	(v_bgscroll_buffer).w,a2
		clr.l	(a2)+					; clear first 12 bytes of scroll buffer
		clr.l	(a2)+
		clr.l	(a2)+
		clr.l	(v_bg1_x_pos_p2).w			; clear BG pos vars for player 2
		clr.l	(v_bg1_y_pos_p2).w
		clr.l	(v_bg2_y_pos_p2).w
		clr.l	(v_bg3_y_pos_p2).w
		rts
; ===========================================================================

LPL_InitBG_Null0:
	if Revision=0
		rts
	endc
; ===========================================================================

LPL_InitBG_WZ:
	if Revision=0
		asr.w	#2,d0
		addi.w	#$400,d0				; d0 = (v_camera_y_pos/4)+$400
		move.w	d0,(v_bg1_y_pos).w
		asr.w	#3,d1					; d1 = v_camera_x_pos/8
		move.w	d1,(v_bg1_x_pos).w
		rts
	endc
; ===========================================================================

LPL_InitBG_MTZ:
		asr.w	#2,d0					; d0 = v_camera_y_pos/4
		move.w	d0,(v_bg1_y_pos).w
		asr.w	#3,d1					; d1 = v_camera_x_pos/8
		move.w	d1,(v_bg1_x_pos).w
		rts
; ===========================================================================

LPL_InitBG_Null1:
		rts
; ===========================================================================

LPL_InitBG_HTZ:
		clr.l	(v_bg1_x_pos).w				; identical to EHZ's code
		clr.l	(v_bg1_y_pos).w
		clr.l	(v_bg2_y_pos).w
		clr.l	(v_bg3_y_pos).w
		lea	(v_bgscroll_buffer).w,a2
		clr.l	(a2)+
		clr.l	(a2)+
		clr.l	(a2)+
		clr.l	(v_bg1_x_pos_p2).w
		clr.l	(v_bg1_y_pos_p2).w
		clr.l	(v_bg2_y_pos_p2).w
		clr.l	(v_bg3_y_pos_p2).w
		rts
; ===========================================================================

LPL_InitBG_HPZ:
	if Revision=0
		asr.w	#1,d0					; d0 = v_camera_y_pos/2
		move.w	d0,(v_bg1_y_pos).w
		clr.l	(v_bg1_x_pos).w
		rts
	endc
; ===========================================================================
; Unused Sonic 1 leftover: Spring Yard Zone's BG init routine from Revision 1
;LPL_InitBG_SYZ:
	if Revision=0
		asl.l	#4,d0
		move.l	d0,d2
		asl.l	#1,d0
		add.l	d2,d0
		asr.l	#8,d0					; d0 = v_camera_y_pos/5 (approx)
		addq.w	#1,d0
		move.w	d0,(v_bg1_y_pos).w
		clr.l	(v_bg1_x_pos).w
		rts
	endc
; ===========================================================================

LPL_InitBG_Null2:
		rts
; ===========================================================================

LPL_InitBG_OOZ:
		lsr.w	#3,d0
		addi.w	#$50,d0					; d0 = (v_camera_y_pos*8)+$50
		move.w	d0,(v_bg1_y_pos).w
		clr.l	(v_bg1_x_pos).w
		rts
; ===========================================================================

LPL_InitBG_MCZ:
		clr.l	(v_bg1_x_pos).w				; clear background 1 x pos
		clr.l	(v_bg1_x_pos_p2).w			; (both players)
		tst.b	(v_act).w
		bne.s	.act2					; branch if it's act 2
		divu.w	#3,d0
		subi.w	#$140,d0				; d0 = (v_camera_y_pos/3)-$140
		move.w	d0,(v_bg1_y_pos).w
		move.w	d0,(v_bg1_y_pos_p2).w
		rts
; ===========================================================================

	.act2:
		divu.w	#6,d0
		subi.w	#$10,d0					; d0 = (v_camera_y_pos/6)-$10
		move.w	d0,(v_bg1_y_pos).w
		move.w	d0,(v_bg1_y_pos_p2).w
		rts
; ===========================================================================

LPL_InitBG_CNZ:
		clr.l	(v_bg1_x_pos).w				; clear bg 1 x and y pos
		clr.l	(v_bg1_y_pos).w
		clr.l	(v_bg1_y_pos_p2).w			; clear player 2's bg 1 y pos
		rts
; ===========================================================================

LPL_InitBG_CPZ:
		lsr.w	#2,d0					; d0 = v_camera_y_pos/4
		move.w	d0,(v_bg1_y_pos).w
		move.w	d0,(v_bg1_y_pos_p2).w
		lsr.w	#1,d1					; d1 = v_camera_x_pos/2
		move.w	d1,(v_bg2_x_pos).w
		lsr.w	#2,d1					; d1 = v_camera_x_pos/8
		move.w	d1,(v_bg1_x_pos).w
		rts
; ===========================================================================

LPL_InitBG_Null3:
		rts
; ===========================================================================

LPL_InitBG_ARZ:
		tst.b	(v_act).w
		beq.s	.act1					; branch if it's act 1
		subi.w	#$E0,d0
		lsr.w	#1,d0					; d0 = (v_camera_y_pos-$E0)/2
		move.w	d0,(v_bg1_y_pos).w
		bra.s	.set_x
; ===========================================================================

	.act1:
		subi.w	#$180,d0				; d0 = v_camera_y_pos-$180
		move.w	d0,(v_bg1_y_pos).w

	.set_x:
		muls.w	#$119,d1
		asr.l	#8,d1					; d1 = (v_camera_x_pos*$119)/$100
		move.w	d1,(v_bg1_x_pos).w			; clear background positions
		move.w	d1,(v_camera_arz_bg_x_pos).w
		clr.w	(v_bg1_x_pos+2).w
		clr.w	(v_camera_arz_bg_x_pos+2).w
		clr.l	(v_bg2_y_pos).w
		clr.l	(v_bg3_y_pos).w
		rts
; ===========================================================================

LPL_InitBG_SCZ:
		clr.l	(v_bg1_x_pos).w				; clear background positions
		clr.l	(v_bg1_y_pos).w
		rts

; ---------------------------------------------------------------------------
; Background layer deformation and camera movement subroutines

;	uses d0.l, d1.l, d2.l, d3.l, d4.l, d5.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

DeformLayers:
		tst.b	(f_disable_scrolling).w			; is scrolling disabled?
		beq.s	.bg_scroll				; if not, branch
		rts
; ===========================================================================

	.bg_scroll:
		clr.w	(v_fg_redraw_direction).w		; clear all redraw flags and camera differences
		clr.w	(v_bg1_redraw_direction).w		; (could be faster by using a data register to clear them)
		clr.w	(v_bg2_redraw_direction).w
		clr.w	(v_bg3_redraw_direction).w
		clr.w	(v_fg_redraw_direction_p2).w
		clr.w	(v_bg1_redraw_direction_p2).w
		clr.w	(v_bg2_redraw_direction_p2).w
		clr.w	(v_bg3_redraw_direction_p2).w
		clr.w	(v_camera_x_diff).w
		clr.w	(v_camera_y_diff).w
		clr.w	(v_camera_x_diff_p2).w
		clr.w	(v_camera_y_diff_p2).w

		cmpi.b	#id_SCZ,(v_zone).w			; is it SCZ?
		bne.w	.notSCZ					; branch if not
		tst.w	(v_debug_active).w			; is debug placement mode active?
		beq.w	.skip_2P				; branch if not

	.notSCZ:
		tst.b	(f_disable_scroll_p1).w
		bne.s	.chk_2P					; branch if horizontal scrolling is disabled for player 1

		lea	(v_ost_player1).w,a0			; load all variables used for updating player 1's camera x pos and horiz redraw flags
		lea	(v_camera_x_pos).w,a1
		lea	(v_boundary_left).w,a2
		lea	(v_fg_redraw_direction).w,a3
		lea	(v_camera_x_diff).w,a4
		lea	(v_hscroll_delay_val).w,a5
		lea	(v_sonic_pos_tracker).w,a6

		cmpi.w	#tails_alone,(v_player_mode).w		; is is a Tails alone game?
		bne.s	.not_tails_alone_X			; branch if not
		lea	(v_hscroll_delay_val_p2).w,a5		; use the hscroll delay and pos tracker variables for Tails
		lea	(v_tails_pos_tracker).w,a6

	.not_tails_alone_X:
		bsr.w	UpdateCamera_X				; update camera x pos
		lea	(v_fg_x_redraw_flag).w,a2
		bsr.w	UpdateHScrollFlags			; update horizontal redraw flags

		lea	(v_camera_y_pos).w,a1			; load all variables used for updating player 1's camera y pos and vert redraw flags
		lea	(v_boundary_left).w,a2
		lea	(v_camera_y_diff).w,a4
		move.w	(v_camera_y_shift).w,d3
		cmpi.w	#tails_alone,(v_player_mode).w		; is is a Tails alone game?
		bne.s	.not_tails_alone_Y			; branch if not
		move.w	(v_camera_y_shift_p2).w,d3		; use Tail's y shift value

	.not_tails_alone_Y:
		bsr.w	UpdateCamera_Y				; update camera y pos
		lea	(v_fg_y_redraw_flag).w,a2
		bsr.w	UpdateVScrollFlags			; update vertical redraw flags

	.chk_2P:
		tst.w	(f_two_player).w
		beq.s	.skip_2P				; branch if it's not 2P mode
		tst.b	(f_disable_scroll_p2).w
		bne.s	.skip_2P				; branch if horizontal scrolling is disabled for player 2
		lea	(v_ost_player2).w,a0			; load all variables used for updating player 2's camera x pos and horiz redraw flags
		lea	(v_camera_x_pos_p2).w,a1
		lea	(v_boundary_left_p2).w,a2
		lea	(v_fg_redraw_direction_p2).w,a3
		lea	(v_camera_x_diff_p2).w,a4
		lea	(v_hscroll_delay_val_p2).w,a5
		lea	(v_tails_pos_tracker).w,a6
		bsr.w	UpdateCamera_X				; update camera x pos
		lea	(v_fg_x_redraw_flag_p2).w,a2
		bsr.w	UpdateHScrollFlags			; update horizontal redraw flags

		lea	(v_camera_y_pos_p2).w,a1		; load all variables used for updating player 1's camera y pos and vert redraw flags
		lea	(v_boundary_left_p2).w,a2
		lea	(v_camera_y_diff_p2).w,a4
		move.w	(v_camera_y_shift_p2).w,d3
		bsr.w	UpdateCamera_Y				; update camera y pos
		lea	(v_fg_y_redraw_flag_p2).w,a2
		bsr.w	UpdateVScrollFlags			; update vertical redraw flags

.skip_2P:
		bsr.w	DynamicLevelEvents			; run DLE (updating level boundaries, loading bosses, and running CNZ's slot machines)
		move.w	(v_camera_y_pos).w,(v_fg_y_pos_vsram).w	; update VSRAM buffer
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		move.l	(v_camera_x_pos).w,(v_camera_x_pos_copy2).w ; update camera position copies
		move.l	(v_camera_y_pos).w,(v_camera_y_pos_copy2).w

		moveq	#0,d0
		move.b	(v_zone).w,d0				; get zone ID
		add.w	d0,d0					; make index
		move.w	Deform_Index(pc,d0.w),d0
		jmp	Deform_Index(pc,d0.w)			; run level-specific deformation code

; ---------------------------------------------------------------------------
; Offset index for background layer deformation	code
; ---------------------------------------------------------------------------

Deform_Index:	index offset(*)
		ptr Deform_EHZ					; EHZ
		ptr Deform_Minimal				; unused
		ptr Deform_Lev2					; unused
		ptr Deform_Minimal				; unused
		ptr Deform_MTZ					; MTZ 1 & 2
		ptr Deform_MTZ					; MTZ 3
		ptr Deform_WFZ					; WFZ
		ptr Deform_HTZ					; HTZ
		ptr Deform_HPZ					; unused
		ptr Deform_Minimal				; unused
		ptr Deform_OOZ					; OOZ
		ptr Deform_MCZ					; MCZ
		ptr Deform_CNZ					; CNZ
		ptr Deform_CPZ					; CPZ
		ptr Deform_DEZ					; DEZ
		ptr Deform_ARZ					; ARZ
		ptr Deform_SCZ					; SCZ
		zonewarning Deform_Index,2

; ---------------------------------------------------------------------------
; Title screen background layer scrolling/deformation routine
; ---------------------------------------------------------------------------

Deform_TitleScreen:
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w	; update background
		addq.w	#1,(v_camera_x_pos).w			; autoscroll 1 pixel to right each frame
		move.w	(v_camera_x_pos).w,d2
		neg.w	d2					; negate camera x pos to make base scroll value
		asr.w	#2,d2					; divide by 4 to get background x pos

		lea	(v_hscroll_buffer).w,a1

		moveq	#0,d0
		move.w	#160-1,d1				; 160 lines of blue sky
	.lines_1_160:
		move.l	d0,(a1)+
		dbf	d1,	.lines_1_160

		move.w	d2,d0					; d0 = background x pos
		move.w	#32-1,d1				; 32 lines of background island that scroll with camera
	.lines_161_193:
		move.l	d0,(a1)+
		dbf	d1,.lines_161_193

		move.w	d0,d3
		move.b	(v_vblank_counter_byte).w,d1		; get byte that increments every frame
		andi.w	#7,d1
		bne.s	.skipripple				; if not a multiple of 8, branch
		subq.w	#1,(v_bgscroll_buffer).w		; animate the 'ripple' every 8 frames

	.skipripple:
		move.w	(v_bgscroll_buffer).w,d1
		andi.w	#$1F,d1					; d1 = index
		lea	Deform_Ripple_Data(pc),a2
		lea	(a2,d1.w),a2				; a2 = start location in ripple data
		move.w	#16-1,d1				; 16 lines that scroll with camera and 'ripple'
	.lines_194_208:
		move.b	(a2)+,d0				; get offset value from ripple data
		ext.w	d0					; extend to word
		add.w	d3,d0					; add base scroll value
		move.l	d0,(a1)+				; write to buffer
		dbf	d1,.lines_194_208
		rts

; ---------------------------------------------------------------------------
; Emerald Hill Zone background layer scrolling/deformation routine
; (All of the loop counter loads here could use moveq)
; ---------------------------------------------------------------------------

Deform_EHZ:
		tst.w	(f_two_player).w			; is it 2P mode?
		bne.w	Deform_EHZ_2P				; if so, use its deformation routine instead

		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w	; update VSRAM buffer

		lea	(v_hscroll_buffer).w,a1
		move.w	(v_camera_x_pos).w,d0			; get camera x pos
		neg.w	d0					; negate it to make base scroll offset
		move.w	d0,d2
		swap	d0
		move.w	#0,d0					; foreground value in high word, background value in low word

		move.w	#22-1,d1				; 22 lines of blue sky
	.lines_1_22:
		move.l	d0,(a1)+
		dbf	d1,.lines_1_22

		move.w	d2,d0					; d0 = negated camera x pos in both words
		asr.w	#6,d0					; divide low word by 64 to get scroll values for clouds

		move.w	#58-1,d1				; 58 lines of clouds on the horizon
	.lines_23_80:
		move.l	d0,(a1)+
		dbf	d1,.lines_23_80

		move.w	d0,d3					; back up scroll values in d3
		move.b	(v_vblank_counter_byte).w,d1		; get current frame number
		andi.w	#7,d1
		bne.s	.skipripple				; if not a multiple of 8, branch
		subq.w	#1,(v_bgscroll_buffer).w		; animate the 'ripple' every 8 frames

	.skipripple:
		move.w	(v_bgscroll_buffer).w,d1
		andi.w	#$1F,d1					; d1 = index
		lea	(Deform_Ripple_Data).l,a2
		lea	(a2,d1.w),a2				; a2 = start location in ripple data

		move.w	#21-1,d1				; 21 lines of rippling cloud reflections on the ocean
	.lines_81_101:
		move.b	(a2)+,d0				; get offset value from ripple data
		ext.w	d0					; extend to word
		add.w	d3,d0					; add base scroll value
		move.l	d0,(a1)+				; write to buffer
		dbf	d1,.lines_81_101

		move.w	#0,d0
		move.w	#11-1,d1				; 11 lines of ocean with no reflections
	.lines_101_112:
		move.l	d0,(a1)+
		dbf	d1,.lines_101_112

		move.w	d2,d0					; get base scroll value
		asr.w	#4,d0					; divide by 16 to get scroll value for distant hills

		move.w	#16-1,d1				; 16 lines of distant hills
	.lines_113_128:
		move.l	d0,(a1)+
		dbf	d1,.lines_113_128

		move.w	d2,d0					; get base scroll value
		asr.w	#4,d0					; divide by 16 (these two lines are unnecessary as d0 hasn't changed)

		move.w	d0,d1
		asr.w	#1,d1					; divide scroll value by 2
		add.w	d1,d0					; add to previous value, increasing by it by a factor of 1.66

		move.w	#16-1,d1				; 16 lines of slightly closer hills
	.lines_129_144:
		move.l	d0,(a1)+
		dbf	d1,.lines_129_144

		move.l	d0,d4
		swap	d4					; d4 = foreground value; next set of values are done as word writes
		move.w	d2,d0					; get base scroll value

		; The next 9 lines effectively divide the base scroll value by $80, with the quotient
		; placed in the high word of d0.
		asr.w	#1,d0					; divide by 2
		move.w	d2,d1					; get base scroll value again
		asr.w	#3,d1					; divide by 8
		sub.w	d1,d0					; (base/2) - (base/8)
		ext.l	d0					; sign extend difference
		asl.l	#8,d0					; multiply by 256
		divs.w	#$30,d0					; divide by 48
		ext.l	d0					; only need the quotient
		asl.l	#8,d0					; multiply by 256; high word contains the delta per scanline for the meadow

		moveq	#0,d3
		move.w	d2,d3					; get base scroll value again
		asr.w	#3,d3					; divide by 8

		move.w	#15-1,d1				; 15 lines of meadow, each line faster than the one before it
	.lines_145_159:
		move.w	d4,(a1)+				; foreground value
		move.w	d3,(a1)+				; background value
		swap	d3					; swap to high word
		add.l	d0,d3					; add delta
		swap	d3					; swap new value to low word
		dbf	d1,.lines_145_159

		move.w	#(18/2)-1,d1				; 18 lines of meadow, two lines each at same speed
	.lines_160_177:
		rept 2
		move.w	d4,(a1)+				; foreground value
		move.w	d3,(a1)+				; background value
		endr
		swap	d3					; swap to high word
		add.l	d0,d3					; add delta*2
		add.l	d0,d3
		swap	d3					; swap new value to low word
		dbf	d1,.lines_160_177

		move.w	#(45/3)-1,d1				; 45 lines of meadow, three lines each at same speed
	.lines_178_222:
		rept 3
		move.w	d4,(a1)+				; foreground value
		move.w	d3,(a1)+				; background value
		endr
		swap	d3					; swap to high word
		add.l	d0,d3					; add delta*3
		add.l	d0,d3
		add.l	d0,d3
		swap	d3					; swap new value to low word
		dbf	d1,.lines_178_222

		; 22+58+21+11+16+16+15+18+45=(screen_height-2)
		; Only 222 out of 224 lines have been processed.

    if FixBugs
		; The bottom two lines haven't had their HScroll values set!
		; The resulting graphical defect is often difficult to see
		; on NTSC CRTs, but is extremely obvious on PAL CRTs, modern LCDs
		; that do not crop overscan, and in emulators.
		; Knuckles in Sonic 2 fixes this with the following code:
	;.lines_223_224:
		rept 2
		move.w	d4,(a1)+				; 2 remaining lines of meadow
		move.w	d3,(a1)+
		endr
    endc
		rts

; ---------------------------------------------------------------------------
; Horizontal offsets for the water rippling effect on title screen and EHZ
; Also used by CPZ, ARZ, CNZ, and HTZ and DEZ screen shaking
; ---------------------------------------------------------------------------

Deform_Ripple_Data:
		dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0
		dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3
		dc.b   1,  2,  1,  3,  1,  2,  2,  1,  2,  3,  1,  2,  1,  2,  0,  0
		dc.b   2,  0,  3,  2,  2,  3,  2,  2,  1,  3,  0,  0,  1,  0,  1,  3
		dc.b   1,  2
		even
; ===========================================================================

Deform_EHZ_2P:
		; Make the 'ripple' animate every 8 frames.
		move.b	(v_vblank_counter_byte).w,d1
		andi.w	#7,d1
		bne.s	.player1
		subq.w	#1,(v_bgscroll_buffer).w

	.player1:
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w	; update vertical scrolling
		andi.l	#$FFFEFFFE,(v_fg_y_pos_vsram).w		; limit v-scroll to two pixels at a time

		; Update the background's (and foreground's) horizontal scrolling.
		; This creates an elaborate parallax effect.
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_camera_x_pos).w,d0

		move.w	#11-1,d1				; do 11 lines.
		bsr.s	.dobackground

	;.player2:
		; Update the background's vertical scrolling.
		moveq	#0,d0
		move.w	d0,(v_bg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_bg_y_pos_vsram_p2).w

		; Update the foregrounds's vertical scrolling.
		move.w	(v_camera_y_pos_p2).w,(v_fg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_fg_y_pos_vsram_p2).w

		; Only allow the screen to vertically scroll two pixels at a time.
		andi.l	#$FFFEFFFE,(v_fg_y_pos_vsram_p2).w

		; Update the background's (and foreground's) horizontal scrolling.
		; This creates an elaborate parallax effect.
		; Tails' screen is slightly taller, to fill the gap between the two
		; screens.
		lea	(v_hscroll_buffer+(112-4)*2*2).w,a1
		move.w	(v_camera_x_pos_p2).w,d0

		; Do 15 lines.
		move.w	#11+4-1,d1

.dobackground:
		neg.w	d0
		move.w	d0,d2
		swap	d0
		move.w	#0,d0

	.loop11or15:						; runs 11 times for player 1, 15 times for player 2
		move.l	d0,(a1)+
		dbf	d1,.loop11or15

		move.w	d2,d0
		asr.w	#6,d0

		; Do 29 lines.
		move.w	#29-1,d1
	.loop29:
		move.l	d0,(a1)+
		dbf	d1,.loop29

		move.w	d0,d3
		move.w	(v_bgscroll_buffer).w,d1
		andi.w	#$1F,d1
		lea_	Deform_Ripple_Data,a2
		lea	(a2,d1.w),a2

		; Do 11 lines.
		move.w	#11-1,d1
	.loop11:
		move.b	(a2)+,d0
		ext.w	d0
		add.w	d3,d0
		move.l	d0,(a1)+
		dbf	d1,.loop11

		move.w	#0,d0

		; Do 5 lines.
		move.w	#5-1,d1
	.loop5:
		move.l	d0,(a1)+
		dbf	d1,.loop5

		move.w	d2,d0
		asr.w	#4,d0

		; Do 8 lines.
		move.w	#8-1,d1
	.loop8_1:
		move.l	d0,(a1)+
		dbf	d1,.loop8_1

		move.w	d2,d0
		asr.w	#4,d0
		move.w	d0,d1
		asr.w	#1,d1
		add.w	d1,d0

		; Do 8 lines.
		move.w	#8-1,d1
	.loop8_2:
		move.l	d0,(a1)+
		dbf	d1,.loop8_2

		move.w	d2,d0
		asr.w	#1,d0
		move.w	d2,d1
		asr.w	#3,d1
		sub.w	d1,d0
		ext.l	d0
		asl.l	#8,d0
		divs.w	#$30,d0
		ext.l	d0
		asl.l	#8,d0
		moveq	#0,d3
		move.w	d2,d3
		asr.w	#3,d3

		; Do 40 lines.
		move.w	#40-1,d1
	.loop40:
		move.w	d2,(a1)+
		move.w	d3,(a1)+
		swap	d3
		add.l	d0,d3
		swap	d3
		dbf	d1,.loop40


		; 11+29+11+5+8+8+40=112.
		; No missing lines here.
		rts

; ===========================================================================

Deform_Lev2:
	if Revision<2
		; Just a duplicate of 'SwScrl_Minimal'.
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#5,d4
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#6,d5
		bsr.w	UpdateBG_XY
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		lea	(v_hscroll_buffer).w,a1
		move.w	#$DF,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d0
		neg.w	d0

loc_C7EA:
		move.l	d0,(a1)+
		dbf	d1,loc_C7EA
	endc
		rts
; ===========================================================================

Deform_MTZ:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#5,d4
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#6,d5
		bsr.w	UpdateBG_XY
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		lea	(v_hscroll_buffer).w,a1
		move.w	#screen_height-1,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d0
		neg.w	d0

loc_C822:
		move.l	d0,(a1)+
		dbf	d1,loc_C822
		rts

; ---------------------------------------------------------------------------
; Wing Fortress Zone background layer scrolling/deformation routine
; ---------------------------------------------------------------------------

Deform_WFZ:
		move.w	(v_bg_x_pos_diff).w,d4			; get BG x pos change since last frame
		ext.l	d4
		asl.l	#8,d4					; multiply by 256
		moveq	#2,d6
		bsr.w	UpdateBG_X2				; update bg x pos and set redraw flags
		move.w	(v_bg_y_pos_diff).w,d5			; get BG y pos change since last frame
		ext.l	d5
		lsl.l	#8,d5					; multiply by 256
		moveq	#6,d6
		bsr.w	UpdateBG_Y_Absolute			; update bg y pos and set redraw flags
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w	; update VSRAM buffer
		move.l	(v_bg1_x_pos).w,d0
		move.l	d0,d1

		; Set up scroll value buffer
		lea	(v_bgscroll_buffer).w,a2
		move.l	d0,(a2)+				; static sections of background (empty sky with no clouds)
		move.l	d1,(a2)+				; Eggman's getaway ship
		addi.l	#$8000,(a2)+				; large clouds
		addi.l	#$4000,(a2)+				; medium clouds
		addi.l	#$2000,(a2)+				; small clouds

		lea	(Deform_WFZ_Transition_Array).l,a3	; array for end-of-level cutscene
		cmpi.w	#$2700,(v_camera_x_pos).w
		bcc.s	.got_array				; branch if camera is right of $2700
		lea	(Deform_WFZ_Normal_Array).l,a3		; use array for main level

.got_array:
		lea	(v_bgscroll_buffer).w,a2
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1
		andi.w	#$7FF,d1
		moveq	#0,d0
		moveq	#0,d3

	.seg_loop:
		move.b	(a3)+,d0				; get number of lines in this segment
		addq.w	#1,a3					; skip over index value
		sub.w	d0,d1					; does this segment have any visible lines?
		bcc.s	.seg_loop				; branch if not

		neg.w	d1					; number of lines to draw in this segment
		move.w	#screen_height-1,d2			; (could be moveq)
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0					; d0 = fg scroll value in high word
		move.b	-1(a3),d3				; d3 = index into v_bgscroll_buffer
		move.w	(a2,d3.w),d0				; d0 = base scroll value for this segment

	if FixBugs
		; The clouds scroll incorrectly when the camera is moving, slowing down when
		; moving left and speeding up when moving right. This is because the scroll
		; values don't take into account the movement of the background. To fix this,
		; we just need to add the background x pos to the scroll value.
		cmpi.b	#8,d3					; clouds use indices 8, $A, and $10
		bcs.s	.notclouds				; branch if this segment isn't clouds
		add.w	(v_bg1_x_pos).w,d0			; add bg x pos so clouds scroll correctly

	.notclouds:
	endc
		neg.w	d0					; negate to make bg scroll value

	.row_loop:
		move.l	d0,(a1)+				; write value to hscroll buffer
		subq.w	#1,d1					; has current segment finished?
		bne.s	.next_row				; branch if not
		move.b	(a3)+,d1				; get number of lines in next segment
		move.b	(a3)+,d3				; get next index
		move.w	(a2,d3.w),d0				; d0 = base scroll value for this segment

	if FixBugs
		; See the fix above.
		cmpi.b	#8,d3					; clouds use indices 8, $A, and $10
		bcs.s	.notclouds2				; branch if this segment isn't clouds
		add.w	(v_bg1_x_pos).w,d0			; add bg x pos so clouds scroll correctly

	.notclouds2:
	endc
		neg.w	d0					; negate to make bg scroll value

	.next_row:
		dbf	d2,.row_loop
		rts
; ===========================================================================

Deform_WFZ_Transition_Array:
		dc.b $C0,  0
		dc.b $C0,  0
		dc.b $80,  0
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $80,  4
		dc.b $80,  4
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $C0,  0
		dc.b $C0,  0
		dc.b $80,  0

Deform_WFZ_Normal_Array:
		dc.b $C0,  0
		dc.b $C0,  0
		dc.b $80,  0
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
		dc.b $C0,  0
		dc.b $C0,  0
		dc.b $80,  0

	if FixBugs
		; This array is missing data for the last $80 lines compared to the transition array.
		; This causes the lower clouds to read the first two instructions of Deform_HTZ.
		; These are the missing entries:
		dc.b $20,  8
		dc.b $30, $C
		dc.b $30,$10
	endc
; ===========================================================================

Deform_HTZ:
		tst.w	(f_two_player).w
		bne.w	Deform_HTZ_2P				; branch if by miracle it's 2P mode

		tst.b	(f_screen_shake_htz).w
		bne.w	HTZ_Screen_Shake			; branch if the screen is shaking due to an earthquake

		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w	; update VSRAM buffer
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_camera_x_pos).w,d0			; get camera x pos
		neg.w	d0					; negate to make base scroll offset
		move.w	d0,d2
		swap	d0
		move.w	d2,d0					; foreground value in high word, background value in low word
		asr.w	#3,d0					; divide background value by 8

		move.w	#128-1,d1				; 128 lines of cliffs and mountains (the distant blue mountains are also animated via dynamic reloading)
	.lines_1_128:
		move.l	d0,(a1)+
		dbf	d1,.lines_1_128

		move.l	d0,d4					; back up foreground value for later

		; Update the values in v_bgscroll_buffer used to dynamically load the cloud art.
		move.w	(v_bgscroll_buffer+$22).w,d0		; get seed value
		addq.w	#4,(v_bgscroll_buffer+$22).w		; increment for next frame
		sub.w	d0,d2					; subtract seed from base scroll value
		move.w	d2,d0
		move.w	d0,d1
		asr.w	#1,d0					; divide by 2
		asr.w	#4,d1					; divide by 16 to get initial value
		sub.w	d1,d0					; (base-seed)/16 - (base-seed)/2
		ext.l	d0
		asl.l	#8,d0					; multiply by 256
		divs.w	#$70,d0					; divide by 112
		ext.l	d0
		asl.l	#8,d0					; multiply by 256 to make delta

		lea	(v_bgscroll_buffer).w,a2
		moveq	#0,d3
		move.w	d1,d3					; d3 = 0 in high word, initial value in low word

		rept 3
		swap	d3
		add.l	d0,d3					; add delta to full register
		swap	d3
		move.w	d3,(a2)+				; write to bg scroll buffer
		endr

		move.w	d3,(a2)+
		swap	d3
		add.l	d0,d3					; add delta*2
		add.l	d0,d3
		swap	d3

		moveq	#4-1,d1
	.bufferloop:
		move.w	d3,(a2)+				; write three times
		move.w	d3,(a2)+
		move.w	d3,(a2)+
		swap	d3
		add.l	d0,d3					; add delta*3
		add.l	d0,d3
		add.l	d0,d3
		swap	d3					; swap back
		dbf	d1,.bufferloop

		; Rest of the screen is the background clouds.
		add.l	d0,d0
		add.l	d0,d0					; multiply delta by 4
		move.w	d3,d4					; combine new background value with foreground value
		move.l	d4,(a1)+				; 3 lines (129-131)
		move.l	d4,(a1)+
		move.l	d4,(a1)+
		swap	d3
		add.l	d0,d3					; add delta
		swap	d3
		move.w	d3,d4
		move.l	d4,(a1)+				; 5 lines (132-136)
		move.l	d4,(a1)+
		move.l	d4,(a1)+
		move.l	d4,(a1)+
		move.l	d4,(a1)+
		swap	d3
		add.l	d0,d3					; add delta
		swap	d3
		move.w	d3,d4

		move.w	#7-1,d1					; 7 lines (137-143; could be moveq)
	.lines_137_143:
		move.l	d4,(a1)+
		dbf	d1,.lines_137_143

		swap	d3
		add.l	d0,d3					; add delta*2
		add.l	d0,d3
		swap	d3
		move.w	d3,d4

		move.w	#8-1,d1					; 8 lines (144-151)
	.lines_144_151:
		move.l	d4,(a1)+
		dbf	d1,.lines_144_151
		swap	d3
		add.l	d0,d3					; add delta*2
		add.l	d0,d3
		swap	d3
		move.w	d3,d4

		move.w	#10-1,d1				; 10 lines (152-161)
	.lines_152_161:
		move.l	d4,(a1)+
		dbf	d1,.lines_152_161
		swap	d3
		add.l	d0,d3					; add delta*3
		add.l	d0,d3
		add.l	d0,d3
		swap	d3
		move.w	d3,d4

		move.w	#15-1,d1				; 15 lines (162-176)
	.lines_162_176:
		move.l	d4,(a1)+
		dbf	d1,.lines_162_176
		swap	d3
		add.l	d0,d3					; add delta*3
		add.l	d0,d3
		add.l	d0,d3
		swap	d3

		move.w	#(48/16)-1,d2				; 48 lines total (177-224)
	.lines_176_224:
		move.w	d3,d4
		move.w	#16-1,d1				; 16 lines between value changes

	.write:
		move.l	d4,(a1)+				; write 16 lines
		dbf	d1,.write
		swap	d3
		add.l	d0,d3					; add delta*4
		add.l	d0,d3
		add.l	d0,d3
		add.l	d0,d3
		swap	d3
		dbf	d2,.lines_176_224
		rts
; ===========================================================================

;loc_CA92:
HTZ_Screen_Shake:
		move.w	(v_bg_x_pos_diff).w,d4
		ext.l	d4
		lsl.l	#8,d4
		moveq	#2,d6
		bsr.w	UpdateBG_X2
		move.w	(v_bg_y_pos_diff).w,d5
		ext.l	d5
		lsl.l	#8,d5
		moveq	#0,d6
		bsr.w	UpdateBG_Y_Absolute
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		move.w	(v_camera_y_pos).w,(v_fg_y_pos_vsram).w
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		moveq	#0,d2
		tst.b	(f_screen_shake).w
		beq.s	loc_CAEE
		move.w	(v_frame_counter).w,d0
		andi.w	#$3F,d0
		lea_	Deform_Ripple_Data,a1
		lea	(a1,d0.w),a1
		moveq	#0,d0
		move.b	(a1)+,d0
		add.w	d0,(v_fg_y_pos_vsram).w
		add.w	d0,(v_bg_y_pos_vsram).w
		add.w	d0,(v_camera_y_pos_copy2).w
		move.b	(a1)+,d2
		add.w	d2,(v_camera_x_pos_copy2).w

loc_CAEE:
		lea	(v_hscroll_buffer).w,a1
		move.w	#224-1,d1
		move.w	(v_camera_x_pos).w,d0
		add.w	d2,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d0
		add.w	d2,d0
		neg.w	d0

loc_CB08:
		move.l	d0,(a1)+
		dbf	d1,loc_CB08
		rts
; ===========================================================================


Deform_HTZ_2P:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#6,d4
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#2,d5
		moveq	#0,d5
		bsr.w	UpdateBG_XY
		move.b	#0,(v_bg1_redraw_direction).w
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		andi.l	#-$10002,(v_fg_y_pos_vsram).w
		lea	(v_hscroll_buffer).w,a1
		move.w	#$6F,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d0
		neg.w	d0

loc_CB50:
		move.l	d0,(a1)+
		dbf	d1,loc_CB50
		move.w	(v_camera_x_diff_p2).w,d4
		ext.l	d4
		asl.l	#6,d4
		add.l	d4,(v_bg1_x_pos_p2).w
		moveq	#0,d0
		move.w	d0,(v_bg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_bg_y_pos_vsram_p2).w
		move.w	(v_camera_y_pos_p2).w,(v_fg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_fg_y_pos_vsram_p2).w
		andi.l	#-$10002,(v_fg_y_pos_vsram_p2).w
		lea	($FFFFE1B0).w,a1
		move.w	#$73,d1
		move.w	(v_camera_x_pos_p2).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos_p2).w,d0
		neg.w	d0

loc_CB98:
		move.l	d0,(a1)+
		dbf	d1,loc_CB98
		rts
; ===========================================================================

Deform_HPZ:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#6,d4
		moveq	#2,d6
		bsr.w	UpdateBG_X2
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#7,d5
		moveq	#6,d6
		bsr.w	UpdateBG_Y_Absolute
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		lea	(v_bgscroll_buffer).w,a1
		move.w	(v_camera_x_pos).w,d2
		neg.w	d2
		move.w	d2,d0
		asr.w	#1,d0
		move.w	#7,d1

loc_CBD4:
		move.w	d0,(a1)+
		dbf	d1,loc_CBD4
		move.w	d2,d0
		asr.w	#3,d0
		sub.w	d2,d0
		ext.l	d0
		asl.l	#3,d0
		divs.w	#8,d0
		ext.l	d0
		asl.l	#4,d0
		asl.l	#8,d0
		moveq	#0,d3
		move.w	d2,d3
		asr.w	#1,d3
		lea	($FFFFA860).w,a2
		swap	d3
		add.l	d0,d3
		swap	d3
		move.w	d3,(a1)+
		move.w	d3,(a1)+
		move.w	d3,(a1)+
		move.w	d3,-(a2)
		move.w	d3,-(a2)
		move.w	d3,-(a2)
		swap	d3
		add.l	d0,d3
		swap	d3
		move.w	d3,(a1)+
		move.w	d3,(a1)+
		move.w	d3,-(a2)
		move.w	d3,-(a2)
		swap	d3
		add.l	d0,d3
		swap	d3
		move.w	d3,(a1)+
		move.w	d3,-(a2)
		swap	d3
		add.l	d0,d3
		swap	d3
		move.w	d3,(a1)+
		move.w	d3,-(a2)
		move.w	(v_bg1_x_pos).w,d0
		neg.w	d0
		move.w	#$19,d1

loc_CC36:
		move.w	d0,(a1)+
		dbf	d1,loc_CC36
		adda.w	#$E,a1
		move.w	d2,d0
		asr.w	#1,d0
		move.w	#$17,d1

loc_CC48:
		move.w	d0,(a1)+
		dbf	d1,loc_CC48
		lea	(v_bgscroll_buffer).w,a2
		move.w	(v_bg1_y_pos).w,d0
		move.w	d0,d2
		andi.w	#$3F0,d0
		lsr.w	#3,d0
		lea	(a2,d0.w),a2
		bra.w	loc_D69E
; ===========================================================================

Deform_OOZ:
		move.w	(v_camera_x_diff).w,d0
		ext.l	d0
		asl.l	#5,d0
		add.l	d0,(v_bg1_x_pos).w
		move.w	(v_camera_y_diff).w,d0
		ext.l	d0
		asl.l	#5,d0
		move.l	(v_bg1_y_pos).w,d3
		add.l	d3,d0
		moveq	#4,d6
		bsr.w	UpdateBG_Y_Absolute2
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		lea	($FFFFE380).w,a1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d7
		neg.w	d7
		move.w	(v_bg1_y_pos).w,d1
		subi.w	#$50,d1
		bcc.s	loc_CCAA
		moveq	#0,d1

loc_CCAA:
		subi.w	#$B0,d1
		bcs.s	loc_CCB2
		moveq	#0,d1

loc_CCB2:
		move.w	#$DF,d6
		add.w	d6,d1
		move.w	d7,d0
		bsr.s	sub_CD1C
		bsr.s	sub_CD10
		bsr.s	sub_CD16
		bsr.s	sub_CD0A
		move.w	d7,d0
		asr.w	#4,d0
		moveq	#6,d1
		bsr.s	sub_CD1C
		move.b	(v_vblank_counter_byte).w,d1
		andi.w	#7,d1
		bne.s	loc_CCD8
		subq.w	#1,(v_bgscroll_buffer).w

loc_CCD8:
		move.w	(v_bgscroll_buffer).w,d1
		andi.w	#$1F,d1
		lea	Deform_Ripple_Data(pc),a2
		lea	(a2,d1.w),a2
		moveq	#$20,d1

loc_CCEA:
		move.b	(a2)+,d0
		ext.w	d0
		move.l	d0,-(a1)
		subq.w	#1,d6
		bmi.s	locret_CD08
		dbf	d1,loc_CCEA
		bsr.s	sub_CD10
		bsr.s	sub_CD16
		bsr.s	sub_CD0A
		bsr.s	sub_CD16
		bsr.s	sub_CD10
		move.w	d7,d0
		moveq	#$47,d1
		bsr.s	sub_CD1C

locret_CD08:
		rts

; ===========================================================================


sub_CD0A:
		move.w	d7,d0
		asr.w	#2,d0
		bra.s	loc_CD1A


; ===========================================================================


sub_CD10:
		move.w	d7,d0
		asr.w	#3,d0
		bra.s	loc_CD1A


; ===========================================================================


sub_CD16:
		move.w	d7,d0
		asr.w	#4,d0

loc_CD1A:
		moveq	#7,d1

; ===========================================================================


sub_CD1C:
		move.l	d0,-(a1)
		subq.w	#1,d6
		bmi.s	loc_CD28
		dbf	d1,sub_CD1C
		rts
; ===========================================================================

loc_CD28:
		addq.l	#4,sp
		rts

; ===========================================================================

Deform_MCZ:
		tst.w	(f_two_player).w
		bne.w	loc_CE84
		move.w	(v_camera_y_pos).w,d0
		move.l	(v_bg1_y_pos).w,d3
		tst.b	(v_act).w
		bne.s	loc_CD4C
		divu.w	#3,d0
		subi.w	#320,d0
		bra.s	loc_CD54
; ===========================================================================

loc_CD4C:
		divu.w	#6,d0
		subi.w	#$10,d0

loc_CD54:
		swap	d0
		moveq	#6,d6
		bsr.w	UpdateBG_Y_Absolute2
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		moveq	#0,d2
		tst.b	(f_screen_shake).w
		beq.s	loc_CD90
		move.w	(v_frame_counter).w,d0
		andi.w	#$3F,d0
		lea_	Deform_Ripple_Data,a1
		lea	(a1,d0.w),a1
		moveq	#0,d0
		move.b	(a1)+,d0
		add.w	d0,(v_fg_y_pos_vsram).w
		add.w	d0,(v_bg_y_pos_vsram).w
		add.w	d0,(v_camera_y_pos_copy2).w
		move.b	(a1)+,d2
		add.w	d2,(v_camera_x_pos_copy2).w

loc_CD90:
		lea	(v_bgscroll_buffer).w,a2
		lea	15*2(a2),a3
		move.w	(v_camera_x_pos).w,d0

		ext.l	d0
		asl.l	#4,d0
		divs.w	#10,d0
		ext.l	d0
		asl.l	#4,d0
		asl.l	#8,d0
		move.l	d0,d1
		swap	d1

		move.w	d1,(a3)+
		move.w	d1,7*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,6*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,5*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,4*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,3*2(a2)
		move.w	d1,8*2(a2)
		move.w	d1,14*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,2*2(a2)
		move.w	d1,9*2(a2)
		move.w	d1,13*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,1*2(a2)
		move.w	d1,10*2(a2)
		move.w	d1,12*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,0*2(a2)
		move.w	d1,11*2(a2)

		lea	(Deform_MCZ_RowHeights).l,a3
		lea	(v_bgscroll_buffer).w,a2
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1
		moveq	#0,d0

loc_CE3E:
		move.b	(a3)+,d0
		addq.w	#2,a2
		sub.w	d0,d1
		bcc.s	loc_CE3E
		neg.w	d1
		subq.w	#2,a2
		move.w	#$DF,d2
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

loc_CE5A:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_CE66
		move.b	(a3)+,d1
		move.w	(a2)+,d0
		neg.w	d0

loc_CE66:
		dbf	d2,loc_CE5A
		rts
; ===========================================================================
Deform_MCZ_RowHeights:
		dc.b $25					; 0
		dc.b $17					; 1
		dc.b $12					; 2
		dc.b   7					; 3
		dc.b   7					; 4
		dc.b   2					; 5
		dc.b   2					; 6
		dc.b $30					; 7
		dc.b  $D					; 8
		dc.b $13					; 9
		dc.b $20					; 10
		dc.b $40					; 11
		dc.b $20					; 12
		dc.b $13					; 13
		dc.b  $D					; 14
		dc.b $30					; 15
		dc.b   2					; 16
		dc.b   2					; 17
		dc.b   7					; 18
		dc.b   7					; 19
		dc.b $20					; 20
		dc.b $12					; 21
		dc.b $17					; 22
		dc.b $25					; 23
; ===========================================================================

loc_CE84:
		moveq	#0,d0
		move.w	(v_camera_y_pos).w,d0
		tst.b	(v_act).w
		bne.s	loc_CE9A
		divu.w	#3,d0
		subi.w	#$140,d0
		bra.s	loc_CEA2
; ===========================================================================

loc_CE9A:
		divu.w	#6,d0
		subi.w	#$10,d0

loc_CEA2:
		move.w	d0,(v_bg1_y_pos).w
		move.w	d0,(v_bg_y_pos_vsram).w
		andi.l	#-$10002,(v_fg_y_pos_vsram).w
		lea	(v_bgscroll_buffer).w,a2
		lea	$1E(a2),a3
		move.w	(v_camera_x_pos).w,d0

		ext.l	d0
		asl.l	#4,d0
		divs.w	#10,d0
		ext.l	d0
		asl.l	#4,d0
		asl.l	#8,d0
		move.l	d0,d1
		swap	d1

		move.w	d1,(a3)+
		move.w	d1,7*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,6*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,5*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,4*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,3*2(a2)
		move.w	d1,8*2(a2)
		move.w	d1,14*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,2*2(a2)
		move.w	d1,9*2(a2)
		move.w	d1,13*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,1*2(a2)
		move.w	d1,10*2(a2)
		move.w	d1,12*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,0*2(a2)
		move.w	d1,11*2(a2)
		lea	(byte_CF90).l,a3
		lea	(v_bgscroll_buffer).w,a2
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1
		lsr.w	#1,d1
		moveq	#0,d0

loc_CF62:
		move.b	(a3)+,d0
		addq.w	#2,a2
		sub.w	d0,d1
		bcc.s	loc_CF62
		neg.w	d1
		subq.w	#2,a2
		move.w	#$6F,d2
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

loc_CF7E:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_CF8A
		move.b	(a3)+,d1
		move.w	(a2)+,d0
		neg.w	d0

loc_CF8A:
		dbf	d2,loc_CF7E
		bra.s	loc_CFA8
; ===========================================================================
byte_CF90:	dc.b $13					; 0
byte_CF91:	dc.b  $B					; 0
		dc.b   9					; 1
		dc.b   4					; 2
		dc.b   3					; 3
		dc.b   1					; 4
		dc.b   1					; 5
		dc.b $18					; 6
		dc.b   6					; 7
		dc.b  $A					; 8
		dc.b $10					; 9
		dc.b $20					; 10
		dc.b $10					; 11
		dc.b  $A					; 12
		dc.b   6					; 13
		dc.b $18					; 14
		dc.b   1					; 15
		dc.b   1					; 16
		dc.b   3					; 17
		dc.b   4					; 18
		dc.b $10					; 19
		dc.b   9					; 20
		dc.b  $B					; 21
		dc.b $13					; 22
; ===========================================================================

loc_CFA8:
		moveq	#0,d0
		move.w	(v_camera_y_pos_p2).w,d0
		tst.b	(v_act).w
		bne.s	loc_CFBE
		divu.w	#3,d0
		subi.w	#$140,d0
		bra.s	loc_CFC6
; ===========================================================================

loc_CFBE:
		divu.w	#6,d0
		subi.w	#$10,d0

loc_CFC6:
		move.w	d0,(v_bg1_y_pos_p2).w
		move.w	d0,(v_bg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_bg_y_pos_vsram_p2).w
		move.w	(v_camera_y_pos_p2).w,(v_fg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_fg_y_pos_vsram_p2).w
		andi.l	#-$10002,(v_fg_y_pos_vsram_p2).w
		lea	(v_bgscroll_buffer).w,a2
		lea	$1E(a2),a3
		move.w	(v_camera_x_pos_p2).w,d0

		ext.l	d0
		asl.l	#4,d0
		divs.w	#10,d0
		ext.l	d0
		asl.l	#4,d0
		asl.l	#8,d0
		move.l	d0,d1
		swap	d1

		move.w	d1,(a3)+
		move.w	d1,7*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,6*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,5*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,4*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,3*2(a2)
		move.w	d1,8*2(a2)
		move.w	d1,14*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,2*2(a2)
		move.w	d1,9*2(a2)
		move.w	d1,13*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,1*2(a2)
		move.w	d1,10*2(a2)
		move.w	d1,12*2(a2)

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		move.w	d1,0*2(a2)
		move.w	d1,11*2(a2)

		lea_	byte_CF91,a3
		lea	(v_bgscroll_buffer).w,a2
		lea	($FFFFE1B0).w,a1
		move.w	(v_bg1_y_pos_p2).w,d1
		lsr.w	#1,d1
		moveq	#$17,d0
		bra.s	loc_D09A
; ===========================================================================

loc_D098:
		move.b	(a3)+,d0

loc_D09A:
		addq.w	#2,a2
		sub.w	d0,d1
		bcc.s	loc_D098
		neg.w	d1
		subq.w	#2,a2
		move.w	#$73,d2
		move.w	(v_camera_x_pos_p2).w,d0
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

loc_D0B4:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_D0C0
		move.b	(a3)+,d1
		move.w	(a2)+,d0
		neg.w	d0

loc_D0C0:
		dbf	d2,loc_D0B4
		rts
; ===========================================================================

Deform_CNZ:
		tst.w	(f_two_player).w
		bne.w	loc_D194
		move.w	(v_camera_y_pos).w,d0
		lsr.w	#6,d0
		move.w	d0,(v_bg1_y_pos).w
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		move.w	(v_camera_x_pos).w,d2
		bsr.w	sub_D160
		lea	(byte_D156).l,a3
		lea	(v_bgscroll_buffer).w,a2
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1
		moveq	#0,d0

loc_D0FA:
		move.b	(a3)+,d0
		addq.w	#2,a2
		sub.w	d0,d1
		bcc.s	loc_D0FA
		neg.w	d1
		subq.w	#2,a2
		move.w	#$DF,d2
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

loc_D116:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_D124

loc_D11C:
		move.w	(a2)+,d0
		neg.w	d0
		move.b	(a3)+,d1
		beq.s	loc_D12A

loc_D124:
		dbf	d2,loc_D116
		rts
; ===========================================================================

loc_D12A:
		move.w	#$F,d1
		move.w	d0,d3
		move.b	(v_vblank_counter_byte).w,d0
		lsr.w	#3,d0
		neg.w	d0
		andi.w	#$1F,d0
		lea_	Deform_Ripple_Data,a4
		lea	(a4,d0.w),a4

loc_D144:
		move.b	(a4)+,d0
		ext.w	d0
		add.w	d3,d0
		move.l	d0,(a1)+
		dbf	d1,loc_D144
		subi.w	#$10,d2
		bra.s	loc_D11C
; ===========================================================================
byte_D156:
		dc.b $10					; 0
		dc.b $10					; 1
		dc.b $10					; 2
		dc.b $10					; 3
		dc.b $10					; 4
		dc.b $10					; 5
		dc.b $10					; 6
		dc.b $10					; 7
		dc.b   0					; 8
		dc.b $F0					; 9

; ===========================================================================


sub_D160:
		lea	(v_bgscroll_buffer).w,a1
		move.w	d2,d0
		asr.w	#3,d0
		sub.w	d2,d0
		ext.l	d0
		asl.l	#5,d0
		asl.l	#8,d0
		moveq	#0,d3
		move.w	d2,d3
		move.w	#6,d1

loc_D178:
		move.w	d3,(a1)+
		swap	d3
		add.l	d0,d3
		swap	d3
		dbf	d1,loc_D178
		move.w	d2,d0
		asr.w	#3,d0
		move.w	d0,4(a1)
		asr.w	#1,d0
		move.w	d0,(a1)+
		move.w	d0,(a1)+
		rts

; ===========================================================================

loc_D194:
		move.w	(v_camera_y_pos).w,d0
		lsr.w	#6,d0
		move.w	d0,(v_bg1_y_pos).w
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		andi.l	#-$10002,(v_fg_y_pos_vsram).w
		move.w	(v_camera_x_pos).w,d2
		bsr.w	sub_D160
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1
		moveq	#0,d0
		move.w	(v_camera_x_pos).w,d0
		move.w	#$6F,d2
		lea	(byte_D270+2).l,a3
		bsr.s	sub_D216
		move.w	(v_camera_y_pos_p2).w,d0
		lsr.w	#6,d0
		move.w	d0,(v_bg1_y_pos_p2).w
		move.w	d0,(v_bg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_bg_y_pos_vsram_p2).w
		move.w	(v_camera_y_pos_p2).w,(v_fg_y_pos_vsram_p2).w
		subi.w	#$E0,(v_fg_y_pos_vsram_p2).w
		andi.l	#-$10002,(v_fg_y_pos_vsram_p2).w
		move.w	(v_camera_x_pos_p2).w,d2
		bsr.w	sub_D160
		lea	($FFFFE1B0).w,a1
		move.w	(v_bg1_y_pos_p2).w,d1
		moveq	#0,d0
		move.w	(v_camera_x_pos_p2).w,d0
		move.w	#$73,d2
		lea	(byte_D270+1).l,a3

; ===========================================================================


sub_D216:
		lsr.w	#1,d1
		lea	(v_bgscroll_buffer).w,a2
		moveq	#0,d3

loc_D21E:
		move.b	(a3)+,d3
		addq.w	#2,a2
		sub.w	d3,d1
		bcc.s	loc_D21E
		neg.w	d1
		subq.w	#2,a2
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

loc_D232:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_D240

loc_D238:
		move.w	(a2)+,d0
		neg.w	d0
		move.b	(a3)+,d1
		beq.s	loc_D246

loc_D240:
		dbf	d2,loc_D232
		rts
; ===========================================================================

loc_D246:
		move.w	#7,d1
		move.w	d0,d3
		move.b	(v_vblank_counter_byte).w,d0
		lsr.w	#3,d0
		neg.w	d0
		andi.w	#$1F,d0
		lea_	Deform_Ripple_Data,a4
		lea	(a4,d0.w),a4

loc_D260:
		move.b	(a4)+,d0
		ext.w	d0
		add.w	d3,d0
		move.l	d0,(a1)+
		dbf	d1,loc_D260
		subq.w	#8,d2
		bra.s	loc_D238

; ===========================================================================
byte_D270:
		dc.b   4					; 0
		dc.b   4					; 1
		dc.b   8					; 2
		dc.b   8					; 3
		dc.b   8					; 4
		dc.b   8					; 5
		dc.b   8					; 6
		dc.b   8					; 7
		dc.b   8					; 8
		dc.b   8					; 9
		dc.b   0					; 10
		dc.b $78					; 11
; ===========================================================================

Deform_CPZ:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#5,d4
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#6,d5
		bsr.w	UpdateBG_XY
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#7,d4
		moveq	#4,d6
		bsr.w	UpdateBG_X_Block2
		move.w	(v_bg1_y_pos).w,d0
		move.w	d0,(v_bg2_y_pos).w
		move.w	d0,(v_bg_y_pos_vsram).w
		move.b	(v_bg1_redraw_direction).w,d0
		or.b	(v_bg2_redraw_direction).w,d0
		move.b	d0,(v_bg3_redraw_direction).w
		clr.b	(v_bg1_redraw_direction).w
		clr.b	(v_bg2_redraw_direction).w
		move.b	(v_vblank_counter_byte).w,d1
		andi.w	#7,d1
		bne.s	loc_D2CC
		subq.w	#1,(v_bgscroll_buffer).w

loc_D2CC:
		lea	(byte_DDD1).l,a0
		move.w	(v_bg1_y_pos).w,d0
		move.w	d0,d2
		andi.w	#$3F0,d0
		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		move.w	d0,d4
		lea	(v_hscroll_buffer).w,a1
		move.w	#$E,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		andi.w	#$F,d2
		move.w	(v_bg1_x_pos).w,d0
		cmpi.b	#$12,d4
		beq.s	loc_D34A
		bcs.s	loc_D308
		move.w	(v_bg2_x_pos).w,d0

loc_D308:
		neg.w	d0
		add.w	d2,d2
		jmp	loc_D322(pc,d2.w)
; ===========================================================================

loc_D310:
		move.w	(v_bg1_x_pos).w,d0
		cmpi.b	#$12,d4
		beq.s	loc_D354
		bcs.s	loc_D320
		move.w	(v_bg2_x_pos).w,d0

loc_D320:
		neg.w	d0

loc_D322:
		rept 16
		move.l	d0,(a1)+
		endr
		addq.b	#1,d4
		dbf	d1,loc_D310
		rts
; ===========================================================================

loc_D34A:
		move.w	#$F,d0
		sub.w	d2,d0
		move.w	d0,d2
		bra.s	loc_D358
; ===========================================================================

loc_D354:
		move.w	#$F,d2

loc_D358:
		move.w	(v_bg1_x_pos).w,d3
		neg.w	d3
		move.w	(v_bgscroll_buffer).w,d0
		andi.w	#$1F,d0
		lea_	Deform_Ripple_Data,a2
		lea	(a2,d0.w),a2

loc_D36E:
		move.b	(a2)+,d0
		ext.w	d0
		add.w	d3,d0
		move.l	d0,(a1)+
		dbf	d2,loc_D36E
		addq.b	#1,d4
		dbf	d1,loc_D310
		rts
; ===========================================================================

Deform_DEZ:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#8,d4
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#8,d5
		bsr.w	UpdateBG_XY

		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w

		move.w	(v_camera_x_pos).w,d4
		lea	(v_bgscroll_buffer).w,a2

		move.w	d4,(a2)+

		addq.w	#3,(a2)+
		addq.w	#2,(a2)+
		addq.w	#4,(a2)+
		addq.w	#1,(a2)+
		addq.w	#2,(a2)+
		addq.w	#4,(a2)+
		addq.w	#3,(a2)+
		addq.w	#4,(a2)+
		addq.w	#2,(a2)+
		addq.w	#6,(a2)+
		addq.w	#3,(a2)+
		addq.w	#4,(a2)+
		addq.w	#1,(a2)+
		addq.w	#2,(a2)+
		addq.w	#4,(a2)+
		addq.w	#3,(a2)+
		addq.w	#2,(a2)+
		addq.w	#3,(a2)+
		addq.w	#4,(a2)+
		addq.w	#1,(a2)+
		addq.w	#3,(a2)+
		addq.w	#4,(a2)+
		addq.w	#2,(a2)+
		addq.w	#1,(a2)

		move.w	(a2)+,d0
		moveq	#0,d1
		move.w	d0,d1
		lsr.w	#1,d0
		move.w	d0,(a2)+

		addq.w	#3,(a2)+
		addq.w	#2,(a2)+
		addq.w	#4,(a2)+

		swap	d1
		move.l	d1,d0
		lsr.l	#3,d1
		sub.l	d1,d0
		swap	d0
		move.w	d0,4(a2)

		swap	d0
		sub.l	d1,d0
		swap	d0
		move.w	d0,2(a2)

		swap	d0
		sub.l	d1,d0
		swap	d0
		move.w	d0,(a2)+

		addq.w	#2*2,a2

		addq.w	#1,(a2)+

		move.w	d4,(a2)+
		move.w	d4,(a2)+
		move.w	d4,(a2)+

		lea	(byte_D48A).l,a3
		lea	(v_bgscroll_buffer).w,a2
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1

		moveq	#0,d0

	loc_D424:
		move.b	(a3)+,d0
		addq.w	#2,a2
		sub.w	d0,d1
		bcc.s	loc_D424

		neg.w	d1
		subq.w	#2,a2
		move.w	#screen_height-1,d2
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

	loc_D440:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_D44C
		move.b	(a3)+,d1
		move.w	(a2)+,d0
		neg.w	d0

	loc_D44C:
		dbf	d2,loc_D440
		moveq	#0,d2
		tst.b	(f_screen_shake).w
		beq.s	locret_D488
		subq.w	#1,(v_dez_shake_timer).w
		bpl.s	loc_D462
		clr.b	(f_screen_shake).w

	loc_D462:
		move.w	(v_frame_counter).w,d0
		andi.w	#$3F,d0
		lea_	Deform_Ripple_Data,a1
		lea	(a1,d0.w),a1
		moveq	#0,d0
		move.b	(a1)+,d0
		add.w	d0,(v_fg_y_pos_vsram).w
		add.w	d0,(v_bg_y_pos_vsram).w
		add.w	d0,(v_camera_y_pos_copy2).w
		move.b	(a1)+,d2
		add.w	d2,(v_camera_x_pos_copy2).w

	locret_D488:
		rts
; ===========================================================================
byte_D48A:
		dc.b 128					; 0
		dc.b   8					; 1
		dc.b   8					; 2
		dc.b   8					; 3
		dc.b   8					; 4
		dc.b   8					; 5
		dc.b   8					; 6
		dc.b   8					; 7
		dc.b   8					; 8
		dc.b   8					; 9
		dc.b   8					; 10
		dc.b   8					; 11
		dc.b   8					; 12
		dc.b   8					; 13
		dc.b   8					; 14
		dc.b   8					; 15
		dc.b   8					; 16
		dc.b   8					; 17
		dc.b   8					; 18
		dc.b   8					; 19
		dc.b   8					; 20
		dc.b   8					; 21
		dc.b   8					; 22
		dc.b   8					; 23
		dc.b   8					; 24
		dc.b   8					; 25
		dc.b   8					; 26
		dc.b   8					; 27
		dc.b   8					; 28
		dc.b   3					; 29
		dc.b   5					; 30
		dc.b   8					; 31
		dc.b  16					; 32
		dc.b 128					; 33
		dc.b 128					; 34
		dc.b 128					; 35
		even
; ===========================================================================

Deform_ARZ:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		muls.w	#$119,d4
		moveq	#2,d6
		bsr.w	UpdateBG_Y_Absolute_ARZ
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#7,d5
		tst.b	(v_act).w
		bne.s	loc_D4CE
		asl.l	#1,d5

loc_D4CE:
		moveq	#6,d6
		bsr.w	UpdateBG_Y_Absolute
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		moveq	#0,d2
		tst.b	(f_screen_shake).w
		beq.s	loc_D508
		move.w	(v_frame_counter).w,d0
		andi.w	#$3F,d0
		lea_	Deform_Ripple_Data,a1
		lea	(a1,d0.w),a1
		moveq	#0,d0
		move.b	(a1)+,d0
		add.w	d0,(v_fg_y_pos_vsram).w
		add.w	d0,(v_bg_y_pos_vsram).w
		add.w	d0,(v_camera_y_pos_copy2).w
		move.b	(a1)+,d2
		add.w	d2,(v_camera_x_pos_copy2).w

loc_D508:
		lea	(v_bgscroll_buffer).w,a2
		lea	6(a2),a3
		move.w	(v_camera_x_pos).w,d0
		ext.l	d0
		asl.l	#4,d0
		divs.w	#$A,d0
		ext.l	d0
		asl.l	#4,d0
		asl.l	#8,d0
		move.l	d0,d1
		swap	d1
		move.w	d1,(a3)+
		swap	d1
		add.l	d1,d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		swap	d1
		add.l	d0,d1
		swap	d1
		move.w	d1,(a3)+

		move.w	d1,(a2)
		move.w	d1,4(a2)
		move.w	(v_bg1_x_pos).w,d0
		move.w	d0,2(a2)
		move.w	d0,$16(a2)
		_move.w	d0,0(a2)
		move.w	d0,4(a2)
		move.w	d0,$18(a2)
		move.w	d0,$1A(a2)
		move.w	d0,$1C(a2)
		move.w	d0,$1E(a2)
		lea	(byte_D5CE).l,a3
		lea	(v_bgscroll_buffer).w,a2
		lea	(v_hscroll_buffer).w,a1
		move.w	(v_bg1_y_pos).w,d1
		moveq	#0,d0

loc_D5A0:
		move.b	(a3)+,d0
		addq.w	#2,a2
		sub.w	d0,d1
		bcc.s	loc_D5A0
		neg.w	d1
		subq.w	#2,a2
		move.w	#$DF,d2
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(a2)+,d0
		neg.w	d0

loc_D5BC:
		move.l	d0,(a1)+
		subq.w	#1,d1
		bne.s	loc_D5C8
		move.b	(a3)+,d1
		move.w	(a2)+,d0
		neg.w	d0

loc_D5C8:
		dbf	d2,loc_D5BC
		rts
; ===========================================================================
byte_D5CE:
		dc.b 176
		dc.b 112					; 1
		dc.b  48					; 2
		dc.b  96					; 3
		dc.b  21					; 4
		dc.b  12					; 5
		dc.b  14					; 6
		dc.b   6					; 7
		dc.b  12					; 8
		dc.b  31					; 9
		dc.b  48					; 10
		dc.b 192					; 11
		dc.b 240					; 12
		dc.b 240					; 13
		dc.b 240					; 14
		dc.b 240					; 15
		even
; ===========================================================================

Deform_SCZ:
		tst.w	(v_debug_active).w
		bne.w	Deform_Minimal
		lea	(v_camera_x_pos).w,a1
		lea	(v_fg_redraw_direction).w,a3
		lea	(v_camera_x_diff).w,a4
		move.w	(v_tornado_x_vel).w,d0
		move.w	(a1),d4
		add.w	(a1),d0
		move.w	d0,d1
		sub.w	(a1),d1
		asl.w	#8,d1
		move.w	d0,(a1)
		move.w	d1,(a4)
		lea	(v_fg_x_redraw_flag).w,a2
		bsr.w	UpdateHScrollFlags
		lea	(v_camera_y_pos).w,a1
		lea	(v_camera_y_diff).w,a4
		move.w	(v_tornado_y_vel).w,d0
		move.w	(a1),d4
		add.w	(a1),d0
		move.w	d0,d1
		sub.w	(a1),d1
		asl.w	#8,d1
		move.w	d0,(a1)
		move.w	d1,(a4)
		lea	(v_fg_y_redraw_flag).w,a2
		bsr.w	UpdateVScrollFlags
		move.w	(v_camera_x_diff).w,d4
		beq.s	loc_D638
		move.w	#$100,d4

loc_D638:
		ext.l	d4
		asl.l	#7,d4
		moveq	#0,d5
		bsr.w	UpdateBG_XY
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		lea	(v_hscroll_buffer).w,a1
		move.w	#$DF,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d0
		neg.w	d0

loc_D65E:
		move.l	d0,(a1)+
		dbf	d1,loc_D65E
		rts
; ===========================================================================

Deform_Minimal:
		move.w	(v_camera_x_diff).w,d4
		ext.l	d4
		asl.l	#5,d4
		move.w	(v_camera_y_diff).w,d5
		ext.l	d5
		asl.l	#6,d5
		bsr.w	UpdateBG_XY
		move.w	(v_bg1_y_pos).w,(v_bg_y_pos_vsram).w
		lea	(v_hscroll_buffer).w,a1
		move.w	#$DF,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		move.w	(v_bg1_x_pos).w,d0
		neg.w	d0

loc_D696:
		move.l	d0,(a1)+
		dbf	d1,loc_D696
		rts
; ===========================================================================

loc_D69E:
		lea	(v_hscroll_buffer).w,a1
		move.w	#$E,d1
		move.w	(v_camera_x_pos).w,d0
		neg.w	d0
		swap	d0
		andi.w	#$F,d2
		add.w	d2,d2
		move.w	(a2)+,d0
		jmp	loc_D6BC(pc,d2.w)
; ===========================================================================

loc_D6BA:
		move.w	(a2)+,d0

loc_D6BC:
		rept 16
		move.l	d0,(a1)+
		endr
		dbf	d1,loc_D6BA
		rts

; ---------------------------------------------------------------------------
; Subroutine to set horizontal scroll flags

; inputs (exact variables will change based on if it's player 1 or 2):
;	a1 = v_camera_x_pos
; 	a2 = v_fg_x_redraw_flag
;	a3 = v_fg_redraw_direction
;	d4 = previous camera x pos

;	uses d0, d1
; ---------------------------------------------------------------------------

UpdateHScrollFlags:
		move.w	(a1),d0					; d0 = camera x pos
		andi.w	#$10,d0
		move.b	(a2),d1
		eor.b	d1,d0
		bne.s	.return
		eori.b	#$10,(a2)
		move.w	(a1),d0
		sub.w	d4,d0					; compare new with old screen position
		bpl.s	.scrollright				; branch if screen has moved forward

		bset	#redraw_left_bit,(a3)			; screen moves forward
		rts
; ===========================================================================

	.scrollright:
		bset	#redraw_right_bit,(a3)			; screen moves backward

	.return:
		rts


; ---------------------------------------------------------------------------
; Subroutine to	update camera as player moves horizontally

; inputs (exact variables will change based on if it's player 1 or 2):
;	a0 = ost of player
;	a1 = v_camera_x_pos
;	a2 = v_boundary_left
;	a4 = v_camera_x_diff
;	a5 = v_hscroll_delay_val
;	a5 = player's position tracking array

;	uses d0, d1, d4
; ---------------------------------------------------------------------------

UpdateCamera_X:
		move.w	(a1),d4					; save old screen position
		tst.b	(f_teleport).w				; is a teleport in progress?
		bne.s	UCX_NoChange				; if so, exit

	if FixBugs
		; To prevent the bug that is described below, this caps the position
		; array index offset so that it does not access position data from
		; before the spin dash was performed. Note that this requires
		; modifications to 'Sonic_UpdateSpindash' and 'Tails_UpdateSpindash'.
		move.w	(a5),d1					; should scrolling be delayed?
		beq.s	UCX_Camera				; branch if not
		lsl.b	#2,d1					; multiply by 4, the size of a position buffer entry
		subq.b	#1,(a5)					; reduce delay value
		move.b	v_sonic_pos_tracker_num+1-v_hscroll_delay_val(a5),d0 ; get low byte of index value for position tracking data
		sub.b	1(a5),d0				; subtract low byte of delay value
		cmp.b	d0,d1					; is this index from before the spindash was performed?
		bcs.b	.nocap					; branch if not
		move.b	d0,d1					; cap the index
	.nocap:
	else
		; The intent of this code is to make the camera briefly lag behind the
		; player right after releasing a spin dash, however it does this by
		; simply making the camera use position data from previous frames. This
		; means that if the camera had been moving recently enough, then
		; releasing a spin dash will cause the camera to jerk around instead of
		; remain still. This can be encountered by running into a wall, and
		; quickly turning around and spin dashing away. Sonic 3 would have had
		; this same issue with the Fire Shield's dash abiliity, but it shoddily
		; works around the issue by resetting the old position values to the
		; current position (see 'Reset_Player_Position_Array').
		move.w	(a5),d1					; should scrolling be delayed?
		beq.s	UCX_Camera				; branch if not
		subi.w	#$100,d1				; reduce delay value
		move.w	d1,(a5)
		moveq	#0,d1
		move.b	(a5),d1					; get delay value as a byte
		lsl.b	#2,d1					; multiply by 4, the size of a position buffer entry
		addq.b	#4,d1					; add 4
	endc
		move.w	v_sonic_pos_tracker_num-v_hscroll_delay_val(a5),d0 ; get current index value for position tracking data
		sub.b	d1,d0
		move.w	(a6,d0.w),d0				; get player's positon from a few frames back
		andi.w	#$3FFF,d0
		bra.s	UCX_Camera_Spindash			; use that value for calculating camera pos and hscroll
; ===========================================================================

UCX_Camera:
		move.w	ost_x_pos(a0),d0

UCX_Camera_Spindash:
		sub.w	(a1),d0					; (a1) = camera x pos; d0 = player's distance from left edge of screen
		subi.w	#(screen_width/2)-16,d0			; is distance less than 144px?
		blt.s	UCX_BehindMid				; branch if so
		subi.w	#16,d0					; is distance more than 160px?
		bge.s	UCX_AheadOfMid				; branch if so
		clr.w	(a4)					; no camera movement

UCX_NoChange:
		rts
; ===========================================================================

UCX_BehindMid:
		cmpi.w	#-16,d0					; is player within 16px of middle area?
		bgt.s	.within_16				; branch if so
		move.w	#-16,d0					; set to 16 if greater

	.within_16:
		add.w	(a1),d0					; d0 = new camera x pos
		cmp.w	(a2),d0					; is camera within boundary?
		bgt.s	UCX_SetScreen				; branch if so
		move.w	(a2),d0					; stop camera moving outside boundary
		bra.s	UCX_SetScreen
; ===========================================================================

UCX_AheadOfMid:
		cmpi.w	#16,d0					; is player within 16px of middle area?
		bcs.s	.within_16				; branch if so
		move.w	#16,d0					; set to 16 if greater

	.within_16:
		add.w	(a1),d0					; d0 = new camera x pos
		cmp.w	v_boundary_right-v_boundary_left(a2),d0	; is camera within boundary?
		blt.s	UCX_SetScreen				; branch if so
		move.w	v_boundary_right-v_boundary_left(a2),d0	; stop camera moving outside boundary

UCX_SetScreen:
		move.w	d0,d1
		sub.w	(a1),d1					; d1 = difference since last camera x pos
		asl.w	#8,d1					; move into high byte (multiply by $100)
		move.w	d0,(a1)					; set new screen position
		move.w	d1,(a4)					; set distance for camera movement
		rts

; ===========================================================================

UpdateCamera_Y:
		moveq	#0,d1
		move.w	ost_y_pos(a0),d0
		sub.w	(a1),d0					; d0 = player's distance from top of screen
		cmpi.w	#-$100,(v_boundary_top).w		; does the level wrap vertically?
		bne.s	.nowrap					; branch if not
		andi.w	#$7FF,d0
	if FixBugs
		; The above andi strips the sign from the y_pos. This results in a situation where
		; if the player ducks, allows the camera to scroll down, then exits the duck
		; and immediately jumps, they will be incorrectly treated them as having gone to the
		; bottom boundary of the level on y-wrapped levels, causing the camera to scroll
		; downward all the way around until it reaches them again. The following three
		; instructions effectively restore the sign, eliminating this bug.
		move.w  #$FC00,d1
    	add.w   d1,d0
   		eor.w   d1,d0
	endc
	.nowrap:
		btst	#status_jump_bit,ost_primary_status(a0)	; is player jumping/rolling?
		beq.s	.not_rolling
		subq.w	#5,d0					; subtract difference between standing and rolling heights

	if FixBugs
		; Tails is shorter than Sonic, so the above subtraction actually
		; causes the camera to jolt slightly when he goes from standing to
		; rolling, and vice versa. Not even Sonic 3 & Knuckles fixed this.
		; To fix this, just adjust the subtraction to suit Tails (who is four
		; pixels shorter).
		cmpi.b	#id_TailsPlayer,ost_id(a0)		; is the player Tails?
		bne.s	.not_rolling				; branch if not
		addq.w	#4,d0					; adjust difference to suit Tails
	endc

	.not_rolling:
		btst	#status_air_bit,ost_primary_status(a0)	; is player in the air?
		beq.s	.ground					; branch if not

		addi.w	#32,d0					; pretend player is 32px lower
		sub.w	d3,d0					; is player within 96px of top of screen? (or other value if looked up/down recenly)
		bcs.s	UCY_OutsideMid_Air			; branch if so
		subi.w	#64,d0					; is distance more than 160px?
		bcc.s	UCY_OutsideMid_Air			; branch if so
		tst.b	(f_boundary_bottom_change).w		; is bottom level boundary set to change?
		bne.s	UCY_BoundaryChange			; branch if so
		bra.s	.no_change
; ===========================================================================

.ground:
		sub.w	d3,d0					; is Sonic exactly 96px from top of screen?
		bne.s	UCY_OutsideMid_Ground			; branch if not
		tst.b	(f_boundary_bottom_change).w		; is bottom level boundary set to change?
		bne.s	UCY_BoundaryChange			; branch if so

.no_change:
		clr.w	(a4)					; no camera movement
		rts
; ===========================================================================

UCY_OutsideMid_Ground:
		cmpi.w	#camera_y_shift_default,d3		; has player looked up/down recently? (default y shift is 96)
		bne.s	.y_shift_different			; branch if so
		mvabs.w	ost_inertia(a0),d1			; get player's absolute inertia
		cmpi.w	#$800,d1
		bcc.s	UCY_OutsideMid_Air			; branch if inertia >= $800
		move.w	#6<<8,d1				; cap camera movement at 6px per frame
		cmpi.w	#6,d0					; is player more than 6px below middle area?
		bgt.s	UCY_BelowMid				; branch if so
		cmpi.w	#-6,d0					; is player more than 6px above middle area?
		blt.s	UCY_AboveMid				; branch if so
		bra.s	UCY_InsideMid
; ===========================================================================

.y_shift_different:
		move.w	#2<<8,d1				; cap camera movement at 2px per frame
		cmpi.w	#2,d0					; is player more than 2px below middle area?
		bgt.s	UCY_BelowMid				; branch if so
		cmpi.w	#-2,d0					; is player more than 2px above middle area?
		blt.s	UCY_AboveMid				; branch if so
		bra.s	UCY_InsideMid
; ===========================================================================

UCY_OutsideMid_Air:
		move.w	#16<<8,d1				; cap camera movement at 16px per frame
		cmpi.w	#16,d0					; is player more than 16px below middle area?
		bgt.s	UCY_BelowMid				; if yes, branch
		cmpi.w	#-16,d0					; is player more than 16px above middle area?
		blt.s	UCY_AboveMid				; if yes, branch
		bra.s	UCY_InsideMid
; ===========================================================================

UCY_BoundaryChange:
		moveq	#0,d0
		move.b	d0,(f_boundary_bottom_change).w		; clear boundary change flag

UCY_InsideMid:
		moveq	#0,d1
		move.w	d0,d1					; d0/d1 = player's distance from middle area
		add.w	(a1),d1					; add camera y pos to d1
		tst.w	d0					; is player below middle?
		bpl.w	UCY_BelowMid_Short			; branch if so
		bra.w	UCY_AboveMid_Short
; ===========================================================================

UCY_AboveMid:
		neg.w	d1					; d1 = -$200/-$600/-$1000
		ext.l	d1
		asl.l	#8,d1					; d1 = -$20000/-$60000/-$100000
		add.l	(a1),d1					; add v_camera_y_pos
		swap	d1					; d1 = v_camera_y_pos minus 2/6/$10 in low word

UCY_AboveMid_Short:
		cmp.w	v_boundary_top-v_boundary_left(a2),d1	; is camera within top boundary?
		bgt.s	UCY_SetScreen
		cmpi.w	#-$100,d1				; is camera no more than 255px outside boundary?
		bgt.s	.just_outside				; branch if so

		andi.w	#$7FF,d1				; clear high bits for levels that wrap vertically
		andi.w	#$7FF,(a1)
		bra.s	UCY_SetScreen
; ===========================================================================

.just_outside:
		move.w	v_boundary_top-v_boundary_left(a2),d1	; prevent camera from going any further up
		bra.s	UCY_SetScreen
; ===========================================================================

UCY_BelowMid:
		ext.l	d1
		asl.l	#8,d1					; d1 = $20000/$60000/$100000
		add.l	(a1),d1					; add v_camera_y_pos
		swap	d1					; d1 = v_camera_y_pos plus 2/6/$10 in low word

UCY_BelowMid_Short:
		cmp.w	v_boundary_bottom-v_boundary_left(a2),d1 ; is camera within bottom boundary?
		blt.s	UCY_SetScreen				; branch if so
		subi.w	#$800,d1				; is camera no more than 255px outside boundary?
		bcs.s	.just_outside				; branch if so
		subi.w	#$800,(a1)				; wrap vertically
		bra.s	UCY_SetScreen
; ===========================================================================

.just_outside:
		move.w	v_boundary_bottom-v_boundary_left(a2),d1 ; prevent camera from going any further down

UCY_SetScreen:
		move.w	(a1),d4					; save old screen position
		swap	d1
		move.l	d1,d3
		sub.l	(a1),d3					; d3 = difference since last camera y pos
		ror.l	#8,d3
		move.w	d3,(a4)					; set distance for camera movement
		move.l	d1,(a1)					; set new screen position
		rts

; ---------------------------------------------------------------------------
; Subroutine to set vertical scroll flags

; inputs (exact variables will change based on if it's player 1 or 2):
;	a1 = v_camera_y_pos
; 	a2 = v_fg_y_redraw_flag
;	a3 = v_fg_redraw_direction
;	d4 = previous camera y pos

;	uses d0, d1
; ---------------------------------------------------------------------------

UpdateVScrollFlags:
		move.w	(a1),d0
		andi.w	#$10,d0
		move.b	(a2),d1
		eor.b	d1,d0
		bne.s	.return
		eori.b	#$10,(a2)
		move.w	(a1),d0
		sub.w	d4,d0					; compare new with old screen position
		bpl.s	.scroll_down				; branch if screen has moved down
		bset	#redraw_top_bit,(a3)			; screen moves down
		rts
; ===========================================================================

	.scroll_down:
		bset	#redraw_bottom_bit,(a3)			; screen moves up

	.return:
		rts


; ===========================================================================

; SetHorizVertiScrollFlagsBG:
UpdateBG_XY:
		move.l	(v_bg1_x_pos).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,(v_bg1_x_pos).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	(v_bg1_x_redraw_flag).w,d3
		eor.b	d3,d1
		bne.s	UpdateBG_Y
		eori.b	#$10,(v_bg1_x_redraw_flag).w
		sub.l	d2,d0
		bpl.s	loc_D8C8
		bset	#2,(v_bg1_redraw_direction).w
		bra.s	UpdateBG_Y

	loc_D8C8:
		bset	#3,(v_bg1_redraw_direction).w

UpdateBG_Y:
		move.l	(v_bg1_y_pos).w,d3
		move.l	d3,d0
		add.l	d5,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	(v_bg1_y_redraw_flag).w,d2
		eor.b	d2,d1
		bne.s	locret_D902
		eori.b	#$10,(v_bg1_y_redraw_flag).w
		sub.l	d3,d0
		bpl.s	loc_D8FC
		bset	#0,(v_bg1_redraw_direction).w
		rts

	loc_D8FC:
		bset	#1,(v_bg1_redraw_direction).w

	locret_D902:
		rts


; ===========================================================================

; SetHorizScrollFlagsBG:
UpdateBG_X2:
		move.l	(v_bg1_x_pos).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,(v_bg1_x_pos).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	(v_bg1_x_redraw_flag).w,d3
		eor.b	d3,d1
		bne.s	locret_D936
		eori.b	#$10,(v_bg1_x_redraw_flag).w
		sub.l	d2,d0
		bpl.s	loc_D930
		bset	d6,(v_bg1_redraw_direction).w
		bra.s	locret_D936

	loc_D930:
		addq.b	#1,d6
		bset	d6,(v_bg1_redraw_direction).w

	locret_D936:
		rts


; ===========================================================================

; SetHorizScrollFlagsBG:
UpdateBG_Y_Absolute:
		move.l	(v_bg1_y_pos).w,d3
		move.l	d3,d0
		add.l	d5,d0

UpdateBG_Y_Absolute2:
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	(v_bg1_y_redraw_flag).w,d2
		eor.b	d2,d1
		bne.s	locret_D96A
		eori.b	#$10,(v_bg1_y_redraw_flag).w
		sub.l	d3,d0
		bpl.s	loc_D964
		bset	d6,(v_bg1_redraw_direction).w
		rts

	loc_D964:
		addq.b	#1,d6
		bset	d6,(v_bg1_redraw_direction).w

	locret_D96A:
		rts


; ===========================================================================

;SetHorizScrollFlagsBG_ARZ:
UpdateBG_Y_Absolute_ARZ:
		move.l	(v_camera_arz_bg_x_pos).w,d0
		add.l	d4,d0
		move.l	d0,(v_camera_arz_bg_x_pos).w
		lea	(v_bg1_x_pos).w,a1
		move.w	(a1),d2
		move.w	(v_camera_arz_bg_x_pos).w,d0
		sub.w	d2,d0
		bcs.s	loc_D988
		bhi.s	loc_D994
		rts

	loc_D988:
		cmpi.w	#-$10,d0
		bgt.s	loc_D99E
		move.w	#-$10,d0
		bra.s	loc_D99E


	loc_D994:
		cmpi.w	#$10,d0
		bcs.s	loc_D99E
		move.w	#$10,d0

	loc_D99E:
		add.w	(a1),d0
		move.w	d0,(a1)
		move.w	d0,d1
		andi.w	#$10,d1
		move.b	(v_bg1_x_redraw_flag).w,d3
		eor.b	d3,d1
		bne.s	locret_D9C6
		eori.b	#$10,(v_bg1_x_redraw_flag).w
		sub.w	d2,d0
		bpl.s	loc_D9C0
		bset	d6,(v_bg1_redraw_direction).w
		bra.s	locret_D9C6

	loc_D9C0:
		addq.b	#1,d6
		bset	d6,(v_bg1_redraw_direction).w

	locret_D9C6:
		rts


; ===========================================================================
; SetHorizScrollFlagsBG2:
UpdateBG_X_Block2:
		move.l	(v_bg2_x_pos).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,(v_bg2_x_pos).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	(v_bg2_x_redraw_flag).w,d3
		eor.b	d3,d1
		bne.s	locret_D9FA
		eori.b	#$10,(v_bg2_x_redraw_flag).w
		sub.l	d2,d0
		bpl.s	loc_D9F4
		bset	d6,(v_bg2_redraw_direction).w
		bra.s	locret_D9FA

	loc_D9F4:
		addq.b	#1,d6
		bset	d6,(v_bg2_redraw_direction).w

	locret_D9FA:
		rts


; ===========================================================================
; Unused Sonic 1 leftover - code to update BG block 3
;UpdateBG_X_Block3:
		move.l	(v_bg3_x_pos).w,d2
		move.l	d2,d0
		add.l	d4,d0
		move.l	d0,(v_bg3_x_pos).w
		move.l	d0,d1
		swap	d1
		andi.w	#$10,d1
		move.b	(v_bg3_x_redraw_flag).w,d3
		eor.b	d3,d1
		bne.s	locret_DA2E
		eori.b	#$10,(v_bg3_x_redraw_flag).w
		sub.l	d2,d0
		bpl.s	loc_DA28
		bset	d6,(v_bg3_redraw_direction).w
		bra.s	locret_DA2E

	loc_DA28:
		addq.b	#1,d6
		bset	d6,(v_bg3_redraw_direction).w

	locret_DA2E:
		rts
; ===========================================================================
; Unused Sonic 1 leftover: first ten lines of that game's version of
; DrawTilesWhenMoving.
		lea	(vdp_control_port).l,a5
		lea	(vdp_data_port).l,a6
		lea	(v_bg1_redraw_direction).w,a2
		lea	(v_bg1_x_pos).w,a3
		lea	($FFFF8080).w,a4
		move.w	#$6000,d2
		bsr.w	DrawBGScrollBlock1
		lea	(v_bg2_redraw_direction).w,a2
		lea	(v_bg2_x_pos).w,a3
		bra.w	DrawBGScrollBlock2
; ===========================================================================

; loc_DA5C: LoadTilesAsYouMove:
DrawTilesWhenMoving:
		lea	(vdp_control_port).l,a5
		lea	(vdp_data_port).l,a6
		lea	(v_bg1_redraw_direction_copy).w,a2
		lea	(v_bg1_x_pos_copy).w,a3
		lea	(v_level_layout+level_max_width).w,a4
		move.w	#$6000,d2
		bsr.w	DrawBGScrollBlock1

		lea	(v_bg2_redraw_direction_copy).w,a2
		lea	(v_bg2_x_pos_copy).w,a3
		bsr.w	DrawBGScrollBlock2

		lea	(v_bg3_redraw_direction_copy).w,a2
		lea	(v_bg3_x_pos_copy).w,a3
		bsr.w	DrawBGScrollBlock3

		tst.w	(f_two_player).w
		beq.s	loc_DAAE
		lea	(v_fg_redraw_direction_p2_copy).w,a2
		lea	(v_camera_pos_p2_copy).w,a3
		lea	(v_level_layout).w,a4
		move.w	#$6000,d2
		bsr.w	DrawFG_P2

loc_DAAE:
		lea	(v_fg_redraw_direction_copy).w,a2
		lea	(v_camera_x_pos_copy).w,a3
		lea	(v_level_layout).w,a4
		move.w	#$4000,d2
		tst.b	(f_screen_redraw).w
		beq.s	DrawFG
		move.b	#0,(f_screen_redraw).w
		moveq	#-$10,d4
		moveq	#$F,d6

loc_DACE:
		movem.l	d4-d6,-(sp)
		moveq	#-$10,d5
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos_P1
		move.w	d1,d4
		moveq	#-$10,d5
		bsr.w	DrawRow
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,loc_DACE
		move.b	#0,(v_fg_redraw_direction_copy).w
		rts
; ===========================================================================

DrawFG:
		tst.b	(a2)
		beq.s	locret_DB5A
		bclr	#0,(a2)
		beq.s	loc_DB10
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawRow

loc_DB10:
		bclr	#1,(a2)
		beq.s	loc_DB2A
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	DrawRow

loc_DB2A:
		bclr	#2,(a2)
		beq.s	loc_DB40
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawColumn

loc_DB40:
		bclr	#3,(a2)
		beq.s	locret_DB5A
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	DrawColumn

locret_DB5A:
		rts

; ===========================================================================


DrawFG_P2:
		tst.b	(a2)
		beq.s	locret_DBC0
		bclr	#0,(a2)
		beq.s	loc_DB76
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P2
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawRow

loc_DB76:
		bclr	#1,(a2)
		beq.s	loc_DB90
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P2
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	DrawRow

loc_DB90:
		bclr	#2,(a2)
		beq.s	loc_DBA6
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P2
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawColumn

loc_DBA6:
		bclr	#3,(a2)
		beq.s	locret_DBC0
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos_P2
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	DrawColumn

locret_DBC0:
		rts

; ===========================================================================


DrawBGScrollBlock1:
		tst.b	(a2)
		beq.w	locret_DC90
		bclr	#0,(a2)
		beq.s	loc_DBDE
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawRow

loc_DBDE:
		bclr	#1,(a2)
		beq.s	loc_DBF8
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	DrawRow

loc_DBF8:
		bclr	#2,(a2)
		beq.s	loc_DC0E
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	DrawColumn

loc_DC0E:
		bclr	#3,(a2)
		beq.s	loc_DC28
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		move.w	#$140,d5
		bsr.w	DrawColumn

loc_DC28:
		bclr	#4,(a2)
		beq.s	loc_DC40
		moveq	#-$10,d4
		moveq	#0,d5
		bsr.w	Calc_VRAM_Pos_P1_AbsX
		moveq	#-$10,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth_AbsX

loc_DC40:
		bclr	#5,(a2)
		beq.s	loc_DC5C
		move.w	#$E0,d4
		moveq	#0,d5
		bsr.w	Calc_VRAM_Pos_P1_AbsX
		move.w	#$E0,d4
		moveq	#0,d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth_AbsX

loc_DC5C:
		bclr	#6,(a2)
		beq.s	loc_DC74
		moveq	#-$10,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		moveq	#-$10,d4
		moveq	#-$10,d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth

loc_DC74:
		bclr	#7,(a2)
		beq.s	locret_DC90
		move.w	#$E0,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$E0,d4
		moveq	#-$10,d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth

locret_DC90:
		rts

; ===========================================================================


DrawBGScrollBlock2:
		tst.b	(a2)
		beq.w	locret_DCD4

; Unused Sonic 1 leftover: used by Green Hill and Spring Yard Zones.
		bclr	#0,(a2)
		beq.s	loc_DCB4
		move.w	#$70,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$70,d4
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	DrawColumn_Partial

	loc_DCB4:
		bclr	#1,(a2)
		beq.s	locret_DCD4
		move.w	#$70,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$70,d4
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	DrawColumn_Partial

locret_DCD4:
		rts

; ===========================================================================
; Unused Sonic 1 leftover - Scrap Brain Zone 1 block positioning array

byte_DCD6:
		dc.b   0					; 0
byte_DCD7:
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b   0					; 2
		dc.b   0					; 3
		dc.b   6					; 4
		dc.b   6					; 5
		dc.b   6					; 6
		dc.b   6					; 7
		dc.b   6					; 8
		dc.b   6					; 9
		dc.b   6					; 10
		dc.b   6					; 11
		dc.b   6					; 12
		dc.b   6					; 13
		dc.b   4					; 14
		dc.b   4					; 15
		dc.b   4					; 16
		dc.b   4					; 17
		dc.b   4					; 18
		dc.b   4					; 19
		dc.b   4					; 20
		dc.b   2					; 21
		dc.b   2					; 22
		dc.b   2					; 23
		dc.b   2					; 24
		dc.b   2					; 25
		dc.b   2					; 26
		dc.b   2					; 27
		dc.b   2					; 28
		dc.b   2					; 29
		dc.b   2					; 30
		dc.b   2					; 31
		dc.b   0					; 32
; ===========================================================================
; Unused Sonic 1 leftover: SBZ1 background drawer

;DrawBGScrollBlock2_SBZ:
		moveq	#-$10,d4
		bclr	#0,(a2)
		bne.s	loc_DD0A
		bclr	#1,(a2)
		beq.s	loc_DD52
		move.w	#$E0,d4

loc_DD0A:
		lea_	byte_DCD7,a0
		move.w	(v_bg1_y_pos).w,d0
		add.w	d4,d0
		andi.w	#$1F0,d0
		lsr.w	#4,d0
		move.b	(a0,d0.w),d0
		lea	(word_DE7E).l,a3
		movea.w	(a3,d0.w),a3
		beq.s	loc_DD3E
		moveq	#-$10,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos_P1
		movem.l	(sp)+,d4-d5
		bsr.w	DrawRow
		bra.s	loc_DD52
; ===========================================================================

loc_DD3E:
		moveq	#0,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos_P1_AbsX
		movem.l	(sp)+,d4-d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth_AbsX

loc_DD52:
		tst.b	(a2)
		bne.s	loc_DD58
		rts
; ===========================================================================

loc_DD58:
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.b	(a2),d0
		andi.b	#-$58,d0
		beq.s	loc_DD6C
		lsr.b	#1,d0
		move.b	d0,(a2)
		move.w	#$140,d5

loc_DD6C:
		lea_	byte_DCD6,a0
		move.w	(v_bg1_y_pos).w,d0
		andi.w	#$1F0,d0
		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		bra.w	loc_DE86

; ===========================================================================


DrawBGScrollBlock3:
		tst.b	(a2)
		beq.w	locret_DDCE
		cmpi.b	#id_CPZ,(v_zone).w
		beq.w	loc_DE12
		bclr	#0,(a2)
		beq.s	loc_DDAE
		move.w	#$40,d4
		moveq	#-$10,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$40,d4
		moveq	#-$10,d5
		moveq	#2,d6
		bsr.w	DrawColumn_Partial

loc_DDAE:
		bclr	#1,(a2)
		beq.s	locret_DDCE
		move.w	#$40,d4
		move.w	#$140,d5
		bsr.w	Calc_VRAM_Pos_P1
		move.w	#$40,d4
		move.w	#$140,d5
		moveq	#2,d6
		bsr.w	DrawColumn_Partial

locret_DDCE:
		rts
; ===========================================================================
byte_DDD0:	dc.b 2
byte_DDD1:	dc.b   2					; 0

		dc.b   2					; 1
		dc.b   2					; 2
		dc.b   2					; 3
		dc.b   2					; 4
		dc.b   2					; 5
		dc.b   2					; 6
		dc.b   2					; 7
		dc.b   2					; 8
		dc.b   2					; 9
		dc.b   2					; 10
		dc.b   2					; 11
		dc.b   2					; 12
		dc.b   2					; 13
		dc.b   2					; 14
		dc.b   2					; 15
		dc.b   2					; 16
		dc.b   2					; 17
		dc.b   2					; 18
		dc.b   4					; 19
		dc.b   4					; 20
		dc.b   4					; 21
		dc.b   4					; 22
		dc.b   4					; 23
		dc.b   4					; 24
		dc.b   4					; 25
		dc.b   4					; 26
		dc.b   4					; 27
		dc.b   4					; 28
		dc.b   4					; 29
		dc.b   4					; 30
		dc.b   4					; 31
		dc.b   4					; 32
		dc.b   4					; 33
		dc.b   4					; 34
		dc.b   4					; 35
		dc.b   4					; 36
		dc.b   4					; 37
		dc.b   4					; 38
		dc.b   4					; 39
		dc.b   4					; 40
		dc.b   4					; 41
		dc.b   4					; 42
		dc.b   4					; 43
		dc.b   4					; 44
		dc.b   4					; 0
		dc.b   4					; 1
		dc.b   4					; 2
		dc.b   4					; 3
		dc.b   4					; 4
		dc.b   4					; 5
		dc.b   4					; 6
		dc.b   4					; 7
		dc.b   4					; 8
		dc.b   4					; 9
		dc.b   4					; 10
		dc.b   4					; 11
		dc.b   4					; 12
		dc.b   4					; 13
		dc.b   4					; 14
		dc.b   4					; 15
		dc.b   4					; 16
		dc.b   4					; 17
		dc.b   4					; 18
		dc.b   0					; 19
; ===========================================================================

loc_DE12:
		moveq	#-$10,d4
		bclr	#0,(a2)
		bne.s	loc_DE24
		bclr	#1,(a2)
		beq.s	loc_DE4E
		move.w	#$E0,d4

loc_DE24:
		lea_	byte_DDD1,a0
		move.w	(v_bg1_y_pos).w,d0
		add.w	d4,d0
		andi.w	#$3F0,d0
		lsr.w	#4,d0
		move.b	(a0,d0.w),d0
		movea.w	word_DE7E(pc,d0.w),a3
		moveq	#-$10,d5
		movem.l	d4-d5,-(sp)
		bsr.w	Calc_VRAM_Pos_P1
		movem.l	(sp)+,d4-d5
		bsr.w	DrawRow

loc_DE4E:
		tst.b	(a2)
		bne.s	loc_DE54
		rts
; ===========================================================================

loc_DE54:
		moveq	#-$10,d4
		moveq	#-$10,d5
		move.b	(a2),d0
		andi.b	#-$58,d0
		beq.s	loc_DE68
		lsr.b	#1,d0
		move.b	d0,(a2)
		move.w	#$140,d5

loc_DE68:
		lea_	byte_DDD0,a0
		move.w	(v_bg1_y_pos).w,d0

    if FixBugs
   		; After right-shifting, the is a mask of $3F. Since CPZ_CameraSections is $40 items
   		; long, this is correct.
		andi.w	#$3F0,d
    else
		; After right-shifting, the is a mask of $7F. Since CPZ_CameraSections
		; is $40 items long, this is incorrect, and will cause accesses to
		; exceed the bounds of CPZ_CameraSections and read invalid data. This
		; is most notably a problem in Marble Zone's version of this code.
		andi.w	#$7F0,d0
    endc

		lsr.w	#4,d0
		lea	(a0,d0.w),a0
		bra.w	loc_DE86
; ===========================================================================
word_DE7E:	dc.w $EE68					; 0
		dc.w $EE68					; 1
		dc.w $EE70					; 2
		dc.w $EE78					; 3
; ===========================================================================

loc_DE86:
		tst.w	(f_two_player).w
		bne.s	loc_DEC8
		moveq	#$F,d6
		move.l	#$800000,d7

loc_DE94:
		moveq	#0,d0
		move.b	(a0)+,d0
		btst	d0,(a2)
		beq.s	loc_DEBC
		movea.w	word_DE7E(pc,d0.w),a3
		movem.l	d4-d5/a0,-(sp)
		movem.l	d4-d5,-(sp)
		bsr.w	GetBlockData
		movem.l	(sp)+,d4-d5
		bsr.w	Calc_VRAM_Pos_P1
		bsr.w	DrawBlock_Vertical
		movem.l	(sp)+,d4-d5/a0

loc_DEBC:
		addi.w	#$10,d4
		dbf	d6,loc_DE94
		clr.b	(a2)
		rts
; ===========================================================================

loc_DEC8:
		moveq	#$F,d6
		move.l	#$800000,d7

loc_DED0:
		moveq	#0,d0
		move.b	(a0)+,d0
		btst	d0,(a2)
		beq.s	loc_DEF8
		movea.w	word_DE7E(pc,d0.w),a3
		movem.l	d4-d5/a0,-(sp)
		movem.l	d4-d5,-(sp)
		bsr.w	GetBlockData
		movem.l	(sp)+,d4-d5
		bsr.w	Calc_VRAM_Pos_P1
		bsr.w	sub_E1FA
		movem.l	(sp)+,d4-d5/a0

loc_DEF8:
		addi.w	#$10,d4

loc_DEFC:
		dbf	d6,loc_DED0
		clr.b	(a2)
		rts


; ===========================================================================

;DrawBlockColumn:
DrawColumn:
		moveq	#((screen_height+16+16)/16)-1,d6
DrawColumn_Partial:
		add.w	(a3),d5
		add.w	4(a3),d4
		move.l	#$800000,d7
		move.l	d0,d1
		bsr.w	sub_E09E
		tst.w	(f_two_player).w
		bne.s	loc_DF54

loc_DF1E:
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		lea	(v_16x16_tiles).w,a1
		adda.w	d3,a1
		move.l	d1,d0
		bsr.w	DrawBlock_Vertical
		adda.w	#$10,a0
		addi.w	#$100,d1
		andi.w	#$FFF,d1
		addi.w	#$10,d4
		move.w	d4,d0
		andi.w	#$70,d0
		bne.s	.notnew128
		bsr.w	sub_E09E

	.notnew128:
		dbf	d6,loc_DF1E
		rts
; ===========================================================================

loc_DF54:
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		lea	(v_16x16_tiles).w,a1
		adda.w	d3,a1
		move.l	d1,d0
		bsr.w	sub_E1FA
		adda.w	#$10,a0
		addi.w	#$80,d1
		andi.w	#$FFF,d1
		addi.w	#$10,d4
		move.w	d4,d0
		andi.w	#$70,d0
		bne.s	loc_DF84
		bsr.w	sub_E09E

loc_DF84:
		dbf	d6,loc_DF54
		rts

; ===========================================================================


DrawRow_CustomWidth:
		add.w	(a3),d5
		add.w	4(a3),d4
		bra.s	DrawRow_CustomWidth_AbsX_AbsY

; ===========================================================================


DrawRow:
		moveq	#((screen_width+16+16)/16)-1,d6		; draw the entire width of the screen + two extra columns
		add.w	(a3),d5

DrawRow_CustomWidth_AbsX:
		add.w	4(a3),d4

DrawRow_CustomWidth_AbsX_AbsY:
		tst.w	(f_two_player).w
		bne.s	loc_E018
		move.l	a2,-(sp)
		move.w	d6,-(sp)
		lea	(v_block_cache).w,a2
		move.l	d0,d1
		or.w	d2,d1
		swap	d1
		move.l	d1,-(sp)
		move.l	d1,(a5)
		swap	d1
		bsr.w	sub_E09E

loc_DFB8:
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		lea	(v_16x16_tiles).w,a1
		adda.w	d3,a1
		bsr.w	DrawBlock_Horizontal
		addq.w	#2,a0
		addq.b	#4,d1
		bpl.s	loc_DFDA
		andi.b	#$7F,d1
		swap	d1
		move.l	d1,(a5)
		swap	d1

loc_DFDA:
		addi.w	#$10,d5
		move.w	d5,d0
		andi.w	#$70,d0
		bne.s	loc_DFEA
		bsr.w	sub_E09E

loc_DFEA:
		dbf	d6,loc_DFB8
		move.l	(sp)+,d1
		addi.l	#$800000,d1
		lea	(v_block_cache).w,a2
		move.l	d1,(a5)
		swap	d1
		move.w	(sp)+,d6

loc_E000:
		move.l	(a2)+,(a6)
		addq.b	#4,d1
		bmi.s	loc_E010
		ori.b	#-$80,d1
		swap	d1
		move.l	d1,(a5)
		swap	d1

loc_E010:
		dbf	d6,loc_E000
		movea.l	(sp)+,a2
		rts
; ===========================================================================

loc_E018:
		move.l	d0,d1
		or.w	d2,d1
		swap	d1
		move.l	d1,(a5)
		swap	d1
		tst.b	d1
		bmi.s	loc_E062
		bsr.w	sub_E09E

loc_E02A:
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		lea	(v_16x16_tiles).w,a1
		adda.w	d3,a1
		bsr.w	sub_E136
		addq.w	#2,a0
		addq.b	#4,d1
		bpl.s	loc_E04C
		andi.b	#$7F,d1
		swap	d1
		move.l	d1,(a5)
		swap	d1

loc_E04C:
		addi.w	#$10,d5
		move.w	d5,d0
		andi.w	#$70,d0
		bne.s	loc_E05C
		bsr.w	sub_E09E

loc_E05C:
		dbf	d6,loc_E02A
		rts
; ===========================================================================

loc_E062:
		bsr.w	sub_E09E

loc_E066:
		move.w	(a0),d3
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		lea	(v_16x16_tiles).w,a1
		adda.w	d3,a1
		bsr.w	sub_E136
		addq.w	#2,a0
		addq.b	#4,d1
		bmi.s	loc_E088
		ori.b	#-$80,d1
		swap	d1
		move.l	d1,(a5)
		swap	d1

loc_E088:
		addi.w	#$10,d5
		move.w	d5,d0
		andi.w	#$70,d0
		bne.s	loc_E098
		bsr.w	sub_E09E

loc_E098:
		dbf	d6,loc_E066
		rts


; ===========================================================================

sub_E09E:
		movem.l	d4-d5,-(sp)
		move.w	d4,d3
		add.w	d3,d3
		andi.w	#$F00,d3
		lsr.w	#3,d5
		move.w	d5,d0
		lsr.w	#4,d0
		andi.w	#$7F,d0
		add.w	d3,d0
		moveq	#-1,d3
		clr.w	d3
		move.b	(a4,d0.w),d3
		lsl.w	#7,d3
		andi.w	#$70,d4
		andi.w	#$E,d5
		add.w	d4,d3
		add.w	d5,d3
		movea.l	d3,a0
		movem.l	(sp)+,d4-d5
		rts


; ===========================================================================

;ProcessAndWriteBlock_Horizontal:
DrawBlock_Horizontal:
		btst	#3,(a0)
		bne.s	loc_E100
		btst	#2,(a0)
		bne.s	loc_E0E6
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a2)+
		rts
; ===========================================================================

loc_E0E6:
		move.l	(a1)+,d3
		eori.l	#$8000800,d3
		swap	d3
		move.l	d3,(a6)
		move.l	(a1)+,d3
		eori.l	#$8000800,d3
		swap	d3
		move.l	d3,(a2)+
		rts
; ===========================================================================

loc_E100:
		btst	#2,(a0)
		bne.s	loc_E11C
		move.l	(a1)+,d0
		move.l	(a1)+,d3
		eori.l	#$10001000,d3
		move.l	d3,(a6)
		eori.l	#$10001000,d0
		move.l	d0,(a2)+
		rts
; ===========================================================================

loc_E11C:
		move.l	(a1)+,d0
		move.l	(a1)+,d3
		eori.l	#$18001800,d3
		swap	d3
		move.l	d3,(a6)
		eori.l	#$18001800,d0
		swap	d0
		move.l	d0,(a2)+
		rts


; ===========================================================================


sub_E136:
		btst	#3,(a0)
		bne.s	loc_E154
		btst	#2,(a0)
		bne.s	loc_E146
		move.l	(a1)+,(a6)
		rts
; ===========================================================================

loc_E146:
		move.l	(a1)+,d3
		eori.l	#$8000800,d3
		swap	d3
		move.l	d3,(a6)
		rts
; ===========================================================================

loc_E154:
		btst	#2,(a0)
		bne.s	loc_E166
		move.l	(a1)+,d3
		eori.l	#$10001000,d3
		move.l	d3,(a6)
		rts
; ===========================================================================

loc_E166:
		move.l	(a1)+,d3
		eori.l	#$18001800,d3
		swap	d3
		move.l	d3,(a6)
		rts


; ===========================================================================

; ProcessAndWriteBlock_Vertical:
DrawBlock_Vertical:
		or.w	d2,d0
		swap	d0
		btst	#3,(a0)
		bne.s	loc_E1B0
		btst	#2,(a0)
		bne.s	loc_E190
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		rts
; ===========================================================================

loc_E190:
		move.l	d0,(a5)
		move.l	(a1)+,d3
		eori.l	#$8000800,d3
		swap	d3
		move.l	d3,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		move.l	(a1)+,d3
		eori.l	#$8000800,d3
		swap	d3
		move.l	d3,(a6)
		rts
; ===========================================================================

loc_E1B0:
		btst	#2,(a0)
		bne.s	loc_E1D6
		move.l	d5,-(sp)
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d3
		eori.l	#$10001000,d3
		move.l	d3,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$10001000,d5
		move.l	d5,(a6)
		move.l	(sp)+,d5
		rts
; ===========================================================================

loc_E1D6:
		move.l	d5,-(sp)
		move.l	d0,(a5)
		move.l	(a1)+,d5
		move.l	(a1)+,d3
		eori.l	#$18001800,d3
		swap	d3
		move.l	d3,(a6)
		add.l	d7,d0
		move.l	d0,(a5)
		eori.l	#$18001800,d5
		swap	d5
		move.l	d5,(a6)
		move.l	(sp)+,d5
		rts


; ===========================================================================


sub_E1FA:
		or.w	d2,d0
		swap	d0
		btst	#3,(a0)
		bne.s	loc_E220
		btst	#2,(a0)
		bne.s	loc_E210
		move.l	d0,(a5)
		move.l	(a1)+,(a6)
		rts
; ===========================================================================

loc_E210:
		move.l	d0,(a5)
		move.l	(a1)+,d3
		eori.l	#$8000800,d3
		swap	d3
		move.l	d3,(a6)
		rts
; ===========================================================================

loc_E220:
		btst	#2,(a0)
		bne.s	loc_E234
		move.l	d0,(a5)
		move.l	(a1)+,d3
		eori.l	#$10001000,d3
		move.l	d3,(a6)
		rts
; ===========================================================================

loc_E234:
		move.l	d0,(a5)
		move.l	(a1)+,d3
		eori.l	#$18001800,d3
		swap	d3
		move.l	d3,(a6)
		rts


; ---------------------------------------------------------------------------
; Subroutine to get the address of a 16x16 tile at a screen coordinate

; input:
;	d4.w = y coordinate
;	d5.w = x coordinate
;	(a3).w = camera/bg x position
;	4(a3).w = camera/bg y position
;	a4 = address of level/bg layout
;	a5 = vdp_control_port
;	a6 = vdp_data_port

; output:
;	a0 = address of 16x16 tile id and x/y flip metadata from 256x256 mappings
;	a1 = address of 16x16 tile mappings

;	uses d0.w, d3.l, d4.w, d5.w
; ---------------------------------------------------------------------------

GetBlockData:
		add.w	(a3),d5					; add camera x pos to relative coordinate
		add.w	v_camera_y_pos_copy-v_camera_x_pos_copy(a3),d4 ; add camera y pos to relative coordinate
		lea	(v_16x16_tiles).w,a1

		; Turn y coordinate into index into level layout
		move.w	d4,d3
		add.w	d3,d3					; multiply by 2 (because layout alternates between level and bg lines)
		andi.w	#$F00,d3				; read only low nybble of high byte (because each level chunk is 1286px tall)
		; Turn x coordinate into index into level layout
		lsr.w	#3,d5					; divide by 8
		move.w	d5,d0
		lsr.w	#4,d0					; divide by 16 (overall division by 128)
		andi.w	#$7F,d0					; read only high byte of x pos
		; Get 128x128 tile id from level layout
		add.w	d3,d0					; combine for position within layout
		moveq	#-1,d3
		clr.w	d3					; d3 = $FFFF0000 (used to make a RAM address)
		move.b	(a4,d0.w),d3				; d3 = $FFFF0000 + 128x128 tile id
		lsl.w	#7,d3					; multiply by 128 (sizeof_128x128)
		; Turn y coordinate into position within 256x256 tile
		andi.w	#$70,d4					; round y offset to nearest pixel boundary
		; Turn x coordinate into position within 256x256 tile
		andi.w	#$E,d5					; round x offset to multiple of 16
		add.w	d4,d3
		add.w	d5,d3
		movea.l	d3,a0					; a0 = address of 16x16 tile id and metadata within 128x128 mappings
		move.w	(a0),d3					; copy 16x16 tile id to d3
		; Turn 16x16 tile id into tile mappings address
		andi.w	#$3FF,d3
		lsl.w	#3,d3
		adda.w	d3,a1					; a1 = address of 16x16 tile mappings
		rts

; ---------------------------------------------------------------------------
; Subroutine to	convert screen relative coordinates to VDP command for VRAM
; fg/bg nametable access

; input:
;	d4.w = y coordinate
;	d5.w = x coordinate
;	(a3).w = camera x position (Calc_VRAM_Pos_P1 only)
;	4(a3).w = camera y position (Calc_VRAM_Pos_P1 & Calc_VRAM_Pos_P1_AbsX only)

; output:
;	d0.l = VDP command (word swapped)

;	uses d4.w, d5.w
; ---------------------------------------------------------------------------

Calc_VRAM_Pos_P1:
		add.w	(a3),d5					; add camera x pos

Calc_VRAM_Pos_P1_AbsX:
		tst.w	(f_two_player).w			; is it two-player mode?
		bne.s	Calc_VRAM_Pos_P1_AbsX_DoubleResolution	; if so, use the double resolution branch
		add.w	v_bg1_y_pos-v_bg1_x_pos(a3),d4		; add camera y pos

Calc_VRAM_Pos_P1_AbsX_AbsY:
		andi.w	#$F0,d4					; round down to 16 (size of block) and limit to $100 (height of plane, 32*8)
		andi.w	#$1F0,d5				; round down to 16 (size of block) and limit to $200 (width of plane, 64*8)
		; Transform the adjusted coordinates into a VDP command
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#draw_base>>14,d0			; bits 15 & 14 of VRAM address ($C000)
		swap	d0					; swap high/low words (swapped back later by DrawBlock)
		move.w	d4,d0					; add offset for coordinate in fg/bg nametable
		rts
; ===========================================================================

Calc_VRAM_Pos_P1_AbsX_DoubleResolution:
		add.w	v_bg1_y_pos-v_bg1_x_pos(a3),d4		; add camera y pos

Calc_VRAM_Pos_P1_AbsX_AbsY_DoubleResolution:
		andi.w	#$1F0,d4				; round down to 16 (size of block) and limit to $200 (height of plane, 64*8)
		andi.w	#$1F0,d5				; round down to 16 (size of block) and limit to $200 (width of plane, 64*8)
		; Transform the adjusted coordinates into a VDP command
		lsl.w	#3,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#draw_base>>14,d0			; bits 15 & 14 of VRAM address ($C000)
		swap	d0					; swap high/low words (swapped back later by DrawBlock)
		move.w	d4,d0					; add offset for coordinate in fg/bg nametable
		rts

; ---------------------------------------------------------------------------
; As above,except the base address for the fg/bg nametable is $A000 instead
; of $C000. .regular_resolution is unused; .double_resolution is used by
; player 2's half of screen in 2p mode.

; input:
;	d4.w = y coordinate
;	d5.w = x coordinate
;	(a3).w = camera x position
;	4(a3).w = camera y position

; output:
;	d0.l = VDP command (word swapped)

;	uses d4.w, d5.w
; ---------------------------------------------------------------------------

Calc_VRAM_Pos_P2:
		tst.w	(f_two_player).w			; is it 2p mode?
		bne.s	.double_resolution			; branch if so (it always will be)

	;.regular_resolution:
		; Unused.
		add.w	v_bg1_y_pos_p2-v_bg1_x_pos_p2(a3),d4	; add camera y pos
		add.w	(a3),d5					; add camera x pos
		andi.w	#$F0,d4					; round down to 16 (size of block) and limit to $100 (height of plane, 32*8)
		andi.w	#$1F0,d5				; round down to 16 (size of block) and limit to $200 (width of plane, 64*8)
		; Transform the adjusted coordinates into a VDP command
		lsl.w	#4,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#draw_base_2p>>14,d0			; bits 15 & 14 of VRAM address ($C000)
		swap	d0					; swap high/low words (swapped back later by DrawBlock)
		move.w	d4,d0					; add offset for coordinate in fg/bg nametable
		rts
; ===========================================================================

	.double_resolution:
		add.w	v_bg1_y_pos_p2-v_bg1_x_pos_p2(a3),d4	; add camera y pos
		add.w	(a3),d5					; add camera x pos
		andi.w	#$1F0,d4				; round down to 16 (size of block) and limit to $200 (height of plane, 32*8)
		andi.w	#$1F0,d5				; round down to 16 (size of block) and limit to $200 (width of plane, 64*8)
		; Transform the adjusted coordinates into a VDP command
		lsl.w	#3,d4
		lsr.w	#2,d5
		add.w	d5,d4
		moveq	#draw_base_2p>>14,d0			; bits 15 & 14 of VRAM address ($C000)
		swap	d0					; swap high/low words (swapped back later by DrawBlock)
		move.w	d4,d0					; add offset for coordinate in fg/bg nametable
		rts

; ---------------------------------------------------------------------------
; Subroutine to	load tiles as soon as the level	appears

; output:
;	a5 = vdp_control_port
;	a6 = vdp_data_port
; ---------------------------------------------------------------------------

DrawTilesAtStart:
		lea	(vdp_control_port).l,a5
		lea	(vdp_data_port).l,a6			; could be 'lea vdp_data_port-vdp_control_port(a5),a6'
		lea	(v_bg1_x_pos).w,a3
		lea	(v_level_layout+level_max_width).w,a4
		vdp_comm.w	move,vram_bg,vram,write,d2,>>16

	if FixBugs
		; The purpose of this function is to dynamically load a portion of
		; the background, based on where the BG camera is pointing. This
		; makes plenty of sense for levels that dynamically load their
		; background to Plane B. However, not all levels do this: some
		; (namely, EHZ, CNZ, and HTZ) are content with just loading their entire
		; (small) background to Plane B and leaving it there, untouched.
		; Unfortunately, that does not mesh well with this function: if the
		; camera is too high or too low, then only part of the background
		; will be properly loaded. This bug most visibly manifests itself in
		; Casino Night Zone Act 1, where the background abruptly cuts off at
		; the bottom.
		; To work around this, an ugly hack was added, to cause the function
		; to load a portion of the background 16 pixels lower than normal.
		; However, this hack applies to both Act 1 AND Act 2, resulting in
		; Act 2's background being cut off at the top.
		; Sonic 3 & Knuckles fixed this problem for good by giving each zone
		; its own background initialisation function (see 'LevelSetup' in the
		; Sonic & Knuckles Git disassembly). This fix by Clownancy doesn't go quite that far,
		; but it does give these 'static' backgrounds their own
		; initialisation logic, much like two player Mystic Cave Zone 2P does.
		move.b	(v_zone).w,d0
		cmpi.b	#id_EHZ,d0
		beq.w	DrawInitialBG_LoadWholeBackground_512x256
		cmpi.b	#id_CNZ,d0
		beq.w	DrawInitialBG_LoadWholeBackground_512x256
		cmpi.b	#id_HTZ,d0
		beq.w	DrawInitialBG_LoadWholeBackground_512x256
	else
		; This is a nasty hack to work around the bug described above.
		moveq	#0,d4
		cmpi.b	#id_CNZ,(v_zone).w			; is it CNZ?
		beq.w	DrawChunks_CustomY			; if so, branch (skipping the 'moveq #-16,d4')
	endc
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.w	DrawChunks				; if not, branch
		cmpi.b	#id_MCZ,(v_zone).w			; is it MCZ 2P?
		beq.w	DrawTilesAtStart_LoadFull_512x512	; if so, branch
		; else run directly into DrawChunks

; ---------------------------------------------------------------------------
; Subroutine to draw 16x16 tiles on whole screen

; input:
;	d2 = VRAM write command ($4000) + nametable start address relative to vram_fg
;	(a3) = camera/bg x position
;	4(a3) = camera/bg y position
;	a4 = address of level/bg layout
;	a5 = vdp_control_port
;	a6 = vdp_data_port
; ---------------------------------------------------------------------------

DrawChunks:
		moveq	#-16,d4					; draw from 16px (1 16x16 block row) above top of screen (skipped by CNZ)

DrawChunks_CustomY:
		moveq	#(256/16)-1,d6				; draw entire height of screen; height of plane in blocks minus 1

	.loop:
		pushr.l	d4-d6
		moveq	#0,d5					; draw from left edge of screen
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos_P1
		move.w	d1,d4
		moveq	#0,d5
		moveq	#(512/16)-1,d6				; draw full row; width of plane in blocks minus 1
		disable_ints
		bsr.w	DrawRow_CustomWidth
		enable_ints
		popr.l	d4-d6
		addi.w	#16,d4					; next row
		dbf	d6,.loop
		rts

; ---------------------------------------------------------------------------
; Unused subroutine to initialize player 2's portion of the background plane
; ---------------------------------------------------------------------------

		moveq	#-16,d4
		moveq	#(256/16)-1,d6				; draw entire height of screen; height of plane in blocks minus 1

	.loop2:
		pushr.l	d4-d6
		moveq	#0,d5					; draw from left edge of screen
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos_P2
		move.w	d1,d4
		moveq	#0,d5
		moveq	#(512/16)-1,d6				; draw full row; width of plane in blocks minus 1
		disable_ints
		bsr.w	DrawRow_CustomWidth
		enable_ints
		popr.l	d4-d6
		addi.w	#16,d4					; next row
		dbf	d6,.loop2
		rts

; ---------------------------------------------------------------------------
; Subroutine to load a static 512x512 background plane
; Used only by MCZ 2P.
; ---------------------------------------------------------------------------

DrawTilesAtStart_LoadFull_512x512:
		moveq	#0,d4					; absolute y plane coordinate
		moveq	#(512/16)-1,d6				; draw entire height of screen; height of plane in blocks minus 1

	.loop:
		pushr.l	d4-d6
		moveq	#0,d5					; draw from left edge of screen
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos_P1_AbsX_AbsY_DoubleResolution
		move.w	d1,d4
		moveq	#0,d5
		moveq	#(512/16)-1,d6				; draw full row; width of plane in blocks minus 1
		disable_ints
		bsr.w	DrawRow_CustomWidth_AbsX_AbsY
		enable_ints
		popr.l	d4-d6
		addi.w	#16,d4					; next row
		dbf	d6,.loop
		rts

; ---------------------------------------------------------------------------
; Subroutine to load a static 512x256 background plane
; Written by Clownacy to fix the bug described in DrawTilesAtStart;
; used by EHZ, CNZ, and HTZ.
; ---------------------------------------------------------------------------

	if FixBugs
DrawTilesAtStart_LoadFull_512x256:
		moveq	#0,d4					; absolute y plane coordinate
		moveq	#(256/16)-1,d6				; draw entire height of screen; height of plane in blocks minus 1

	.loop:
		pushr.l	d4-d6
		moveq	#0,d5					; draw from left edge of screen
		move.w	d4,d1
		pea	.drawrow(pc)				; push return address so we can do an 'if true then call this, else call that'
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.w	Calc_VRAM_Pos_P1_AbsX_AbsY		; branch if not
		bra.w	Calc_VRAM_Pos_P1_AbsX_AbsY_DoubleResolution ; if 2P mode, use double resolution version of function

	.drawrow:
		move.w	d1,d4
		moveq	#0,d5
		moveq	#(512/16)-1,d6				; draw full row; width of plane in blocks minus 1
		disable_ints
		bsr.w	DrawRow_CustomWidth_AbsX_AbsY
		enable_ints
		popr.l	d4-d6
		addi.w	#16,d4					; next row
		dbf	d6,.loop
		rts
   	endc

; ===========================================================================

LevelBlockMapsLoad:
		moveq	#0,d0
		move.b	(v_zone).w,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	(LevelHeaders).l,a2
		lea	(a2,d0.w),a2
		move.l	a2,-(sp)
		addq.w	#4,a2
		move.l	(a2)+,d0
		andi.l	#$FFFFFF,d0
		movea.l	d0,a0
		lea	(v_16x16_tiles).w,a1
		jsrto	KosDec,JmpTo_KosDec
		cmpi.b	#id_HTZ,(v_zone).w
		bne.s	loc_E40C
		lea	($FFFF9980).w,a1
		lea	(BM16_HTZ).l,a0
		jsrto	KosDec,JmpTo_KosDec

loc_E40C:
		tst.w	(f_two_player).w
		beq.s	loc_E430
		lea	(v_16x16_tiles).w,a1
		move.w	#$BFF,d2

loc_E41A:
		move.w	(a1),d0
		move.w	d0,d1
		andi.w	#-$800,d0
		andi.w	#$7FF,d1
		lsr.w	#1,d1
		or.w	d1,d0
		move.w	d0,(a1)+
		dbf	d2,loc_E41A

loc_E430:
		move.l	(a2)+,d0
		andi.l	#$FFFFFF,d0
		movea.l	d0,a0
		lea	(v_128x128_tiles).l,a1
		jsrto	KosDec,JmpTo_KosDec
		bsr.w	sub_E462
		movea.l	(sp)+,a2
		addq.w	#4,a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	loc_E456
		jsrto	AddPLC,JmpTo_AddPLC

loc_E456:
		addq.w	#4,a2
		moveq	#0,d0
		move.b	(a2),d0
		jsrto	PalLoad_Now,JmpTo_PalLoad_Now
		rts

; ===========================================================================


sub_E462:
		moveq	#0,d0
		move.w	(v_zone).w,d0
		ror.b	#1,d0
		lsr.w	#6,d0
		lea	(LevelIndex).l,a0
		move.w	(a0,d0.w),d0
		lea	(a0,d0.l),a0
		lea	(v_level_layout).w,a1
		jmpto	KosDec,JmpTo_KosDec

; ===========================================================================
		lea	(v_level_layout).w,a3
		move.w	#$3FF,d1
		moveq	#0,d0

loc_E48C:
		move.l	d0,(a3)+
		dbf	d1,loc_E48C
		lea	(v_level_layout).w,a3
		moveq	#0,d1
		bsr.w	sub_E4A2
		lea	($FFFF8080).w,a3
		moveq	#2,d1

; ===========================================================================


sub_E4A2:
		moveq	#0,d0
		move.w	(v_zone).w,d0
		ror.b	#1,d0
		lsr.w	#5,d0
		add.w	d1,d0
		lea	(LevelIndex).l,a1
		move.w	(a1,d0.w),d0
		lea	(a1,d0.l),a1
		moveq	#0,d1
		move.w	d1,d2
		move.b	(a1)+,d1
		move.b	(a1)+,d2
		move.l	d1,d5
		addq.l	#1,d5
		moveq	#0,d3
		move.w	#$80,d3
		divu.w	d5,d3
		subq.w	#1,d3

loc_E4D2:
		movea.l	a3,a0
		move.w	d3,d4

loc_E4D6:
		move.l	a1,-(sp)
		move.w	d1,d0

loc_E4DA:
		move.b	(a1)+,(a0)+
		dbf	d0,loc_E4DA
		movea.l	(sp)+,a1
		dbf	d4,loc_E4D6
		lea	(a1,d5.w),a1
		lea	$100(a3),a3
		dbf	d2,loc_E4D2
		rts

; ===========================================================================
		lea	($FE0000).l,a1
		lea	($FE0080).l,a2
		lea	(v_128x128_tiles).l,a3
		move.w	#$3F,d1

loc_E50A:
		bsr.w	sub_E59C
		bsr.w	sub_E59C
		dbf	d1,loc_E50A
		lea	($FE0000).l,a1
		lea	($FF0000).l,a2
		move.w	#$3F,d1

loc_E526:
		move.w	#0,(a2)+
		dbf	d1,loc_E526
		move.w	#$3FBF,d1

loc_E532:
		move.w	(a1)+,(a2)+
		dbf	d1,loc_E532
		rts
; ===========================================================================
		lea	($FE0000).l,a1
		lea	(v_128x128_tiles).l,a3
		moveq	#$1F,d0

loc_E548:
		move.l	(a1)+,(a3)+
		dbf	d0,loc_E548
		moveq	#0,d7
		lea	($FE0000).l,a1
		move.w	#$FF,d5

loc_E55A:
		lea	(v_128x128_tiles).l,a3
		move.w	d7,d6

loc_E562:
		movem.l	a1-a3,-(sp)
		move.w	#$3F,d0

loc_E56A:
		cmpm.w	(a1)+,(a3)+
		bne.s	loc_E580
		dbf	d0,loc_E56A
		movem.l	(sp)+,a1-a3
		adda.w	#$80,a1
		dbf	d5,loc_E55A
		bra.s	loc_E59A
; ===========================================================================

loc_E580:
		movem.l	(sp)+,a1-a3
		adda.w	#$80,a3
		dbf	d6,loc_E562
		moveq	#$1F,d0

loc_E58E:
		move.l	(a1)+,(a3)+
		dbf	d0,loc_E58E
		addq.l	#1,d7
		dbf	d5,loc_E55A

loc_E59A:
		bra.s	loc_E59A

; ===========================================================================


sub_E59C:
		moveq	#7,d0

loc_E59E:
		rept 4
		move.l	(a3)+,(a1)+
		endr
		rept 4
		move.l	(a3)+,(a2)+
		endr
		dbf	d0,loc_E59E
		adda.w	#$80,a1
		adda.w	#$80,a2
		rts

; ===========================================================================

	if Revision=0
		nop
	endc


	if RemoveJmpTos=0
JmpTo_PalLoad_Now:
		jmp	(PalLoad_Now).l
JmpTo_AddPLC:
		jmp	(AddPLC).l
JmpTo_KosDec:
		jmp	(KosDec).l

		align 4
	endc

; ===========================================================================


DynamicLevelEvents:
		moveq	#0,d0
		move.b	(v_zone).w,d0
		add.w	d0,d0
		move.w	DLE_Index(pc,d0.w),d0
		jsr	DLE_Index(pc,d0.w)
		moveq	#2,d1
		move.w	(v_boundary_bottom_next).w,d0
		sub.w	(v_boundary_bottom).w,d0
		beq.s	locret_E60E
		bcc.s	loc_E610
		neg.w	d1
		move.w	(v_camera_y_pos).w,d0
		cmp.w	(v_boundary_bottom_next).w,d0
		bls.s	loc_E604
		move.w	d0,(v_boundary_bottom).w
		andi.w	#-2,(v_boundary_bottom).w

loc_E604:
		add.w	d1,(v_boundary_bottom).w
		move.b	#1,(f_boundary_bottom_change).w

locret_E60E:
		rts
; ===========================================================================

loc_E610:
		move.w	(v_camera_y_pos).w,d0
		addi_.w	#8,d0
		cmp.w	(v_boundary_bottom).w,d0
		bcs.s	loc_E62A
		btst	#1,($FFFFB022).w
		beq.s	loc_E62A
		add.w	d1,d1
		add.w	d1,d1

loc_E62A:
		add.w	d1,(v_boundary_bottom).w
		move.b	#1,(f_boundary_bottom_change).w
		rts

; ===========================================================================
DLE_Index:	index offset(*),,2
		ptr loc_E658					; 0
		ptr locret_E752					; 1
		ptr locret_E754					; 2
		ptr locret_E756					; 3
		ptr locret_E758					; 4
		ptr loc_E75A					; 5
		ptr loc_E842					; 6
		ptr loc_E986					; 7
		ptr locret_F05A					; 8
		ptr locret_F05C					; 9
		ptr loc_F05E					; 10
		ptr loc_F13E					; 11
		ptr loc_F26A					; 12
		ptr loc_F378					; 13
		ptr loc_F446					; 14
		ptr loc_F4D0					; 15
		ptr loc_F59E					; 16
		zonewarning DLE_Index,2
; ===========================================================================

loc_E658:
		tst.b	(v_act).w
		bne.s	loc_E660
		rts
; ===========================================================================

loc_E660:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_E66E(pc,d0.w),d0
		jmp	off_E66E(pc,d0.w)
; ===========================================================================
off_E66E:	index offset(*),,2
		ptr loc_E676					; 0
		ptr loc_E6B0					; 2
		ptr loc_E6EE					; 4
		ptr loc_E738					; 6
; ===========================================================================

loc_E676:
		tst.w	(f_two_player).w
		bne.s	loc_E6A2
		cmpi.w	#$2780,(v_camera_x_pos).w
		bcs.s	locret_E6A0
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$390,(v_boundary_bottom_next).w
		move.w	#$390,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_E6A0:
		rts
; ===========================================================================

loc_E6A2:
		move.w	#$2920,(v_boundary_right).w
		move.w	#$2920,(v_boundary_right_p2).w
		rts
; ===========================================================================

loc_E6B0:
		cmpi.w	#$28F0,(v_camera_x_pos).w
		bcs.s	locret_E6EC
		move.w	#$28F0,(v_boundary_left).w
		move.w	#$2940,(v_boundary_right).w
		move.w	#$28F0,(v_boundary_left_p2).w
		move.w	#$2940,(v_boundary_right_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.b	#2,(v_current_boss).w
		moveq	#$29,d0
		jsrto	AddPLC,JmpTo2_AddPLC

locret_E6EC:
		rts
; ===========================================================================

loc_E6EE:
		cmpi.w	#$388,(v_camera_y_pos).w
		bcs.s	loc_E702
		move.w	#$388,(v_boundary_top).w
		move.w	#$388,(v_boundary_top_p2).w

loc_E702:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_E736
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_E72A
		move.b	#id_BossEmeraldHill,ost_id(a1)
		move.b	#-$7F,ost_subtype(a1)
		move.w	#$29D0,ost_x_pos(a1)
		move.w	#$426,ost_y_pos(a1)

loc_E72A:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_E736:
		rts
; ===========================================================================

loc_E738:
		tst.b	(v_boss_status).w
		beq.s	locret_E750
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w

locret_E750:
		rts
; ===========================================================================

locret_E752:
		rts
; ===========================================================================

locret_E754:
		rts
; ===========================================================================

locret_E756:
		rts
; ===========================================================================

locret_E758:
		rts
; ===========================================================================

loc_E75A:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_E768(pc,d0.w),d0
		jmp	off_E768(pc,d0.w)
; ===========================================================================
off_E768:		index offset(*),,2
		ptr loc_E772					; 0
		ptr loc_E792					; 2
		ptr loc_E7B8					; 4
		ptr loc_E7F6					; 6
		ptr loc_E82E					; 8
; ===========================================================================

loc_E772:
		cmpi.w	#$2530,(v_camera_x_pos).w
		bcs.s	locret_E790
		move.w	#$500,(v_boundary_bottom).w
		move.w	#$450,(v_boundary_bottom_next).w
		move.w	#$450,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_E790:
		rts
; ===========================================================================

loc_E792:
		cmpi.w	#$2980,(v_camera_x_pos).w
		bcs.s	locret_E7B6
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$400,(v_boundary_bottom_next).w
		move.w	#$400,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_E7B6:
		rts
; ===========================================================================

loc_E7B8:
		cmpi.w	#$2A80,(v_camera_x_pos).w
		bcs.s	locret_E7F4
		move.w	#$2AB0,(v_boundary_left).w
		move.w	#$2AB0,(v_boundary_right).w
		move.w	#$2AB0,(v_boundary_left_p2).w
		move.w	#$2AB0,(v_boundary_right_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.b	#7,(v_current_boss).w
		moveq	#$2E,d0
		jsrto	AddPLC,JmpTo2_AddPLC

locret_E7F4:
		rts
; ===========================================================================

loc_E7F6:
		cmpi.w	#$400,(v_camera_y_pos).w
		bcs.s	loc_E80A
		move.w	#$400,(v_boundary_top).w
		move.w	#$400,(v_boundary_top_p2).w

loc_E80A:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_E82C
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_E820
		move.b	#id_BossMetropolis,ost_id(a1)

loc_E820:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_E82C:
		rts
; ===========================================================================

loc_E82E:
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		rts
; ===========================================================================

loc_E842:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_E862(pc,d0.w),d0
		jsr	off_E862(pc,d0.w)
		move.w	($FFFFF660).w,d0
		move.w	off_E85C(pc,d0.w),d0
		jmp	off_E85C(pc,d0.w)
; ===========================================================================
off_E85C:	index offset(*),,2
		ptr loc_E94A					; 0
		ptr loc_E96C					; 2
		ptr locret_E984					; 4

off_E862:	index offset(*),,2
		ptr loc_E86A					; 0
		ptr loc_E88E					; 2
		ptr loc_E8C0					; 4
		ptr loc_E904					; 6
; ===========================================================================

loc_E86A:
		move.l	(v_camera_x_pos).w,(v_bg1_x_pos).w
		move.l	(v_camera_y_pos).w,(v_bg1_y_pos).w
		moveq	#0,d0
		move.w	d0,(v_bg_x_pos_diff).w
		move.w	d0,(v_bg_y_pos_diff).w
		move.w	d0,(v_camera_x_pos_offset).w
		move.w	d0,(v_camera_y_pos_offset).w
		addq.b	#2,(v_dle_routine).w
		rts
; ===========================================================================

loc_E88E:
		cmpi.w	#$2BC0,(v_camera_x_pos).w
		bcs.s	loc_E8A8
		cmpi.w	#$580,(v_camera_y_pos).w
		bcs.s	loc_E8A8
		addq.b	#2,(v_dle_routine).w
		move.w	#0,($FFFFF662).w

loc_E8A8:
		move.w	(v_camera_x_diff).w,(v_bg_x_pos_diff).w
		move.w	(v_camera_y_diff).w,(v_bg_y_pos_diff).w
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_camera_y_pos).w,d1
		bra.w	sub_EB78
; ===========================================================================

loc_E8C0:
		cmpi.w	#$800,(v_camera_x_pos_offset).w
		beq.s	loc_E8CC
		addq.w	#2,(v_camera_x_pos_offset).w

loc_E8CC:
		cmpi.w	#$600,(v_camera_x_pos_offset).w
		blt.s	loc_E8EC
		move.w	($FFFFF662).w,d0
		moveq	#4,d1
		cmpi.w	#$840,d0
		bcc.s	loc_E8E6
		add.w	d1,d0
		move.w	d0,($FFFFF662).w

loc_E8E6:
		lsr.w	#8,d0
		add.w	d0,(v_camera_y_pos_offset).w

loc_E8EC:
		move.w	(v_camera_x_diff).w,(v_bg_x_pos_diff).w
		move.w	(v_camera_y_diff).w,(v_bg_y_pos_diff).w
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_camera_y_pos).w,d1
		bra.w	sub_EB78
; ===========================================================================

loc_E904:
		cmpi.w	#-$2C0,(v_camera_x_pos_offset).w
		beq.s	loc_E932
		subi_.w	#2,(v_camera_x_pos_offset).w
		cmpi.w	#$1B81,(v_camera_y_pos_offset).w
		beq.s	loc_E932
		move.w	($FFFFF662).w,d0
		beq.s	loc_E92C
		moveq	#4,d1
		neg.w	d1
		add.w	d1,d0
		move.w	d0,($FFFFF662).w
		lsr.w	#8,d0

loc_E92C:
		addq.w	#1,d0
		add.w	d0,(v_camera_y_pos_offset).w

loc_E932:
		move.w	(v_camera_x_diff).w,(v_bg_x_pos_diff).w
		move.w	(v_camera_y_diff).w,(v_bg_y_pos_diff).w
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_camera_y_pos).w,d1
		bra.w	sub_EB78
; ===========================================================================

loc_E94A:
		cmpi.w	#$2880,(v_camera_x_pos).w
		bcs.s	locret_E96A
		cmpi.w	#$400,(v_camera_y_pos).w
		bcs.s	locret_E96A
		addq.w	#2,($FFFFF660).w
		moveq	#$3E,d0
		jsrto	AddPLC,JmpTo2_AddPLC
		move.w	#$2880,(v_boundary_left).w

locret_E96A:
		rts
; ===========================================================================

loc_E96C:
		cmpi.w	#$500,(v_camera_y_pos).w
		bcs.s	locret_E982
		addq.w	#2,($FFFFF660).w
		st.b	(f_lock_controls).w
		moveq	#$3F,d0
		jsrto	AddPLC,JmpTo2_AddPLC

locret_E982:
		rts
; ===========================================================================

locret_E984:
		rts
; ===========================================================================

loc_E986:
		tst.b	(v_act).w
		bne.w	loc_EBEA
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_E99C(pc,d0.w),d0
		jmp	off_E99C(pc,d0.w)
; ===========================================================================
off_E99C:	index offset(*),,2
		ptr loc_E9A2					; 0
		ptr loc_EA0E					; 2
		ptr loc_EB14					; 4
; ===========================================================================

loc_E9A2:
		cmpi.w	#$400,(v_camera_y_pos).w
		bcs.s	loc_E9EA
		cmpi.w	#$1800,(v_camera_x_pos).w
		bcs.s	loc_E9EA
		move.b	#1,(f_screen_shake_htz).w
		move.l	(v_camera_x_pos).w,(v_bg1_x_pos).w
		move.l	(v_camera_y_pos).w,(v_bg1_y_pos).w
		moveq	#0,d0
		move.w	d0,(v_bg_x_pos_diff).w
		move.w	d0,(v_bg_y_pos_diff).w
		move.w	d0,(v_camera_x_pos_offset).w
		move.w	#$140,(v_camera_y_pos_offset).w
		subi.w	#$100,(v_bg1_y_pos).w
		move.w	#0,(v_htz_terrain_delay).w
		addq.b	#2,(v_dle_routine).w

locret_E9E8:
		rts
; ===========================================================================

loc_E9EA:
		tst.b	(f_screen_shake_htz).w
		beq.s	locret_E9E8
		move.w	#$200,d0
		moveq	#0,d1
		move.w	d1,(v_bg_x_pos_diff).w
		move.w	d1,(v_bg_y_pos_diff).w
		bsr.w	sub_EB78
		or.w	d0,d1
		bne.s	locret_E9E8
		move.b	#0,(f_screen_shake_htz).w
		rts
; ===========================================================================

loc_EA0E:
		cmpi.w	#$1978,(v_camera_x_pos).w
		bcs.w	loc_EAA0
		cmpi.w	#$1E00,(v_camera_x_pos).w
		bcs.s	loc_EA28
		move.b	#0,(f_screen_shake).w
		bra.s	loc_EAA0
; ===========================================================================

loc_EA28:
		tst.b	(v_htz_terrain_direction).w
		bne.s	loc_EA58
		cmpi.w	#$140,(v_camera_y_pos_offset).w
		beq.s	loc_EA82
		move.w	(v_frame_counter).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	loc_EAA0
		addq.w	#1,(v_camera_y_pos_offset).w
		andi.w	#$3F,d1
		bne.s	loc_EAA0
		move.w	#$E1,d0
		jsr	(PlaySound).l
		bra.s	loc_EAA0
; ===========================================================================

loc_EA58:
		cmpi.w	#$E0,(v_camera_y_pos_offset).w
		beq.s	loc_EA82
		move.w	(v_frame_counter).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	loc_EAA0
		subq.w	#1,(v_camera_y_pos_offset).w
		andi.w	#$3F,d1
		bne.s	loc_EAA0
		move.w	#$E1,d0
		jsr	(PlaySound).l
		bra.s	loc_EAA0
; ===========================================================================

loc_EA82:
		move.b	#0,(f_screen_shake).w
		subq.w	#1,(v_htz_terrain_delay).w
		bpl.s	loc_EAA0
		move.w	#$78,(v_htz_terrain_delay).w
		eori.b	#1,(v_htz_terrain_direction).w
		move.b	#1,(f_screen_shake).w

loc_EAA0:
		cmpi.w	#$1800,(v_camera_x_pos).w
		bcs.s	loc_EAC8
		cmpi.w	#$1F00,(v_camera_x_pos).w
		bcc.s	loc_EAEE
		move.w	(v_camera_x_diff).w,(v_bg_x_pos_diff).w
		move.w	(v_camera_y_diff).w,(v_bg_y_pos_diff).w
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_camera_y_pos).w,d1
		bra.w	sub_EB78
; ===========================================================================

loc_EAC8:
		move.l	#$4000000,(v_bg1_x_pos).w
		moveq	#0,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,(v_camera_x_pos_offset).w
		move.b	d0,(v_htz_terrain_direction).w
		subq.b	#2,(v_dle_routine).w
		move.w	#$F8,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_EAEE:
		move.l	#$4000000,(v_bg1_x_pos).w
		moveq	#0,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,(v_camera_x_pos_offset).w
		move.b	d0,(v_htz_terrain_direction).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F8,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_EB14:
		cmpi.w	#$1F00,(v_camera_x_pos).w
		bcc.s	loc_EB54
		move.b	#1,(f_screen_shake_htz).w
		move.l	(v_camera_x_pos).w,(v_bg1_x_pos).w
		move.l	(v_camera_y_pos).w,(v_bg1_y_pos).w
		moveq	#0,d0
		move.w	d0,(v_bg_x_pos_diff).w
		move.w	d0,(v_bg_y_pos_diff).w
		move.w	d0,(v_camera_x_pos_offset).w
		move.w	#$140,(v_camera_y_pos_offset).w
		subi.w	#$100,(v_bg1_y_pos).w
		move.w	#0,(v_htz_terrain_delay).w
		subq.b	#2,(v_dle_routine).w

locret_EB52:
		rts
; ===========================================================================

loc_EB54:
		tst.b	(f_screen_shake_htz).w
		beq.s	locret_EB52
		move.w	#$200,d0
		moveq	#0,d1
		move.w	d1,(v_bg_x_pos_diff).w
		move.w	d1,(v_bg_y_pos_diff).w
		bsr.w	sub_EB78
		or.w	d0,d1
		bne.s	locret_EB52
		move.b	#0,(f_screen_shake_htz).w
		rts

; ===========================================================================


sub_EB78:
		sub.w	(v_bg1_x_pos).w,d0
		sub.w	(v_camera_x_pos_offset).w,d0
		bpl.s	loc_EB8E
		cmpi.w	#-$10,d0
		bgt.s	loc_EB8C
		move.w	#-$10,d0

loc_EB8C:
		bra.s	loc_EB98
; ===========================================================================

loc_EB8E:
		cmpi.w	#$10,d0
		bcs.s	loc_EB98
		move.w	#$10,d0

loc_EB98:
		move.b	d0,(v_bg_x_pos_diff).w
		sub.w	(v_bg1_y_pos).w,d1
		sub.w	(v_camera_y_pos_offset).w,d1
		bpl.s	loc_EBB2
		cmpi.w	#-$10,d1
		bgt.s	loc_EBB0
		move.w	#-$10,d1

loc_EBB0:
		bra.s	loc_EBBC
; ===========================================================================

loc_EBB2:
		cmpi.w	#$10,d1
		bcs.s	loc_EBBC
		move.w	#$10,d1

loc_EBBC:
		move.b	d1,(v_bg_y_pos_diff).w
		rts

; ===========================================================================
		btst	#0,(v_joypad2_hold_actual).w
		beq.s	loc_EBD4
		tst.w	(v_camera_y_pos_offset).w
		beq.s	loc_EBD4
		subq.w	#1,(v_camera_y_pos_offset).w

loc_EBD4:
		btst	#1,(v_joypad2_hold_actual).w
		beq.s	locret_EBE8
		cmpi.w	#$700,(v_camera_y_pos_offset).w
		beq.s	locret_EBE8
		addq.w	#1,(v_camera_y_pos_offset).w

locret_EBE8:
		rts
; ===========================================================================

loc_EBEA:
		bsr.w	sub_EF66
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_EBFC(pc,d0.w),d0
		jmp	off_EBFC(pc,d0.w)
; ===========================================================================
off_EBFC:	index offset(*),,2
		ptr loc_EC0E					; 0
		ptr loc_EC90					; 2
		ptr loc_ED96					; 4
		ptr loc_EDFA					; 6
		ptr loc_EEF8					; 8
		ptr loc_EF84					; $A
		ptr loc_EFAA					; $C
		ptr loc_EFE8					; $E
		ptr loc_F020					; $10
; ===========================================================================

loc_EC0E:
		cmpi.w	#$14C0,(v_camera_x_pos).w
		bcs.s	loc_EC6C
		move.b	#1,(f_screen_shake_htz).w
		move.l	(v_camera_x_pos).w,(v_bg1_x_pos).w
		move.l	(v_camera_y_pos).w,(v_bg1_y_pos).w
		moveq	#0,d0
		move.w	d0,(v_bg_x_pos_diff).w
		move.w	d0,(v_bg_y_pos_diff).w
		move.w	d0,(v_camera_x_pos_offset).w
		move.w	#$2C0,(v_camera_y_pos_offset).w
		subi.w	#$100,(v_bg1_y_pos).w
		move.w	#0,(v_htz_terrain_delay).w
		addq.b	#2,(v_dle_routine).w
		cmpi.w	#$380,(v_camera_y_pos).w
		bcs.s	locret_EC6A
		move.w	#-$680,(v_camera_x_pos_offset).w
		addi.w	#$480,(v_bg1_x_pos).w
		move.w	#$300,(v_camera_y_pos_offset).w
		addq.b	#6,(v_dle_routine).w

locret_EC6A:
		rts
; ===========================================================================

loc_EC6C:
		tst.b	(f_screen_shake_htz).w
		beq.s	locret_EC6A
		move.w	#$200,d0
		moveq	#0,d1
		move.w	d1,(v_bg_x_pos_diff).w
		move.w	d1,(v_bg_y_pos_diff).w
		bsr.w	sub_EB78
		or.w	d0,d1
		bne.s	locret_EC6A
		move.b	#0,(f_screen_shake_htz).w
		rts
; ===========================================================================

loc_EC90:
		cmpi.w	#$1678,(v_camera_x_pos).w
		bcs.w	loc_ED22
		cmpi.w	#$1A00,(v_camera_x_pos).w
		bcs.s	loc_ECAA
		move.b	#0,(f_screen_shake).w
		bra.s	loc_ED22
; ===========================================================================

loc_ECAA:
		tst.b	(v_htz_terrain_direction).w
		bne.s	loc_ECDA
		cmpi.w	#$2C0,(v_camera_y_pos_offset).w
		beq.s	loc_ED04
		move.w	(v_frame_counter).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	loc_ED22
		addq.w	#1,(v_camera_y_pos_offset).w
		andi.w	#$3F,d1
		bne.s	loc_ED22
		move.w	#$E1,d0
		jsr	(PlaySound).l
		bra.s	loc_ED22
; ===========================================================================

loc_ECDA:
		cmpi.w	#0,(v_camera_y_pos_offset).w
		beq.s	loc_ED04
		move.w	(v_frame_counter).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	loc_ED22
		subq.w	#1,(v_camera_y_pos_offset).w
		andi.w	#$3F,d1
		bne.s	loc_ED22
		move.w	#$E1,d0
		jsr	(PlaySound).l
		bra.s	loc_ED22
; ===========================================================================

loc_ED04:
		move.b	#0,(f_screen_shake).w
		subq.w	#1,(v_htz_terrain_delay).w
		bpl.s	loc_ED22
		move.w	#$78,(v_htz_terrain_delay).w
		eori.b	#1,(v_htz_terrain_direction).w
		move.b	#1,(f_screen_shake).w

loc_ED22:
		cmpi.w	#$14C0,(v_camera_x_pos).w
		bcs.s	loc_ED4A
		cmpi.w	#$1B00,(v_camera_x_pos).w
		bcc.s	loc_ED70
		move.w	(v_camera_x_diff).w,(v_bg_x_pos_diff).w
		move.w	(v_camera_y_diff).w,(v_bg_y_pos_diff).w
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_camera_y_pos).w,d1
		bra.w	sub_EB78
; ===========================================================================

loc_ED4A:
		move.l	#$4000000,(v_bg1_x_pos).w
		moveq	#0,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,(v_camera_x_pos_offset).w
		move.b	d0,(v_htz_terrain_direction).w
		subq.b	#2,(v_dle_routine).w
		move.w	#$F8,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_ED70:
		move.l	#$4000000,(v_bg1_x_pos).w
		moveq	#0,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,(v_camera_x_pos_offset).w
		move.b	d0,(v_htz_terrain_direction).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F8,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_ED96:
		cmpi.w	#$1B00,(v_camera_x_pos).w
		bcc.s	loc_EDD6
		move.b	#1,(f_screen_shake_htz).w
		move.l	(v_camera_x_pos).w,(v_bg1_x_pos).w
		move.l	(v_camera_y_pos).w,(v_bg1_y_pos).w
		moveq	#0,d0
		move.w	d0,(v_bg_x_pos_diff).w
		move.w	d0,(v_bg_y_pos_diff).w
		move.w	d0,(v_camera_x_pos_offset).w
		move.w	#$2C0,(v_camera_y_pos_offset).w
		subi.w	#$100,(v_bg1_y_pos).w
		move.w	#0,(v_htz_terrain_delay).w
		subq.b	#2,(v_dle_routine).w

locret_EDD4:
		rts
; ===========================================================================

loc_EDD6:
		tst.b	(f_screen_shake_htz).w
		beq.s	locret_EDD4
		move.w	#$200,d0
		moveq	#0,d1
		move.w	d1,(v_bg_x_pos_diff).w
		move.w	d1,(v_bg_y_pos_diff).w
		bsr.w	sub_EB78
		or.w	d0,d1
		bne.s	locret_EDD4
		move.b	#0,(f_screen_shake_htz).w
		rts
; ===========================================================================

loc_EDFA:
		cmpi.w	#$15F0,(v_camera_x_pos).w
		bcs.w	loc_EE84
		cmpi.w	#$1AC0,(v_camera_x_pos).w
		bcc.s	loc_EE84
		tst.b	(v_htz_terrain_direction).w
		bne.s	loc_EE3C
		cmpi.w	#$300,(v_camera_y_pos_offset).w
		beq.s	loc_EE66
		move.w	(v_frame_counter).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	loc_EE84
		addq.w	#1,(v_camera_y_pos_offset).w
		andi.w	#$3F,d1
		bne.s	loc_EE84
		move.w	#$E1,d0
		jsr	(PlaySound).l
		bra.s	loc_EE84
; ===========================================================================

loc_EE3C:
		cmpi.w	#0,(v_camera_y_pos_offset).w
		beq.s	loc_EE66
		move.w	(v_frame_counter).w,d0
		move.w	d0,d1
		andi.w	#3,d0
		bne.s	loc_EE84
		subq.w	#1,(v_camera_y_pos_offset).w
		andi.w	#$3F,d1
		bne.s	loc_EE84
		move.w	#$E1,d0
		jsr	(PlaySound).l
		bra.s	loc_EE84
; ===========================================================================

loc_EE66:
		move.b	#0,(f_screen_shake).w
		subq.w	#1,(v_htz_terrain_delay).w
		bpl.s	loc_EE84
		move.w	#$78,(v_htz_terrain_delay).w
		eori.b	#1,(v_htz_terrain_direction).w
		move.b	#1,(f_screen_shake).w

loc_EE84:
		cmpi.w	#$14C0,(v_camera_x_pos).w
		bcs.s	loc_EEAC
		cmpi.w	#$1B00,(v_camera_x_pos).w
		bcc.s	loc_EED2
		move.w	(v_camera_x_diff).w,(v_bg_x_pos_diff).w
		move.w	(v_camera_y_diff).w,(v_bg_y_pos_diff).w
		move.w	(v_camera_x_pos).w,d0
		move.w	(v_camera_y_pos).w,d1
		bra.w	sub_EB78
; ===========================================================================

loc_EEAC:
		move.l	#$4000000,(v_bg1_x_pos).w
		moveq	#0,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,(v_camera_x_pos_offset).w
		move.b	d0,(v_htz_terrain_direction).w
		subq.b	#6,(v_dle_routine).w
		move.w	#$F8,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_EED2:
		move.l	#$4000000,(v_bg1_x_pos).w
		moveq	#0,d0
		move.l	d0,(v_bg1_y_pos).w
		move.l	d0,(v_camera_x_pos_offset).w
		move.b	d0,(v_htz_terrain_direction).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F8,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_EEF8:
		cmpi.w	#$1B00,(v_camera_x_pos).w
		bcc.s	loc_EF40
		move.b	#1,(f_screen_shake_htz).w
		move.l	(v_camera_x_pos).w,(v_bg1_x_pos).w
		move.l	(v_camera_y_pos).w,(v_bg1_y_pos).w
		moveq	#0,d0
		move.w	d0,(v_bg_x_pos_diff).w
		move.w	d0,(v_bg_y_pos_diff).w
		move.w	#-$680,(v_camera_x_pos_offset).w
		addi.w	#$480,(v_bg1_x_pos).w
		move.w	#$300,(v_camera_y_pos_offset).w
		subi.w	#$100,(v_bg1_y_pos).w
		move.w	#0,(v_htz_terrain_delay).w
		subq.b	#2,(v_dle_routine).w

locret_EF3E:
		rts
; ===========================================================================

loc_EF40:
		tst.b	(f_screen_shake_htz).w
		beq.s	locret_EF3E
		move.w	#$200,d0
		moveq	#0,d1
		move.w	d1,(v_bg_x_pos_diff).w
		move.w	d1,(v_bg_y_pos_diff).w
		bsr.w	sub_EB78
		or.w	d0,d1
		bne.s	locret_EF3E
		move.b	#0,(f_screen_shake_htz).w
		rts
; ===========================================================================
		rts

; ===========================================================================


sub_EF66:
		cmpi.w	#$2B00,(v_camera_x_pos).w
		bcs.s	locret_EF82
		cmpi.b	#$A,(v_dle_routine).w
		bge.s	locret_EF82
		move.b	#$A,(v_dle_routine).w
		move.b	#0,(f_screen_shake_htz).w

locret_EF82:
		rts

; ===========================================================================

loc_EF84:
		cmpi.w	#$2C50,(v_camera_x_pos).w
		bcs.s	locret_EFA8
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$480,(v_boundary_bottom_next).w
		move.w	#$480,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_EFA8:
		rts
; ===========================================================================

loc_EFAA:
		cmpi.w	#$2EDF,(v_camera_x_pos).w
		bcs.s	locret_EFE6
		move.w	#$2EE0,(v_boundary_left).w
		move.w	#$2F5E,(v_boundary_right).w
		move.w	#$2EE0,(v_boundary_left_p2).w
		move.w	#$2F5E,(v_boundary_right_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.b	#3,(v_current_boss).w
		moveq	#$2A,d0
		jmpto	AddPLC,JmpTo2_AddPLC
; ===========================================================================

locret_EFE6:
		rts
; ===========================================================================

loc_EFE8:
		cmpi.w	#$478,(v_camera_y_pos).w
		bcs.s	loc_EFFC
		move.w	#$478,(v_boundary_top).w
		move.w	#$478,(v_boundary_top_p2).w

loc_EFFC:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w

loc_F006:
		bcs.s	locret_F01E
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_F012
		move.b	#id_BossHillTop,ost_id(a1)

loc_F012:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_F01E:
		rts
; ===========================================================================

loc_F020:
		tst.b	(v_boss_status).w
		beq.s	locret_F058
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		cmpi.w	#$30E0,(v_camera_x_pos).w
		bcs.s	locret_F058
		cmpi.w	#$428,(v_boundary_top).w
		bcs.s	loc_F04C
		subq.w	#2,(v_boundary_top).w

loc_F04C:
		cmpi.w	#$430,(v_boundary_bottom_next).w
		bcs.s	locret_F058
		subq.w	#2,(v_boundary_bottom_next).w

locret_F058:
		rts
; ===========================================================================

locret_F05A:
		rts
; ===========================================================================

locret_F05C:
		rts
; ===========================================================================

loc_F05E:
		tst.b	(v_act).w
		bne.s	loc_F066
		rts
; ===========================================================================

loc_F066:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F074(pc,d0.w),d0
		jmp	off_F074(pc,d0.w)
; ===========================================================================
off_F074:	index offset(*),,2
		ptr loc_F07C					; 0
		ptr loc_F0A8					; 2
		ptr loc_F0EC					; 4
		ptr loc_F124					; 6
; ===========================================================================

loc_F07C:
		cmpi.w	#$2668,(v_camera_x_pos).w
		bcs.s	locret_F0A6
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$2D8,($FFFFB38C).w
		move.w	#$1E0,(v_boundary_bottom_next).w
		move.w	#$1E0,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_F0A6:
		rts
; ===========================================================================

loc_F0A8:
		cmpi.w	#$2880,(v_camera_x_pos).w
		bcs.s	locret_F0EA
		move.w	#$2880,(v_boundary_left).w
		move.w	#$28C0,(v_boundary_right).w
		move.w	#$2880,(v_boundary_left_p2).w
		move.w	#$28C0,(v_boundary_right_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.b	#8,(v_current_boss).w
		moveq	#$2F,d0
		jsrto	AddPLC,JmpTo2_AddPLC
		moveq	#$25,d0
		jsrto	PalLoad_Now,JmpTo2_PalLoad_Now

locret_F0EA:
		rts
; ===========================================================================

loc_F0EC:
		cmpi.w	#$1D8,(v_camera_y_pos).w
		bcs.s	loc_F100
		move.w	#$1D8,(v_boundary_top).w
		move.w	#$1D8,(v_boundary_top_p2).w

loc_F100:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_F122
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_F116
		move.b	#id_BossOilOcean,ost_id(a1)

loc_F116:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_F122:
		rts
; ===========================================================================

loc_F124:
		tst.b	(v_boss_status).w
		beq.s	locret_F13C
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w

locret_F13C:
		rts
; ===========================================================================

loc_F13E:
		tst.b	(v_act).w
		bne.s	loc_F146
		rts
; ===========================================================================

loc_F146:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F154(pc,d0.w),d0
		jmp	off_F154(pc,d0.w)
; ===========================================================================
off_F154:	index offset(*),,2
		ptr loc_F15C					; 0
		ptr loc_F196					; 2
		ptr loc_F206					; 4
		ptr loc_F23E					; 6
; ===========================================================================

loc_F15C:
		tst.w	(f_two_player).w
		bne.s	loc_F188
		cmpi.w	#$2080,(v_camera_x_pos).w
		bcs.s	locret_F186
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$5D0,(v_boundary_bottom_next).w
		move.w	#$5D0,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_F186:
		rts
; ===========================================================================

loc_F188:
		move.w	#$2100,(v_boundary_right).w
		move.w	#$2100,(v_boundary_right_p2).w
		rts
; ===========================================================================

loc_F196:
		cmpi.w	#$20F0,(v_camera_x_pos).w
		bcs.s	locret_F204
		move.w	#$20F0,(v_boundary_right).w
		move.w	#$20F0,(v_boundary_left).w
		move.w	#$20F0,(v_boundary_right_p2).w
		move.w	#$20F0,(v_boundary_left_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.l	#$6C000002,(vdp_control_port).l
		lea	(vdp_data_port).l,a6
		lea	(Art_FallingRocks).l,a2
		moveq	#7,d0

	loc_F1DE:
		rept 8
		move.l	(a2)+,(a6)
		endr
		dbf	d0,loc_F1DE

		move.b	#5,(v_current_boss).w
		moveq	#$2C,d0
		jsrto	AddPLC,JmpTo2_AddPLC
		moveq	#$19,d0
		jsrto	PalLoad_Now,JmpTo2_PalLoad_Now

locret_F204:
		rts
; ===========================================================================

loc_F206:
		cmpi.w	#$5C8,(v_camera_y_pos).w
		bcs.s	loc_F21A
		move.w	#$5C8,(v_boundary_top).w
		move.w	#$5C8,(v_boundary_top_p2).w

loc_F21A:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_F23C
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_F230
		move.b	#id_BossMysticCave,ost_id(a1)

loc_F230:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_F23C:
		rts
; ===========================================================================

loc_F23E:
		tst.b	(f_screen_shake).w
		beq.s	loc_F256
		move.w	(v_frame_counter).w,d0
		andi.w	#$1F,d0
		bne.s	loc_F256
		move.w	#sfx_Rumbling2,d0
		jsrto	PlaySound,JmpTo3_PlaySound

loc_F256:
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		rts
; ===========================================================================

loc_F26A:
		jsr	(SlotMachine).l
		tst.b	(v_act).w
		bne.s	loc_F278
		rts
; ===========================================================================

loc_F278:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F286(pc,d0.w),d0
		jmp	off_F286(pc,d0.w)
; ===========================================================================
off_F286:	index offset(*),,2
		ptr loc_F28E					; 0
		ptr loc_F2CE					; 2
		ptr loc_F318					; 4
		ptr loc_F350					; 6
; ===========================================================================

loc_F28E:
		tst.w	(f_two_player).w
		bne.s	loc_F2C0
		cmpi.w	#$27C0,(v_camera_x_pos).w
		bcs.s	locret_F2BE
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$62E,(v_boundary_bottom_next).w
		move.w	#$62E,(v_boundary_bottom_p2).w
		move.b	#-7,($FFFF8C54).w
		addq.b	#2,(v_dle_routine).w

locret_F2BE:
		rts
; ===========================================================================

loc_F2C0:
		move.w	#$26A0,(v_boundary_right).w
		move.w	#$26A0,(v_boundary_right_p2).w
		rts
; ===========================================================================

loc_F2CE:
		cmpi.w	#$2890,(v_camera_x_pos).w
		bcs.s	locret_F316
		move.b	#-7,($FFFF8C50).w
		move.w	#$2860,(v_boundary_left).w
		move.w	#$28E0,(v_boundary_right).w
		move.w	#$2860,(v_boundary_left_p2).w
		move.w	#$28E0,(v_boundary_right_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.b	#6,(v_current_boss).w
		moveq	#$2D,d0
		jsrto	AddPLC,JmpTo2_AddPLC
		moveq	#$1A,d0
		jsrto	PalLoad_Now,JmpTo2_PalLoad_Now

locret_F316:
		rts
; ===========================================================================

loc_F318:
		cmpi.w	#$4E0,(v_camera_y_pos).w
		bcs.s	loc_F32C
		move.w	#$4E0,(v_boundary_top).w
		move.w	#$4E0,(v_boundary_top_p2).w

loc_F32C:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_F34E
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_F342
		move.b	#id_BossCasinoNight,ost_id(a1)

loc_F342:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_F34E:
		rts
; ===========================================================================

loc_F350:
		cmpi.w	#$2A00,(v_camera_x_pos).w
		bcs.s	locret_F376
		move.w	#$5D0,(v_boundary_bottom_next).w
		move.w	#$5D0,(v_boundary_bottom_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w

locret_F376:
		rts
; ===========================================================================

loc_F378:
		tst.b	(v_act).w
		bne.s	loc_F380
		rts
; ===========================================================================

loc_F380:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F38E(pc,d0.w),d0
		jmp	off_F38E(pc,d0.w)
; ===========================================================================
off_F38E:	index offset(*),,2
		ptr loc_F396					; 0
		ptr loc_F3BC					; 2
		ptr loc_F3FA					; 4
		ptr loc_F432					; 6
; ===========================================================================

loc_F396:
		cmpi.w	#$2680,(v_camera_x_pos).w
		bcs.s	locret_F3BA
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$450,(v_boundary_bottom_next).w
		move.w	#$450,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w

locret_F3BA:
		rts
; ===========================================================================

loc_F3BC:
		cmpi.w	#$2A20,(v_camera_x_pos).w
		bcs.s	locret_F3F8
		move.w	#$2A20,(v_boundary_left).w
		move.w	#$2A20,(v_boundary_right).w
		move.w	#$2A20,(v_boundary_left_p2).w
		move.w	#$2A20,(v_boundary_right_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		move.b	#1,(v_current_boss).w
		moveq	#$28,d0
		jmpto	AddPLC,JmpTo2_AddPLC
; ===========================================================================

locret_F3F8:
		rts
; ===========================================================================

loc_F3FA:
		cmpi.w	#$448,(v_camera_y_pos).w
		bcs.s	loc_F40E
		move.w	#$448,(v_boundary_top).w
		move.w	#$448,(v_boundary_top_p2).w

loc_F40E:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_F430
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	loc_F424
		move.b	#id_BossChemicalPlant,ost_id(a1)

loc_F424:
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_F430:
		rts
; ===========================================================================

loc_F432:
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		rts
; ===========================================================================

loc_F446:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F454(pc,d0.w),d0
		jmp	off_F454(pc,d0.w)
; ===========================================================================
off_F454:	index offset(*),,2
		ptr loc_F45E					; 0
		ptr locret_F490					; 2
		ptr loc_F492					; 4
		ptr loc_F4AC					; 6
		ptr locret_F4CE					; 8
; ===========================================================================

loc_F45E:
		move.w	#$140,d0
		cmp.w	(v_camera_x_pos).w,d0
		bhi.s	locret_F48E
		addq.b	#2,(v_dle_routine).w
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	locret_F48E
		move.b	#id_MechaSonic,ost_id(a1)
		move.b	#$48,ost_subtype(a1)
		move.w	#$348,ost_x_pos(a1)
		move.w	#$A0,ost_y_pos(a1)
		moveq	#$30,d0
		jmpto	AddPLC,JmpTo2_AddPLC
; ===========================================================================

locret_F48E:
		rts
; ===========================================================================

locret_F490:
		rts
; ===========================================================================

loc_F492:
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		cmpi.w	#$300,(v_camera_x_pos).w
		bcs.s	locret_F4AA
		addq.b	#2,(v_dle_routine).w
		moveq	#$31,d0
		jmpto	AddPLC,JmpTo2_AddPLC
; ===========================================================================

locret_F4AA:
		rts
; ===========================================================================

loc_F4AC:
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	#$680,d0
		cmp.w	(v_camera_x_pos).w,d0
		bhi.s	locret_F4CC
		addq.b	#2,(v_dle_routine).w
		move.w	d0,(v_boundary_left).w
		addi.w	#$C0,d0
		move.w	d0,(v_boundary_right).w

locret_F4CC:
		rts
; ===========================================================================

locret_F4CE:
		rts
; ===========================================================================

loc_F4D0:
		tst.b	(v_act).w
		bne.s	loc_F4D8
		rts
; ===========================================================================

loc_F4D8:
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F4E6(pc,d0.w),d0
		jmp	off_F4E6(pc,d0.w)
; ===========================================================================
off_F4E6:	index offset(*),,2
		ptr loc_F4EE					; 0
		ptr loc_F520					; 2
		ptr loc_F55C					; 4
		ptr loc_F58A					; 6
; ===========================================================================

loc_F4EE:
		cmpi.w	#$2810,(v_camera_x_pos).w
		bcs.s	locret_F51E
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		move.w	#$400,(v_boundary_bottom_next).w
		move.w	#$400,(v_boundary_bottom_p2).w
		addq.b	#2,(v_dle_routine).w
		move.b	#4,(v_current_boss).w
		moveq	#$2B,d0
		jsrto	AddPLC,JmpTo2_AddPLC

locret_F51E:
		rts
; ===========================================================================

loc_F520:
		cmpi.w	#$2A40,(v_camera_x_pos).w
		bcs.s	locret_F55A
		move.w	#$2A40,(v_boundary_right).w
		move.w	#$2A40,(v_boundary_left).w
		move.w	#$2A40,(v_boundary_right_p2).w
		move.w	#$2A40,(v_boundary_left_p2).w
		addq.b	#2,(v_dle_routine).w
		move.w	#$F9,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic
		clr.b	(v_boss_spawn_delay).w
		jsrto	FindFreeObj,JmpTo_FindFreeObj
		bne.s	locret_F55A
		move.b	#id_BossAquaticRuin,ost_id(a1)

locret_F55A:
		rts
; ===========================================================================

loc_F55C:
		cmpi.w	#$3F8,(v_camera_y_pos).w
		bcs.s	loc_F570
		move.w	#$3F8,(v_boundary_top).w
		move.w	#$3F8,(v_boundary_top_p2).w

loc_F570:
		addq.b	#1,(v_boss_spawn_delay).w
		cmpi.b	#$5A,(v_boss_spawn_delay).w
		bcs.s	locret_F588
		addq.b	#2,(v_dle_routine).w
		move.w	#$93,d0
		jsrto	PlayMusic,JmpTo3_PlayMusic

locret_F588:
		rts
; ===========================================================================

loc_F58A:
		move.w	(v_camera_x_pos).w,(v_boundary_left).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_camera_x_pos).w,(v_boundary_left_p2).w
		rts
; ===========================================================================

loc_F59E:
		tst.b	(v_act).w
		bne.w	locret_F624
		moveq	#0,d0
		move.b	(v_dle_routine).w,d0
		move.w	off_F5B4(pc,d0.w),d0
		jmp	off_F5B4(pc,d0.w)
; ===========================================================================
off_F5B4:	index offset(*),,2
		ptr loc_F5BE					; 0
		ptr loc_F5D0					; 2
		ptr loc_F5F0					; 4
		ptr loc_F60A					; 6
		ptr locret_F622					; 8
; ===========================================================================

loc_F5BE:
		move.w	#1,(v_tornado_x_vel).w
		move.w	#0,(v_tornado_y_vel).w
		addq.b	#2,(v_dle_routine).w
		rts
; ===========================================================================

loc_F5D0:
		cmpi.w	#$1180,(v_camera_x_pos).w
		bcs.s	locret_F5EE
		move.w	#-1,(v_tornado_x_vel).w
		move.w	#1,(v_tornado_y_vel).w
		move.w	#$500,(v_boundary_bottom_next).w
		addq.b	#2,(v_dle_routine).w

locret_F5EE:
		rts
; ===========================================================================

loc_F5F0:
		cmpi.w	#$500,(v_camera_y_pos).w
		bcs.s	locret_F608
		move.w	#1,(v_tornado_x_vel).w
		move.w	#0,(v_tornado_y_vel).w
		addq.b	#2,(v_dle_routine).w

locret_F608:
		rts
; ===========================================================================

loc_F60A:
		cmpi.w	#$1400,(v_camera_x_pos).w
		bcs.s	locret_F622
		move.w	#0,(v_tornado_x_vel).w
		move.w	#0,(v_tornado_y_vel).w
		addq.b	#2,(v_dle_routine).w

locret_F622:
		rts
; ===========================================================================

locret_F624:
		rts
; ===========================================================================

RestoreLevelMusic:
		move.w	(v_level_music).w,d0
		jmpto	PlayMusic,JmpTo3_PlayMusic
; ===========================================================================

LoadAnimalExplosionArt:
		moveq	#0,d0
		move.b	(v_zone).w,d0
		lea	(Animal_PLCs).l,a2
		move.b	(a2,d0.w),d0
		jsrto	AddPLC,JmpTo2_AddPLC
		moveq	#$41,d0
		jsrto	AddPLC,JmpTo2_AddPLC
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo3_PlaySound:
		jmp	(PlaySound).l
JmpTo2_PalLoad_Now:
		jmp	(PalLoad_Now).l
JmpTo2_AddPLC:
		jmp	(AddPLC).l
JmpTo3_PlayMusic:
		jmp	(PlayMusic).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 11 - Emerald Hill and Hidden Palace Bridges
; ----------------------------------------------------------------------------

Bridge:
		btst	#render_subsprites_bit,ost_render(a0)
		bne.w	.ischild
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_F68C(pc,d0.w),d1
		jmp	off_F68C(pc,d1.w)
; ===========================================================================

.ischild:
		move.w	#$180,d0
		bra.w	DisplaySprite3
; ===========================================================================
off_F68C:	index offset(*),,2
		ptr loc_F694					; 0
		ptr loc_F77A					; 2
		ptr loc_F80C					; 4
		ptr loc_F810					; 6
; ===========================================================================

loc_F694:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_EmeraldHillBridge,ost_mappings(a0)
		move.w	#tile_Nem_EHZBridge+tile_pal3,ost_tile(a0)
		move.b	#3,ost_priority(a0)
		cmpi.b	#id_HPZ,(v_zone).w
		bne.s	loc_F6C6
		addq.b	#4,ost_primary_routine(a0)
		move.l	#Map_HiddenPalaceBridge,ost_mappings(a0)
		move.w	#(vram_HiddenPalaceBridge/sizeof_cell)+tile_pal4,ost_tile(a0)

loc_F6C6:
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#-$80,ost_displaywidth(a0)
		move.w	ost_y_pos(a0),d2
		move.w	d2,$3C(a0)
		move.w	ost_x_pos(a0),d3
		lea	ost_subtype(a0),a2
		moveq	#0,d1
		move.b	(a2),d1
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		swap	d1
		move.w	#8,d1
		bsr.s	sub_F728
		move.w	ost_subspr6_x_pos(a1),d0
		subq.w	#8,d0
		move.w	d0,ost_x_pos(a1)
		move.l	a1,$30(a0)
		swap	d1
		subq.w	#8,d1
		bls.s	loc_F726
		move.w	d1,d4
		bsr.s	sub_F728
		move.l	a1,$34(a0)
		move.w	d4,d0
		add.w	d0,d0
		add.w	d4,d0
		move.w	ost_subspr2_x_pos(a1,d0.w),d0
		subq.w	#8,d0
		move.w	d0,ost_x_pos(a1)

loc_F726:
		bra.s	loc_F77A

; ===========================================================================


sub_F728:
		jsrto	FindNextFreeObj,JmpTo_FindNextFreeObj
		bne.s	locret_F778
		_move.b	ost_id(a0),ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	ost_render(a0),ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#$40,ost_mainspr_width(a1)
		move.b	d1,ost_mainspr_childsprites(a1)
		subq.b	#1,d1
		lea	ost_subspr2_x_pos(a1),a2

loc_F768:
		move.w	d3,(a2)+
		move.w	d2,(a2)+
		move.w	#0,(a2)+
		addi.w	#$10,d3
		dbf	d1,loc_F768

locret_F778:
		rts

; ===========================================================================

loc_F77A:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_F790
		tst.b	$3E(a0)
		beq.s	loc_F7BC
		subq.b	#4,$3E(a0)
		bra.s	loc_F7B8
; ===========================================================================

loc_F790:
		andi.b	#$10,d0
		beq.s	loc_F7AC
		move.b	$3F(a0),d0
		sub.b	$3B(a0),d0
		beq.s	loc_F7AC
		bcc.s	loc_F7A8
		addq.b	#1,$3F(a0)
		bra.s	loc_F7AC
; ===========================================================================

loc_F7A8:
		subq.b	#1,$3F(a0)

loc_F7AC:
		cmpi.b	#$40,$3E(a0)
		beq.s	loc_F7B8
		addq.b	#4,$3E(a0)

loc_F7B8:
		bsr.w	loc_F9E8

loc_F7BC:
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		add.w	d2,d2
		moveq	#8,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	sub_F872

loc_F7D4:
		tst.w	(f_two_player).w
		beq.s	loc_F7DC
		rts
; ===========================================================================

loc_F7DC:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_F7F0
		rts
; ===========================================================================

loc_F7F0:
		movea.l	$30(a0),a1
		bsr.w	DeleteChild
		cmpi.b	#8,ost_subtype(a0)
		bls.s	loc_F808
		movea.l	$34(a0),a1
		bsr.w	DeleteChild

loc_F808:
		bra.w	DeleteObject
; ===========================================================================

loc_F80C:
		bra.w	DisplaySprite
; ===========================================================================

loc_F810:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_F826
		tst.b	$3E(a0)
		beq.s	loc_F852
		subq.b	#4,$3E(a0)
		bra.s	loc_F84E
; ===========================================================================

loc_F826:
		andi.b	#$10,d0
		beq.s	loc_F842
		move.b	$3F(a0),d0
		sub.b	$3B(a0),d0
		beq.s	loc_F842
		bcc.s	loc_F83E
		addq.b	#1,$3F(a0)
		bra.s	loc_F842
; ===========================================================================

loc_F83E:
		subq.b	#1,$3F(a0)

loc_F842:
		cmpi.b	#$40,$3E(a0)
		beq.s	loc_F84E
		addq.b	#4,$3E(a0)

loc_F84E:
		bsr.w	loc_F9E8

loc_F852:
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		add.w	d2,d2
		moveq	#8,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	sub_F872
		bsr.w	sub_F912
		bra.w	loc_F7D4

; ===========================================================================


sub_F872:
		lea	($FFFFB040).w,a1
		moveq	#4,d6
		moveq	#$3B,d5
		movem.l	d1-d4,-(sp)
		bsr.s	sub_F88C
		movem.l	(sp)+,d1-d4
		lea	($FFFFB000).w,a1
		subq.b	#1,d6
		moveq	#$3F,d5


; ===========================================================================


sub_F88C:
		btst	d6,ost_primary_status(a0)
		beq.s	loc_F8F0
		btst	#1,ost_primary_status(a1)
		bne.s	loc_F8AC
		moveq	#0,d0
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_F8AC
		cmp.w	d2,d0
		bcs.s	loc_F8BA

loc_F8AC:
		bclr	#3,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)
		moveq	#0,d4
		rts
; ===========================================================================

loc_F8BA:
		lsr.w	#4,d0
		move.b	d0,(a0,d5.w)
		movea.l	$30(a0),a2
		cmpi.w	#8,d0
		bcs.s	loc_F8D2
		movea.l	$34(a0),a2
		subi_.w	#8,d0

loc_F8D2:
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.w	ost_subspr2_y_pos(a2,d0.w),d0
		subq.w	#8,d0
		moveq	#0,d1
		move.b	ost_height(a1),d1
		sub.w	d1,d0
		move.w	d0,ost_y_pos(a1)
		moveq	#0,d4
		rts
; ===========================================================================

loc_F8F0:
		move.w	d1,-(sp)
		jsrto	DetectPlatform_FullWidth,JmpTo_DetectPlatform_FullWidth
		move.w	(sp)+,d1
		btst	d6,ost_primary_status(a0)
		beq.s	locret_F910
		moveq	#0,d0
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0
		lsr.w	#4,d0
		move.b	d0,(a0,d5.w)

locret_F910:
		rts

; ===========================================================================


sub_F912:
		moveq	#0,d0
		tst.w	($FFFFB010).w
		bne.s	loc_F924
		move.b	(v_vblank_counter_byte).w,d0
		andi.w	#$1C,d0
		lsr.w	#1,d0

loc_F924:
		moveq	#0,d2
		move.b	byte_F950+1(pc,d0.w),d2
		swap	d2
		move.b	byte_F950(pc,d0.w),d2
		moveq	#0,d0
		tst.w	($FFFFB050).w
		bne.s	loc_F942
		move.b	(v_vblank_counter_byte).w,d0
		andi.w	#$1C,d0
		lsr.w	#1,d0

loc_F942:
		moveq	#0,d6
		move.b	byte_F950+1(pc,d0.w),d6
		swap	d6
		move.b	byte_F950(pc,d0.w),d6
		bra.s	loc_F960
; ===========================================================================
byte_F950:
		dc.b   1,  2					; 0
		dc.b   1,  2					; 2
		dc.b   1,  2					; 4
		dc.b   1,  2					; 6
		dc.b   0,  1					; 8
		dc.b   0,  0					; 10
		dc.b   0,  0					; 12
		dc.b   0,  1					; 14
; ===========================================================================

loc_F960:
		moveq	#-2,d3
		moveq	#-2,d4
		move.b	ost_primary_status(a0),d0
		andi.b	#8,d0
		beq.s	loc_F972
		move.b	$3F(a0),d3

loc_F972:
		move.b	ost_primary_status(a0),d0
		andi.b	#$10,d0
		beq.s	loc_F980
		move.b	$3B(a0),d4

loc_F980:
		movea.l	$30(a0),a1
		lea	ost_subspr9_frame+next_subspr(a1),a2
		lea	ost_subspr2_frame(a1),a1
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		subq.b	#1,d1
		moveq	#0,d5

loc_F996:
		moveq	#0,d0
		subq.w	#1,d3
		cmp.b	d3,d5
		bne.s	loc_F9A0
		move.w	d2,d0

loc_F9A0:
		addq.w	#2,d3
		cmp.b	d3,d5
		bne.s	loc_F9A8
		move.w	d2,d0

loc_F9A8:
		subq.w	#1,d3
		subq.w	#1,d4
		cmp.b	d4,d5
		bne.s	loc_F9B2
		move.w	d6,d0

loc_F9B2:
		addq.w	#2,d4
		cmp.b	d4,d5
		bne.s	loc_F9BA
		move.w	d6,d0

loc_F9BA:
		subq.w	#1,d4
		cmp.b	d3,d5
		bne.s	loc_F9C6
		swap	d2
		move.w	d2,d0
		swap	d2

loc_F9C6:
		cmp.b	d4,d5
		bne.s	loc_F9D0
		swap	d6
		move.w	d6,d0
		swap	d6

loc_F9D0:
		move.b	d0,(a1)
		addq.w	#1,d5
		addq.w	#6,a1
		cmpa.w	a2,a1
		bne.s	loc_F9E2
		movea.l	$34(a0),a1
		lea	ost_subspr2_frame(a1),a1

loc_F9E2:
		dbf	d1,loc_F996
		rts

; ===========================================================================

loc_F9E8:
		move.b	$3E(a0),d0
		jsrto	CalcSine,JmpTo_CalcSine
		move.w	d0,d4
		lea	(byte_FB28).l,a4
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#4,d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		move.w	d3,d2
		add.w	d0,d3
		moveq	#0,d5
		lea	(byte_FA98-$80).l,a5
		move.b	(a5,d3.w),d5

loc_FA16:
		andi.w	#$F,d3
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		movea.l	$30(a0),a1
		lea	ost_subspr9_y_pos+next_subspr(a1),a2
		lea	ost_subspr2_y_pos(a1),a1

loc_FA2C:
		moveq	#0,d0
		move.b	(a3)+,d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a0),d0
		move.w	d0,(a1)
		addq.w	#6,a1
		cmpa.w	a2,a1
		bne.s	loc_FA4C
		movea.l	$34(a0),a1
		lea	ost_subspr2_y_pos(a1),a1

loc_FA4C:
		dbf	d2,loc_FA2C
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		addq.b	#1,d3
		sub.b	d0,d3
		neg.b	d3
		bmi.s	locret_FA96
		move.w	d3,d2
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		adda.w	d2,a3
		subq.w	#1,d2
		bcs.s	locret_FA96

loc_FA72:
		moveq	#0,d0
		move.b	-(a3),d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a0),d0
		move.w	d0,(a1)
		addq.w	#6,a1
		cmpa.w	a2,a1
		bne.s	loc_FA92
		movea.l	$34(a0),a1
		lea	ost_subspr2_y_pos(a1),a1

loc_FA92:
		dbf	d2,loc_FA72

locret_FA96:
		rts
; ===========================================================================
byte_FA98:
		dc.b   2,  4,  6,  8,  8,  6,  4,  2,  0,  0,  0,  0,  0,  0,  0,  0 ; 0
		dc.b   2,  4,  6,  8, $A,  8,  6,  4,  2,  0,  0,  0,  0,  0,  0,  0 ; 16
		dc.b   2,  4,  6,  8, $A, $A,  8,  6,  4,  2,  0,  0,  0,  0,  0,  0 ; 32
		dc.b   2,  4,  6,  8, $A, $C, $A,  8,  6,  4,  2,  0,  0,  0,  0,  0 ; 48
		dc.b   2,  4,  6,  8, $A, $C, $C, $A,  8,  6,  4,  2,  0,  0,  0,  0 ; 64
		dc.b   2,  4,  6,  8, $A, $C, $E, $C, $A,  8,  6,  4,  2,  0,  0,  0 ; 80
		dc.b   2,  4,  6,  8, $A, $C, $E, $E, $C, $A,  8,  6,  4,  2,  0,  0 ; 96
		dc.b   2,  4,  6,  8, $A, $C, $E,$10, $E, $C, $A,  8,  6,  4,  2,  0 ; 112
		dc.b   2,  4,  6,  8, $A, $C, $E,$10,$10, $E, $C, $A,  8,  6,  4,  2 ; 128

byte_FB28:
		dc.b $FF,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 0
		dc.b $B5,$FF,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 16
		dc.b $7E,$DB,$FF,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 32
		dc.b $61,$B5,$EC,$FF,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 48
		dc.b $4A,$93,$CD,$F3,$FF,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 64
		dc.b $3E,$7E,$B0,$DB,$F6,$FF,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 80
		dc.b $38,$6D,$9D,$C5,$E4,$F8,$FF,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 96
		dc.b $31,$61,$8E,$B5,$D4,$EC,$FB,$FF,  0,  0,  0,  0,  0,  0,  0,  0 ; 112
		dc.b $2B,$56,$7E,$A2,$C1,$DB,$EE,$FB,$FF,  0,  0,  0,  0,  0,  0,  0 ; 128
		dc.b $25,$4A,$73,$93,$B0,$CD,$E1,$F3,$FC,$FF,  0,  0,  0,  0,  0,  0 ; 144
		dc.b $1F,$44,$67,$88,$A7,$BD,$D4,$E7,$F4,$FD,$FF,  0,  0,  0,  0,  0 ; 160
		dc.b $1F,$3E,$5C,$7E,$98,$B0,$C9,$DB,$EA,$F6,$FD,$FF,  0,  0,  0,  0 ; 176
		dc.b $19,$38,$56,$73,$8E,$A7,$BD,$D1,$E1,$EE,$F8,$FE,$FF,  0,  0,  0 ; 192
		dc.b $19,$38,$50,$6D,$83,$9D,$B0,$C5,$D8,$E4,$F1,$F8,$FE,$FF,  0,  0 ; 208
		dc.b $19,$31,$4A,$67,$7E,$93,$A7,$BD,$CD,$DB,$E7,$F3,$F9,$FE,$FF,  0 ; 224
		dc.b $19,$31,$4A,$61,$78,$8E,$A2,$B5,$C5,$D4,$E1,$EC,$F4,$FB,$FE,$FF ; 240

		even


		include "mappings/sprite/HPZ Bridge (unused).asm" ; unused
		include "mappings/sprite/EHZ Bridge.asm"


; ===========================================================================

	if RemoveJmpTos=0
JmpTo_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo_DetectPlatform_FullWidth:
		jmp	(DetectPlatform_FullWidth).l
JmpTo_CalcSine:
		jmp	(CalcSine).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 15 - Aquatic Ruin, Mystic Cave, and Oil Ocean Swinging Platforms
; ----------------------------------------------------------------------------

SwingingPlatform:
		btst	#render_subsprites_bit,ost_render(a0)
		bne.w	loc_FCB4
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_FCBC(pc,d0.w),d1
		jmp	off_FCBC(pc,d1.w)
; ===========================================================================

loc_FCB4:
		move.w	#$200,d0
		bra.w	DisplaySprite3
; ===========================================================================
off_FCBC:	index offset(*),,2
		ptr loc_FCCA					; 0
		ptr loc_FE50					; 2
		ptr loc_1003A					; 4
		ptr loc_1003E					; 6
		ptr loc_100F8					; 8
		ptr loc_10100					; $A
		ptr loc_10166					; $C
; ===========================================================================

loc_FCCA:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Swing_OOZ,ost_mappings(a0)
		move.w	#tile_Nem_OOZSwingPlat+tile_pal3,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#$10,ost_height(a0)
		move.w	ost_y_pos(a0),$38(a0)
		move.w	ost_x_pos(a0),$3A(a0)
		cmpi.b	#id_MCZ,(v_zone).w
		bne.s	loc_FD22
		move.l	#Map_Swing_Track_CPZ_MCZ,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#8,ost_height(a0)

loc_FD22:
		cmpi.b	#id_ARZ,(v_zone).w
		bne.s	loc_FD44
		move.l	#Map_ARZPlats,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#8,ost_height(a0)

loc_FD44:
		bsr.w	AdjustVRAM2P
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		bpl.s	loc_FD54
		addq.b	#4,ost_primary_routine(a0)

loc_FD54:
		move.b	d1,d4
		andi.b	#$70,d4
		andi.w	#$F,d1
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		jsrto	FindNextFreeObj,JmpTo2_FindNextFreeObj
		bne.w	loc_FE24
		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		cmpi.b	#$20,d4
		bne.s	loc_FDC6
		move.b	#4,ost_primary_routine(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#$50,ost_height(a1)
		bset	#render_useheight_bit,ost_render(a1)
		move.b	#3,ost_frame(a1)
		move.w	d2,ost_x_pos(a1)
		addi.w	#$40,d3
		move.w	d3,ost_y_pos(a1)
		addi.w	#$48,d3
		move.w	d3,ost_y_pos(a0)
		bra.s	loc_FE20
; ===========================================================================

loc_FDC6:
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#$48,ost_mainspr_width(a1)
		move.b	d1,ost_mainspr_childsprites(a1)
		subq.b	#1,d1
		lea	ost_subspr2_x_pos(a1),a2

loc_FDDC:
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	#1,(a2)+
		addi.w	#$10,d3
		dbf	d1,loc_FDDC

		move.b	#2,ost_subspr2_frame(a1)
		move.w	ost_subspr6_x_pos(a1),ost_x_pos(a1)
		move.w	ost_subspr6_y_pos(a1),ost_y_pos(a1)
		move.w	d2,ost_subspr6_x_pos(a1)
		move.w	d3,ost_subspr6_y_pos(a1)
		move.b	#1,ost_mainspr_frame(a1)
		addi_.w	#8,d3
		move.w	d3,ost_y_pos(a0)
		move.b	#$50,ost_mainspr_height(a1)
		bset	#render_useheight_bit,ost_render(a1)

loc_FE20:
		move.l	a1,$30(a0)

loc_FE24:
		move.w	#$8000,ost_angle(a0)
		move.w	#0,$3E(a0)
		move.b	ost_subtype(a0),d1
		andi.w	#$70,d1
		move.b	d1,ost_subtype(a0)
		cmpi.b	#$40,d1
		bne.s	loc_FE50
		move.l	#Map_SpikedSwing_MCZ,ost_mappings(a0)
		move.b	#id_col_32x2+id_col_hurt,ost_col_type(a0)

loc_FE50:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	sub_FE70
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#0,d3
		move.b	ost_height(a0),d3
		addq.b	#1,d3
		popr.w	d4
		jsrto	DetectPlatform2,JmpTo_DetectPlatform2
		bra.w	loc_1000C

; ===========================================================================


sub_FE70:
		moveq	#0,d0
		moveq	#0,d1
		move.b	($FFFFFE78).w,d0
		move.b	ost_subtype(a0),d1
		beq.s	loc_FEC2
		cmpi.b	#$10,d1
		bne.s	loc_FE9E
		cmpi.b	#$3F,d0
		beq.s	loc_FE90
		bcc.s	loc_FEC2
		moveq	#$40,d0
		bra.s	loc_FEC2
; ===========================================================================

loc_FE90:
		move.w	#$D7,d0
		jsr	(PlaySoundLocal).l
		moveq	#$40,d0
		bra.s	loc_FEC2
; ===========================================================================

loc_FE9E:
		cmpi.b	#$20,d1
		beq.w	locret_FF6C
		cmpi.b	#$30,d1
		bne.s	loc_FEB8
		cmpi.b	#$41,d0
		beq.s	loc_FE90
		bcs.s	loc_FEC2
		moveq	#$40,d0
		bra.s	loc_FEC2
; ===========================================================================

loc_FEB8:
		cmpi.b	#$40,d1
		bne.s	loc_FEC2
		bsr.w	loc_FF6E

loc_FEC2:
		move.b	$2E(a0),d1
		cmp.b	d0,d1
		beq.w	locret_FF6C
		move.b	d0,$2E(a0)
		move.w	#$80,d1
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_FEE0
		neg.w	d0
		add.w	d1,d0

loc_FEE0:
		jsrto	CalcSine,JmpTo2_CalcSine
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		moveq	#0,d6
		movea.l	$30(a0),a1
		move.b	ost_mainspr_childsprites(a1),d6
		subq.w	#1,d6
		bcs.s	locret_FF6C
		swap	d0
		swap	d1
		asr.l	#4,d0
		asr.l	#4,d1
		moveq	#0,d4
		moveq	#0,d5

		lea	ost_subspr2_x_pos(a1),a2

loc_FF0A:
		pushr.l	d4-d5
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,(a2)+
		move.w	d4,(a2)+
		popr.l	d4-d5
		add.l	d0,d4
		add.l	d1,d5
		addq.w	#next_subspr-4,a2
		dbf	d6,loc_FF0A

		pushr.l	d4-d5
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	ost_subspr6_x_pos(a1),d2
		move.w	ost_subspr6_y_pos(a1),d3
		move.w	d5,ost_subspr6_x_pos(a1)
		move.w	d4,ost_subspr6_y_pos(a1)
		move.w	d2,ost_x_pos(a1)
		move.w	d3,ost_y_pos(a1)
		popr.l	d4-d5
		asr.l	#1,d0
		asr.l	#1,d1
		add.l	d0,d4
		add.l	d1,d5
		swap	d4
		swap	d5
		add.w	$38(a0),d4
		add.w	$3A(a0),d5
		move.w	d4,ost_y_pos(a0)
		move.w	d5,ost_x_pos(a0)

locret_FF6C:
		rts

; ===========================================================================

loc_FF6E:
		tst.w	$36(a0)
		beq.s	loc_FF7C
		subq.w	#1,$36(a0)
		bra.w	loc_10006
; ===========================================================================

loc_FF7C:
		tst.b	$34(a0)
		bne.s	loc_FFA2
		move.w	($FFFFB008).w,d0
		sub.w	$3A(a0),d0
		addi.w	#$20,d0
		cmpi.w	#$40,d0
		bcc.s	loc_10006
		tst.w	(v_debug_active).w
		bne.w	loc_10006
		move.b	#1,$34(a0)

loc_FFA2:
		tst.b	$3D(a0)
		beq.s	loc_FFD8
		move.w	$3E(a0),d0
		addi_.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,ost_angle(a0)
		cmpi.w	#$200,d0
		bne.s	loc_10006
		move.w	#0,$3E(a0)
		move.w	#$8000,ost_angle(a0)

loc_FFCA:
		move.b	#0,$3D(a0)
		move.w	#$3C,$36(a0)
		bra.s	loc_10006
; ===========================================================================

loc_FFD8:
		move.w	$3E(a0),d0
		subi_.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,ost_angle(a0)
		cmpi.w	#$FE00,d0
		bne.s	loc_10006

loc_FFEE:
		move.w	#0,$3E(a0)
		move.w	#$4000,ost_angle(a0)
		move.b	#1,$3D(a0)

loc_10000:
		move.w	#$3C,$36(a0)

loc_10006:
		move.b	ost_angle(a0),d0
		rts
; ===========================================================================

loc_1000C:
		tst.w	(f_two_player).w
		beq.s	loc_10016
		bra.w	DisplaySprite
; ===========================================================================

loc_10016:
		move.w	$3A(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	loc_1002E
		bra.w	DisplaySprite
; ===========================================================================

loc_1002E:
		movea.l	$30(a0),a1
		bsr.w	DeleteChild
		bra.w	DeleteObject
; ===========================================================================

loc_1003A:
		bra.w	DisplaySprite
; ===========================================================================

loc_1003E:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	sub_FE70
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#0,d3
		move.b	ost_height(a0),d3
		addq.b	#1,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform2,JmpTo_DetectPlatform2
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.w	loc_100F4
		tst.b	($FFFFFE78).w
		bne.w	loc_100F4
		jsrto	FindNextFreeObj,JmpTo2_FindNextFreeObj
		bne.s	loc_100E4
		moveq	#0,d0
		move.w	#$F,d1

loc_1007A:
		move.l	(a0,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_1007A
		move.b	#$A,ost_primary_routine(a1)
		cmpi.b	#id_ARZ,(v_zone).w
		bne.s	loc_10098
		addq.b	#2,ost_primary_routine(a1)

loc_10098:
		move.w	#$200,ost_x_vel(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_100AA
		neg.w	ost_x_vel(a1)

loc_100AA:
		bset	#1,ost_primary_status(a1)
		move.w	a0,d0
		subi.w	#-$5000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.w	a1,d1
		subi.w	#-$5000,d1
		lsr.w	#6,d1
		andi.w	#$7F,d1
		lea	($FFFFB000).w,a1
		cmp.b	$3D(a1),d0
		bne.s	loc_100D6
		move.b	d1,$3D(a1)

loc_100D6:
		lea	($FFFFB040).w,a1
		cmp.b	$3D(a1),d0
		bne.s	loc_100E4
		move.b	d1,$3D(a1)

loc_100E4:
		move.b	#3,ost_frame(a0)
		addq.b	#2,ost_primary_routine(a0)
		andi.b	#-$19,ost_primary_status(a0)

loc_100F4:
		bra.w	loc_1000C
; ===========================================================================

loc_100F8:
		bsr.w	sub_FE70
		bra.w	loc_1000C
; ===========================================================================

loc_10100:
		move.w	ost_x_pos(a0),-(sp)
		btst	#1,ost_primary_status(a0)
		beq.s	loc_1013E
		bsr.w	SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		cmpi.w	#$720,ost_y_pos(a0)
		bcs.s	loc_1014E
		move.w	#$720,ost_y_pos(a0)
		bclr	#1,ost_primary_status(a0)
		move.w	#0,ost_x_vel(a0)			; could be clr.w
		move.w	#0,ost_y_vel(a0)
		move.w	ost_y_pos(a0),$38(a0)
		bra.s	loc_1014E
; ===========================================================================

loc_1013E:
		moveq	#0,d0
		move.b	($FFFFFE74).w,d0
		lsr.w	#1,d0
		add.w	$38(a0),d0
		move.w	d0,ost_y_pos(a0)

loc_1014E:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#0,d3
		move.b	ost_height(a0),d3
		addq.b	#1,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform2,JmpTo_DetectPlatform2
		bra.w	DespawnObject
; ===========================================================================

loc_10166:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	SpeedToPos
		btst	#1,ost_primary_status(a0)
		beq.s	loc_101A2
		addi.w	#$18,ost_y_vel(a0)
		move.w	(v_water_height_normal).w,d0
		cmp.w	ost_y_pos(a0),d0
		bhi.s	loc_101D0
		move.w	d0,ost_y_pos(a0)
		move.w	d0,$38(a0)
		bclr	#1,ost_primary_status(a0)
		move.w	#$100,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		bra.s	loc_101D0
; ===========================================================================

loc_101A2:
		moveq	#0,d0
		move.b	($FFFFFE74).w,d0
		lsr.w	#1,d0
		add.w	$38(a0),d0
		move.w	d0,ost_y_pos(a0)
		tst.w	ost_x_vel(a0)
		beq.s	loc_101D0
		moveq	#0,d3
		move.b	ost_displaywidth(a0),d3
		jsrto	FindWallRightObj,JmpTo_FindWallRightObj
		tst.w	d1
		bpl.s	loc_101D0
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)			; could be clr.w

loc_101D0:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#0,d3
		move.b	ost_height(a0),d3
		addq.b	#1,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform2,JmpTo_DetectPlatform2
		bra.w	DespawnObject
; ===========================================================================

		include "mappings/sprite/OOZ Swinging Platform.asm"
		include "mappings/sprite/ARZ Swinging and Circling Platforms.asm"
		include	"mappings/sprite/CPZ & MCZ Swinging and Tracked Platforms.asm"
		include "mappings/sprite/MCZ Spiked Swinging Platform.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_DetectPlatform2:
		jmp	(DetectPlatform2).l
JmpTo2_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo2_CalcSine:
		jmp	(CalcSine).l
JmpTo_FindWallRightObj:
		jmp	(FindWallRightObj).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 17 - GHZ rotating log helix spikes (from Sonic 1, unused)
; the programming of this was modified somewhat between Sonic 1 and Sonic 2
; ----------------------------------------------------------------------------

Helix:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1031E(pc,d0.w),d1
		jmp	off_1031E(pc,d1.w)
; ===========================================================================
off_1031E:	index offset(*),,2
		ptr loc_10324					; 0
		ptr loc_103E8					; 2
		ptr loc_1044A					; 4
; ===========================================================================

loc_10324:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Hel,ost_mappings(a0)
		move.w	#(vram_SpikePole/sizeof_cell)+tile_pal3,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		_move.b	ost_id(a0),d4
		lea	ost_subtype(a0),a2
		moveq	#0,d1
		move.b	(a2),d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		bcs.s	loc_103E8
		moveq	#0,d6

loc_10372:
		bsr.w	FindNextFreeObj
		bne.s	loc_103E8
		addq.b	#1,ost_subtype(a0)
		move.w	a1,d5
		subi.w	#$B000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,ost_primary_routine(a1)
		_move.b	d4,ost_id(a1)
		move.w	d2,ost_y_pos(a1)
		move.w	d3,ost_x_pos(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	#(vram_SpikePole/sizeof_cell)+tile_pal3,ost_tile(a1)
		bsr.w	AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	d6,$3E(a1)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		cmp.w	ost_x_pos(a0),d3
		bne.s	loc_103E4
		move.b	d6,$3E(a0)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		addq.b	#1,ost_subtype(a0)

loc_103E4:
		dbf	d1,loc_10372

loc_103E8:
		bsr.w	sub_1042A
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	loc_10404
		bra.w	DisplaySprite
; ===========================================================================

loc_10404:
		moveq	#0,d2
		lea	ost_subtype(a0),a2
		move.b	(a2)+,d2

loc_1040C:
		subq.b	#2,d2
		bcs.s	loc_10426

loc_10410:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a1
		bsr.w	DeleteChild
		dbf	d2,loc_10410

loc_10426:
		bra.w	DeleteObject

; ===========================================================================

sub_1042A:
		move.b	(v_syncani_0_frame).w,d0
		move.b	#0,ost_col_type(a0)
		add.b	$3E(a0),d0
		andi.b	#7,d0
		move.b	d0,ost_frame(a0)
		bne.s	locret_10448
		move.b	#id_col_4x16+id_col_hurt,ost_col_type(a0)

locret_10448:
		rts

; ===========================================================================

loc_1044A:
		bsr.w	sub_1042A
		bra.w	DisplaySprite
; ===========================================================================
		include "mappings/sprite/GHZ Spiked Helix Pole (unused).asm"
; ===========================================================================

	if Revision<2
		nop
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 18 - Stationary floating platform in EHZ, ARZ, and HTZ
; ----------------------------------------------------------------------------
Platform1:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_104BA(pc,d0.w),d1
		jmp	off_104BA(pc,d1.w)
; ===========================================================================
off_104BA:	index offset(*),,2
		ptr loc_104CE					; 0
		ptr loc_1056A					; 2
		ptr BranchTo3_DeleteObject			; 4
		ptr loc_105A8					; 6
		ptr loc_105D4					; 8

word_104C4:
		;	ost_width
		;	ost_frame
		dc.b $20, 0
		dc.b $20, 1
		dc.b $20, 2
		dc.b $40, 3
		dc.b $30, 4
; ===========================================================================

loc_104CE:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	word_104C4(pc,d0.w),a2
		move.b	(a2)+,ost_displaywidth(a0)
		move.b	(a2)+,ost_frame(a0)
		move.l	#Map_Plat_EHZ_HTZ,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_pal3,ost_tile(a0)
		cmpi.b	#id_ARZ,(v_zone).w
		bne.s	loc_1050E
		move.l	#Map_Plat_ARZ,ost_mappings(a0)
		move.w	#0+tile_pal3,ost_tile(a0)

loc_1050E:
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_y_pos(a0),$2C(a0)
		move.w	ost_y_pos(a0),$34(a0)
		move.w	ost_x_pos(a0),$32(a0)
		move.w	#$80,ost_angle(a0)
		tst.b	ost_subtype(a0)
		bpl.s	loc_10564
		addq.b	#6,ost_primary_routine(a0)
		andi.b	#$F,ost_subtype(a0)
		move.b	#$30,ost_height(a0)
		cmpi.b	#id_ARZ,(v_zone).w
		bne.s	loc_1055A
		move.b	#$28,ost_height(a0)

loc_1055A:
		bset	#render_useheight_bit,ost_render(a0)
		bra.w	loc_105D4
; ===========================================================================

loc_10564:
		andi.b	#$F,ost_subtype(a0)

loc_1056A:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_10580
		tst.b	$38(a0)
		beq.s	loc_1058C
		subq.b	#4,$38(a0)
		bra.s	loc_1058C
; ===========================================================================

loc_10580:
		cmpi.b	#$40,$38(a0)
		beq.s	loc_1058C
		addq.b	#4,$38(a0)

loc_1058C:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	sub_10638
		bsr.w	sub_1061E
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#8,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform,JmpTo_DetectPlatform
		bra.s	loc_105B0
; ===========================================================================

loc_105A8:
		bsr.w	sub_10638
		bsr.w	sub_1061E

loc_105B0:
		tst.w	(f_two_player).w
		beq.s	loc_105BA
		bra.w	DisplaySprite
; ===========================================================================

loc_105BA:
		move.w	$32(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	BranchTo3_DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

BranchTo3_DeleteObject:
		bra.w	DeleteObject
; ===========================================================================

loc_105D4:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_105EA
		tst.b	$38(a0)
		beq.s	loc_105F6
		subq.b	#4,$38(a0)
		bra.s	loc_105F6
; ===========================================================================

loc_105EA:
		cmpi.b	#$40,$38(a0)
		beq.s	loc_105F6
		addq.b	#4,$38(a0)

loc_105F6:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	sub_10638

loc_105FE:
		bsr.w	sub_1061E
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo_SolidObject
		bra.s	loc_105B0

; ===========================================================================


sub_1061E:
		move.b	$38(a0),d0
		jsrto	CalcSine,JmpTo3_CalcSine
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$2C(a0),d0
		move.w	d0,ost_y_pos(a0)
		rts

; ===========================================================================


sub_10638:
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	off_1064C(pc,d0.w),d1
		jmp	off_1064C(pc,d1.w)

; ===========================================================================
off_1064C:	index offset(*)
		ptr locret_10668				; 0
		ptr loc_1067A					; 1
		ptr loc_106C0					; 2
		ptr loc_106D8					; 3
		ptr loc_10702					; 4
		ptr loc_1066A					; 5
		ptr loc_106B0					; 6
		ptr loc_10778					; 7
		ptr loc_107A4					; 8
		ptr locret_10668				; 9
		ptr loc_107BC					; 10
		ptr loc_107D6					; 11
		ptr loc_106A2					; 12
		ptr loc_10692					; 13
; ===========================================================================

locret_10668:
		rts
; ===========================================================================

loc_1066A:
		move.w	$32(a0),d0
		move.b	ost_angle(a0),d1
		neg.b	d1
		addi.b	#$40,d1
		bra.s	loc_10686
; ===========================================================================

loc_1067A:
		move.w	$32(a0),d0
		move.b	ost_angle(a0),d1
		subi.b	#$40,d1

loc_10686:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,ost_x_pos(a0)
		bra.w	loc_107EE
; ===========================================================================

loc_10692:
		move.w	$34(a0),d0
		move.b	($FFFFFE6C).w,d1
		neg.b	d1
		addi.b	#$30,d1
		bra.s	loc_106CC
; ===========================================================================

loc_106A2:
		move.w	$34(a0),d0
		move.b	($FFFFFE6C).w,d1
		subi.b	#$30,d1
		bra.s	loc_106CC
; ===========================================================================

loc_106B0:
		move.w	$34(a0),d0
		move.b	ost_angle(a0),d1
		neg.b	d1
		addi.b	#$40,d1
		bra.s	loc_106CC
; ===========================================================================

loc_106C0:
		move.w	$34(a0),d0
		move.b	ost_angle(a0),d1
		subi.b	#$40,d1

loc_106CC:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,$2C(a0)
		bra.w	loc_107EE
; ===========================================================================

loc_106D8:
		tst.w	$3A(a0)
		bne.s	loc_106F0
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_106EE
		move.w	#$1E,$3A(a0)

locret_106EE:
		rts
; ===========================================================================

loc_106F0:
		subq.w	#1,$3A(a0)
		bne.s	locret_106EE
		move.w	#$20,$3A(a0)
		addq.b	#1,ost_subtype(a0)
		rts
; ===========================================================================

loc_10702:
		tst.w	$3A(a0)

loc_10706:
		beq.s	loc_10730

loc_10708:
		subq.w	#1,$3A(a0)
		bne.s	loc_10730
		bclr	#3,ost_primary_status(a0)
		beq.s	loc_1071C
		lea	($FFFFB000).w,a1
		bsr.s	sub_1075E

loc_1071C:
		bclr	#4,ost_primary_status(a0)
		beq.s	.do_updatesA
		lea	($FFFFB040).w,a1
		bsr.s	sub_1075E

.do_updatesA:
		move.b	#6,ost_primary_routine(a0)

loc_10730:
		move.l	$2C(a0),d3
		move.w	ost_y_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,$2C(a0)
		addi.w	#$38,ost_y_vel(a0)
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$120,d0
		cmp.w	$2C(a0),d0
		bcc.s	locret_1075C
		move.b	#4,ost_primary_routine(a0)

locret_1075C:
		rts

; ===========================================================================


sub_1075E:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.w	ost_y_vel(a0),ost_y_vel(a1)
		rts

; ===========================================================================

loc_10778:
		tst.w	$3A(a0)
		bne.s	loc_10798
		lea	(v_button_state).w,a2
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#4,d0
		tst.b	(a2,d0.w)
		beq.s	locret_10796
		move.w	#$3C,$3A(a0)

locret_10796:
		rts
; ===========================================================================

loc_10798:
		subq.w	#1,$3A(a0)
		bne.s	locret_10796
		addq.b	#1,ost_subtype(a0)
		rts
; ===========================================================================

loc_107A4:
		subq.w	#2,$2C(a0)
		move.w	$34(a0),d0
		subi.w	#$200,d0
		cmp.w	$2C(a0),d0
		bne.s	locret_107BA
		clr.b	ost_subtype(a0)

locret_107BA:
		rts
; ===========================================================================

loc_107BC:
		move.w	$34(a0),d0
		move.b	ost_angle(a0),d1
		subi.b	#$40,d1
		ext.w	d1
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,$2C(a0)
		bra.w	loc_107EE
; ===========================================================================

loc_107D6:
		move.w	$34(a0),d0
		move.b	ost_angle(a0),d1
		neg.b	d1
		addi.b	#$40,d1
		ext.w	d1
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,$2C(a0)

loc_107EE:
		move.b	($FFFFFE78).w,ost_angle(a0)
		rts
; ===========================================================================

		include "mappings/sprite/EHZ & HTZ Stationary Platforms.asm"
		include "mappings/sprite/ARZ Stationary Platform.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo3_CalcSine:
		jmp	(CalcSine).l
JmpTo_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 1A - Collapsing platform from HPZ (and Sonic 1's GHZ)
; also supports OOZ, but never made use of, so effectively an unused beta leftover
;
; Unlike Object 1F, this supports sloped platforms and subtype-dependent
; mappings. Both were used by GHZ, the latter to allow different shading
; on right-facing ledges.
; ----------------------------------------------------------------------------

CollapseLedge:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_108CA(pc,d0.w),d1
		jmp	off_108CA(pc,d1.w)
; ===========================================================================
off_108CA:	index offset(*),,2
		ptr loc_108D0					; 0
		ptr loc_1097C					; 2
		ptr loc_109B4					; 4
; ===========================================================================

loc_108D0:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Ledge,ost_mappings(a0)
		move.w	#0+tile_pal3,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#7,$38(a0)
		move.b	ost_subtype(a0),ost_frame(a0)
		move.l	#byte_10BF2,$34(a0)
		cmpi.b	#id_HPZ,(v_zone).w
		bne.s	loc_10938
		move.l	#Map_CPlat_HPZ,ost_mappings(a0)
		move.w	#(vram_HPZPlatform/sizeof_cell)+tile_pal3,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$30,ost_displaywidth(a0)
		move.l	#byte_10FEC,$3C(a0)
		move.l	#byte_10C0B,$34(a0)
		bra.s	loc_1097C
; ===========================================================================

loc_10938:
		cmpi.b	#id_OOZ,(v_zone).w
		bne.s	loc_10962
		move.l	#Map_CFlo_OOZ,ost_mappings(a0)
		move.w	#tile_Nem_OOZPlatform+tile_pal4,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$40,ost_displaywidth(a0)
		move.l	#byte_10FDC,$3C(a0)
		bra.s	loc_1097C
; ===========================================================================

loc_10962:
		move.l	#byte_10C3C,$3C(a0)
		move.b	#$34,ost_displaywidth(a0)
		move.b	#$38,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)

loc_1097C:


		tst.b	$3A(a0)
		beq.s	loc_1098E
		tst.b	$38(a0)
		beq.w	loc_10B68
		subq.b	#1,$38(a0)

loc_1098E:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	sub_1099E
		move.b	#1,$3A(a0)

; ===========================================================================

sub_1099E:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		movea.l	$3C(a0),a2
		move.w	ost_x_pos(a0),d4
		jsrto	SlopeObject,JmpTo_SlopeObject
		bra.w	DespawnObject

; ===========================================================================

loc_109B4:
		tst.b	$38(a0)
		beq.s	loc_109F8
		tst.b	$3A(a0)
		bne.s	loc_109C8
		subq.b	#1,$38(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_109C8:
		bsr.w	sub_1099E
		subq.b	#1,$38(a0)
		bne.s	locret_109F6
		lea	($FFFFB000).w,a1
		bsr.s	sub_109DC
		lea	($FFFFB040).w,a1

; ===========================================================================


sub_109DC:
		btst	#3,ost_primary_status(a1)
		beq.s	locret_109F6
		bclr	#3,ost_primary_status(a1)
		bclr	#5,ost_primary_status(a1)
		move.b	#1,ost_anim_restart(a1)

locret_109F6:
		rts

; ===========================================================================

loc_109F8:
		bsr.w	ObjectFall
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 1F - Collapsing platform from ARZ, MCZ and OOZ
; (same object as the collapsing floors in Sonic 1's MZ, SLZ and SBZ)
; ----------------------------------------------------------------------------

CollapseFloor:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_10A16(pc,d0.w),d1
		jmp	off_10A16(pc,d1.w)
; ===========================================================================
off_10A16:	index offset(*),,2
		ptr loc_10A1C					; 0
		ptr loc_10AD6					; 2
		ptr loc_10B0E					; 4
; ===========================================================================

loc_10A1C:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_CFlo_S1,ost_mappings(a0)
		move.w	#(vram_MZPlatform/sizeof_cell)+tile_pal3,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#7,$38(a0)
		move.b	#$44,ost_displaywidth(a0)
		lea	(byte_10C17).l,a4
		btst	#0,ost_subtype(a0)
		beq.s	loc_10A5A
		lea	(byte_10C1F).l,a4

loc_10A5A:
		move.l	a4,$34(a0)
		cmpi.b	#id_OOZ,(v_zone).w
		bne.s	loc_10A86
		move.l	#Map_CFlo_OOZ,ost_mappings(a0)
		move.w	#tile_Nem_OOZPlatform+tile_pal4,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$40,ost_displaywidth(a0)
		move.l	#byte_10C27,$34(a0)

loc_10A86:
		cmpi.b	#id_MCZ,(v_zone).w
		bne.s	loc_10AAE
		move.l	#Map_CFlo_MCZ,ost_mappings(a0)
		move.w	#tile_Nem_MCZCollapsingPlat+tile_pal4,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$20,ost_displaywidth(a0)
		move.l	#byte_10C2E,$34(a0)

loc_10AAE:
		cmpi.b	#id_ARZ,(v_zone).w
		bne.s	loc_10AD6
		move.l	#Map_CFlo_ARZ,ost_mappings(a0)
		move.w	#0+tile_pal3,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$20,ost_displaywidth(a0)
		move.l	#byte_10C34,$34(a0)

loc_10AD6:
		tst.b	$3A(a0)
		beq.s	loc_10AE8
		tst.b	$38(a0)
		beq.w	loc_10B62
		subq.b	#1,$38(a0)

loc_10AE8:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	sub_10AF8
		move.b	#1,$3A(a0)

; ===========================================================================

sub_10AF8:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		move.w	#$10,d3
		move.w	ost_x_pos(a0),d4
		jsrto	DetectPlatform,JmpTo2_DetectPlatform
		bra.w	DespawnObject

; ===========================================================================

loc_10B0E:
		tst.b	$38(a0)
		beq.s	loc_10B52
		tst.b	$3A(a0)
		bne.s	loc_10B22
		subq.b	#1,$38(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_10B22:
		bsr.w	sub_10AF8
		subq.b	#1,$38(a0)
		bne.s	locret_10B50
		lea	($FFFFB000).w,a1
		bsr.s	sub_10B36
		lea	($FFFFB040).w,a1

; ===========================================================================


sub_10B36:
		btst	#3,ost_primary_status(a1)
		beq.s	locret_10B50
		bclr	#3,ost_primary_status(a1)
		bclr	#5,ost_primary_status(a1)
		move.b	#1,ost_anim_restart(a1)

locret_10B50:
		rts

; ===========================================================================

loc_10B52:
		bsr.w	ObjectFall
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_10B62:
		addq.b	#1,ost_frame(a0)
		bra.s	loc_10B6C
; ===========================================================================

loc_10B68:
		addq.b	#2,ost_frame(a0)

loc_10B6C:
		movea.l	$34(a0),a4
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		add.w	d0,d0
		movea.l	ost_mappings(a0),a3
		adda.w	(a3,d0.w),a3
		move.w	(a3)+,d1
		subq.w	#1,d1
		bset	#render_rawmap_bit,ost_render(a0)
		_move.b	ost_id(a0),d4
		move.b	ost_render(a0),d5
		movea.l	a0,a1
		bra.s	loc_10B9E
; ===========================================================================

loc_10B96:
		bsr.w	FindFreeObj
		bne.s	loc_10BE4
		addq.w	#8,a3

loc_10B9E:
		move.b	#4,ost_primary_routine(a1)
		_move.b	d4,ost_id(a1)
		move.l	a3,ost_mappings(a1)
		move.b	d5,ost_render(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	ost_priority(a0),ost_priority(a1)
		move.b	ost_displaywidth(a0),ost_displaywidth(a1)
		move.b	ost_height(a0),ost_height(a1)
		move.b	(a4)+,$38(a1)
		cmpa.l	a0,a1
		bcc.s	loc_10BE0
		bsr.w	DisplaySprite2

loc_10BE0:
		dbf	d1,loc_10B96

loc_10BE4:
		bsr.w	DisplaySprite
		move.w	#$B9,d0
		jmp	(PlaySound).l
; ===========================================================================
byte_10BF2:
		dc.b $1C,$18,$14,$10,$1A,$16,$12, $E, $A,  6,$18,$14,$10, $C,  8,  4 ; 0
		dc.b $16,$12, $E, $A,  6,  2,$14,$10, $C	; 16

byte_10C0B:
		dc.b $18,$1C,$20,$1E,$1A,$16,  6, $E,$14,$12, $A,  2 ; 0

byte_10C17:
		dc.b $1E,$16, $E,  6,$1A,$12, $A,  2		; 0

byte_10C1F:
		dc.b $16,$1E,$1A,$12,  6, $E, $A,  2		; 0

byte_10C27:
		dc.b $1A,$12, $A,  2,$16, $E,  6		; 0

byte_10C2E:
		dc.b $1A,$16,$12, $E, $A,  2			; 0

byte_10C34:
		dc.b $16,$1A,$18,$12,  6, $E, $A,  2		; 0

; Unused Sonic 1 leftover: slope data for GHZ collapsing ledges
byte_10C3C:
		dc.b $20,$20,$20,$20,$20,$20,$20,$20,$21,$21,$22,$22,$23,$23,$24,$24 ; 0
		dc.b $25,$25,$26,$26,$27,$27,$28,$28,$29,$29,$2A,$2A,$2B,$2B,$2C,$2C ; 16
		dc.b $2D,$2D,$2E,$2E,$2F,$2F,$30,$30,$30,$30,$30,$30,$30,$30,$30,$30 ; 32

		include	"mappings/sprite/GHZ Collapsing Ledge (unused).asm"
		include	"mappings/sprite/MZ, SLZ, & SBZ Collapsing Floors (unused).asm"

; Unused beta leftovers: slope data for HPZ and OOZ collapsing platforms
; (required due to how the object is coded)
byte_10FDC:
		rept 16
		dc.b $10
		endr

byte_10FEC:
		rept 48
		dc.b $10
		endr


		include	"mappings/sprite/HPZ Collapsing Platform (unused).asm"
		include	"mappings/sprite/OOZ Collapsing Platform.asm"
		include "mappings/sprite/MCZ Collapsing Platform.asm"
		include	"mappings/sprite/ARZ Collapsing Platform.asm"


; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_SlopeObject:
		jmp	(SlopeObject).l
JmpTo2_DetectPlatform:
		jmp	(DetectPlatform).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 1C - EHZ bridge stakes, HTZ tram posts, and OOZ falling oil
; ----------------------------------------------------------------------------

Scenery1:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Scenery1_Index(pc,d0.w),d1
		jmp	Scenery1_Index(pc,d1.w)
; ===========================================================================
Scenery1_Index:	index offset(*),,2
		ptr loc_112A4					; 0
		ptr loc_112EC					; 2

Scenery1_ObjData:
		sceneryobjdata	id_Frame_Rope1,Map_BoltEnd_Rope,tile_Nem_BoltEnd_Rope+tile_pal3,4,6 ; end of looped rope emerging from lava (right)
		sceneryobjdata	id_Frame_Rope2,Map_BoltEnd_Rope,tile_Nem_BoltEnd_Rope+tile_pal3,4,6 ; end of looped rope emerging from lava (left)
		sceneryobjdata	1,Map_EmeraldHillBridge,tile_Nem_EHZBridge+tile_pal3,4,1
		sceneryobjdata	id_Frame_BoltEnd,Map_BoltEnd_Rope,tile_Nem_BoltEnd_Rope+tile_pal2,$10,6 ; bottom tip of hanging bolts
		sceneryobjdata	3,Map_Tram,tile_Nem_Tram+tile_pal3,8,4
		sceneryobjdata	4,Map_Tram,tile_Nem_Tram+tile_pal3,8,4
		sceneryobjdata	1,Map_Tram,tile_Nem_Tram+tile_pal3,$20,1
		sceneryobjdata	0,Map_TramStake,tile_LevelArt+tile_pal3,8,1
		sceneryobjdata	1,Map_TramStake,tile_LevelArt+tile_pal3,8,1
		sceneryobjdata	0,Map_ARZUnusedScenery,tile_Art_Waterfall3+tile_pal3,4,4 ; unused, appears to be a small slice of ground
		sceneryobjdata	0,Map_NarrowFallingOil,tile_Nem_OilFall2+tile_pal3,4,4
		sceneryobjdata	1,Map_NarrowFallingOil,tile_Nem_OilFall2+tile_pal3,4,4
		sceneryobjdata	2,Map_NarrowFallingOil,tile_Nem_OilFall2+tile_pal3,4,4
		sceneryobjdata	3,Map_NarrowFallingOil,tile_Nem_OilFall2+tile_pal3,4,4
		sceneryobjdata	4,Map_NarrowFallingOil,tile_Nem_OilFall2+tile_pal3,4,4
		sceneryobjdata	5,Map_NarrowFallingOil,tile_Nem_OilFall2+tile_pal3,4,4
		sceneryobjdata	0,Map_WideFallingOil,tile_Nem_OilFall2+tile_pal3,$18,4
		sceneryobjdata	1,Map_WideFallingOil,tile_Nem_OilFall2+tile_pal3,$18,4
		sceneryobjdata	2,Map_WideFallingOil,tile_Nem_OilFall2+tile_pal3,8,4
		sceneryobjdata	3,Map_WideFallingOil,tile_Nem_OilFall2+tile_pal3,8,4
		sceneryobjdata	4,Map_WideFallingOil,tile_Nem_OilFall2+tile_pal3,8,4


Scenery1_Radii:
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b   0					; 2
		dc.b   0					; 3
	if FixBugs
		; These entries are for the Hill Top Zone tram poles.
		; Using 0 here is good for objects that are at most 32 pixels tall, but these are 40
		; pixels tall, so they need to be explicitly set here.
		; This fixes these objects disappearing when they're partially off-screen vertically.
		dc.b $28
		dc.b $28
	else
		dc.b   0					; 4
		dc.b   0					; 5
	endc
		dc.b   0					; 6
		dc.b   0					; 7
		dc.b   0					; 8
		dc.b   0					; 9
		dc.b   0					; 10
		dc.b   0					; 11
		dc.b   0					; 12
		dc.b $30					; 13
		dc.b $40					; 14
		dc.b $60					; 15
		dc.b   0					; 16
		dc.b   0					; 17
		dc.b $30					; 18
		dc.b $40					; 19
		dc.b $50					; 20
		dc.b   0					; 21
; ===========================================================================

loc_112A4:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.w	d0,d1
		lsl.w	#3,d0
		lea	Scenery1_ObjData(pc),a1
		lea	(a1,d0.w),a1
		move.b	(a1),ost_frame(a0)
		move.l	(a1)+,ost_mappings(a0)
		move.w	(a1)+,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	(a1)+,ost_displaywidth(a0)
		move.b	(a1)+,ost_priority(a0)
		lea	Scenery1_Radii(pc),a1
		move.b	(a1,d1.w),d1
		beq.s	loc_112EC
		move.b	d1,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)

loc_112EC:
		bra.w	DespawnObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 71 - ; MTZ lava bubble, HPZ bridge stake, and HPZ pulsing orb
; ----------------------------------------------------------------------------

Scenery2:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Scenery2_Index(pc,d0.w),d1
		jmp	Scenery2_Index(pc,d1.w)
; ===========================================================================
Scenery2_Index:	index offset(*),,2
		ptr loc_1131A					; 0
		ptr loc_1135C					; 2

Scenery2_ObjData:
		sceneryobjdata	3,Map_HiddenPalaceBridge,(vram_HiddenPalaceBridge/sizeof_cell)+tile_pal4,4,1
		sceneryobjdata	0,Map_HiddenPalaceOrb,(vram_HiddenPalaceOrb/sizeof_cell)+tile_pal4+tile_hi,$10,1
		sceneryobjdata	0,Map_LavaBubble,tile_Nem_LavaBubble+tile_pal3,$10,1
; ===========================================================================

loc_1131A:
		addq.b	#2,ost_primary_routine(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lsl.w	#3,d0
		lea	Scenery2_ObjData(pc),a1
		lea	(a1,d0.w),a1
		move.b	(a1),ost_frame(a0)
		move.l	(a1)+,ost_mappings(a0)
		move.w	(a1)+,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	(a1)+,ost_displaywidth(a0)
		move.b	(a1)+,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#$F0,d0
		lsr.b	#4,d0
		move.b	d0,ost_anim(a0)

loc_1135C:
		lea	(Ani_Scenery2).l,a1			; could be PC-relative
		bsr.w	AnimateSprite
		bra.w	DespawnObject
; ===========================================================================
Ani_Scenery2:
		dc.w byte_11372-Ani_Scenery2			; 0
		dc.w byte_1137A-Ani_Scenery2			; 1
		dc.w byte_11389-Ani_Scenery2			; 2
		dc.w byte_11392-Ani_Scenery2			; 3
byte_11372:	dc.b   8,  3,  3,  4,  5,  5,  4,$FF		; 0
byte_1137A:	dc.b   5,  0,  0,  0,  1,  2,  3,  3,  2,  1,  2,  3,  3,  1,$FF ; 0
byte_11389:	dc.b  $B,  0,  1,  2,  3,  4,  5,$FD,  3	; 0
byte_11392:	dc.b $7F,  6,$FD,  2				; 0


		include	"mappings/sprite/HPZ Orb (unused).asm"
		include	"mappings/sprite/HTZ Tram Stakes.asm"
		include	"mappings/sprite/ARZ Ground Slice (unused).asm"
		include "mappings/sprite/OOZ Narrow Falling Oil.asm"
		include "mappings/sprite/OOZ Wide Falling Oil.asm"
		include "mappings/sprite/MTZ Bolt End and Ropes Emerging from Lava.asm"
		include "mappings/sprite/MTZ Lava Bubble.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 2A - MCZ Stomper
; ----------------------------------------------------------------------------

Stomper:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_115D2(pc,d0.w),d1
		jmp	off_115D2(pc,d1.w)
; ===========================================================================
off_115D2:	index offset(*),,2
		ptr loc_115D6					; 0
		ptr loc_11610					; 2
; ===========================================================================

loc_115D6:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Stomper,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_pal3,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.b	#$50,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)

loc_11610:
		tst.b	ost_secondary_routine(a0)
		bne.s	loc_1162A
		addq.w	#1,$30(a0)
		cmpi.w	#$60,$30(a0)
		bne.s	loc_1163C
		move.b	#2,ost_secondary_routine(a0)
		bra.s	loc_1163C
; ===========================================================================

loc_1162A:
		subq.w	#8,$30(a0)
		bhi.s	loc_1163C
		move.w	#0,$30(a0)
		move.b	#0,ost_secondary_routine(a0)

loc_1163C:
		move.w	$32(a0),d0
		sub.w	$30(a0),d0
		move.w	d0,ost_y_pos(a0)
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#$40,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo2_SolidObject
		bra.w	DespawnObject
; ===========================================================================

		include "mappings/sprite/MCZ Stomper.asm"

; ----------------------------------------------------------------------------
; Object 2D - CPZ, HTZ, MTZ, WFZ, and DEZ one-way door
; (also supports ARZ, but never used)
; ----------------------------------------------------------------------------

AutoDoor:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ADoor_Index(pc,d0.w),d1
		jmp	ADoor_Index(pc,d1.w)
; ===========================================================================
ADoor_Index:	index offset(*),,2
		ptr ADoor_Init					; 0
		ptr ADoor_OpenShut				; 2

		rsobj	AutoDoor,$30
ost_adoor_motion:		equ ost_secondary_routine	; $25; 0 if door is closed or closing, 2 if open or opening
ost_adoor_y_delta:		rs.w 1 ; $30; distance in pixels that door has retracted
ost_adoor_og_ypos:		rs.w 1 ; $32; initial y pos of door
		rsset $38
ost_adoor_rangeleft:	rs.w 1 ; $38; left limit of range within which door opens
ost_adoor_rangeright:	rs.w 1 ; $3A; right limit of range within which door opens
		rsobjend
; ===========================================================================

ADoor_Init:							; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to ADoor_OpenShut next
		move.l	#Map_Barrier,ost_mappings(a0)
		move.w	#tile_Nem_HTZOneWayBarrier+tile_pal2,ost_tile(a0)
		move.b	#16/2,ost_displaywidth(a0)
		cmpi.b	#id_MTZ,(v_zone).w			; is it MTZ acts 1 or 2?
		beq.s	.is_mtz					; if so, branch
		cmpi.b	#id_MTZ_2,(v_zone).w			; is it MTZ act 3?
		bne.s	.not_mtz				; if not, branch

	.is_mtz:
		move.w	#tile_LevelArt+tile_pal4,ost_tile(a0)
		move.b	#24/2,ost_displaywidth(a0)

	.not_mtz:
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		bne.s	.not_cpz				; branch if not
		move.w	#tile_Nem_ConstructionStripes_CPZ+tile_pal2,ost_tile(a0)
		move.b	#16/2,ost_displaywidth(a0)		; (redundant)

	.not_cpz:
		cmpi.b	#id_DEZ,(v_zone).w			; is it DEZ?
		bne.s	.not_dez				; branch if not
		move.w	#tile_Nem_ConstructionStripes_DEZ+tile_pal2,ost_tile(a0)
		move.b	#16/2,ost_displaywidth(a0)		; (redundant)

	.not_dez:
		cmpi.b	#id_ARZ,(v_zone).w
		bne.s	.not_arz
		move.w	#tile_Nem_ARZBarrier+tile_pal2,ost_tile(a0)
		move.b	#16/2,ost_displaywidth(a0)		; (redundant)

	.not_arz:
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_y_pos(a0),ost_adoor_og_ypos(a0)
		move.b	ost_subtype(a0),ost_frame(a0)		; subtype is frame ID (though a bug means only HTZ and MTZ's are used
		move.w	ost_x_pos(a0),d2
		move.w	d2,d3
		subi.w	#512,d2					; door opens when player is within 512px of front
		addi.w	#24,d3					; door remains open until player is 24px beyond door
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	.no_xflip				; branch if door isn't x-flipped
		subi.w	#-($200-$18),d2				; invert detection ranges
		addi.w	#($200-$18),d3

	.no_xflip:
		move.w	d2,ost_adoor_rangeleft(a0)
		move.w	d3,ost_adoor_rangeright(a0)

ADoor_OpenShut:	; Routine 2
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	.x_flip					; branch if door is x-flipped

		move.w	ost_adoor_rangeleft(a0),d2		; d2 = front range limit
		move.w	ost_x_pos(a0),d3			; d3 = door x pos
		tst.b	ost_adoor_motion(a0)			; is door closed?
		beq.s	ADoor_ChkPlayers			; branch if so (check if player is within range to open door)
		move.w	ost_adoor_rangeright(a0),d3		; d3 = rear range limit
		bra.s	ADoor_ChkPlayers			; check if player is within range to keep door open
; ===========================================================================

	.x_flip:
		move.w	ost_x_pos(a0),d2			; d2 = door x pos
		move.w	ost_adoor_rangeright(a0),d3		; d3 = front range limit
		tst.b	ost_adoor_motion(a0)			; is door closed?
		beq.s	ADoor_ChkPlayers			; branch if so (check if player is within range to open door)
		move.w	ost_adoor_rangeleft(a0),d2		; d2 = rear range limit
		; fall through (check if player is within range to keep door open)

ADoor_ChkPlayers:
		move.w	ost_adoor_og_ypos(a0),d4		; get initial y pos
		move.w	d4,d5
		subi.w	#32,d4					; set y range for detection
		addi.w	#32,d5					; (32px above and below initial y pos)
		move.b	#0,ost_adoor_motion(a0)			; door is closed by default
		lea	(v_ost_player1).w,a1
		bsr.s	ADoor_CheckPlayer			; check player 1
		lea	(v_ost_player2).w,a1
		bsr.s	ADoor_CheckPlayer			; check player 2

		tst.b	ost_adoor_motion(a0)
		beq.s	.door_closing				; branch if door is closing
		cmpi.w	#64,ost_adoor_y_delta(a0)
		beq.s	ADoor_ChkSolid				; branch if door is fully open
		addq.w	#8,ost_adoor_y_delta(a0)		; move door up 8px
		bra.s	.set_y
; ===========================================================================

	.door_closing:
		tst.w	ost_adoor_y_delta(a0)
		beq.s	ADoor_ChkSolid				; branch if door is fully closed
		subq.w	#8,ost_adoor_y_delta(a0)		; move door down 8px

	.set_y:
		move.w	ost_adoor_og_ypos(a0),d0
		sub.w	ost_adoor_y_delta(a0),d0		; d0 = new y pos of door
		move.w	d0,ost_y_pos(a0)

ADoor_ChkSolid:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#11,d1
		move.w	#64/2,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo2_SolidObject
		bra.w	DespawnObject

; ----------------------------------------------------------------------------
; Subroutine to check if player is within door's range

; input:
;	d2 = left range limit
;	d3 = right range limit
;	d4 = top range limit
; 	d5 = bottom range limit
; ----------------------------------------------------------------------------

ADoor_CheckPlayer:
		move.w	ost_x_pos(a1),d0			; d0 = player x pos
		cmp.w	d2,d0
		blt.w	.done					; branch if player is left of door's range
		cmp.w	d3,d0
		bcc.w	.done					; branch if player is right of door's range

		move.w	ost_y_pos(a1),d0			; d0 = player y pos
		cmp.w	d4,d0
		bcs.w	.done					; branch if player is above door's range
		cmp.w	d5,d0
		bcc.w	.done					; branch if player is below door's range

		tst.b	ost_obj_control(a1)
		bmi.s	.done					; branch if object collision is disabled

		move.b	#2,ost_adoor_motion(a0)			; set door to open

	.done:
		rts

; ===========================================================================

		include	"mappings/sprite/CPZ, ARZ, HTZ, MTZ, WFZ, & DEZ One-Way Door.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo2_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 28 - Animals
; ----------------------------------------------------------------------------

Animals:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Anml_Index(pc,d0.w),d1
		jmp	Anml_Index(pc,d1.w)
; ===========================================================================
Anml_Index:	index offset(*),,2
		ptr Anml_Main					; 0
		ptr loc_11ADE					; 2
		ptr loc_11B38					; 4
		ptr loc_11B74					; 6
		ptr loc_11B38					; 8
		ptr loc_11B38					; $A
		ptr loc_11B38					; $C
		ptr loc_11B74					; $E
		ptr loc_11B38					; $10
		ptr loc_11B74					; $12
		ptr loc_11B38					; $14
		ptr loc_11B38					; $16
		ptr loc_11B38					; $18
		ptr loc_11B38					; $1A
		ptr loc_11BF4					; $1C

	; Routines below are unused Sonic 1 leftovers:
	; these managed the animals in that game's ending sequence.
		ptr loc_11C14					; $1E
		ptr loc_11C14					; $20
		ptr loc_11C34					; $22
		ptr loc_11C6E					; $24
		ptr loc_11CC8					; $26
		ptr loc_11CE6					; $28
		ptr loc_11CC8					; $2A
		ptr loc_11CE6					; $2C
		ptr loc_11CC8					; $2E
		ptr loc_11D24					; $30
		ptr loc_11C8A					; $30

; ===========================================================================
; ---------------------------------------------------------------------------
; Declare which animals will appear in each level.
; When an enemy is destroyed, one of the two animals listed for the zone will
; be chosen randomly. Note that the corresponding art for each animal
; MUST be loaded in the level's PLC list.
; ---------------------------------------------------------------------------

zoneanmls:	macro	first,second
		dc.b	\first
		dc.b	\second
		endm

Anml_VarIndex:
		zoneanmls	id_Squirrel,id_Flicky		; EHZ;		0, 1
		zoneanmls	id_Squirrel,id_Flicky		; Zone 1;	2, 3
		zoneanmls	id_Squirrel,id_Flicky		; WZ;		4, 5
		zoneanmls	id_Squirrel,id_Flicky		; Zone 3;	6, 7
		zoneanmls	id_Beaver,	id_Eagle	; MTZ 1/2;	8, 9
		zoneanmls	id_Beaver,	id_Eagle	; MTZ 3;	$A, $B
		zoneanmls	id_Beaver,	id_Eagle	; WFZ;		$C, $D
		zoneanmls	id_Beaver,	id_Eagle	; HTZ;		$E, $F
		zoneanmls	id_Mouse,	id_Seal		; HPZ;		$10, $11
		zoneanmls	id_Mouse,	id_Seal		; Zone 9;	$12, $13
		zoneanmls	id_Penguin,	id_Seal		; OOZ;		$14, $15
		zoneanmls	id_Mouse,	id_Chicken	; MCZ;		$16, $17
		zoneanmls	id_Bear,	id_Flicky	; CNZ;		$18, $19
		zoneanmls	id_Rabbit,	id_Eagle	; CPZ;		$1A, $1B
		zoneanmls	id_Pig,		id_Chicken	; DEZ;		$1C, $1D
		zoneanmls	id_Penguin,	id_Flicky	; ARZ;		$1E, $1F
		zoneanmls	id_Turtle,	id_Chicken	; SCZ;		$20, $21

		zonewarning	Anml_VarIndex,2

; ---------------------------------------------------------------------------
; Declare the speeds and mappings for each animal, and generate IDs for use
; in Anml_VarIndex.
; ---------------------------------------------------------------------------

anmldecl:	macro	*,xvel,yvel,mappings

\* equ *

	Anml_\*_Vars:
		dc.w \xvel,\yvel
		dc.l \mappings

		id_\*:	equ	ptr_id				; make id constant

		ptr_id: = ptr_id+ptr_id_inc			; increment id
		endm

Anml_Variables:
		ptr_id:		= 0
		ptr_id_inc: = 1

Rabbit:		anmldecl -$200,-$400,Map_Animal5		; 0
Chicken:	anmldecl -$200,-$300,Map_Animal1		; 1
Penguin:	anmldecl -$180,-$300,Map_Animal5		; 2
Seal:		anmldecl -$140,-$180,Map_Animal4		; 3
Pig:		anmldecl -$1C0,-$300,Map_Animal3		; 4
Flicky:		anmldecl -$300,-$400,Map_Animal1		; 5
Squirrel:	anmldecl -$280,-$380,Map_Animal2		; 6
Eagle:		anmldecl -$280,-$300,Map_Animal1		; 7
Mouse:		anmldecl -$200,-$380,Map_Animal2		; 8
Beaver:		anmldecl -$2C0,-$300,Map_Animal2		; 9
Turtle:		anmldecl -$140,-$200,Map_Animal2		; $A
Bear:		anmldecl -$200,-$300,Map_Animal2		; $B

; ===========================================================================
; ---------------------------------------------------------------------------
; Unused Sonic 1 leftover: speeds, mapping pointers, and tile settings
; for animals in that game's ending sequence.
; ---------------------------------------------------------------------------

Anml_EndSpeeds:
		dc.w -$440, -$400				; 0
		dc.w -$440, -$400				; 2
		dc.w -$440, -$400				; 4
		dc.w -$300, -$400				; 6
		dc.w -$300, -$400				; 8
		dc.w -$180, -$300				; 10
		dc.w -$180, -$300				; 12
		dc.w -$140, -$180				; 14
		dc.w -$1C0, -$300				; 16
		dc.w -$200, -$300				; 18
		dc.w -$280, -$380				; 20

Anml_EndMap:
		dc.l Map_Animal1				; 2
		dc.l Map_Animal1				; 2
		dc.l Map_Animal1				; 2
		dc.l Map_Animal5				; 1
		dc.l Map_Animal5				; 1
		dc.l Map_Animal5				; 1
		dc.l Map_Animal5				; 1
		dc.l Map_Animal4				; 7
		dc.l Map_Animal3				; 8
		dc.l Map_Animal1				; 2
		dc.l Map_Animal2				; 10

Anml_EndVram:
		dc.w  vram_Flicky_End/sizeof_cell		; 0
		dc.w  vram_Flicky_End/sizeof_cell		; 2
		dc.w  vram_Flicky_End/sizeof_cell		; 4
		dc.w  vram_Rabbit_End/sizeof_cell		; 6
		dc.w  vram_Rabbit_End/sizeof_cell		; 8
		dc.w  vram_Penguin_End/sizeof_cell		; $A
		dc.w  vram_Penguin_End/sizeof_cell		; $C
		dc.w  vram_Seal_End/sizeof_cell			; $E
		dc.w  vram_Pig_End/sizeof_cell			; $10
		dc.w  vram_Chicken_End/sizeof_cell		; $12
		dc.w  vram_Squirrel_End/sizeof_cell		; $14

; ===========================================================================

Anml_Main:
		tst.b	ost_subtype(a0)				; did animal come from an enemy or prison capsule? (it always will)
		beq.w	Anml_FromEnemy				; if so, branch

	;.Anml_Ending:	; unused Sonic 1 leftover: spawns animals in that game's ending sequence
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		move.b	d0,ost_primary_routine(a0)
		subi.w	#$14,d0
		move.w	Anml_EndVram(pc,d0.w),ost_tile(a0)
		add.w	d0,d0
		move.l	Anml_EndMap(pc,d0.w),ost_mappings(a0)
		lea	Anml_EndSpeeds(pc),a1
		move.w	(a1,d0.w),$32(a0)
		move.w	(a1,d0.w),ost_x_vel(a0)
		move.w	2(a1,d0.w),$34(a0)
		move.w	2(a1,d0.w),ost_y_vel(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$C,ost_height(a0)
		move.b	#render_rel,ost_render(a0)
		bset	#render_xflip_bit,ost_render(a0)
		move.b	#6,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#7,ost_anim_time(a0)
		bra.w	DisplaySprite
; ===========================================================================

Anml_FromEnemy:
		addq.b	#2,ost_primary_routine(a0)
		jsrto	RandomNumber,JmpTo_RandomNumber
		move.w	#tile_Nem_Squirrel,ost_tile(a0)		; VRAM common to first animal
		andi.w	#1,d0
		beq.s	loc_11A46
		move.w	#tile_Nem_Flicky,ost_tile(a0)

loc_11A46:
		moveq	#0,d1
		move.b	(v_zone).w,d1
		add.w	d1,d1
		add.w	d0,d1
		lea	Anml_VarIndex(pc),a1
		move.b	(a1,d1.w),d0
		move.b	d0,$30(a0)
		lsl.w	#3,d0
		lea	Anml_Variables(pc),a1
		adda.w	d0,a1
		move.w	(a1)+,$32(a0)
		move.w	(a1)+,$34(a0)
		move.l	(a1)+,ost_mappings(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$C,ost_height(a0)
		move.b	#render_rel,ost_render(a0)
		bset	#render_xflip_bit,ost_render(a0)
		move.b	#6,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#7,ost_anim_time(a0)
		move.b	#2,ost_frame(a0)
		move.w	#-$400,ost_y_vel(a0)
		tst.b	$38(a0)
		bne.s	loc_11AD0
		bsr.w	FindFreeObj
		bne.s	loc_11ACC
		_move.b	#id_Points,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	$3E(a0),d0
		lsr.w	#1,d0
		move.b	d0,ost_frame(a1)

loc_11ACC:
		bra.w	DisplaySprite
; ===========================================================================

loc_11AD0:
		move.b	#$1C,ost_primary_routine(a0)
		clr.w	ost_x_vel(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_11ADE:
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		bsr.w	ObjectFall
		tst.w	ost_y_vel(a0)
		bmi.s	loc_11B34
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_11B34
		add.w	d1,ost_y_pos(a0)
		move.w	$32(a0),ost_x_vel(a0)
		move.w	$34(a0),ost_y_vel(a0)
		move.b	#1,ost_frame(a0)
		move.b	$30(a0),d0
		add.b	d0,d0
		addq.b	#4,d0
		move.b	d0,ost_primary_routine(a0)
		tst.b	$38(a0)
		beq.s	loc_11B34
		btst	#4,(v_vblank_counter_byte).w
		beq.s	loc_11B34
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)

loc_11B34:
		bra.w	DisplaySprite
; ===========================================================================

loc_11B38:
		bsr.w	ObjectFall
		move.b	#1,ost_frame(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_11B62
		move.b	#0,ost_frame(a0)
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_11B62
		add.w	d1,ost_y_pos(a0)
		move.w	$34(a0),ost_y_vel(a0)

loc_11B62:
		tst.b	ost_subtype(a0)
		bne.s	loc_11BD8
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_11B74:
		bsr.w	SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_11BB0
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_11BB0
		add.w	d1,ost_y_pos(a0)
		move.w	$34(a0),ost_y_vel(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_11BB0
		cmpi.b	#$A,ost_subtype(a0)
		beq.s	loc_11BB0
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)

loc_11BB0:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_11BC6
		move.b	#1,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		andi.b	#1,ost_frame(a0)

loc_11BC6:
		tst.b	ost_subtype(a0)
		bne.s	loc_11BD8
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_11BD8:
		move.w	ost_x_pos(a0),d0
		sub.w	($FFFFB008).w,d0
		bcs.s	loc_11BF0
		subi.w	#$180,d0
		bpl.s	loc_11BF0
		tst.b	ost_render(a0)
		bpl.w	DeleteObject

loc_11BF0:
		bra.w	DisplaySprite
; ===========================================================================

loc_11BF4:
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		subq.w	#1,$36(a0)
		bne.w	loc_11C10
		move.b	#2,ost_primary_routine(a0)
		move.b	#1,ost_priority(a0)

loc_11C10:
		bra.w	DisplaySprite
; ===========================================================================

loc_11C14:
		bsr.w	sub_11DB8
		bcc.s	loc_11C30
		move.w	$32(a0),ost_x_vel(a0)
		move.w	$34(a0),ost_y_vel(a0)
		move.b	#$E,ost_primary_routine(a0)
		bra.w	loc_11B74
; ===========================================================================

loc_11C30:
		bra.w	loc_11BD8
; ===========================================================================

loc_11C34:
		bsr.w	sub_11DB8
		bpl.s	loc_11C6A
		clr.w	ost_x_vel(a0)
		clr.w	$32(a0)
		bsr.w	SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		bsr.w	sub_11D78
		bsr.w	sub_11DA0
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_11C6A
		move.b	#1,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		andi.b	#1,ost_frame(a0)

loc_11C6A:
		bra.w	loc_11BD8
; ===========================================================================

loc_11C6E:
		bsr.w	sub_11DB8
		bpl.s	loc_11CC4
		move.w	$32(a0),ost_x_vel(a0)
		move.w	$34(a0),ost_y_vel(a0)
		move.b	#4,ost_primary_routine(a0)
		bra.w	loc_11B38
; ===========================================================================

loc_11C8A:
		bsr.w	ObjectFall
		move.b	#1,ost_frame(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_11CC4
		move.b	#0,ost_frame(a0)
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_11CC4
		not.b	$29(a0)
		bne.s	loc_11CBA
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)

loc_11CBA:
		add.w	d1,ost_y_pos(a0)
		move.w	$34(a0),ost_y_vel(a0)

loc_11CC4:
		bra.w	loc_11BD8
; ===========================================================================

loc_11CC8:
		bsr.w	sub_11DB8
		bpl.s	loc_11CE2
		clr.w	ost_x_vel(a0)
		clr.w	$32(a0)
		bsr.w	ObjectFall
		bsr.w	sub_11D78
		bsr.w	sub_11DA0

loc_11CE2:
		bra.w	loc_11BD8
; ===========================================================================

loc_11CE6:
		bsr.w	sub_11DB8
		bpl.s	loc_11D20
		bsr.w	ObjectFall
		move.b	#1,ost_frame(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_11D20
		move.b	#0,ost_frame(a0)
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_11D20
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		add.w	d1,ost_y_pos(a0)
		move.w	$34(a0),ost_y_vel(a0)

loc_11D20:
		bra.w	loc_11BD8
; ===========================================================================

loc_11D24:
		bsr.w	sub_11DB8
		bpl.s	loc_11D74
		bsr.w	SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_11D5E
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_11D5E
		not.b	$29(a0)
		bne.s	loc_11D54
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)

loc_11D54:
		add.w	d1,ost_y_pos(a0)
		move.w	$34(a0),ost_y_vel(a0)

loc_11D5E:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_11D74
		move.b	#1,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		andi.b	#1,ost_frame(a0)

loc_11D74:
		bra.w	loc_11BD8

; ===========================================================================


sub_11D78:
		move.b	#1,ost_frame(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	locret_11D9E
		move.b	#0,ost_frame(a0)
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	locret_11D9E
		add.w	d1,ost_y_pos(a0)
		move.w	$34(a0),ost_y_vel(a0)

locret_11D9E:
		rts

; ===========================================================================


sub_11DA0:
		bset	#render_xflip_bit,ost_render(a0)
		move.w	ost_x_pos(a0),d0
		sub.w	($FFFFB008).w,d0
		bcc.s	locret_11DB6
		bclr	#render_xflip_bit,ost_render(a0)

locret_11DB6:
		rts

; ===========================================================================


sub_11DB8:
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		subi.w	#$B8,d0
		rts

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 29 - "100 points" text
; ----------------------------------------------------------------------------

Points:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Poi_Index(pc,d0.w),d1
		jmp	Poi_Index(pc,d1.w)
; ===========================================================================
Poi_Index:	index offset (*),,2
		ptr Poi_Main					; 0
		ptr Poi_Slower					; 2
; ===========================================================================

Poi_Main:
		addq.b	#2,ost_primary_routine(a0)		; goto Poi_Slower next
		move.l	#Map_Points,ost_mappings(a0)
		move.w	#tile_Nem_Numbers+tile_hi,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#1,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.w	#-$300,ost_y_vel(a0)			; move object upwards

Poi_Slower:
		tst.w	ost_y_vel(a0)				; is object moving?
		bpl.w	DeleteObject				; if not, delete
		bsr.w	SpeedToPos				; update position
		addi.w	#$18,ost_y_vel(a0)			; reduce object speed
		bra.w	DisplaySprite

; ===========================================================================

		include "mappings/sprite/Animals.asm"
		include "mappings/sprite/Points.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo_RandomNumber:
		jmp	(RandomNumber).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 25 - Individual rings spawned in debug placement mode
; Rings that are part of the level layout are run by the RingsManager psuedoobject.
; ----------------------------------------------------------------------------

Ring:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_11F52(pc,d0.w),d1
		jmp	off_11F52(pc,d1.w)
; ===========================================================================
off_11F52:	index offset(*),,2
		ptr loc_11F5C					; 0
		ptr loc_11F90					; 2
		ptr loc_11F9E					; 4
		ptr loc_11FB0					; 6
		ptr loc_11FBE					; 8
; ===========================================================================

loc_11F5C:
		addq.b	#2,ost_primary_routine(a0)
		move.w	ost_x_pos(a0),$32(a0)
		move.l	#Map_Ring,ost_mappings(a0)
		move.w	#tile_Nem_Ring+tile_pal2,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#2,ost_priority(a0)
		move.b	#id_col_6x6+id_col_item,ost_col_type(a0)
		move.b	#8,ost_displaywidth(a0)

loc_11F90:
		move.b	(v_syncani_1_frame).w,ost_frame(a0)
		move.w	$32(a0),d0
		bra.w	DespawnObject2
; ===========================================================================

loc_11F9E:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_col_type(a0)
		move.b	#1,ost_priority(a0)
		bsr.s	CollectRing

loc_11FB0:
		lea	(Ani_Ring).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

loc_11FBE:
		bra.w	DeleteObject

; ===========================================================================


CollectRing:
		tst.b	$3F(a0)
		bne.s	loc_1201E

loc_11FC8:
		cmpi.w	#$3E7,(v_rings_collected_p1).w
		bcc.s	loc_11FD4
		addq.w	#1,(v_rings_collected_p1).w

loc_11FD4:
		move.w	#$B5,d0
		cmpi.w	#$3E7,(v_rings).w
		bcc.s	loc_12016
		addq.w	#1,(v_rings).w
		ori.b	#1,(v_hud_rings_update).w
		cmpi.w	#$64,(v_rings).w
		bcs.s	loc_12016
		bset	#1,(v_ring_reward).w
		beq.s	loc_1200A
		cmpi.w	#$C8,(v_rings).w
		bcs.s	loc_12016
		bset	#2,(v_ring_reward).w
		bne.s	loc_12016

loc_1200A:
		addq.b	#1,(v_lives).w
		addq.b	#1,(f_hud_lives_update).w
		move.w	#$98,d0

loc_12016:
		jmp	(PlaySound2).l
; ===========================================================================
		rts						; dead code
; ===========================================================================

loc_1201E:
		cmpi.w	#$3E7,(v_rings_collected_p2).w
		bcc.s	loc_1202A
		addq.w	#1,(v_rings_collected_p2).w

loc_1202A:
		cmpi.w	#$3E7,(v_rings_p2).w
		bcc.s	loc_12036
		addq.w	#1,(v_rings_p2).w

loc_12036:
		tst.w	(f_two_player).w
		beq.s	loc_11FD4
		ori.b	#1,(v_hud_rings_update_p2).w
		move.w	#$B5,d0
		cmpi.w	#$64,(v_rings_p2).w
		bcs.s	loc_12072
		bset	#1,(v_ring_reward_p2).w
		beq.s	loc_12066
		cmpi.w	#$C8,(v_rings_p2).w
		bcs.s	loc_12072
		bset	#2,(v_ring_reward_p2).w
		bne.s	loc_12072

loc_12066:
		addq.b	#1,(v_lives_p2).w
		addq.b	#1,(f_hud_lives_update_p2).w
		move.w	#$98,d0

loc_12072:
		jmp	(PlaySound2).l

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 37 - Rings flying out of Sonic or Tails when they're hurt
; ----------------------------------------------------------------------------

RingLoss:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_12086(pc,d0.w),d1
		jmp	off_12086(pc,d1.w)
; ===========================================================================
off_12086:	index offset(*),,2
		ptr loc_12090					; 0
		ptr loc_12178					; 2
		ptr loc_121DA					; 4
		ptr loc_121EE					; 6
		ptr loc_121FC					; 8
; ===========================================================================

loc_12090:
		movea.l	a0,a1
		moveq	#0,d5
		move.w	(v_rings).w,d5
		tst.b	$3F(a0)
		beq.s	loc_120A2
		move.w	(v_rings_p2).w,d5

loc_120A2:
		moveq	#$20,d0
		cmp.w	d0,d5
		bcs.s	loc_120AA
		move.w	d0,d5

loc_120AA:
		subq.w	#1,d5
		move.w	#$288,d4
		bra.s	loc_120BA
; ===========================================================================

loc_120B2:
		bsr.w	FindFreeObj
		bne.w	loc_12142

loc_120BA:
		_move.b	#id_RingLoss,ost_id(a1)
		addq.b	#2,ost_primary_routine(a1)
		move.b	#8,ost_height(a1)
		move.b	#8,ost_width(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	#Map_Ring,ost_mappings(a1)
		move.w	#tile_Nem_Ring+tile_pal2,ost_tile(a1)
		bsr.w	AdjustVRAM2P2
		move.b	#render_rel|render_onscreen,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#id_col_6x6+id_col_item,ost_col_type(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	#-1,(v_syncani_3_time).w
		tst.w	d4
		bmi.s	loc_12132
		move.w	d4,d0
		jsrto	CalcSine,JmpTo4_CalcSine
		move.w	d4,d2
		lsr.w	#8,d2
		asl.w	d2,d0
		asl.w	d2,d1
		move.w	d0,d2
		move.w	d1,d3
		addi.b	#$10,d4
		bcc.s	loc_12132
		subi.w	#$80,d4
		bcc.s	loc_12132
		move.w	#$288,d4

loc_12132:
		move.w	d2,ost_x_vel(a1)
		move.w	d3,ost_y_vel(a1)
		neg.w	d2
		neg.w	d4
		dbf	d5,loc_120B2

loc_12142:
		move.w	#$C6,d0
		jsr	(PlaySound2).l
		tst.b	$3F(a0)
		bne.s	loc_12166
		move.w	#0,(v_rings).w
		move.b	#$80,(v_hud_rings_update).w
		move.b	#0,(v_ring_reward).w
		bra.s	loc_12178
; ===========================================================================

loc_12166:
		move.w	#0,(v_rings_p2).w
		move.b	#$80,(v_hud_rings_update_p2).w
		move.b	#0,(v_ring_reward_p2).w

loc_12178:
		move.b	(v_syncani_3_frame).w,ost_frame(a0)
		bsr.w	SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		bmi.s	loc_121B8
		move.b	(v_vblank_counter_byte).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	loc_121B8
		tst.b	ost_render(a0)
		bpl.s	loc_121D0
		jsr	(FindFloorRing).l
		tst.w	d1
		bpl.s	loc_121B8
		add.w	d1,ost_y_pos(a0)
		move.w	ost_y_vel(a0),d0
		asr.w	#2,d0
		sub.w	d0,ost_y_vel(a0)
		neg.w	ost_y_vel(a0)

loc_121B8:
		tst.b	(v_syncani_3_time).w
		beq.s	loc_121FC
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		bcs.s	loc_121FC
		bra.w	DisplaySprite
; ===========================================================================

loc_121D0:
		tst.w	(f_two_player).w
		bne.w	loc_121FC
		bra.s	loc_121B8
; ===========================================================================

loc_121DA:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_col_type(a0)
		move.b	#1,ost_priority(a0)
		bsr.w	CollectRing

loc_121EE:
		lea	(Ani_Ring).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

loc_121FC:
		bra.w	DeleteObject

; ===========================================================================
; ----------------------------------------------------------------------------
; Unused Sonic 1 leftover: giant ring for entry to special stage
; ----------------------------------------------------------------------------
GiantRing:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1220E(pc,d0.w),d1
		jmp	off_1220E(pc,d1.w)
; ===========================================================================
off_1220E:		index offset(*),,2
		ptr loc_12216					; 0
		ptr loc_12264					; 2
		ptr loc_12282					; 4
		ptr loc_122C0					; 6
; ===========================================================================

loc_12216:
		move.l	#Map_GRing,ost_mappings(a0)
		move.w	#(vram_GiantRing/sizeof_cell)+tile_pal2,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$40,ost_displaywidth(a0)
		tst.b	ost_render(a0)
		bpl.s	loc_12264
		cmpi.b	#6,(f_got_emerald).w
		beq.w	loc_122C0
		cmpi.w	#$32,(v_rings).w
		bcc.s	loc_1224E
		rts
; ===========================================================================

loc_1224E:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#2,ost_priority(a0)
		move.b	#id_col_8x16+id_col_item,ost_col_type(a0)
		move.w	#$C40,(v_giantring_gfx_offset).w

loc_12264:
		move.b	(v_syncani_1_frame).w,ost_frame(a0)
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_12282:
		subq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_col_type(a0)
		bsr.w	FindFreeObj
		bne.w	loc_122B4
		; Note: the object ID is not set
		; If you want to restore the giant ring object, you'll also have to
		; restore the ring flash object (right after this) and assign its ID to
		; the created object here as follows:
	 	;move.b	#id_RingFlash,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	a0,$3C(a1)
		move.w	($FFFFB008).w,d0
		cmp.w	ost_x_pos(a0),d0
		bcs.s	loc_122B4
		bset	#render_xflip_bit,ost_render(a1)

loc_122B4:
		move.w	#$C3,d0
		jsr	(PlaySound2).l
		bra.s	loc_12264
; ===========================================================================

loc_122C0:
		bra.w	DeleteObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Unused Sonic 1 leftover: flash effect when you collect the giant ring
; ----------------------------------------------------------------------------
RingFlash:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_122D2(pc,d0.w),d1
		jmp	off_122D2(pc,d1.w)
; ===========================================================================
off_122D2:	index offset(*),,2
		ptr loc_122D8					; 0
		ptr loc_12306					; 2
		ptr loc_12376					; 4
; ===========================================================================

loc_122D8:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_RingFlash,ost_mappings(a0)
		move.w	#(vram_GiantRingFlash/sizeof_cell)+tile_pal2,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#0,ost_priority(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#-1,ost_frame(a0)

loc_12306:
		bsr.s	sub_12320
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite

; ===========================================================================


sub_12320:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_12366
		move.b	#1,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#8,ost_frame(a0)
		bcc.s	loc_12368
		cmpi.b	#3,ost_frame(a0)
		bne.s	locret_12366
		movea.l	$3C(a0),a1
		move.b	#6,ost_primary_routine(a1)
		move.b	#$1C,($FFFFB01C).w
		move.b	#1,(f_unused_ss_flag).w
		lea	($FFFFB000).w,a1
		bclr	#1,$2B(a1)
		bclr	#0,$2B(a1)

locret_12366:
		rts
; ===========================================================================

loc_12368:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#0,($FFFFB000).w
		addq.l	#4,sp
		rts

; ===========================================================================

loc_12376:
		bra.w	DeleteObject
; ===========================================================================
Ani_Ring:
		dc.b 0						; 0
		dc.b 2						; 1
		dc.b 5						; 2
		dc.b 4						; 3
		dc.b 5						; 4
		dc.b 6						; 5
		dc.b 7						; 6
		dc.b $FC					; 7

; ===========================================================================

		include "mappings/sprite/Ring.asm"
		include "mappings/sprite/Giant Ring (unused).asm"
		include "mappings/sprite/Giant Ring Flash (unused).asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object DC - Ring prize from CNZ slot machines
; ----------------------------------------------------------------------------

RingPrize:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	RingPrize_Index(pc,d0.w),d1
		jmp	RingPrize_Index(pc,d1.w)
; ===========================================================================
RingPrize_Index:	index offset(*),,2
		ptr RingPrize_Main				; 0
		ptr RingPrize_Animate				; 2
		ptr RingPrize_Delete				; 4

		rsobj	RingPrize,$2A
ost_casinoprz_childcnt_ptr:		rs.l 1			; $2A; pointer to parent cage's child object counter
		rsset $2E
ost_casinoprz_angle:			rs.w 1			; $2E; spawn angle of ring
ost_casinoprz_x_pos: 			rs.l 1			; $30; X position of the ring with greater precision
ost_casinoprz_y_pos:			rs.l 1			; $34; Y position of the ring with greater precision
ost_casinoprz_machine_x_pos:	rs.w 1				; $38; X position of the slot machine that generated the ring
ost_casinoprz_machine_y_pos:	rs.w 1				; $3A; Y position of the slot machine that generated the ring
ost_casinoprz_display_delay:	rs.w 1				; $3C; number of frames remaining that ring will be displayed
ost_casinoprz_player:			rs.w 1			; $3E; id of player this ring is being awarded to
		rsobjend
; ===========================================================================

RingPrize_Main:
		; Make ring move toward the cage each frame
		moveq	#0,d1
		move.w	ost_casinoprz_machine_x_pos(a0),d1	; get x pos of cage associated with slot machine
		swap	d1					; swap to high word
		move.l	ost_casinoprz_x_pos(a0),d0		; get current x pos of ring
		sub.l	d1,d0					; get difference
		asr.l	#4,d0					; divide by 16
		sub.l	d0,ost_casinoprz_x_pos(a0)		; subtract from old x pos to get new x pos
		move.w	ost_casinoprz_x_pos(a0),ost_x_pos(a0)	; set new x pos of ring
		moveq	#0,d1
		move.w	ost_casinoprz_machine_y_pos(a0),d1	; get y pos of cage associated with slot machine
		swap	d1					; swap to high word
		move.l	ost_casinoprz_y_pos(a0),d0		; get current y pos of ring
		sub.l	d1,d0					; get difference
		asr.l	#4,d0					; divide by 16
		sub.l	d0,ost_casinoprz_y_pos(a0)		; subtract from old y pos to get new y pos
		move.w	ost_casinoprz_y_pos(a0),ost_y_pos(a0)	; set new y pos of ring
		lea	Ani_RingPrize(pc),a1
		bsr.w	AnimateSprite
		subq.w	#1,ost_casinoprz_display_delay(a0)	; decrement timer
		bne.w	DisplaySprite				; branch if time remains
		movea.l	ost_casinoprz_childcnt_ptr(a0),a1	; parent's cage's child counter
		subq.w	#1,(a1)					; decrement child counter
		bsr.w	CollectRing				; add ring to player's count
		addi_.b	#2,ost_primary_routine(a0)		; go to RingPrize_Animate next

RingPrize_Animate:
		lea	Ani_Ring(pc),a1
		bsr.w	AnimateSprite				; animate ring sparkle; go to RingPrize_Delete when animation is finished
		bra.w	DisplaySprite
; ===========================================================================

RingPrize_Delete:
		bra.w	DeleteObject

; ===========================================================================
Ani_RingPrize:
		dc.b 0
		dc.b id_Frame_Ring_Edge
		dc.b id_Frame_Ring_Angle1
		dc.b id_Frame_Ring_Front
		dc.b id_Frame_Ring_Angle1
		dc.b id_Frame_Ring_Edge
		dc.b id_Frame_Ring_Angle2
		dc.b afEnd
		even
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo4_CalcSine:
		jmp	(CalcSine).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 26 - Monitors
; This object handles monitor collision and graphics. The power-ups themselves
; are handled by object 2E.
; ----------------------------------------------------------------------------

Monitor:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1267E(pc,d0.w),d1
		jmp	off_1267E(pc,d1.w)
; ===========================================================================
off_1267E:	index offset(*),,2
		ptr loc_12688					; 0
		ptr loc_126FA					; 2
		ptr loc_127BC					; 4
		ptr loc_12748					; 6
		ptr loc_12752					; 8
; ===========================================================================

loc_12688:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$E,ost_height(a0)
		move.b	#$E,ost_width(a0)
		move.l	#Map_Monitor,ost_mappings(a0)
		move.w	#tile_Nem_Monitors,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#$F,ost_displaywidth(a0)
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		bclr	#7,2(a2,d0.w)
		btst	#0,2(a2,d0.w)
		beq.s	loc_126E2
		move.b	#8,ost_primary_routine(a0)
		move.b	#$B,ost_frame(a0)
		rts
; ===========================================================================

loc_126E2:
		move.b	#id_col_16x16+id_col_item,ost_col_type(a0)
		move.b	ost_subtype(a0),ost_anim(a0)
		tst.w	(f_two_player).w
		beq.s	loc_126FA
		move.b	#9,ost_anim(a0)

loc_126FA:
		move.b	ost_secondary_routine(a0),d0
		beq.s	loc_1271C
		bsr.w	ObjectFall
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.w	loc_1271C
		add.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		clr.b	ost_secondary_routine(a0)

loc_1271C:
		move.w	#$1A,d1
		move.w	#$F,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4
		bsr.w	sub_12756
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#status_p2_platform_bit,d6
		bsr.w	sub_12768

loc_12748:
		lea	(Ani_Monitor).l,a1
		bsr.w	AnimateSprite

loc_12752:
		bra.w	DespawnObject

; ===========================================================================


sub_12756:
		btst	d6,ost_primary_status(a0)
		bne.s	loc_12782
		cmpi.b	#2,ost_anim(a1)
		bne.w	Solid_SkipRenderChk
		rts

; ===========================================================================


sub_12768:
		btst	d6,ost_primary_status(a0)
		bne.s	loc_12782
		tst.w	(f_two_player).w
		beq.w	Solid_SkipRenderChk
		cmpi.b	#2,ost_anim(a1)
		bne.w	Solid_SkipRenderChk
		rts
; ===========================================================================

loc_12782:
		move.w	d1,d2
		add.w	d2,d2
		btst	#1,ost_primary_status(a1)
		bne.s	loc_1279E
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0
		bmi.s	loc_1279E
		cmp.w	d2,d0
		bcs.s	loc_127B2

loc_1279E:
		bclr	#3,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)
		moveq	#0,d4
		rts
; ===========================================================================

loc_127B2:
		move.w	d4,d2
		bsr.w	MoveWithPlatform
		moveq	#0,d4
		rts

; ===========================================================================

loc_127BC:
		move.b	ost_primary_status(a0),d0
		andi.b	#$78,d0
		beq.s	loc_127EC
		move.b	d0,d1
		andi.b	#$28,d1
		beq.s	loc_127DA
		andi.b	#-$29,($FFFFB022).w
		ori.b	#2,($FFFFB022).w

loc_127DA:
		andi.b	#$50,d0
		beq.s	loc_127EC
		andi.b	#-$29,($FFFFB062).w
		ori.b	#2,($FFFFB062).w

loc_127EC:
		clr.b	ost_primary_status(a0)
		addq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_col_type(a0)
		bsr.w	FindFreeObj
		bne.s	loc_1281E
		_move.b	#id_PowerUp,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	ost_anim(a0),ost_anim(a1)
		move.w	$3E(a0),$3E(a1)

loc_1281E:
		bsr.w	FindFreeObj
		bne.s	loc_1283A
		_move.b	#id_ExplosionItem,ost_id(a1)
		addq.b	#2,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

loc_1283A:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		bset	#0,2(a2,d0.w)
		move.b	#$A,ost_anim(a0)
		bra.w	DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 2E - Monitor contents (code for power-ups and the rising image after
; monitor is broken)
; ----------------------------------------------------------------------------

PowerUp:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_12862(pc,d0.w),d1
		jmp	off_12862(pc,d1.w)
; ===========================================================================
off_12862:	index offset(*),,2
		ptr loc_12868					; 0
		ptr loc_128DE					; 2
		ptr loc_12CC2					; 4
; ===========================================================================

loc_12868:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#tile_Nem_Monitors+tile_hi,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel|render_rawmap,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.w	#-$300,ost_y_vel(a0)
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		tst.w	(f_two_player).w
		beq.s	loc_128C6
		move.w	(v_frame_counter).w,d0
		andi.w	#7,d0
		addq.w	#1,d0
		tst.w	(f_two_player_monitors).w
		beq.s	loc_128AC
		moveq	#8,d0

loc_128AC:
		cmpi.w	#8,d0
		bne.s	loc_128C2
		move.b	(f_hud_time_update).w,d1
		add.b	(f_hud_time_update_p2).w,d1
		cmpi.b	#2,d1
		beq.s	loc_128C2
		moveq	#7,d0

loc_128C2:
		move.b	d0,ost_anim(a0)

loc_128C6:
		addq.b	#1,d0
		move.b	d0,ost_frame(a0)
		movea.l	#Map_Monitor,a1
		add.b	d0,d0
		adda.w	(a1,d0.w),a1
		addq.w	#2,a1
		move.l	a1,ost_mappings(a0)

loc_128DE:
		bsr.s	sub_128E4
		bra.w	DisplaySprite

; ===========================================================================


sub_128E4:
		tst.w	ost_y_vel(a0)
		bpl.w	loc_128F8
		bsr.w	SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		rts
; ===========================================================================

loc_128F8:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$1D,ost_anim_time(a0)
		movea.w	$3E(a0),a1
		lea	(v_monitors_broken_p1).w,a2
		cmpa.w	#-$5000,a1
		beq.s	loc_12914
		lea	(v_monitors_broken_p2).w,a2

loc_12914:
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		add.w	d0,d0
		move.w	off_12924(pc,d0.w),d0
		jmp	off_12924(pc,d0.w)

; ===========================================================================
off_12924:	index offset(*)
		ptr loc_12938					; 0
		ptr loc_1293E					; 1
		ptr loc_12954					; 2
		ptr loc_12938					; 3
		ptr loc_1296A					; 4
		ptr loc_129E0					; 5
		ptr loc_12A2C					; 6
		ptr Pow_Invinc					; 7
		ptr Pow_Teleport				; 8
		ptr loc_12CBE					; 9
; ===========================================================================

loc_12938:
		addq.w	#1,(a2)
		bra.w	React_ChkHurt2
; ===========================================================================

loc_1293E:
		addq.w	#1,(v_monitors_broken_p1).w
		addq.b	#1,(v_lives).w
		addq.b	#1,(f_hud_lives_update).w
		move.w	#$98,d0
		jmp	(PlayMusic).l
; ===========================================================================

loc_12954:
		addq.w	#1,(v_monitors_broken_p2).w
		addq.b	#1,(v_lives_p2).w
		addq.b	#1,(f_hud_lives_update_p2).w
		move.w	#$98,d0
		jmp	(PlayMusic).l
; ===========================================================================

loc_1296A:
		addq.w	#1,(a2)
		lea	(v_rings).w,a2
		lea	(v_hud_rings_update).w,a3
		lea	(v_ring_reward).w,a4
		lea	(v_rings_collected_p1).w,a5
		cmpa.w	#-$5000,a1
		beq.s	loc_12992
		lea	(v_rings_p2).w,a2
		lea	(v_hud_rings_update_p2).w,a3
		lea	(v_ring_reward_p2).w,a4
		lea	(v_rings_collected_p2).w,a5

loc_12992:
		addi.w	#$A,(a5)
		cmpi.w	#$3E7,(a5)
		bcs.s	loc_129A0
		move.w	#$3E7,(a5)

loc_129A0:
		addi.w	#$A,(a2)
		cmpi.w	#$3E7,(a2)
		bcs.s	loc_129AE
		move.w	#$3E7,(a2)

loc_129AE:
		ori.b	#1,(a3)
		cmpi.w	#$64,(a2)
		bcs.s	loc_129CA
		bset	#1,(a4)
		beq.s	loc_129D4
		cmpi.w	#$C8,(a2)
		bcs.s	loc_129CA
		bset	#2,(a4)
		beq.s	loc_129D4

loc_129CA:
		move.w	#$B5,d0
		jmp	(PlayMusic).l
; ===========================================================================

loc_129D4:
		cmpa.w	#-$5000,a1
		beq.w	loc_1293E
		bra.w	loc_12954
; ===========================================================================

loc_129E0:
		addq.w	#1,(a2)
		bset	#2,$2B(a1)
		move.w	#$4B0,$34(a1)
		cmpa.w	#-$5000,a1
		bne.s	loc_12A10
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	loc_12A10
		move.w	#$C00,(v_sonic_max_speed).w
		move.w	#$18,(v_sonic_acceleration).w
		move.w	#$80,(v_sonic_deceleration).w
		bra.s	loc_12A22
; ===========================================================================

loc_12A10:
		move.w	#$C00,(v_tails_max_speed).w
		move.w	#$18,(v_tails_acceleration).w
		move.w	#$80,(v_tails_deceleration).w

loc_12A22:
		move.w	#$FB,d0
		jmp	(PlayMusic).l
; ===========================================================================

loc_12A2C:
		addq.w	#1,(a2)
		bset	#0,$2B(a1)
		move.w	#$AF,d0
		jsr	(PlayMusic).l
		tst.b	$3F(a0)
		bne.s	loc_12A50
		move.b	#$38,($FFFFD180).w
		move.w	a1,($FFFFD1BE).w
		rts
; ===========================================================================

loc_12A50:
		move.b	#$38,($FFFFD1C0).w
		move.w	a1,($FFFFD1FE).w
		rts
; ===========================================================================

Pow_Invinc:
		addq.w	#1,(a2)
		tst.b	(f_super).w				; is Sonic super?
		bne.s	locret_12AA4				; if yes, exit
		bset	#1,$2B(a1)				; make character invincible
		move.w	#20*60,$32(a1)				; for 20 seconds (20 seconds * 60 frames per second)
		tst.b	(v_current_boss).w			; don't change music during boss battles
		bne.s	.nomusic
		cmpi.b	#air_alert,ost_air_left(a1)		; or when drowning
		bls.s	.nomusic
		move.w	#$97,d0
		jsr	(PlayMusic).l

	.nomusic:
		tst.b	$3F(a0)
		bne.s	loc_12A9A
		move.b	#$35,($FFFFD200).w
		move.w	a1,($FFFFD23E).w
		rts
; ===========================================================================

	loc_12A9A:
		move.b	#$35,($FFFFD300).w
		move.w	a1,($FFFFD33E).w

	locret_12AA4:
		rts
; ===========================================================================

Pow_Teleport:
		addq.w	#1,(a2)
		cmpi.b	#id_Sonic_Death,(v_ost_player1+ost_primary_routine).w ; is player 1 dead or respawning?
		bcc.s	.no_teleport				; if so, branch
		cmpi.b	#id_Tails_Death,(v_ost_player2+ost_primary_routine).w ; is player 2 dead or respawning?
		bcs.s	.swap_players				; if not, branch

	.no_teleport:
		rts						; we can't teleport if one player is dead or respawning
; ===========================================================================

.swap_players:
		lea	(Teleport_Swap_Table).l,a3
		moveq	#(sizeof_Teleport_Swap_Table/6)-1,d2	; number of entries in table - 1

loc_12AC2:
		movea.w	(a3)+,a1
		movea.w	(a3)+,a2
		move.w	(a3)+,d1

loc_12AC8:
		move.w	(a1),d0
		move.w	(a2),(a1)+
		move.w	d0,(a2)+
		dbf	d1,loc_12AC8
		dbf	d2,loc_12AC2
		move.b	#1,($FFFFB01D).w			; MainCharacter+prev_anim
		move.b	#1,($FFFFB05D).w			; v_ost_player2+prev_anim
	if Revision>0
		; Revision 0 did not reset the character's mapping frames.
		move.b	#0,($FFFFB01A).w			; MainCharacter+mapping_frame
		move.b	#0,($FFFFB05A).w			; v_ost_player2+mapping_frame
	endc
		move.b	#-1,(v_sonic_last_frame_id).w
		move.b	#-1,(v_tails_last_frame_id).w
		move.b	#-1,(v_tailstails_last_frame_id).w
		lea	(v_opl_loaded_blocks_p1).w,a1
		lea	(v_opl_loaded_blocks_p2).w,a2
		moveq	#2,d1

loc_12B0A:
		move.b	(a1),d0
		move.b	(a2),(a1)+
		move.b	d0,(a2)+
		dbf	d1,loc_12B0A
		subi.w	#$180,(v_camera_y_pos).w
		subi.w	#$180,(v_camera_y_pos_p2).w
		move.w	(v_ost_player1+ost_tile).w,d0
		andi.w	#tile_draw,(v_ost_player1+ost_tile).w
		tst.w	(v_ost_player2+ost_tile).w
		bpl.s	loc_12B36
		ori.w	#tile_hi,(v_ost_player1+ost_tile).w

loc_12B36:
		andi.w	#tile_draw,(v_ost_player2+ost_tile).w
		tst.w	d0
		bpl.s	loc_12B46
		ori.w	#tile_hi,(v_ost_player2+ost_tile).w

loc_12B46:
		move.b	#1,(f_boundary_bottom_change).w
		lea	($FFFFB400).w,a1
		moveq	#$6F,d1

loc_12B52:
		cmpi.b	#id_PinballMode,ost_id(a1)
		beq.s	loc_12B5E
		cmpi.b	#id_PlaneSwitcher,ost_id(a1)
		bne.s	loc_12B6C

loc_12B5E:
		move.b	$34(a1),d0
		move.b	$35(a1),$34(a1)
		move.b	d0,$35(a1)

loc_12B6C:
		cmpi.b	#id_Cage,ost_id(a1)
		bne.s	loc_12B80
		move.l	$30(a1),d0
		move.l	$34(a1),$30(a1)
		move.l	d0,$34(a1)

loc_12B80:
		cmpi.b	#id_PinballLauncher,ost_id(a1)
		bne.s	loc_12B94
		move.b	$36(a1),d0
		move.b	$37(a1),$36(a1)
		move.b	d0,$37(a1)

loc_12B94:
		lea	$40(a1),a1
		dbf	d1,loc_12B52
		lea	($FFFFB000).w,a1
		move.b	#$38,($FFFFD180).w
		move.w	a1,($FFFFD1BE).w
		move.b	#$35,($FFFFD200).w
		move.w	a1,($FFFFD23E).w
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_12BC8
		move.b	#$13,ost_height(a1)
		move.b	#9,ost_width(a1)

loc_12BC8:
		btst	#3,ost_primary_status(a1)
		beq.s	loc_12BEC
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a2
		bclr	#4,ost_primary_status(a2)
		bset	#3,ost_primary_status(a2)

loc_12BEC:
		lea	($FFFFB040).w,a1
		move.b	#$38,($FFFFD1C0).w
		move.w	a1,($FFFFD1FE).w
		move.b	#$35,($FFFFD300).w
		move.w	a1,($FFFFD33E).w
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_12C18
		move.b	#$F,ost_height(a1)
		move.b	#9,ost_width(a1)

loc_12C18:
		btst	#3,ost_primary_status(a1)
		beq.s	loc_12C3C
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a2
		bclr	#3,ost_primary_status(a2)
		bset	#4,ost_primary_status(a2)

loc_12C3C:
		move.b	#$40,(v_teleport_timer).w
		move.b	#1,(f_teleport).w
		move.w	#$EC,d0
		jmp	(PlayMusic).l
; ===========================================================================

teleport_table_entry: macro address_a,address_b
		if (sizeof_\address_a<>sizeof_\address_b)
			inform 3,"The blocks of RAM assigned to \address_a and \address_b must be the same size, but they are $%h bytes and $%h bytes respectively.",sizeof_\address_a,sizeof_\address_b
		endc
		dc.w	\address_a,\address_b, (sizeof_\address_a\/2)-1
		endm

Teleport_Swap_Table:

		dc.w v_ost_player1+ost_x_pos, v_ost_player2+ost_x_pos, ((sizeof_ost-ost_x_pos)/2)-1

		teleport_table_entry	v_opl_screen_x_pos,			v_opl_screen_x_pos_p2
		teleport_table_entry 	v_respawn_list, 			v_respawn_list_p2
		teleport_table_entry 	object_manager_addresses, 	object_manager_addresses_p2
		teleport_table_entry 	sonic_speeds, 				tails_speeds
		teleport_table_entry	ring_manager_pointers,		ring_manager_pointers_p2
		teleport_table_entry	bumper_manager_pointers,	bumper_manager_pointers_p2
		teleport_table_entry	camera_positions,			camera_positions_p2
		teleport_table_entry	v_camera_x_pos_coarse,		v_camera_x_pos_coarse_p2
		teleport_table_entry	camera_boundaries, 			camera_boundaries_p2
		teleport_table_entry	horiz_scroll_delay,			horiz_scroll_delay_P2
		teleport_table_entry	v_camera_y_shift,			v_camera_y_shift_p2
		teleport_table_entry	block_redraw_flags, 		block_redraw_flags_p2
		teleport_table_entry	scroll_redraw_flags, 		scroll_redraw_flags_p2
		teleport_table_entry	vblank_camera_copies,		v_camera_pos_p2_copy
		teleport_table_entry 	vblank_scroll_redraw_flags, vblank_scroll_redraw_flags_p2
		teleport_table_entry	camera_diffs, 				camera_diffs_p2
		teleport_table_entry	v_sonic_pos_tracker,		v_tails_pos_tracker

		arraysize Teleport_Swap_Table
; ===========================================================================

loc_12CBE:
		addq.w	#1,(a2)
		rts
; ===========================================================================

loc_12CC2:
		subq.w	#1,ost_anim_time(a0)
		bmi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Ani_Monitor:	index offset(*)
		ptr byte_12CE4					; 0
		ptr byte_12CE8					; 1
		ptr byte_12CF0					; 2
		ptr byte_12CF8					; 3
		ptr byte_12D00					; 4
		ptr byte_12D08					; 5
		ptr byte_12D10					; 6
		ptr byte_12D18					; 7
		ptr byte_12D20					; 8
		ptr byte_12D28					; 9
		ptr byte_12D30					; 10
byte_12CE4:	dc.b   1,  0,  1,$FF				; 0
byte_12CE8:	dc.b   1,  0,  2,  2,  1,  2,  2,$FF		; 0
byte_12CF0:	dc.b   1,  0,  3,  3,  1,  3,  3,$FF		; 0
byte_12CF8:	dc.b   1,  0,  4,  4,  1,  4,  4,$FF		; 0
byte_12D00:	dc.b   1,  0,  5,  5,  1,  5,  5,$FF		; 0
byte_12D08:	dc.b   1,  0,  6,  6,  1,  6,  6,$FF		; 0
byte_12D10:	dc.b   1,  0,  7,  7,  1,  7,  7,$FF		; 0
byte_12D18:	dc.b   1,  0,  8,  8,  1,  8,  8,$FF		; 0
byte_12D20:	dc.b   1,  0,  9,  9,  1,  9,  9,$FF		; 0
byte_12D28:	dc.b   1,  0, $A, $A,  1, $A, $A,$FF		; 0
byte_12D30:	dc.b   2,  0,  1, $B,$FE,  1			; 0


		include	"mappings/sprite/Monitors.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0E - Title screen intro animation
; Manages the entire animation sequence on the title screen; Sonic is the
; parent object
; ----------------------------------------------------------------------------

TitleIntro:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TitlIntr_Index(pc,d0.w),d1
		jmp	TitlIntr_Index(pc,d1.w)
; ===========================================================================
TitlIntr_Index:	index offset(*),,2
		ptr TitlIntr_Main				; 0
		ptr TitlIntr_Sonic				; 2
		ptr TitlIntr_Tails				; 4
		ptr TitlIntr_LogoTop				; 6
		ptr TitlIntr_FlashingStar			; 8
		ptr TitlIntr_SonicHand				; $A
		ptr TitlIntr_FallingStar			; $C
		ptr TitlIntr_MaskingSprite			; $E
		ptr TitlIntr_TailsHand				; $10

		rsobj	TitleIntro,$2A
ost_titlintr_counter:			rs.w 1			; $2A
ost_titlintr_array_index:		rs.w 1			; $2C; pointer to current location in position arrays
		rsset $2F
ost_titlintr_complete:		rs.b 1				; $2F
ost_titlintr_music_flag:	rs.b 1				; $30
		rsset $34
ost_titlintr_current_frame:	rs.w 1				; $34
		rsobjend
; ===========================================================================

TitlIntr_Main:
		addq.b	#2,ost_primary_routine(a0)		; pointless, because it's overwritten with the subtype below
		move.l	#Map_TitleIntro,ost_mappings(a0)
		move.w	#tile_TitleSprites,ost_tile(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),ost_primary_routine(a0)	; subtype is also routine
		bra.s	TitleIntro
; ===========================================================================

TitlIntr_Sonic:
		addq.w	#1,ost_titlintr_current_frame(a0)	; increment frame count
		cmpi.w	#288,ost_titlintr_current_frame(a0)	; have we reached the end?
		bcc.s	.not_done				; if not, branch
		bsr.w	TitlIntr_SetFinalState

	.not_done:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_Sonic_Index(pc,d0.w),d1
		jmp	TitlIntr_Sonic_Index(pc,d1.w)
; ===========================================================================
TitlIntr_Sonic_Index:		index offset(*),,2
		ptr TitlIntr_Sonic_Main				; 0
		ptr TitlIntr_Sonic_FadeInAndPlayMusic		; 2
		ptr TitlIntr_Sonic_LoadPalette			; 4
		ptr TitlIntr_Sonic_Move				; 6
		ptr TitlIntr_Animate				; 8
		ptr TitlIntr_Sonic_AnimationFinished		; $A
		ptr TitlIntr_Sonic_SpawnTails			; $C
		ptr TitlIntr_Sonic_FlashBackground		; $E
		ptr TitlIntr_Sonic_SpawnFallingStar		; $10
		ptr TitlIntr_Sonic_FallingStarSparkle		; $12
; ===========================================================================

TitlIntr_Sonic_Main:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_FadeInAndPlayMusic next
		move.b	#id_Frame_IntroSonic_0,ost_frame(a0)	; initial frame of Sonic's animation
		move.w	#screen_left+144,ost_x_screen(a0)	; set x pos
		move.w	#screen_top+96,ost_y_screen(a0)		; set y pos

		lea	(v_title_flashing_star).w,a1		; load flashing star object
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_flashingstar,ost_subtype(a1)

		lea	(v_title_logo_top).w,a1			; load logo top object
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_logotop,ost_subtype(a1)

		moveq_	sfx_Sparkle,d0				; play twinkling sound
		jmpto	PlaySound,JmpTo4_PlaySound
; ===========================================================================

TitlIntr_Sonic_FadeInAndPlayMusic:
		cmpi.w	#56,ost_titlintr_current_frame(a0)	; have 56 frames elapsed?
		bcc.s	.load_palchanger			; if so, branch
		rts
; ===========================================================================

	.load_palchanger:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_LoadPalette next

		lea	(v_title_palette_changer_3).w,a1	; load palette changer object
		move.b	#id_PalChanger,ost_id(a1)
		move.b	#type_palchngr_titlelogo,ost_subtype(a1)

		st.b	ost_titlintr_music_flag(a0)		; play the title screen music
		moveq_	mus_Title,d0
		jmpto	PlayMusic,JmpTo4_PlayMusic
; ===========================================================================

TitlIntr_Sonic_LoadPalette:
		cmpi.w	#128,ost_titlintr_current_frame(a0)	; have 128 frames elapsed?
		bcc.s	.loadpalette				; if so, branch
		rts
; ===========================================================================

	.loadpalette:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_Move next

		lea	(Pal_TitleSonic).l,a1			; load Title Screen Sonic palette
		lea	(v_pal_dry).w,a2
		moveq	#countof_color-1,d6

	.loop:
		move.w	(a1)+,(a2)+
		dbf	d6,.loop

TitlIntr_Sonic_LoadMaskingSprite:
		lea	(v_title_masking_sprite).w,a1		; load the masking sprite object
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_maskingsprite,ost_subtype(a1)
		rts

; ===========================================================================

TitlIntr_Sonic_Move:
		moveq	#sizeof_TitlIntr_Sonic_Positions+4,d2	; position array counter
		lea	(TitlIntr_Sonic_Positions).l,a1

TitlIntr_Move:
		move.w	ost_titlintr_counter(a0),d0		; get frame counter
		addq.w	#1,d0					; increment
		move.w	d0,ost_titlintr_counter(a0)		; store new value
		andi.w	#3,d0					; reset if it has reached 4
		bne.s	.display				; if it has not reached 4, branch

	;.update_position:
		move.w	ost_titlintr_array_index(a0),d1		; get current array index
		addq.w	#4,d1					; increment
		cmp.w	d2,d1					; have we reached the end?
		bcc.w	TitlIntr_NextSecondaryRoutine		; if so, go to TitlIntr_Animate next?

		move.w	d1,ost_titlintr_array_index(a0)
		move.l	-4(a1,d1.w),d0				; get new position from array
		move.w	d0,ost_y_screen(a0)			; apply to object
		swap	d0
		move.w	d0,ost_x_screen(a0)

	.display:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_Animate:
		lea	(Ani_TitleIntro).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_Sonic_AnimationFinished:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_SpawnTails next
		move.b	#id_Frame_IntroSonic_NoArm,ost_frame(a0) ; set Sonic's armless frame

		lea	(v_title_sonic_hand).w,a1		; load Sonic's hand
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_sonichand,ost_subtype(a1)

		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_Sonic_SpawnTails:
		cmpi.w	#192,ost_titlintr_current_frame(a0)	; have we reached the 192nd frame?
		bcs.s	.display				; if not, branch

		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_FlashBackground next
		lea	(v_title_tails).w,a1
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_tails,ost_subtype(a1)

	.display:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_Sonic_FlashBackground:
		cmpi.w	#288,ost_titlintr_current_frame(a0)	; have we reached the 288th frame?
		bcs.s	.display				; if not, branch
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_SpawnFallingStar next
		clr.w	ost_titlintr_array_index(a0)
		st.b	ost_titlintr_complete(a0)		; set flag indicating the intro animation is complete

		lea	(v_pal_dry_line3).w,a1
		move.w	#cWhite,d0				; fill palette line 3 with white
		moveq	#countof_color-1,d6

	.loop:
		move.w	d0,(a1)+
		dbf	d6,.loop

		lea	(v_title_palette_changer_2).w,a1	; load palette changer object
		move.b	#id_PalChanger,ost_id(a1)
		move.b	#type_palchngr_titlebackground,ost_subtype(a1)

		move.b	#id_TitleMenu,(v_title_menu+id).w	; load title screen menu object

	.display:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_Sonic_SpawnFallingStar:
		; Wait for 176 frames on NTSC consoles and 112 on PAL; this ensures the
		; falling star synchronizes properly with the music.
		btst	#console_speed_bit,(v_console_region).w	; are we on a PAL console?
		beq.s	.ntsc					; if not, branch

	;.pal:
		cmpi.w	#400,ost_titlintr_current_frame(a0)	; have we reached the 400th frame?
		beq.s	.spawn_star				; if so, branch
		bra.w	DisplaySprite
; ===========================================================================

	.ntsc:
		cmpi.w	#464,ost_titlintr_current_frame(a0)	; have we reached the 464th frame?
		beq.s	.spawn_star				; if so, branch
		bra.w	DisplaySprite
; ===========================================================================

	.spawn_star:
		lea	(v_title_falling_star).w,a1		; load falling star object
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_fallingstar,ost_subtype(a1)

		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Sonic_FallingStarSparkle next

		lea	(v_title_masking_sprite).w,a1
		bsr.w	DeleteChild				; delete the masking sprite object
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_Sonic_FallingStarSparkle:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#7,d0
		bne.s	.display				; if frame count is not a multiple of 8, branch

		; Update palette cycle of falling star every 8 frames.
		move.w	ost_titlintr_array_index(a0),d0		; get index
		addq.w	#2,d0					; increment
		cmpi.w	#sizeof_Pal_TitleStarCyc,d0		; have we reached the end?
		bcs.s	.not_done				; if we have not, branch
		moveq	#0,d0					; reset index

	.not_done:
		move.w	d0,ost_titlintr_array_index(a0)		; update index
		move.w	Pal_TitleStarCyc(pc,d0.w),(v_pal_dry_line3+(5*2)).w ; copy updated color to palette

	.display:
		bra.w	DisplaySprite
; ===========================================================================

		incfile	Pal_TitleStarCyc

TitlIntr_Sonic_Positions:
		;           		X,      		Y
		dc.w  screen_left+136, screen_top+80
		dc.w  screen_left+128, screen_top+64
		dc.w  screen_left+120, screen_top+48
		dc.w  screen_left+118, screen_top+38
		dc.w  screen_left+122, screen_top+30
		dc.w  screen_left+128, screen_top+26
		dc.w  screen_left+132, screen_top+25
		dc.w  screen_left+136, screen_top+24
		arraysize	TitlIntr_Sonic_Positions
; ===========================================================================

TitlIntr_Tails:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_Tails_Index(pc,d0.w),d1
		jmp	TitlIntr_Tails_Index(pc,d1.w)
; ===========================================================================
TitlIntr_Tails_Index:	index offset(*),,2
		ptr TitlIntr_Tails_Main				; 0
		ptr TitlIntr_Tails_Move				; 2
		ptr TitlIntr_Animate				; 4
		ptr TitlIntr_Tails_AnimationFinished		; 6
		ptr BranchTo10_DisplaySprite			; 8
; ===========================================================================

TitlIntr_Tails_Main:
		addq.b	#2,ost_secondary_routine(a0)
	if FixBugs
		; Tails' priority is never set, even though it is set in
		; 'TitleScreen_SetFinalState', suggesting that it was meant to be.
		; This causes Tails to be layered behind Sonic instead of in front of
		; him.
		move.b	#3,ost_priority(a0)
	endc
		move.w	#screen_left+88,ost_x_screen(a0)
		move.w	#screen_top+88,ost_y_screen(a0)
		move.b	#id_Ani_TitlIntr_Tails,ost_anim(a0)
		rts
; ===========================================================================

TitlIntr_Tails_Move:
		moveq	#sizeof_TitlIntr_Tails_Positions+4,d2
		lea	(TitlIntr_Tails_Positions).l,a1
		bra.w	TitlIntr_Move
; ===========================================================================

TitlIntr_Tails_AnimationFinished:
		addq.b	#2,ost_secondary_routine(a0)		; go to BranchTo10_DisplaySprite next
		lea	(v_title_tails_hand).w,a1		; load Tails' hand object
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_tailshand,ost_subtype(a1)

BranchTo10_DisplaySprite:
		bra.w	DisplaySprite

; ===========================================================================
TitlIntr_Tails_Positions:
		;           		X,      		Y
		dc.w   screen_left+87, screen_top+72
		dc.w   screen_left+83, screen_top+56
		dc.w   screen_left+78, screen_top+44
		dc.w   screen_left+76, screen_top+38
		dc.w   screen_left+74, screen_top+34
		dc.w   screen_left+73, screen_top+33
		dc.w   screen_left+72, screen_top+32
		arraysize	TitlIntr_Tails_Positions
; ===========================================================================

TitlIntr_LogoTop:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_LogoTop_Index(pc,d0.w),d1
		jmp	TitlIntr_LogoTop_Index(pc,d1.w)
; ===========================================================================

TitlIntr_LogoTop_Index:	index offset(*),,2
		ptr TitlIntr_LogoTop_Main			; 0
		ptr BranchTo11_DisplaySprite			; 2
; ===========================================================================

TitlIntr_LogoTop_Main:
		move.b	#id_Frame_LogoTop_TM,ost_frame(a0)
		tst.b	(v_console_region).w			; is console Japanese or Korean?
		bmi.s	.notJPKR				; if so, branch
		move.b	#id_Frame_LogoTop_NoTM,ost_frame(a0)	; use alternate mappings that remove the TM symbol

	.notJPKR:
		move.b	#2,ost_priority(a0)
		move.w	#screen_left+(screen_width/2),ost_x_screen(a0)
		move.w	#screen_top+104,ost_y_screen(a0)

TitlIntr_NextSecondaryRoutine:
		addq.b	#2,ost_secondary_routine(a0)		; go to BranchTo11_DisplaySprite next

BranchTo11_DisplaySprite:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_MaskingSprite:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_MaskingSprite_Index(pc,d0.w),d1
		jmp	TitlIntr_MaskingSprite_Index(pc,d1.w)
; ===========================================================================
TitlIntr_MaskingSprite_Index:	index offset(*),,2
		ptr TitlIntr_MaskingSprite_Main			; 0
		ptr BranchTo12_DisplaySprite			; 2
; ===========================================================================

TitlIntr_MaskingSprite_Main:
		addq.b	#2,ost_secondary_routine(a0)		; go to BranchTo12_DisplaySprite next
		move.w	#vram_Title,ost_tile(a0)		; start of VRAM
		move.b	#id_Frame_MaskingSprite,ost_frame(a0)
		move.b	#2,ost_priority(a0)
		move.w	#screen_left+128,ost_x_screen(a0)	; should be zero, but is corrected by the titlescreen loop
		move.w	#screen_top+224/2,ost_y_screen(a0)

BranchTo12_DisplaySprite:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_FlashingStar:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_FlashingStar_Index(pc,d0.w),d1
		jmp	TitlIntr_FlashingStar_Index(pc,d1.w)
; ===========================================================================
TitlIntr_FlashingStar_Index:	index offset(*),,2
		ptr TitlIntr_FlashingStar_Main			; 0
		ptr TitlIntr_Animate				; 2
		ptr TitlIntr_FlashingStar_Wait			; 4
		ptr TitlIntr_FlashingStar_Move			; 6
; ===========================================================================

TitlIntr_FlashingStar_Main:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_Animate next
		move.b	#id_Frame_IntroStar_0,ost_frame(a0)
		ori.w	#tile_hi,ost_tile(a0)
		move.b	#id_Ani_TitlIntr_FlashingStar,ost_anim(a0)
		move.b	#1,ost_priority(a0)
		move.w	#screen_left+128,ost_x_screen(a0)
		move.w	#screen_top+40,ost_y_screen(a0)
		move.w	#4,ost_titlintr_counter(a0)
		rts
; ===========================================================================

TitlIntr_FlashingStar_Wait:
		subq.w	#1,ost_titlintr_counter(a0)		; decrement counter
		bmi.s	.wait_done				; if less than 0, branch
		rts
; ===========================================================================

	.wait_done:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_FlashingStar_Move next
		rts
; ===========================================================================

TitlIntr_FlashingStar_Move:
		move.b	#id_titlintr_animate_2,ost_secondary_routine(a0) ; go to TitlIntr_Animate next
		move.b	#0,ost_anim_frame(a0)
		move.b	#0,ost_anim_time(a0)
		move.w	#6,ost_titlintr_counter(a0)

		move.w	ost_titlintr_array_index(a0),d0		; get current index
		addq.w	#4,d0					; increment
		cmpi.w	#sizeof_TitlIntr_FlashingStar_Positions+4,d0 ; have we reached the end?
		bcc.w	DeleteObject				; if so, branch
		move.w	d0,ost_titlintr_array_index(a0)		; store new index

		move.l	TitlIntr_FlashingStar_Positions-4(pc,d0.w),d0 ; get new position from array
		move.w	d0,ost_y_screen(a0)
		swap	d0
		move.w	d0,ost_x_screen(a0)

		moveq_	sfx_Sparkle,d0				; play twinkling sound
		jmpto	PlaySound,JmpTo4_PlaySound
; ===========================================================================
TitlIntr_FlashingStar_Positions:
		;          			 X,     	 	Y
		dc.w  screen_left+90,  screen_top+114
		dc.w  screen_left+240, screen_top+120
		dc.w  screen_left+178, screen_top+177
		dc.w  screen_left+286, screen_top+34
		dc.w  screen_left+64,  screen_top+99
		dc.w  screen_left+256, screen_top+96
		dc.w  screen_left+141, screen_top+187
		dc.w  screen_left+64,  screen_top+43
		dc.w  screen_left+229, screen_top+135
		arraysize	TitlIntr_FlashingStar_Positions
; ===========================================================================

TitlIntr_SonicHand:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_SonicHand_Index(pc,d0.w),d1
		jmp	TitlIntr_SonicHand_Index(pc,d1.w)
; ===========================================================================
TitlIntr_SonicHand_Index:	index offset(*),,2
		ptr TitlIntr_SonicHand_Main			; 0
		ptr TitlIntr_SonicHand_Move			; 2
		ptr BranchTo13_DisplaySprite			; 4
; ===========================================================================

TitlIntr_SonicHand_Main:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_SonicHand_Move next
		move.b	#id_Frame_IntroSonic_Hand,ost_frame(a0)
	if FixBugs
		; This matches 'TitleScreen_SetFinalState'.
		move.b	#2,ost_priority(a0)
	else
		; This is inconsistent with 'TitleScreen_SetFinalState'.
		move.b	#3,ost_priority(a0)
	endc
		move.w	#screen_left+197,ost_x_screen(a0)
		move.w	#screen_top+63,ost_y_screen(a0)

BranchTo13_DisplaySprite:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_SonicHand_Move:
		moveq	#sizeof_TitlIntr_SonicHand_Positions+4,d2
		lea	(TitlIntr_SonicHand_Positions).l,a1
		bra.w	TitlIntr_Move
; ===========================================================================

TitlIntr_SonicHand_Positions:
		dc.w  screen_left+195, screen_top+65
		dc.w  screen_left+192, screen_top+66
		dc.w  screen_left+193, screen_top+65
		arraysize	TitlIntr_SonicHand_Positions
; ===========================================================================

TitlIntr_TailsHand:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_TailsHand_Index(pc,d0.w),d1
		jmp	TitlIntr_TailsHand_Index(pc,d1.w)
; ===========================================================================

TitlIntr_TailsHand_Index:	index offset(*),,2
		ptr TitlIntr_TailsHand_Main			; 0
		ptr TitlIntr_TailsHand_Move			; 2
		ptr BranchTo14_DisplaySprite			; 4
; ===========================================================================

TitlIntr_TailsHand_Main:
		addq.b	#2,ost_secondary_routine(a0)		; go to TitlIntr_TailsHand_Move next
		move.b	#id_Frame_IntroTails_Hand,ost_frame(a0)
	if FixBugs
		; This matches 'TitlIntr_SetFinalState'.
		move.b	#2,ost_priority(a0)
	else
		; This is inconsistent with 'TitlIntr_SetFinalState', and causes
		; Tails' hand to be layered behind Tails if his priority is fixed
		; in TitlIntr_Tails_Main.
		move.b	#3,ost_priority(a0)
	endc
		move.w	#screen_left+143,ost_x_screen(a0)
		move.w	#screen_left+85,ost_y_screen(a0)

BranchTo14_DisplaySprite:
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_TailsHand_Move:
		moveq	#sizeof_TitlIntr_TailsHand_Positions+4,d2
		lea	(TitlIntr_TailsHand_Positions).l,a1
		bra.w	TitlIntr_Move
; ===========================================================================

TitlIntr_TailsHand_Positions:
		dc.w  screen_left+140, screen_top+80
		dc.w  screen_left+141, screen_top+81
		arraysize	TitlIntr_TailsHand_Positions
; ===========================================================================

TitlIntr_FallingStar:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	TitlIntr_FallingStar_Index(pc,d0.w),d1
		jmp	TitlIntr_FallingStar_Index(pc,d1.w)
; ===========================================================================

TitlIntr_FallingStar_Index:	index offset(*),,2
		ptr TitlIntr_FallingStar_Main			; 0
		ptr TitlIntr_FallingStar_Fall			; 2
; ===========================================================================

TitlIntr_FallingStar_Main:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#id_Frame_IntroStar_0,ost_frame(a0)
		move.b	#5,ost_priority(a0)
		move.w	#screen_left+240,ost_x_screen(a0)
		move.w	#screen_top,ost_y_screen(a0)
		move.b	#id_Ani_TitlIntr_FallingStar,ost_anim(a0)
		move.w	#140,ost_titlintr_counter(a0)		; run for 140 frames
		bra.w	DisplaySprite
; ===========================================================================

TitlIntr_FallingStar_Fall:
		subq.w	#1,ost_titlintr_counter(a0)		; has the animation finished?
		bmi.w	DeleteObject				; if so, delete object

		subq.w	#2,ost_x_screen(a0)			; move star left two pixels and down one pixel
		addq.w	#1,ost_y_screen(a0)

		lea	(Ani_TitleIntro).l,a1
		bsr.w	AnimateSprite
		bra.w	DisplaySprite

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C9 - Title Screen and ending palette change handler
; ----------------------------------------------------------------------------

PalChanger:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	PalChanger_Index(pc,d0.w),d1
		jmp	PalChanger_Index(pc,d1.w)
; ===========================================================================
PalChanger_Index:	index offset(*),,2
		ptr	PalChanger_Init
		ptr PalChanger_Main

		rsobj	PalChanger,$30
ost_palchngr_fadein_time_left:	rs.b 1				; $30
ost_palchngr_fadein_time:		rs.b 1			; $31
ost_palchngr_fadein_amount:		rs.b 1			; $32
		rsset $34
ost_palchngr_start_offset: 		rs.w 1			; $34
ost_palchngr_length: 			rs.w 1			; $36
		rsset $3A
ost_palchngr_codeptr: 			rs.l 1			; $3A
		rsobjend

; ===========================================================================

PalChanger_Init:
		addq.b	#2,ost_primary_routine(a0)		; go to PalChanger_Main next
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lea	(PalChangerData_Index).l,a1		; load palette change data array
		adda.w	(a1,d0.w),a1				; subtype corresponds to the palette change data
		move.l	(a1)+,ost_palchngr_codeptr(a0)		; code pointer
		movea.l	(a1)+,a2				; palette pointer
		move.b	(a1)+,d0				; start offset
		move.w	d0,ost_palchngr_start_offset(a0)
		lea	(v_pal_dry_next).w,a3
		adda.w	d0,a3					; add start offset to v_pal_dry_next
		move.b	(a1)+,d0				; length
		move.w	d0,ost_palchngr_length(a0)

	.loop:
		move.w	(a2)+,(a3)+				; load target palette to v_pal_dry_next
		dbf	d0,.loop

		move.b	(a1)+,d0				; fade-in time
		move.b	d0,ost_palchngr_fadein_time_left(a0)
		move.b	d0,ost_palchngr_fadein_time(a0)
		move.b	(a1)+,ost_palchngr_fadein_amount(a0)	; fade-in amount
		rts
; ===========================================================================

PalChanger_Main:
		subq.b	#1,ost_palchngr_fadein_time_left(a0)	; decrement time left
		bpl.s	.exit					; if there is time left, exit
		move.b	ost_palchngr_fadein_time(a0),ost_palchngr_fadein_time_left(a0) ; reset time left
		subq.b	#1,ost_palchngr_fadein_amount(a0)	; decrement fade amount
		bmi.w	DeleteObject				; if fade-in is complete, delete the PalChanger object
		movea.l	ost_palchngr_codeptr(a0),a2		; get code pointer
		movea.l	a0,a3					; back up a0
		move.w	ost_palchngr_length(a0),d0		; get length
		move.w	ost_palchngr_start_offset(a0),d1
		lea	(v_pal_dry).w,a0
		adda.w	d1,a0					; set start offset
		lea	(v_pal_dry_next).w,a1
		adda.w	d1,a1					; same with palette fade buffer

	.loop:
		jsr	(a2)					; run the palette fade code
		dbf	d0,.loop				; repeat for length of palette
		movea.l	a3,a0					; restore a0

	.exit:
		rts
; ===========================================================================

PalChangerData_Index:	index offset(*),,2
		ptr PalChngrData_TitleLogo			; 0
		ptr PalChngrData_TitleBackground		; 2
		ptr PalChngrData_EndingStillFirst		; 4
		ptr PalChngrData_EndingStillNext		; 6
		ptr PalChngrData_EndingSonic			; 8
		ptr PalChngrData_EndingCharacterDescend		; $A
		ptr PalChngrData_EndingSuperSonic		; $C
		ptr PalChngrData_EndingTails			; $E

; ---------------------------------------------------------------------------
; Data for each palette change handled by this object.

; Each entry is $C bytes, and consists of:
; - pointer to the actual palette change subroutine that will be used (longword)
; - pointer to the palette data to use (longword)
; - the first palette entry to modify, represented as an offset relative to v_pal_dry
; 	(byte)
; - the length of the data to modify (byte)
; - the duration of the fade (byte)
; - the amount of the fade (byte)
; ---------------------------------------------------------------------------

palchngrdata:	macro codeptr,dataptr,loadto_offset,length,fadein_time,fadein_amount
		dc.l	\codeptr,\dataptr
		dc.b	\loadto_offset,\length,\fadein_time,\fadein_amount
    	endm


PalChngrData_TitleLogo:					palchngrdata	FadeIn_AddColor,	Pal_TitleLogo, 			$60,$F,	2,$15
PalChngrData_TitleBackground:			palchngrdata	PalChanger_WhiteIn,	Pal_TitleBackground,	$40,$F,	4,7
PalChngrData_EndingStillFirst:			palchngrdata	PalChanger_WhiteIn,	Pal_EndingStills,		0, 	$F,	8,7
PalChngrData_EndingStillNext:			palchngrdata	PalChanger_WhiteOut,Pal_EndingStills,		0, 	$F,	8,7
PalChngrData_EndingSonic:				palchngrdata	PalChanger_WhiteIn,	Pal_EndingSonic,		0,	$1F,4,7
PalChngrData_EndingCharacterDescend:	palchngrdata	PalChanger_WhiteIn,	Pal_EndingBG,			$40,$1F,4,7
PalChngrData_EndingSuperSonic:			palchngrdata	PalChanger_WhiteIn,	Pal_EndingSuperSonic,	0,	$F,	4,7
PalChngrData_EndingTails:				palchngrdata	PalChanger_WhiteIn,	Pal_EndingSonicFar,		0,	$1F,4,7

	incfile	Pal_TitleSonic
	incfile	Pal_TitleBackground
	incfile	Pal_TitleLogo

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to reduce the values of a single palette entry while fading in
; from white. Used by the title screen background, the still transitions in
; the ending sequence, and the fade-in to Sonic or Tails descending during
; the ending sequence.

; input:
;	a0 = target palette
;	a1 = current palette

;	uses d2, d3, d4, d5, a0, a1
;-----------------------------------------------------------------------------
PalChanger_WhiteIn:
		move.b	(a1)+,d2				; blue byte of target color
		andi.b	#cBlue>>8,d2				; only bits 1-3 used by the actual color data
		move.b	(a0),d3					; blue byte of current color

		cmp.b	d2,d3					; has blue reached the target?
		bls.s	.skipblue				; if so, branch
		subq.b	#2,d3					; reduce blue value
		move.b	d3,(a0)					; update blue

	.skipblue:
		addq.w	#1,a0
		move.b	(a1)+,d2				; green/red byte of target color
		move.b	d2,d3
		andi.b	#cGreen,d2				; only green bits
		andi.b	#cRed,d3				; only red bits
		move.b	(a0),d4					; green/red byte of current color
		move.b	d4,d5
		andi.b	#cGreen,d4				; only green bits
		andi.b	#cRed,d5				; only red bits

		cmp.b	d2,d4					; has green reached the target?
		bls.s	.skipgreen				; if so, branch
		subi.b	#$20,d4					; reduce green value

	.skipgreen:
		cmp.b	d3,d5					; has red reached the target?
		bls.s	.skipred				; if so, branch
		subq.b	#2,d5					; reduce red value

	.skipred:
		or.b	d4,d5
		move.b	d5,(a0)+				; update green and red
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to increase the values of a single palette entry while fading to
; white. Used only by the still transitions in the ending sequence.

; input:
;	a0 = target palette
;	a1 = current palette

;	uses d2, d3, d4, a0
; ---------------------------------------------------------------------------
PalChanger_WhiteOut:
		moveq	#cBlue>>8,d2
		move.b	(a0),d3					; blue byte of current color
		and.b	d2,d3					; only bits 1-3 used by the actual color data

		cmp.b	d2,d3					; has blue reached its max?
		bcc.s	.skipblue				; if so, branch
		addq.b	#2,d3					; increase blue value
		move.b	d3,(a0)					; update blue

	.skipblue:
		addq.w	#1,a0
		move.b	(a0),d3					; green/red byte of current color
		move.b	d3,d4
		andi.b	#cGreen,d3				; only green bits
		andi.b	#cRed,d4				; only red bits (could have used 'and.b d2,d4')

		cmpi.b	#cGreen,d3				; has green reached its max?
		bcc.s	.skipgreen				; if so, branch
		addi.b	#$20,d3					; increase green

	.skipgreen:
		cmp.b	d2,d4					; has red reached its max? (cRed = cBlue>>8)
		bcc.s	.skipred				; if so, branch
		addq.b	#2,d4					; increase red value

	.skipred:
		or.b	d3,d4
		move.b	d4,(a0)+				; update green and red
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to skip the title screen animation when the start button
; is pressed.
; ---------------------------------------------------------------------------

TitlIntr_SetFinalState:
		tst.b	ost_titlintr_complete(a0)		; has the intro animation already finished?
		bne.w	.exit					; if it has, exit
		move.b	(v_joypad_press_actual).w,d0		; get joypad press state
		or.b	(v_joypad2_press_actual).w,d0		; (both pads)
		andi.b	#btnDir|btnABC,(v_joypad_press_actual).w ; clear start bit from input state
		andi.b	#btnDir|btnABC,(v_joypad2_press_actual).w ; (both pads)
		andi.b	#btnStart,d0				; is start button pressed?
		beq.w	.exit					; if not, exit

		st.b	ost_titlintr_complete(a0)		; set intro finished flag

		move.b	#id_TitlIntr_Sonic_SpawnFallingStar,ost_secondary_routine(a0) ; load Sonic
		move.b	#id_Frame_IntroSonic_NoArm,ost_frame(a0)
		move.w	#screen_left+136,ost_x_screen(a0)
		move.w	#screen_top+24,ost_y_screen(a0)

		lea	(v_title_sonic_hand).w,a1		; load Sonic's hand
		bsr.w	TitlIntr_InitSprite
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#id_TitlIntr_SonicHand,ost_primary_routine(a1)
		move.b	#2,ost_priority(a1)
		move.b	#id_Frame_IntroSonic_Hand,ost_frame(a1)
		move.b	#id_BranchTo13_DisplaySprite,ost_secondary_routine(a1)
		move.w	#screen_left+193,ost_x_screen(a1)
		move.w	#screen_top+65,ost_y_screen(a1)

		lea	(v_title_tails).w,a1			; load Tails
		bsr.w	TitlIntr_InitSprite
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#id_TitlIntr_Tails,ost_primary_routine(a1)
		move.b	#id_Frame_IntroTails_4,ost_frame(a1)
		move.b	#id_TitlIntr_Tails_AnimationFinished,ost_secondary_routine(a1)
		move.b	#3,ost_priority(a1)
		move.w	#screen_left+72,ost_x_screen(a1)
		move.w	#screen_top+32,ost_y_screen(a1)

		lea	(v_title_tails_hand).w,a1		; load Tails' hand
		bsr.w	TitlIntr_InitSprite
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#id_TitlIntr_TailsHand,ost_primary_routine(a1)
		move.b	#2,ost_priority(a1)
		move.b	#id_Frame_IntroTails_Hand,ost_frame(a1)
		move.b	#id_BranchTo14_DisplaySprite,ost_secondary_routine(a1)
		move.w	#screen_left+141,ost_x_screen(a1)
		move.w	#screen_top+81,ost_y_screen(a1)

		lea	(v_title_logo_top).w,a1			; load logo top
		move.b	#id_TitleIntro,ost_id(a1)
		move.b	#type_titlintr_logotop,ost_subtype(a1)

		bsr.w	TitlIntr_Sonic_LoadMaskingSprite	; load masking sprite

		move.b	#id_TitleMenu,(v_title_menu+ost_id).w	; load the title screen menu

		lea	(v_title_palette_changer_1).w,a1	; delete the palette changer object
		bsr.w	DeleteChild

		lea_	Pal_TitleLogo,a1			; load the logo palette
		lea	(v_pal_dry_line4).w,a2
		moveq	#(sizeof_pal/4)-1,d6
	.loop1:
		move.l	(a1)+,(a2)+
		dbf	d6,.loop1

		lea_	Pal_TitleBackground,a1			; load the background palette
		lea	(v_pal_dry_line3).w,a2
		moveq	#(sizeof_pal/4)-1,d6
	.loop2:
		move.l	(a1)+,(a2)+
		dbf	d6,.loop2

		lea_	Pal_TitleSonic,a1			; load Sonic and Tails' palette
		lea	(v_pal_dry_line1).w,a2
		moveq	#(sizeof_pal/4)-1,d6
	.loop3:
		move.l	(a1)+,(a2)+
		dbf	d6,.loop3

		tst.b	ost_titlintr_music_flag(a0)		; is title screen music already playing?
		bne.s	.exit					; if so, exit
		moveq_	mus_Title,d0				; play the title screen music
		jsrto	PlayMusic,JmpTo4_PlayMusic

	.exit:
		rts


; ===========================================================================

TitlIntr_InitSprite:
		move.l	#Map_TitleIntro,ost_mappings(a1)
		move.w	#tile_TitleSprites,ost_tile(a1)
		move.b	#4,ost_priority(a1)
		rts

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0F - Title screen menu
; ----------------------------------------------------------------------------

TitleMenu:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_13612(pc,d0.w),d1
		jsr	off_13612(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
off_13612:	index offset(*),,2
		ptr loc_13616					; 0
		ptr loc_13644					; 2
; ===========================================================================

loc_13616:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#screen_left+(screen_width/2)+8,ost_x_screen(a0)
		move.w	#screen_top+(screen_height/2)+92,ost_y_screen(a0)
		move.l	#Map_TitleMenu,ost_mappings(a0)
		move.w	#vram_start,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		andi.b	#1,(v_title_screen_option).w
		move.b	(v_title_screen_option).w,ost_frame(a0)

loc_13644:
		moveq	#0,d2
		move.b	(v_title_screen_option).w,d2
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		btst	#0,d0
		beq.s	loc_13660
		subq.b	#1,d2
		bcc.s	loc_13660
		move.b	#2,d2

loc_13660:
		btst	#1,d0
		beq.s	loc_13670
		addq.b	#1,d2
		cmpi.b	#3,d2
		bcs.s	loc_13670
		moveq	#0,d2

loc_13670:
		move.b	d2,ost_frame(a0)
		move.b	d2,(v_title_screen_option).w
		andi.b	#3,d0
		beq.s	locret_13684
		moveq	#-$33,d0
		jsrto	PlaySound,JmpTo4_PlaySound

locret_13684:
		rts
; ===========================================================================
Ani_TitleIntro:	index offset(*)

		ptr Ani_TitlIntr_Sonic				; 0
		ptr Ani_TitlIntr_Tails				; 1
		ptr Ani_TitlIntr_FlashingStar			; 2
		ptr Ani_TitlIntr_FallingStar			; 3

Ani_TitlIntr_Sonic:
		dc.b	1
		dc.b	id_Frame_IntroSonic_0
		dc.b	id_Frame_IntroSonic_1
		dc.b	id_Frame_IntroSonic_2
	if FixBugs=0
		; This appears to be a leftover prototype frame: it's a duplicate of
		; frame $12, except Sonic is missing his right arm. The old frame
		; being here in this animation script causes Sonic to appear with
		; both of his arms missing for a single frame.
		dc.b	id_Frame_IntroSonic_BetaLeftover
	endc
		dc.b	af2ndRoutine
		even

Ani_TitlIntr_Tails:
		dc.b	1
		dc.b	id_Frame_IntroTails_0
		dc.b	id_Frame_IntroTails_1
		dc.b	id_Frame_IntroTails_2
		dc.b	id_Frame_IntroTails_3
		dc.b	id_Frame_IntroTails_4
		dc.b 	af2ndRoutine
		even

Ani_TitlIntr_FlashingStar:
		dc.b	1
		dc.b	id_Frame_IntroStar_0
		dc.b	id_Frame_IntroStar_1
		dc.b	id_Frame_IntroStar_2
		dc.b	id_Frame_IntroStar_1
		dc.b	id_Frame_IntroStar_0
		dc.b	af2ndRoutine
		even

Ani_TitlIntr_FallingStar:
		dc.b	3
		dc.b	id_Frame_IntroStar_0
		dc.b	id_Frame_IntroStar_3
		dc.b 	afEnd
		even

	include "mappings/sprite/Title Intro.asm"
	include "mappings/sprite/Title Menu.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo4_PlaySound:
		jmp	(PlaySound).l
JmpTo4_PlayMusic:
		jmp	(PlayMusic).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 34 - Zone title cards (screen with red, yellow, and blue)
; ----------------------------------------------------------------------------

TitleCard:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Card_Index(pc,d0.w),d1
		jmp	Card_Index(pc,d1.w)
; ===========================================================================
Card_Index:	index offset(*),,2
		ptr Card_Load					; 0
		ptr Card_RightIn				; 2
		ptr Card_BottomIn				; 4
		ptr Card_LeftIn					; 6
		ptr Card_ZoneName				; 8
		ptr Card_Zone					; $A
		ptr Card_ActNumber				; $C
		ptr Card_LeftOut				; $E
		ptr Card_BottomOut				; $10
		ptr Card_RightOutInit				; $12
		ptr Card_RightOut				; $14
		ptr Card_WaitAndGoAway				; $16


		rsobj TitleCard,$30
ost_card_x_stop:		rs.w 1				; $30 ; on screen x position
ost_card_x_start:		rs.w 1				; $32 ; start & finish x position
ost_card_location:		rs.w 1				; $34 ; point up to which titlecard is drawn
ost_card_vram_dest:		rs.w 1				; $36 ; target of VRAM write
ost_card_vram_dest_2p:	rs.w 1					; $38 ; target of VRAM write
ost_card_split_point:	rs.w 1					; $3A ; point to split drawing for yellow and red portions
		rsset $3E
ost_card_leaveflag:		rs.w 1				; $3E ;  whether or not titlecard is leaving screen
		rsobjend

; ===========================================================================

Card_Load:
		lea	(a0),a1
		lea	TitleCard_Data(pc),a2			; load title card data array
		moveq	#((sizeof_TitleCard_Data)/$A)-1,d1	; each object's data is $A bytes

	.loadloop:
		_move.b	#id_TitleCard,ost_id(a1)		; load title card object (this first object becomes the zone name after loading all the others)
		move.b	(a2)+,ost_primary_routine(a1)		; load data from the TitleCard_Data array
		move.l	#Map_Card,ost_mappings(a1)
		move.b	(a2)+,ost_frame(a1)
		move.b	(a2)+,ost_displaywidth(a1)
		move.b	(a2)+,ost_anim_time(a1)
		move.w	(a2),ost_x_screen(a1)
		move.w	(a2)+,ost_card_x_start(a1)
		move.w	(a2)+,ost_card_x_stop(a1)
		move.w	(a2)+,ost_y_screen(a1)
		move.b	#render_abs,ost_render(a1)
		lea	sizeof_ost(a1),a1			; next ost slot
		dbf	d1,.loadloop				; repeat until all title card objects are loaded

		move.w	#$26,(v_ost_titlecard_bottom+ost_card_location).w

		clr.w	(v_fg_y_pos_vsram).w
		move.w	#$FF20,(v_fg_y_pos_vsram_p2).w
		clear_ram hscroll,hscroll_end			; clear the hscroll buffer

		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; The following array is data used to populate the OSTs for each
; title card object. Each entry is $A bytes, and consists of:
; - the initial routine counter (byte)
; - the initial mapping frame (byte)
; - the width of the object (byte)
; - the number of frames before it appears on screen (byte)
; - the X position where it starts and where it will go back (word)
; - the X position to reach (word)
; - the Y position (word)
; ---------------------------------------------------------------------------

titlecardobjdata macro routine,frame,width,duration,xstart,xstop,y
		dc.b \routine,\frame,\width,\duration
		dc.w \xstart,\xstop,\y
		endm

TitleCard_Data:
		titlecardobjdata	id_Card_ZoneName,   0, 							$80, $1B, screen_right+128, screen_left+160,	screen_top+56 ; zone name, frame is set later based on v_zone
		titlecardobjdata	id_Card_Zone, 		id_Frame_Card_Zone, 		$40, $1C, screen_left-88, 	screen_left+200, 	screen_top+80 ; "ZONE"
		titlecardobjdata	id_Card_ActNumber, 	id_Frame_Card_Act1, 		$18, $1C, screen_left-24, 	screen_left+264, 	screen_top+80 ; act number
		titlecardobjdata	id_Card_RightIn,  	0, 							0,   0,   0,    			0,					0 ; blue background
		titlecardobjdata 	id_Card_BottomIn, 	id_Frame_Card_STH,			$48, 8,	  screen_right+232, screen_left+232, 	screen_top+160 ; bottom yellow part
		titlecardobjdata	id_Card_LeftIn, 	id_Frame_Card_RedTriangles,	8,	 $15, screen_left,  	screen_left+112, 	screen_top+112 ; left red part
		arraysize	TitleCard_Data
; ===========================================================================

;Obj34_Wait:
Card_Wait:
		subq.b	#1,ost_anim_time(a0)			; decrement timer
		bne.s	.timeleft				; if it's not 0, branch
		move.b	#1,ost_anim_time(a0)			; reset timer
		rts
; ===========================================================================

	.timeleft:
		addq.w	#4,sp					; don't run the code after the call to this routine
		rts

; ===========================================================================
;Obj34_BackgroundIn:
Card_RightIn:
		moveq	#$10,d0					; values used to calculate the VRAM destination
		moveq	#8,d1
		tst.w	(f_two_player).w			; is it two player mode?
		sne	d6					; if so, set d6 to $FF, else set to 0
		beq.s	.not2P					; if not two-player mode, branch
		moveq	#$20,d0					; use these values to calculate the VRAM destination instead
		moveq	#7,d1

	.not2P:
		move.w	ost_card_location(a0),d2
		cmp.w	d0,d2					; has background reached the target position?
		beq.s	.exit					; if it has, exit
		lsl.w	d1,d2
		move.w	#vram_fg,d0
		add.w	d2,d0
		move.w	d0,ost_card_vram_dest(a0)		; set VRAM destination
		tst.b	d6					; is it two-player mode?
		beq.s	.update_position			; if not, branch
		addi.w	#vram_fg_2p,d2
		move.w	d2,ost_card_vram_dest_2p(a0)		; set VRAM destination for player 2's half of screen

	.update_position:
		addq.w	#1,ost_card_location(a0)

	.exit:
		rts
; ===========================================================================
;Obj34_BottomPartIn:
Card_BottomIn:
		jsr	Card_Wait(pc)
		move.w	ost_card_location(a0),d0		; current position
		bmi.w	Card_Move				; branch if outside right of screen
		add.w	d0,d0
		move.w	#(sizeof_vram_row_64*$14)/2,d1		; Line 20 in 2P mode
		tst.w	(f_two_player).w			; is it two-player mode?
		sne	d6					; if so, set d6...
		bne.s	.not2P					; ...and branch
		add.w	d1,d1					; Line 40 in 1P mode

	.not2P:
		move.w	#vram_fg,d2
		add.w	d0,d2
		add.w	d1,d2
		move.w	d2,ost_card_vram_dest(a0)		; set VRAM destination
		tst.b	d6					; is it two-player mode?
		beq.s	.update_position			; if not, branch
		addi.w	#vram_fg_2p,d1
		add.w	d0,d1
		move.w	d1,ost_card_vram_dest_2p(a0)

	.update_position:
		subq.w	#2,ost_card_location(a0)
		move.w	ost_card_location(a0),ost_card_split_point(a0)
		cmpi.w	#6,ost_card_location(a0)		; is card location 6?
		seq	ost_card_location(a0)			; if so, set to $FF, else set to 0
		bra.w	Card_Move
; ===========================================================================
;Obj34_LeftPartIn:
Card_LeftIn:
		jsr	Card_Wait(pc)
		tst.w	ost_card_location(a0)			; current position
		bmi.w	Card_Move				; branch if outside left of screen
		move.w	#vram_fg,ost_card_vram_dest(a0)
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.s	.update_position			; if not, branch
		move.w	#vram_fg_2p,ost_card_vram_dest_2p(a0)

	.update_position:
		addq.w	#2,ost_card_location(a0)
		move.w	ost_card_location(a0),ost_card_split_point(a0)
		cmpi.w	#$E,ost_card_location(a0)		; is card location $E?
		seq	ost_card_location(a0)			; if so, set to $FF, else set to 0
		bra.w	Card_Move
; ===========================================================================

Card_ZoneName:
		jsr	Card_Wait(pc)
		move.b	(v_zone).w,ost_frame(a0)		; set mapping frame based on zone ID
		bra.s	Card_Move
; ===========================================================================

Card_Zone:
		jsr	Card_Wait(pc)
		bra.s	Card_Move
; ===========================================================================

Card_ActNumber:
		jsr	Card_Wait(pc)
		move.b	(v_zone).w,d0				; get current zone
		cmpi.b	#id_SCZ,d0				; is it SCZ?
		beq.s	BranchTo9_DeleteObject			; if so, delete this object since there is no act number
		cmpi.b	#id_WFZ,d0				; do the same if it is WFZ...
		beq.s	BranchTo9_DeleteObject
		cmpi.b	#id_DEZ,d0				; ...or DEZ
		beq.s	BranchTo9_DeleteObject
		move.b	(v_act).w,d1				; get act number
		addi.b	#id_Frame_Card_Act1,d1			; add $12 to make index for act number
		cmpi.b	#id_MTZ_2,d0				; is it MTZ act 3?
		bne.s	.set_act_num
		moveq	#id_Frame_Card_Act3,d1			; if so, use the "3" frame instead

	.set_act_num:
		move.b	d1,ost_frame(a0)
		; continue straight into Card_Move

;Obj34_MoveTowardsTargetPosition:
Card_Move:
		moveq	#$10,d0					; set to move 16px (direction depends on object)
		move.w	ost_x_screen(a0),d1
		cmp.w	ost_card_x_stop(a0),d1			; has item reached the target position?
		beq.s	.at_target				; if so, branch
		bhi.s	.beyond_target				; if it is beyond the target positon, branch
		neg.w	d0					; move in the other direction

	.beyond_target:
		sub.w	d0,ost_x_screen(a0)			; move the item
		cmpi.w	#screen_right+64,ost_x_screen(a0)	; is is more than 64 pixels beyond right edge of screen?
		bhi.s	.no_display				; if so, branch

	.at_target:
		bra.w	DisplaySprite
; ===========================================================================

	.no_display:
		rts
; ===========================================================================

BranchTo9_DeleteObject:
		bra.w	DeleteObject
; ===========================================================================

Card_LeftOut:
		move.w	ost_card_location(a0),d0		; current location of card
		bpl.s	.onscreen				; branch if still on screen
		move.b	#id_Card_BottomOut,v_ost_titlecard_bottom-v_ost_titlecard_left+ost_primary_routine(a0) ; set bottom to move out
		clr.w	v_ost_titlecard_bottom-v_ost_titlecard_left+ost_card_location(a0) ; clear bottom's position
		bra.s	BranchTo9_DeleteObject			; delete card left object
; ===========================================================================

	.onscreen:
		add.w	d0,d0
		move.w	#vram_fg,ost_card_vram_dest(a0)
		add.w	d0,ost_card_vram_dest(a0)		; set VRAM destination
		tst.w	(f_two_player).w			; is it two=player mode?
		beq.s	.not2P					; if not, branch
		move.w	#vram_fg_2p,ost_card_vram_dest_2p(a0)
		add.w	d0,ost_card_vram_dest_2p(a0)

	.not2P:
		subq.w	#4,ost_card_location(a0)		; move card to left
		cmpi.w	#-2,ost_card_location(a0)
		bne.s	.is_right				; branch if right of target
		clr.w	ost_card_location(a0)

	.is_right:
		bra.w	Card_MoveBack
; ===========================================================================

Card_BottomOut:
		move.w	ost_card_location(a0),d0		; current location of card
		cmpi.w	#$28,d0
		bne.s	.not_at_target				; branch if it has not reached target
		move.b	#id_Card_RightOutInit,v_ost_titlecard_background-v_ost_titlecard_bottom+ost_primary_routine(a0) ; set right to move out
		bra.s	BranchTo9_DeleteObject			; delete card bottom object
; ===========================================================================

	.not_at_target:
		add.w	d0,d0
		move.w	#($80*$14)/2,d1				; Line 10 in 2P mode
		tst.w	(f_two_player).w			; is it two-player mode?
		sne	d6					; if so, set d6 to $FF, else set to 0
		bne.s	.not2P					; if not two-player mode, branch
		add.w	d1,d1					; Line 20 in 1P mode

	.not2P:
		move.w	#vram_fg,d2
		add.w	d0,d2
		add.w	d1,d2
		move.w	d2,ost_card_vram_dest(a0)		; set VRAM destination
		tst.b	d6					; is it two-player mode?
		beq.s	.update_position			; if not, branch
		addi.w	#vram_fg_2p,d1
		add.w	d0,d1
		move.w	d1,ost_card_vram_dest_2p(a0)

	.update_position:
		addq.w	#4,ost_card_location(a0)
		; continue straight into Card_MoveBack

Card_MoveBack:
		moveq	#$20,d0					; move 32 pixels
		move.w	ost_x_screen(a0),d1			; current location of card
		cmp.w	ost_card_x_start(a0),d1			; has item reached the target position?
		beq.s	.no_display				; if so, exit
		bhi.s	.not_at_target				; if it hasn't reached target, branch
		neg.w	d0

	.not_at_target:
		sub.w	d0,ost_x_screen(a0)			; move the item
		cmpi.w	#screen_right+64,ost_x_screen(a0)	; is is more than 64 pixels beyond right edge of screen?
		bhi.s	.no_display				; if so, branch
		bra.w	DisplaySprite
; ===========================================================================

	.no_display:
		rts
; ===========================================================================
;Obj34_BackgroundOutInit:
Card_RightOutInit:
		pushr.l	a0
		pushr.l	d7
		bsr.w	DeformLayers
		popr.l	d7
		popr.l	a0
		addi_.b	#2,ost_primary_routine(a0)		; go to Card_RightOut next
		move.w	#$F0,ost_card_location(a0)

;Obj34_BackgroundOut:
Card_RightOut:
		move.w	ost_card_location(a0),d0
		subi.w	#$20,d0
		cmpi.w	#-$30,d0
		beq.w	BranchTo9_DeleteObject
		move.w	d0,ost_card_location(a0)
		move.w	d0,ost_card_vram_dest(a0)
		rts
; ===========================================================================
Card_WaitAndGoAway:
		tst.w	ost_anim_time(a0)			; has timer hit 0?
		beq.s	.moveback				; if so, branch
		subq.w	#1,ost_anim_time(a0)			; decrement timer
		bra.s	.display
; ===========================================================================

	.moveback:
		moveq	#$20,d0					; move 32 pixels
		move.w	ost_x_screen(a0),d1
		cmp.w	ost_card_x_start(a0),d1			; has item reached the finish position?
		beq.s	Card_ChangeArt				; if so, branch
		bhi.s	.beyond_target				; if item is beyond target, branch
		neg.w	d0					; move in the opposite direction

	.beyond_target:
		sub.w	d0,ost_x_screen(a0)			; update position
		cmpi.w	#screen_right+64,ost_x_screen(a0)	; is is more than 64 pixels beyond right edge of screen?
		bhi.s	Card_ChangeArt				; if so, branch

	.display:
		bra.w	DisplaySprite
; ===========================================================================

Card_ChangeArt:
		cmpa.w	#v_ost_titlecard_zonename,a0		; is this the zone name object (the parent of all the titlecard objects)
		bne.s	.delete					; if not, branch
		moveq	#id_PLC_Water,d0			; load standard water graphics
		jsrto	LoadPLC,JmpTo3_AddPLC
		moveq	#0,d0
		move.b	(v_zone).w,d0
		move.b	Animal_PLCs(pc,d0.w),d0			; load the animal graphics for the current zone
		jsrto	LoadPLC,JmpTo3_AddPLC

	.delete:
		bra.w	DeleteObject				; delete the title card object
; ===========================================================================
Animal_PLCs:
		dc.b id_PLC_EHZAnimals				; 0
		dc.b id_PLC_EHZAnimals				; 1
		dc.b id_PLC_EHZAnimals				; 2
		dc.b id_PLC_EHZAnimals				; 3
		dc.b id_PLC_MTZAnimals				; 4
		dc.b id_PLC_MTZAnimals				; 5
		dc.b id_PLC_WFZAnimals				; 6
		dc.b id_PLC_HTZAnimals				; 7
		dc.b id_PLC_HPZAnimals				; 8
		dc.b id_PLC_HPZAnimals				; 9
		dc.b id_PLC_OOZAnimals				; $A
		dc.b id_PLC_MCZAnimals				; $B
		dc.b id_PLC_CNZAnimals				; $C
		dc.b id_PLC_CPZAnimals				; $D
		dc.b id_PLC_DEZAnimals				; $E
		dc.b id_PLC_ARZAnimals				; $F
		dc.b id_PLC_SCZAnimals				; $10
		zonewarning Animal_PLCs,1

		dc.b id_PLC_SCZAnimals				; non-existent slot $11
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 39 - Game/Time Over text
; ----------------------------------------------------------------------------

GameOverCard:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Over_Index(pc,d0.w),d1
		jmp	Over_Index(pc,d1.w)
; ===========================================================================
Over_Index:	index offset(*),,2
		ptr Over_ChkPLC					; 0
		ptr Over_Move					; 2
		ptr Over_Wait					; 4
; ===========================================================================

Over_ChkPLC:
		tst.l	(v_plc_buffer).w
		beq.s	loc_13F90
		rts
; ===========================================================================

loc_13F90:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#screen_left-48,ost_x_screen(a0)
		btst	#0,ost_frame(a0)
		beq.s	loc_13FA8
		move.w	#screen_right+48,ost_x_screen(a0)

loc_13FA8:
		move.w	#screen_top+112,ost_y_screen(a0)
		move.l	#Map_Over,ost_mappings(a0)
		move.w	#tile_Nem_Game_Over+tile_hi,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_abs,ost_render(a0)
		move.b	#0,ost_priority(a0)

Over_Move:
		moveq	#$10,d1
		cmpi.w	#screen_left+160,ost_x_screen(a0)
		beq.s	loc_13FE2
		bcs.s	loc_13FDA
		neg.w	d1

loc_13FDA:
		add.w	d1,ost_x_screen(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_13FE2:
		move.w	#$2D0,ost_anim_time(a0)
		addq.b	#2,ost_primary_routine(a0)
	if FixBugs
		; The GAME OVER/TIME OVER text disappears for a single frame once it
		; reaches its final position. This is because it forgets to queue itself
		; for display here.
		bra.w	DisplaySprite
	else
		rts
	endif
; ===========================================================================

Over_Wait:
		btst	#0,ost_frame(a0)
		bne.w	loc_14082
		move.b	(v_joypad_press_actual).w,d0
		or.b	(v_joypad2_press_actual).w,d0
		andi.b	#$70,d0
		bne.s	loc_14014
		tst.w	ost_anim_time(a0)
		beq.s	loc_14014
		subq.w	#1,ost_anim_time(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_14014:
		tst.b	(f_time_over).w
		bne.s	loc_14034
		tst.b	(f_time_over_p2).w
		bne.s	loc_14034
		move.b	#$14,(v_gamemode).w
		tst.b	(v_continues).w
		bne.s	loc_1403E
		move.b	#0,(v_gamemode).w
		bra.s	loc_1403E
; ===========================================================================

loc_14034:
		clr.l	(v_time_lampcopy).w
		move.w	#1,(f_restart).w

loc_1403E:
		tst.w	(f_two_player).w
		beq.s	loc_14082
		move.w	#0,(f_restart).w
		move.b	#$18,(v_gamemode).w
		move.w	#0,(v_results_screen_2p).w
		tst.b	(f_time_over).w
		bne.s	loc_14082
		tst.b	(f_time_over_p2).w
		bne.s	loc_14082
		move.w	#1,(v_game_over_2p).w
		move.w	#1,(v_results_screen_2p).w
		jsrto	sub_8476,JmpTo_sub_8476
		move.w	#-1,(a4)
		tst.b	$3F(a0)
		beq.s	loc_1407E
		addq.w	#1,a4

loc_1407E:
		move.b	#-2,(a4)

loc_14082:
		bra.w	DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 3A - End of level results screen
; ----------------------------------------------------------------------------

GotThroughCard:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_14094(pc,d0.w),d1
		jmp	off_14094(pc,d1.w)
; ===========================================================================
off_14094:	index offset(*),,2
		ptr loc_140AC					; 0
		ptr loc_14102					; 2
		ptr loc_14142					; 4
		ptr loc_14146					; 6
		ptr loc_14168					; 8
		ptr loc_1419C					; $A
		ptr loc_141AA					; $C
		ptr loc_1419C					; $E
		ptr loc_14270					; $10
		ptr loc_142B0					; $12
		ptr loc_142CC					; $14
		ptr loc_1413A					; $16
; ===========================================================================

loc_140AC:
		tst.l	(v_plc_buffer).w
		beq.s	loc_140B4
		rts
; ===========================================================================

loc_140B4:
		movea.l	a0,a1
		lea	GotThroughCard_Data(pc),a2
		moveq	#7,d1

loc_140BC:
		_move.b	ost_id(a1),d0
		beq.s	loc_140CE
		cmpi.b	#$3A,d0
		beq.s	loc_140CE
		lea	$40(a1),a1
		bra.s	loc_140BC
; ===========================================================================

loc_140CE:
		_move.b	#id_GotThroughCard,ost_id(a1)
		move.w	(a2)+,ost_x_screen(a1)
		move.w	(a2)+,$30(a1)
		move.w	(a2)+,ost_y_screen(a1)
		move.b	(a2)+,ost_primary_routine(a1)
		move.b	(a2)+,ost_frame(a1)
		move.l	#Map_GotThrough,ost_mappings(a1)
		bsr.w	AdjustVRAM2P2
		move.b	#render_abs,ost_render(a1)
		lea	$40(a1),a1
		dbf	d1,loc_140BC

loc_14102:
		moveq	#0,d0
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_14118
		addq.w	#1,d0
		btst	#console_region_bit,(v_console_region).w
		beq.s	loc_14118
		addq.w	#1,d0

loc_14118:
		move.b	d0,ost_frame(a0)
		bsr.w	Card_Move
		move.w	ost_x_screen(a0),d0
		cmp.w	$30(a0),d0
		bne.w	locret_14138
		move.b	#$A,ost_primary_routine(a0)
		move.w	#$B4,ost_anim_time(a0)

locret_14138:
		rts
; ===========================================================================

loc_1413A:
		tst.w	(v_perfect_rings_left).w
		bne.w	DeleteObject

loc_14142:
		bra.w	Card_Move
; ===========================================================================

loc_14146:
		move.b	(v_zone).w,d0
		cmpi.b	#$10,d0
		beq.s	loc_1415E
		cmpi.b	#6,d0
		beq.s	loc_1415E
		cmpi.b	#$E,d0
		bne.w	Card_Move

loc_1415E:
		move.b	#5,ost_frame(a0)
		bra.w	Card_Move
; ===========================================================================

loc_14168:
		move.b	(v_zone).w,d0
		cmpi.b	#$10,d0
		beq.w	BranchTo9_DeleteObject
		cmpi.b	#6,d0
		beq.w	BranchTo9_DeleteObject
		cmpi.b	#$E,d0
		beq.w	BranchTo9_DeleteObject
		cmpi.b	#5,d0
		bne.s	loc_1418E
		moveq	#8,d0
		bra.s	loc_14194
; ===========================================================================

loc_1418E:
		move.b	(v_act).w,d0
		addq.b	#6,d0

loc_14194:
		move.b	d0,ost_frame(a0)
		bra.w	Card_Move
; ===========================================================================

loc_1419C:
		subq.w	#1,ost_anim_time(a0)
		bne.s	loc_141A6
		addq.b	#2,ost_primary_routine(a0)

loc_141A6:
		bra.w	DisplaySprite
; ===========================================================================

loc_141AA:
		bsr.w	DisplaySprite
		move.b	#1,(f_pass_bonus_update).w
		moveq	#0,d0
		tst.w	(v_bonus_count_1).w
		beq.s	loc_141C6
		addi.w	#$A,d0
		subi.w	#$A,(v_bonus_count_1).w

loc_141C6:
		tst.w	(v_bonus_count_2).w
		beq.s	loc_141D6
		addi.w	#$A,d0
		subi.w	#$A,(v_bonus_count_2).w

loc_141D6:
		tst.w	(v_bonus_count_3).w
		beq.s	loc_141E6
		addi.w	#$A,d0
		subi.w	#$A,(v_bonus_count_3).w

loc_141E6:
		add.w	d0,(v_total_bonus_countdown).w
		tst.w	d0
		bne.s	loc_14256
		move.w	#$C5,d0
		jsr	(PlaySound).l
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$B4,ost_anim_time(a0)
		cmpi.w	#$3E8,(v_total_bonus_countdown).w
		bcs.s	locret_14254
		move.w	#$12C,ost_anim_time(a0)
		lea	$40(a0),a1

loc_14214:
		_tst.b	ost_id(a1)
		beq.s	loc_14220
		lea	$40(a1),a1
		bra.s	loc_14214
; ===========================================================================

loc_14220:
		_move.b	#id_GotThroughCard,ost_id(a1)
		move.b	#$12,ost_primary_routine(a1)
		move.w	#screen_left+264,ost_x_screen(a1)
		move.w	#screen_top+152,ost_y_screen(a1)
		move.l	#Map_GotThrough,ost_mappings(a1)
		bsr.w	AdjustVRAM2P2
		move.b	#render_abs,ost_render(a1)
		move.w	#$3C,ost_anim_time(a1)
		addq.b	#1,(v_continues).w

locret_14254:
		rts
; ===========================================================================

loc_14256:
		jsr	(AddPoints).l
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#3,d0
		bne.s	locret_14254
		move.w	#$CD,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_14270:
		moveq	#0,d0
		move.b	(v_zone).w,d0
		add.w	d0,d0
		add.b	(v_act).w,d0
		add.w	d0,d0
		lea	LevelOrder(pc),a1
		tst.w	(f_two_player).w
		beq.s	loc_1428C
		lea	LevelOrder_2P(pc),a1

loc_1428C:
		move.w	(a1,d0.w),d0				; get id of next level
		tst.w	d0
		bpl.s	loc_1429C				; branch if it's not the terminator ($FFFF)
		move.b	#id_Sega,(v_gamemode).w			; go to Sega screen
		rts
; ===========================================================================

loc_1429C:
		move.w	d0,(v_zone).w
		clr.b	(v_last_lamppost).w
		clr.b	(v_last_lamppost_p2).w
		move.w	#1,(f_restart).w
		rts
; ===========================================================================

loc_142B0:
		tst.w	ost_anim_time(a0)
		beq.s	loc_142BC
		subq.w	#1,ost_anim_time(a0)
		rts
; ===========================================================================

loc_142BC:
		addi_.b	#2,ost_primary_routine(a0)
		move.w	#sfx_ContinueJingle,d0
		jsr	(PlaySound).l

loc_142CC:
		subq.w	#1,ost_anim_time(a0)
		bpl.s	loc_142E2
		move.w	#$13,ost_anim_time(a0)
		addq.b	#1,ost_anim_frame(a0)
		andi.b	#1,ost_anim_frame(a0)

loc_142E2:
		moveq	#$C,d0
		add.b	ost_anim_frame(a0),d0
		move.b	d0,ost_frame(a0)
		btst	#4,(v_frame_counter_low).w
		bne.w	DisplaySprite
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Level	order arrays

; Lists which levels which are loaded after the current level
; ---------------------------------------------------------------------------
LevelOrder:
		; Emerald Hill Zone
		dc.w id_EHZ_act2				; Act 1
		dc.w id_CPZ_act1				; Act 2

		; Level 1 (unused)
		dc.w id_EHZ_act1
		dc.w id_EHZ_act1

		; Wood Zone (unused)
		dc.w id_WZ_act2					; Act 1
		dc.w id_MTZ_act1				; Act 2

		; Level 3 (unused)
		dc.w id_EHZ_act1
		dc.w id_EHZ_act1

		; Metropolis Zone Acts 1 & 2
		dc.w id_MTZ_act2				; Act 1
		dc.w id_MTZ_act3				; Act 2

		; Metropolis Zone Act 3
		dc.w id_SCZ_act1				; Act 3
		dc.w id_EHZ_act1				; unused

		; Wing Fortress Zone
		dc.w id_DEZ_act1				; Act 1
		dc.w id_EHZ_act1				; unused

		; Hill Top Zone
		dc.w id_HTZ_act2				; Act 1
		dc.w id_MCZ_act1				; Act 2

		; Hidden Palace Zone (unused)
		dc.w id_HPZ_act2				; Act 1
		dc.w id_OOZ_act1				; Act 2

		; Level 9 (unused)
		dc.w id_EHZ_act1
		dc.w id_EHZ_act1

		; Oil Ocean Zone
		dc.w id_OOZ_act2				; Act 1
		dc.w id_MTZ_act1				; Act 2

		; Mystic Cave Zone
		dc.w id_MCZ_act2				; Act 1
		dc.w id_OOZ_act1				; Act 2

		; Casino Night Zone
		dc.w id_CNZ_act2				; Act 1
		dc.w id_HTZ_act1				; Act 2

		; Chemical Plant Zone
		dc.w id_CPZ_act2				; Act 1
		dc.w id_ARZ_act1				; Act 2

		; Death Egg Zone (unused, as no results screen is loaded on that level)
		dc.w $FFFF					; Act 1
		dc.w id_EHZ_act1				; unused

		; Aquatic Ruin Zone
		dc.w id_ARZ_act2				; Act 1
		dc.w id_CNZ_act1				; Act 2

		dc.w id_WFZ_act1				; Act 1
		dc.w id_EHZ_act1				; unused
		zonewarning LevelOrder,4

LevelOrder_2P:
		; Emerald Hill Zone
		dc.w id_EHZ_act2				; Act 1
		dc.w id_CNZ_act1				; Act 2

		; Level 1 (unused)
		dc.w id_EHZ_act1
		dc.w id_EHZ_act1

		; Wood Zone (unused)
		dc.w id_WZ_act2					; Act 1
		dc.w id_MTZ_act1				; Act 2

		; Level 3 (unused)
		dc.w id_EHZ_act1
		dc.w id_EHZ_act1

		; Metropolis Zone Acts 1 & 2
		dc.w id_MTZ_act2				; Act 1
		dc.w id_MTZ_act3				; Act 2

		; Metropolis Zone Act 3
		dc.w id_SCZ_act1				; Act 3
		dc.w id_EHZ_act1				; unused

		; Wing Fortress Zone
		dc.w id_DEZ_act1				; Act 1
		dc.w id_EHZ_act1				; unused

		; Hill Top Zone
		dc.w id_HTZ_act2				; Act 1
		dc.w id_MCZ_act1				; Act 2

		; Hidden Palace Zone (unused)
		dc.w id_HPZ_act2				; Act 1
		dc.w id_OOZ_act1				; Act 2

		; Level 9 (unused)
		dc.w id_EHZ_act1
		dc.w id_EHZ_act1

		; Oil Ocean Zone
		dc.w id_OOZ_act2				; Act 1
		dc.w id_MTZ_act1				; Act 2

		; Mystic Cave Zone
		dc.w id_MCZ_act2				; Act 1
		dc.w $FFFF					; Act 2

		; Casino Night Zone
		dc.w id_CNZ_act2				; Act 1
		dc.w id_MCZ_act1				; Act 2

		; Chemical Plant Zone
		dc.w id_CPZ_act2				; Act 1
		dc.w id_ARZ_act1				; Act 2

		; Death Egg Zone
		dc.w $FFFF					; Act 1, sends game to Sega screen
		dc.w id_EHZ_act1				; unused

		; Aquatic Ruin Zone
		dc.w id_ARZ_act2				; Act 1
		dc.w id_CNZ_act1				; Act 2

		dc.w id_WFZ_act1				; Act 1
		dc.w id_EHZ_act1				; unused
		zonewarning LevelOrder_2P,4

; ===========================================================================

GotThroughCard_Data:

gotthrough_data: macro startx,targetx,y,routine,frame
		dc.w	\startx,\targetx,\y
		dc.b	\routine,\frame
   		endm

		gotthrough_data  screen_left-96,   screen_left+160,  screen_top+56,    2,  0
		gotthrough_data  screen_right+64,  screen_left+128,  screen_top+74,    4,  3
		gotthrough_data  screen_right+128, screen_left+192,  screen_top+74,    6,  4
		gotthrough_data  screen_right+184, screen_left+248,  screen_top+62,    8,  6
		gotthrough_data  screen_right+400, screen_left+160,  screen_top+160,   4,  9
		gotthrough_data  screen_right+352, screen_left+160,  screen_top+112,   4, $A
		gotthrough_data  screen_right+368, screen_left+160,  screen_top+128,   4, $B
		gotthrough_data  screen_right+384, screen_left+160,  screen_top+144, $16, $E

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 6F - End of special stage results screen
; ----------------------------------------------------------------------------

SSResult:
		moveq	#0,d0
		moveq	#0,d6
		move.b	ost_primary_routine(a0),d0
		move.w	SSR_Index(pc,d0.w),d1
		jmp	SSR_Index(pc,d1.w)
; ===========================================================================
SSR_Index:	index offset(*),,2
		ptr loc_14406					; 0
		ptr loc_14450					; 2
		ptr loc_14484					; 4
		ptr loc_144C2					; 6
		ptr loc_144C0					; 8
		ptr loc_144BE					; $A
		ptr loc_144BC					; $C
		ptr loc_144BA					; $E
		ptr loc_144B8					; $10
		ptr loc_144B6					; $12
		ptr loc_14564					; $14
		ptr loc_14500					; $16
		ptr loc_144DC					; $18
		ptr loc_14568					; $1A
		ptr loc_14572					; $1C
		ptr loc_14580					; $1E
		ptr loc_14572					; $20
		ptr loc_1461C					; $22
		ptr loc_14572					; $24
		ptr loc_14572					; $26
		ptr loc_14626					; $28
		ptr loc_14692					; $2A
		ptr loc_14572					; $2C
		ptr loc_1461C					; $2E
		ptr SSR_InitAndMoveSuperMsg			; $30
		ptr loc_14714					; $32
		ptr loc_14736					; $34
; ===========================================================================

loc_14406:
		tst.l	(v_plc_buffer).w
		beq.s	loc_1440E
		rts
; ===========================================================================

loc_1440E:
		movea.l	a0,a1
		lea	byte_14752(pc),a2
		moveq	#$C,d1

loc_14416:
		_move.b	ost_id(a0),ost_id(a1)
		move.w	(a2),ost_x_screen(a1)
		move.w	(a2)+,$32(a1)
		move.w	(a2)+,$30(a1)
		move.w	(a2)+,ost_y_screen(a1)
		move.b	(a2)+,ost_primary_routine(a1)
		move.b	(a2)+,ost_frame(a1)
		move.l	#Map_SSR,ost_mappings(a1)
		move.b	#$78,ost_displaywidth(a1)
		move.b	#render_abs,ost_render(a1)
		lea	$40(a1),a1
		dbf	d1,loc_14416

loc_14450:
		tst.b	(f_got_emerald).w
		beq.s	loc_1445C
		move.b	#4,ost_frame(a0)

loc_1445C:
		cmpi.b	#7,(v_emeralds).w
		bne.s	loc_1446A
		move.b	#$19,ost_frame(a0)

loc_1446A:
		move.w	$30(a0),d0
		cmp.w	ost_x_screen(a0),d0
		bne.s	loc_14480
		move.b	#$1C,ost_primary_routine(a0)
		move.w	#$B4,ost_anim_time(a0)

loc_14480:
		bra.w	Card_Move
; ===========================================================================

loc_14484:
		cmpi.b	#7,(v_emeralds).w
		bne.s	loc_14490
		moveq	#$16,d0
		bra.s	loc_1449A
; ===========================================================================

loc_14490:
		tst.b	(f_got_emerald).w
		beq.w	DeleteObject
		moveq	#1,d0

loc_1449A:
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_144AE
		addq.w	#1,d0
		btst	#console_region_bit,(v_console_region).w
		beq.s	loc_144AE
		addq.w	#1,d0

loc_144AE:
		move.b	d0,ost_frame(a0)
		bra.w	Card_Move
; ===========================================================================

loc_144B6:
		addq.w	#1,d6

loc_144B8:
		addq.w	#1,d6

loc_144BA:
		addq.w	#1,d6

loc_144BC:
		addq.w	#1,d6

loc_144BE:
		addq.w	#1,d6

loc_144C0:
		addq.w	#1,d6

loc_144C2:
		lea	(v_emerald_list).w,a1
		tst.b	(a1,d6.w)
		beq.w	DeleteObject
		btst	#0,(v_vblank_counter_byte).w
		beq.s	locret_144DA
		bsr.w	DisplaySprite

locret_144DA:
		rts
; ===========================================================================

loc_144DC:
		tst.w	(v_player_mode).w
		bne.w	DeleteObject
		cmpi.b	#$26,($FFFFB824).w
		beq.w	DeleteObject
		moveq	#$E,d0
		btst	#console_region_bit,(v_console_region).w
		beq.s	loc_144FA
		addq.w	#1,d0

loc_144FA:
		lea	(v_bonus_count_2).w,a1
		bra.s	loc_1455A
; ===========================================================================

loc_14500:
		cmpi.b	#$26,($FFFFB824).w
		bne.s	loc_14532
		move.w	#$1388,(v_bonus_count_1).w
		move.b	#$2A,ost_primary_routine(a0)
		move.w	#screen_top+160,ost_y_screen(a0)
		st.b	(f_pass_bonus_update).w
		move.w	#$CF,d0
		jsr	(PlaySound).l
		move.w	#$5A,(v_ss_results_1+ost_anim_time).w
		bra.w	loc_14692
; ===========================================================================

loc_14532:
		move.w	(v_player_mode).w,d0
		beq.s	loc_14554
		move.w	#screen_top+160,ost_y_screen(a0)
		subq.w	#1,d0
		beq.s	loc_14554
		moveq	#$E,d0
		btst	#console_region_bit,(v_console_region).w
		beq.s	loc_1454E
		addq.w	#1,d0

loc_1454E:
		lea	(v_bonus_count_2).w,a1
		bra.s	loc_1455A
; ===========================================================================

loc_14554:
		moveq	#$D,d0
		lea	(v_bonus_count_1).w,a1

loc_1455A:
		tst.w	(a1)
		bne.s	loc_14560
		addq.w	#5,d0

loc_14560:
		move.b	d0,ost_frame(a0)

loc_14564:
		bra.w	Card_Move
; ===========================================================================

loc_14568:
		tst.b	(f_got_emerald).w
		beq.w	DeleteObject
		bra.s	loc_14564
; ===========================================================================

loc_14572:
		subq.w	#1,ost_anim_time(a0)
		bne.s	loc_1457C
		addq.b	#2,ost_primary_routine(a0)

loc_1457C:
		bra.w	DisplaySprite
; ===========================================================================

loc_14580:
		bsr.w	DisplaySprite
		move.b	#1,(f_pass_bonus_update).w
		moveq	#0,d0
		tst.w	(v_bonus_count_1).w
		beq.s	loc_1459A
		addi.w	#$A,d0
		subq.w	#1,(v_bonus_count_1).w

loc_1459A:
		tst.w	(v_bonus_count_2).w
		beq.s	loc_145A8
		addi.w	#$A,d0
		subq.w	#1,(v_bonus_count_2).w

loc_145A8:
		tst.w	(v_total_bonus_countdown).w
		beq.s	loc_145B8
		addi.w	#$A,d0
		subi.w	#$A,(v_total_bonus_countdown).w

loc_145B8:
		tst.w	d0
		bne.s	loc_14602
		move.w	#$C5,d0
		jsr	(PlaySound).l
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$78,ost_anim_time(a0)
		tst.w	(f_ss_perfect).w
		bne.s	loc_145F4
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	locret_14600
		tst.b	(f_got_emerald).w
		beq.s	locret_14600
		cmpi.b	#7,(v_emeralds).w
		bne.s	locret_14600
		move.b	#$30,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_145F4:
		move.b	#$24,ost_primary_routine(a0)
		move.w	#$5A,ost_anim_time(a0)

locret_14600:
		rts
; ===========================================================================

loc_14602:
		jsr	(AddPoints).l
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#3,d0
		bne.s	locret_14600
		move.w	#$CD,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_1461C:
		move.w	#1,(f_restart).w
		bra.w	DisplaySprite
; ===========================================================================

loc_14626:
		bsr.w	DisplaySprite
		move.b	#1,(f_pass_bonus_update).w
		moveq	#0,d0
		tst.w	(v_bonus_count_1).w
		beq.s	loc_14642
		addi.w	#$14,d0
		subi.w	#$14,(v_bonus_count_1).w

loc_14642:
		tst.w	d0
		beq.s	loc_14660
		jsr	(AddPoints).l
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#3,d0
		bne.s	locret_14690
		move.w	#$CD,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_14660:
		move.w	#$C5,d0
		jsr	(PlaySound).l
		addq.b	#4,ost_primary_routine(a0)
		move.w	#$78,ost_anim_time(a0)
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	locret_14690
		tst.b	(f_got_emerald).w
		beq.s	locret_14690
		cmpi.b	#7,(v_emeralds).w
		bne.s	locret_14690
		move.b	#$30,ost_primary_routine(a0)

locret_14690:
		rts
; ===========================================================================

loc_14692:
		moveq	#$11,d0
		btst	#3,(v_vblank_counter_byte).w
		beq.s	loc_1469E
		moveq	#$15,d0

loc_1469E:
		move.b	d0,ost_frame(a0)
		bra.w	DisplaySprite
; ===========================================================================

SSR_InitAndMoveSuperMsg:
		move.b	#$32,sizeof_ost+ost_primary_routine(a0)
		move.w	ost_x_pos(a0),d0
		cmp.w	$32(a0),d0
		bne.s	loc_14714
		move.b	#$14,sizeof_ost+ost_primary_routine(a0)
		subq.w	#8,sizeof_ost+ost_y_screen(a0)
		move.b	#$1A,sizeof_ost+ost_frame(a0)
		move.b	#$34,ost_primary_routine(a0)
		subq.w	#8,ost_y_screen(a0)
		move.b	#$1B,ost_frame(a0)
		lea	($FFFFBB40).w,a1
		_move.b	ost_id(a0),ost_id(a1)
		clr.w	ost_x_screen(a1)
		move.w	#$120,$30(a1)
		move.w	#screen_top+52,ost_y_screen(a1)
		move.b	#$14,ost_primary_routine(a1)
		move.b	#$1C,ost_frame(a1)
		move.l	#Map_SSR,ost_mappings(a1)
		move.b	#$78,ost_displaywidth(a1)
		move.b	#render_abs,ost_render(a1)
		bra.w	DisplaySprite
; ===========================================================================

loc_14714:
		moveq	#$20,d0
		move.w	ost_x_pos(a0),d1
		cmp.w	$32(a0),d1
		beq.s	loc_14730
		bhi.s	loc_14724
		neg.w	d0

loc_14724:
		sub.w	d0,ost_x_pos(a0)
		cmpi.w	#$200,ost_x_pos(a0)
		bhi.s	locret_14734

loc_14730:
		bra.w	DisplaySprite
; ===========================================================================

locret_14734:
		rts
; ===========================================================================

loc_14736:
		move.w	ost_x_pos(a0),d0
		cmp.w	$30(a0),d0
		bne.w	Card_Move
		move.w	#$B4,ost_anim_time(a0)
		move.b	#$20,ost_primary_routine(a0)
		bra.w	DisplaySprite
; ===========================================================================
byte_14752:
		gotthrough_data  screen_right+128, 	screen_left+160,	screen_top+42,   2,   0 ; "Special Stage"
		gotthrough_data  0, 				screen_left+160,	screen_top+24,   4,   1 ; "Sonic got a"
		gotthrough_data  screen_left+152,   0,  				screen_top+68,   6,   5 ; Emerald 0
		gotthrough_data  screen_left+176,   0,  				screen_top+80,   8,   6 ; Emerald 1
		gotthrough_data  screen_left+176,	0,					screen_top+104,  $A,   7 ; Emerald 2
		gotthrough_data  screen_left+152,   0,					screen_top+116,  $C,   8 ; Emerald 3
		gotthrough_data  screen_left+128,   0,					screen_top+104,  $E,   9 ; Emerald 4
		gotthrough_data  screen_left+128,	0,					screen_top+80, 	$10,  $A ; Emerald 5
		gotthrough_data  screen_left+152,   0,  				screen_top+92,	$12,  $B ; Emerald 6
		gotthrough_data  screen_right+368, 	screen_left+160,	screen_top+136, $14,  $C ; Score
		gotthrough_data  screen_right+384, 	screen_left+160,	screen_top+152, $16,  $D ; Sonic Rings
		gotthrough_data  screen_right+400, 	screen_left+160,	screen_top+168, $18,  $E ; Miles Rings
		gotthrough_data  screen_right+416, 	screen_left+160,	screen_top+184, $1A, $10 ; Gems Bonus

; ===========================================================================

		include	"mappings/sprite/Title Cards.asm"
		include "mappings/sprite/Game Over & Time Over.asm"
		include	"mappings/sprite/Got Through Card.asm"
		include	"mappings/sprite/Special Stage Results.asm"

; ===========================================================================

DrawLevelTitleCard:
		lea	(vdp_data_port).l,a6
		tst.w	($FFFFB0BE).w
		bne.w	loc_15670
		moveq	#$3F,d5

loc_15594:
		move.l	#-$7A257A26,d6
		tst.w	(f_two_player).w
		beq.s	loc_155A8
		moveq	#$1F,d5
		move.l	#-$7D127D13,d6

loc_155A8:
		lea	($FFFFB176).w,a0
		moveq	#1,d7

loc_155AE:
		move.w	(a0)+,d0
		beq.s	loc_155C6
		clr.w	-2(a0)
		jsr	sub_15792(pc)
		move.l	d0,vdp_control_port-vdp_data_port(a6)
		move.w	d5,d4

loc_155C0:
		move.l	d6,(a6)
		dbf	d4,loc_155C0

loc_155C6:
		dbf	d7,loc_155AE
		moveq	#$26,d1
		sub.w	($FFFFB1BA).w,d1
		lsr.w	#1,d1
		subq.w	#1,d1
		moveq	#7,d5
		move.l	#-$5A235A24,d6

loc_155DC:
		tst.w	(f_two_player).w
		beq.s	loc_155EA
		moveq	#3,d5
		move.l	#-$5D115D12,d6

loc_155EA:
		lea	($FFFFB1B6).w,a0
		moveq	#1,d7

loc_155F0:
		move.w	(a0)+,d0
		beq.s	loc_15614
		clr.w	-2(a0)
		jsr	sub_15792(pc)
		move.w	d5,d4

loc_155FE:
		move.l	d0,vdp_control_port-vdp_data_port(a6)
		move.w	d1,d3

loc_15604:
		move.l	d6,(a6)
		dbf	d3,loc_15604
		addi.l	#$800000,d0
		dbf	d4,loc_155FE

loc_15614:
		dbf	d7,loc_155F0
		move.w	($FFFFB1FA).w,d1
		subq.w	#1,d1
		moveq	#$D,d5
		move.l	#-$7A277A28,d6
		tst.w	(f_two_player).w
		beq.s	loc_15634
		moveq	#6,d5
		move.l	#-$7D137D14,d6

loc_15634:
		lea	($FFFFB1F6).w,a0
		moveq	#1,d7
		move.w	#-$7080,vdp_control_port-vdp_data_port(a6)

loc_15640:
		move.w	(a0)+,d0
		beq.s	loc_15664
		clr.w	-2(a0)
		jsr	sub_15792(pc)
		move.w	d1,d4

loc_1564E:
		move.l	d0,vdp_control_port-vdp_data_port(a6)
		move.w	d5,d3

loc_15654:
		move.l	d6,(a6)
		dbf	d3,loc_15654
		addi.l	#$20000,d0
		dbf	d4,loc_1564E

loc_15664:
		dbf	d7,loc_15640
		move.w	#-$70FE,vdp_control_port-vdp_data_port(a6)
		rts
; ===========================================================================

loc_15670:
		moveq	#9,d3
		moveq	#3,d4
		move.l	#-$7A257A26,d5
		move.l	#-$5A235A24,d6
		tst.w	(f_two_player).w
		beq.s	loc_15696
		moveq	#4,d3
		moveq	#1,d4
		move.l	#-$7D127D13,d5
		move.l	#-$5D115D12,d6

loc_15696:
		lea	($FFFFB1F6).w,a0
		moveq	#1,d7
		move.w	#-$7080,vdp_control_port-vdp_data_port(a6)

loc_156A2:
		move.w	(a0)+,d0
		beq.s	loc_156CE
		clr.w	-2(a0)
		jsr	sub_15792(pc)
		moveq	#3,d2

loc_156B0:
		move.l	d0,vdp_control_port-vdp_data_port(a6)
		move.w	d3,d1

loc_156B6:
		move.l	d5,(a6)
		dbf	d1,loc_156B6
		move.w	d4,d1

loc_156BE:
		move.l	d6,(a6)
		dbf	d1,loc_156BE
		addi.l	#$20000,d0
		dbf	d2,loc_156B0

loc_156CE:
		dbf	d7,loc_156A2
		move.w	#-$70FE,vdp_control_port-vdp_data_port(a6)
		moveq	#7,d5
		move.l	#-$7A257A26,d6
		tst.w	(f_two_player).w
		beq.s	loc_156EE
		moveq	#3,d5
		move.l	#-$7D127D13,d6

loc_156EE:
		lea	($FFFFB1B6).w,a0
		moveq	#1,d7

loc_156F4:
		move.w	(a0)+,d0
		beq.s	loc_15714
		clr.w	-2(a0)
		jsr	sub_15792(pc)
		move.w	d5,d4

loc_15702:
		move.l	d0,vdp_control_port-vdp_data_port(a6)
		move.l	d6,(a6)
		move.l	d6,(a6)
		addi.l	#$80<<16,d0
		dbf	d4,loc_15702

loc_15714:
		dbf	d7,loc_156F4
		move.w	($FFFFB176).w,d4
		beq.s	loc_1578C
		lea	vdp_control_port-vdp_data_port(a6),a5
		tst.w	(f_two_player).w
		beq.s	loc_15758
		lea	(v_camera_x_pos_p2).w,a3
		lea	(v_level_layout).w,a4
		vdp_comm.w	move,vram_fg_2p,vram,write,d2,>>16
		moveq	#1,d6

loc_15736:
		movem.l	d4-d6,-(sp)
		moveq	#-$10,d5
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos_P2
		move.w	d1,d4
		moveq	#-$10,d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,loc_15736

loc_15758:
		lea	(v_camera_x_pos).w,a3
		lea	(v_level_layout).w,a4
		move.w	#$4000,d2
		move.w	($FFFFB176).w,d4
		moveq	#1,d6

loc_1576A:
		movem.l	d4-d6,-(sp)
		moveq	#-$10,d5
		move.w	d4,d1
		bsr.w	Calc_VRAM_Pos_P1
		move.w	d1,d4
		moveq	#-$10,d5
		moveq	#$1F,d6
		bsr.w	DrawRow_CustomWidth
		movem.l	(sp)+,d4-d6
		addi.w	#$10,d4
		dbf	d6,loc_1576A

loc_1578C:
		clr.w	($FFFFB176).w
		rts

; ===========================================================================


sub_15792:
		andi.l	#$FFFF,d0
		lsl.l	#2,d0
		lsr.w	#2,d0
		ori.w	#$4000,d0
		swap	d0
		rts

; ===========================================================================

LoadTitleCardSS:
		movem.l	d0/a0,-(sp)
		bsr.s	sub_157B0
		movem.l	(sp)+,d0/a0
		bra.s	loc_157EC

; ===========================================================================


sub_157B0:
		vdp_comm.l	move,vram_TitleCard,vram,write,(vdp_control_port).l
		lea	(Nem_TitleCard).l,a0
		jsrto	NemDec,JmpTo2_NemDec
		lea	(v_level_layout).w,a4
		lea	(Nem_TitleCardFont).l,a0
		jmpto	NemDecToRAM,JmpTo_NemDecToRAM
; ===========================================================================

LoadTitleCard:
		bsr.s	sub_157B0
		moveq	#0,d0
		move.b	(v_zone).w,d0
		move.b	TitleCardLetters_Index(pc,d0.w),d0
		lea	TitleCardLetters(pc),a0
		lea	(a0,d0.w),a0
		vdp_comm.l	move,vram_LevelName,vram,write,d0

loc_157EC:
		disable_ints
		lea	(v_level_layout).w,a1
		lea	(vdp_data_port).l,a6
		move.l	d0,vdp_control_port-vdp_data_port(a6)

loc_157FE:
		moveq	#0,d0
		move.b	(a0)+,d0
		bmi.s	loc_1581A
		lsl.w	#5,d0
		lea	(a1,d0.w),a2
		moveq	#0,d1
		move.b	(a0)+,d1
		lsl.w	#3,d1
		subq.w	#1,d1

loc_15812:
		move.l	(a2)+,(a6)
		dbf	d1,loc_15812
		bra.s	loc_157FE
; ===========================================================================

loc_1581A:
		enable_ints
		rts
; ===========================================================================

TitleCardLetters_Index:						; index and ptr can't be used here unfortunately due to forward reference restrictions
		dc.b TitleCardLetters_EHZ-TitleCardLetters
		dc.b TitleCardLetters_Null-TitleCardLetters
		dc.b TitleCardLetters_Null-TitleCardLetters
		dc.b TitleCardLetters_Null-TitleCardLetters
		dc.b TitleCardLetters_MTZ-TitleCardLetters
		dc.b TitleCardLetters_MTZ-TitleCardLetters
		dc.b TitleCardLetters_WFZ-TitleCardLetters
		dc.b TitleCardLetters_HTZ-TitleCardLetters
		dc.b TitleCardLetters_HPZ-TitleCardLetters
		dc.b TitleCardLetters_Null-TitleCardLetters
		dc.b TitleCardLetters_OOZ-TitleCardLetters
		dc.b TitleCardLetters_MCZ-TitleCardLetters
		dc.b TitleCardLetters_CNZ-TitleCardLetters
		dc.b TitleCardLetters_CPZ-TitleCardLetters
		dc.b TitleCardLetters_DEZ-TitleCardLetters
		dc.b TitleCardLetters_ARZ-TitleCardLetters
		dc.b TitleCardLetters_SCZ-TitleCardLetters
		even

TitleCardLetters:
TitleCardLetters_Null:
TitleCardLetters_EHZ:	charset titlecard,"EMERALD HILL"
TitleCardLetters_MTZ:	charset titlecard,"METROPOLIS"
TitleCardLetters_HTZ:	charset titlecard,"HILL TOP"
TitleCardLetters_HPZ:	charset titlecard,"HIDDEN PALACE"
TitleCardLetters_OOZ:	charset titlecard,"OIL OCEAN"
TitleCardLetters_MCZ:	charset titlecard,"MYSTIC CAVE"
TitleCardLetters_CNZ:	charset titlecard,"CASINO NIGHT"
TitleCardLetters_CPZ:	charset titlecard,"CHEMICAL PLANT"
TitleCardLetters_ARZ:	charset titlecard,"AQUATIC RUIN"
TitleCardLetters_SCZ:	charset titlecard,"SKY CHASE"
TitleCardLetters_WFZ:	charset titlecard,"WING FORTRESS"
TitleCardLetters_DEZ:	charset titlecard,"DEATH EGG"
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo2_NemDec:
		jmp	(NemDec).l
JmpTo_NemDecToRAM:
		jmp	(NemDecToRAM).l
JmpTo3_AddPLC:
		jmp	(AddPLC).l
JmpTo_sub_8476:
		jmp	(sub_8476).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 36 - Spikes
; ----------------------------------------------------------------------------

Spikes:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1590E(pc,d0.w),d1
		jmp	off_1590E(pc,d1.w)
; ===========================================================================
off_1590E:	index offset(*),,2
		ptr loc_15926					; 0
		ptr loc_15996					; 2
		ptr loc_159E6					; 4
		ptr loc_15A42					; 6

byte_15916:
		dc.b $10					; 0
		dc.b $10					; 1
		dc.b $20					; 2
		dc.b $10					; 3
		dc.b $30					; 4
		dc.b $10					; 5
		dc.b $40					; 6
		dc.b $10					; 7
		dc.b $10					; 8
		dc.b $10					; 9
		dc.b $10					; 10
		dc.b $20					; 11
		dc.b $10					; 12
		dc.b $30					; 13
		dc.b $10					; 14
		dc.b $40					; 15
; ===========================================================================

loc_15926:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Spike,ost_mappings(a0)
		move.w	#tile_Nem_Spikes+tile_pal2,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		andi.b	#$F,ost_subtype(a0)
		andi.w	#$F0,d0
		lea_	byte_15916,a1
		lsr.w	#3,d0
		adda.w	d0,a1
		move.b	(a1)+,ost_displaywidth(a0)
		move.b	(a1)+,ost_height(a0)
		lsr.w	#1,d0
		move.b	d0,ost_frame(a0)
		cmpi.b	#4,d0
		bcs.s	loc_15978
		addq.b	#2,ost_primary_routine(a0)
		move.w	#tile_Nem_HorizSpike+tile_pal2,ost_tile(a0)

loc_15978:
		btst	#1,ost_primary_status(a0)
		beq.s	loc_15986
		move.b	#6,ost_primary_routine(a0)

loc_15986:
		move.w	ost_x_pos(a0),$30(a0)			; spikes_base_x_pos(a0)
		move.w	ost_y_pos(a0),$32(a0)			; spikes_base_y_pos(a0)
		bra.w	AdjustVRAM2P
; ===========================================================================

loc_15996:
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	SolidObject
		move.b	ost_primary_status(a0),d6
		andi.b	#$18,d6
		beq.s	loc_159DE
		move.b	d6,d0
		andi.b	#8,d0
		beq.s	loc_159D0
		lea	($FFFFB000).w,a1
		bsr.w	React_ChkHurt2

loc_159D0:
		andi.b	#$10,d6
		beq.s	loc_159DE
		lea	($FFFFB040).w,a1
		bsr.w	React_ChkHurt2

loc_159DE:
		move.w	$30(a0),d0				; spikes_base_x_pos(a0)
		bra.w	DespawnObject2
; ===========================================================================

loc_159E6:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		bsr.w	SolidObject
		swap	d6
		andi.w	#3,d6
		beq.s	loc_15A3A
		move.b	d6,d0
		andi.b	#1,d0
		beq.s	loc_15A26
		lea	($FFFFB000).w,a1
		bsr.w	React_ChkHurt2
		bclr	#5,ost_primary_status(a0)

loc_15A26:
		andi.b	#2,d6
		beq.s	loc_15A3A
		lea	($FFFFB040).w,a1
		bsr.w	React_ChkHurt2
		bclr	#status_underwater_bit,ost_primary_status(a0)

loc_15A3A:
		move.w	$30(a0),d0				; spikes_base_x_pos(a0)
		bra.w	DespawnObject2
; ===========================================================================

loc_15A42:
		bsr.w	sub_15AC6
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	SolidObject
		swap	d6
		andi.w	#$C,d6
		beq.s	loc_15A88
		move.b	d6,d0
		andi.b	#4,d0
		beq.s	loc_15A7A
		lea	($FFFFB000).w,a1
		bsr.w	React_ChkHurt2

loc_15A7A:
		andi.b	#8,d6
		beq.s	loc_15A88
		lea	($FFFFB040).w,a1
		bsr.w	React_ChkHurt2

loc_15A88:
		move.w	$30(a0),d0				; spikes_base_x_pos(a0)
		bra.w	DespawnObject2

; ===========================================================================


React_ChkHurt2:
		btst	#1,$2B(a1)
		bne.s	locret_15AC4
		tst.w	$30(a1)
		bne.s	locret_15AC4
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_15AC4
		move.l	ost_y_pos(a1),d3
		move.w	ost_y_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,ost_y_pos(a1)
		movea.l	a0,a2
		movea.l	a1,a0
		jsr	(HurtCharacter).l
		movea.l	a2,a0

locret_15AC4:
		rts

; ===========================================================================


sub_15AC6:
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		move.w	off_15AD6(pc,d0.w),d1
		jmp	off_15AD6(pc,d1.w)

; ===========================================================================
off_15AD6:	index offset(*)
		ptr locret_15ADC				; 0
		ptr loc_15ADE					; 2
		ptr loc_15AF2					; 4
; ===========================================================================

locret_15ADC:
		rts
; ===========================================================================

loc_15ADE:
		bsr.w	sub_15B06
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================

loc_15AF2:
		bsr.w	sub_15B06
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$30(a0),d0				; spikes_base_x_pos(a0)
		move.w	d0,ost_x_pos(a0)
		rts

; ===========================================================================


sub_15B06:
		tst.w	$38(a0)
		beq.s	loc_15B24
		subq.w	#1,$38(a0)
		bne.s	locret_15B66
		tst.b	ost_render(a0)
		bpl.s	locret_15B66
		move.w	#$B6,d0
		jsr	(PlaySound).l
		bra.s	locret_15B66
; ===========================================================================

loc_15B24:
		tst.w	$36(a0)
		beq.s	loc_15B46
		subi.w	#$800,$34(a0)
		bcc.s	locret_15B66
		move.w	#0,$34(a0)
		move.w	#0,$36(a0)
		move.w	#$3C,$38(a0)
		bra.s	locret_15B66
; ===========================================================================

loc_15B46:
		addi.w	#$800,$34(a0)
		cmpi.w	#$2000,$34(a0)
		bcs.s	locret_15B66
		move.w	#$2000,$34(a0)
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0)

locret_15B66:
		rts

; ===========================================================================

		include "mappings/sprite/Spikes.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 3B - Purple rock (unused Sonic 1 leftover)
; ----------------------------------------------------------------------------

PurpleRock:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_15CD6(pc,d0.w),d1
		jmp	off_15CD6(pc,d1.w)
; ===========================================================================
off_15CD6:	index offset(*),,2
		ptr loc_15CDA					; 0
		ptr loc_15D02					; 2
; ===========================================================================

loc_15CDA:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_PRock,ost_mappings(a0)
		move.w	#(vram_PurpleRock/sizeof_cell)+tile_pal4,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$13,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)

loc_15D02:
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$10,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	SolidObject
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

		include "mappings/sprite/GHZ Purple Rock (unused).asm"

; ===========================================================================

	if RemoveJmpTos=0
		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 3C - Breakable wall (mostly unused Sonic 1 leftover; the SmashObject
; function is called by a few other objects, but the SmashWall object itself
; is unused)
; ----------------------------------------------------------------------------

SmashWall:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_15D56(pc,d0.w),d1
		jsr	off_15D56(pc,d1.w)
		bra.w	DespawnObject
; ===========================================================================
off_15D56:	index offset(*),,2
		ptr loc_15D5C					; 0
		ptr loc_15D8A					; 2
		ptr loc_15E02					; 4
; ===========================================================================

loc_15D5C:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Smash,ost_mappings(a0)
		move.w	#(vram_SmashWall/sizeof_cell)+tile_pal3,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),ost_frame(a0)

loc_15D8A:
		move.w	($FFFFB010).w,$30(a0)
		move.w	#$1B,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	SolidObject
		btst	#5,ost_primary_status(a0)
		bne.s	loc_15DAE

locret_15DAC:
		rts
; ===========================================================================

loc_15DAE:
		lea	(v_ost_player1).w,a1
		cmpi.b	#2,ost_anim(a1)
		bne.s	locret_15DAC
		move.w	$30(a0),d0
		bpl.s	loc_15DC2
		neg.w	d0

loc_15DC2:
		cmpi.w	#$480,d0
		bcs.s	locret_15DAC
		move.w	$30(a0),ost_x_vel(a1)
		addq.w	#4,ost_x_pos(a1)
		lea	(word_15E8C).l,a4
		move.w	ost_x_pos(a0),d0
		cmp.w	ost_x_pos(a1),d0
		bcs.s	loc_15DEE
		subi_.w	#8,ost_x_pos(a1)
		lea	(word_15EAC).l,a4

loc_15DEE:
		move.w	ost_x_vel(a1),ost_inertia(a1)
		bclr	#5,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		bsr.s	SmashObject

loc_15E02:
		bsr.w	SpeedToPos
		addi.w	#$70,ost_y_vel(a0)
		tst.b	ost_render(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite

; ===========================================================================

;BreakObjectToPieces:
SmashObject:
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		add.w	d0,d0
		movea.l	ost_mappings(a0),a3
		adda.w	(a3,d0.w),a3
		move.w	(a3)+,d1
		subq.w	#1,d1
		bset	#render_rawmap_bit,ost_render(a0)
		_move.b	ost_id(a0),d4
		move.b	ost_render(a0),d5
		movea.l	a0,a1
		bra.s	loc_15E46
; ===========================================================================

loc_15E3E:
		bsr.w	FindNextFreeObj
		bne.s	loc_15E82
		addq.w	#8,a3

loc_15E46:
		move.b	#4,ost_primary_routine(a1)
		_move.b	d4,ost_id(a1)
		move.l	a3,ost_mappings(a1)
		move.b	d5,ost_render(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	ost_priority(a0),ost_priority(a1)
		move.b	ost_displaywidth(a0),ost_displaywidth(a1)
		move.w	(a4)+,ost_x_vel(a1)
		move.w	(a4)+,ost_y_vel(a1)
		dbf	d1,loc_15E3E

loc_15E82:
		move.w	#$CB,d0
		jmp	(PlaySound).l

; ===========================================================================
word_15E8C:
		;    x_vel,y_vel
		dc.w  $400,-$500				; 0
		dc.w  $600,-$100				; 2
		dc.w  $600, $100				; 4
		dc.w  $400, $500				; 6
		dc.w  $600,-$600				; 8
		dc.w  $800,-$200				; 10
		dc.w  $800, $200				; 12
		dc.w  $600, $600				; 14
word_15EAC:
		dc.w -$600,-$600				; 0
		dc.w -$800,-$200				; 2
		dc.w -$800, $200				; 4
		dc.w -$600, $600				; 6
		dc.w -$400,-$500				; 8
		dc.w -$600,-$100				; 10
		dc.w -$600, $100				; 12
		dc.w -$400, $500				; 14
; -------------------------------------------------------------------------------
; Unknown Sprite Mappings
; -------------------------------------------------------------------------------

		include "mappings/sprite/GHZ & SLZ Smashable Wall (unused).asm"

; ===========================================================================
		bra.w	NullObject				; dead

; ---------------------------------------------------------------------------
; Object code execution subroutine

; output:
;	a0 = address of OST of last object

;	uses d0.l, a1 (objects may use other registers)
; ---------------------------------------------------------------------------

ExecuteObjects:
		tst.b	(f_teleport).w				; is a teleport in progress?
		bne.s	.done					; if so, exit

		lea	(v_ost_all).w,a0			; set address for object RAM
		moveq	#countof_ost-1,d7			; $80 objects -1 (main OSTs only)
		moveq	#0,d0
		cmpi.b	#id_Demo,(v_gamemode).w			; are we in a demo?
		beq.s	.in_level				; if so, branch
		cmpi.b	#id_Level,(v_gamemode).w		; are we in a level?
		bne.s	.run_object				; branch if not

	.in_level:
		move.w	#(countof_ost+countof_ost_level_only)-1,d7 ; $90 objects -1 (main and level only OSTs)
		tst.w	(f_two_player).w			; is it 2P mode?
		bne.s	.run_object				; branch if not
		cmpi.b	#id_Death,(v_ost_player1+ost_primary_routine).w ; is player 1 dead, drowning, or respawning?
		bcc.s	.dead					; if so, branch

	.run_object:
		move.b	ost_id(a0),d0				; load object number
		beq.s	.no_object				; branch if 0
		add.w	d0,d0
		add.w	d0,d0					; multiply by 4 to make index
		movea.l	Obj_Index-4(pc,d0.w),a1
		jsr	(a1)					; run the object's code
		moveq	#0,d0

	.no_object:
		lea	sizeof_ost(a0),a0			; next object
		dbf	d7,.run_object				; repeat for all objects

	.done:
		rts
; ===========================================================================

	.dead:
	if FixBugs
		; Drowning fixes: if player 1 has just drowned, continue running objects normally
		; until they are marked as dead, so that the bubbles from their mouth are
		; displayed.
		cmpi.b	#id_Drown,(v_ost_player+ost_routine)	; has main character just drowned?
		beq.s	.run_object				; if so, run objects normally
	endc
		moveq	#countof_ost_reserved-1,d7
		bsr.s	.run_object				; run first $10 objects normally
		moveq	#countof_ost_dynamic-1,d7
		bsr.s	.display_object				; next $70 objects are only displayed
		moveq	#countof_ost_level_only-1,d7
		bra.s	.run_object				; run final $10 objects run normally
; ===========================================================================


.display_object:
		moveq	#0,d0
		move.b	ost_id(a0),d0				; load object number
		beq.s	.no_object2				; branch if 0
		tst.b	ost_render(a0)
		bpl.s	.no_object2				; branch if off-screen

	if FixBugs
		; If this is a multi-sprite object, then we cannot use its 'priority'
		; value to display it, as it's being used for coordinate data.
		; In theory, this means that calls to 'DisplaySprite' here could
		; overflow 'v_sprite_buffer' and write to the OST
		; instead, which could be quite disasterous. However, I don't think
		; it's possible for an object to have a Y coordinate higher than
		; $7FF, so, in practice, the overflow never occurs. Still, it can
		; result in objects displaying on a random layer. The best we can do
		; is force them to display on a certain layer consistently.
		; This quirk becomes a much bigger problem if you extend the
		; 'priority' value to 16-bit, such as if you've ported S3K's priority
		; manager: rather than just the upper byte of the Y coordinate being
		; read as priority data, the whole word is. This makes it much more
		; likely to lead to buffer overflow and memory corruption.

		pea .no_object2(pc)				; return to .no_object2 after returning from DisplaySprite or DisplaySprite3
		btst	#render_subsprites_bit,ost_render(a0)	; is this a multisprite object?
		beq.w	DisplaySprite				; if not, display using object's priority value
		move.w	#sizeof_priority*4,d0			; if so, display with priority of four
		bra.w	DisplaySprite3
	else
		bsr.w	DisplaySprite
	endc

	.no_object2:
		lea	sizeof_ost(a0),a0
		dbf	d7,.display_object
		rts

; ---------------------------------------------------------------------------
; Object pointers
; ---------------------------------------------------------------------------

Obj_Index:	index.l 0,1					; longword, absolute (relative to 0), start ids at 1
		ptr SonicPlayer					; 1
		ptr TailsPlayer
		ptr PlaneSwitcher
		ptr WaterSurface				; 4
		ptr TailsTails
		ptr Spiral
		ptr Oil
		ptr Splash_SpindashDust				; 8
		ptr SonicSpecial
		ptr DrownCount
		ptr TippingPipe					; CPZ tipping pipe section
		ptr CPZBetaPlatform				; $C; unused beta leftover
		ptr Signpost
		ptr TitleIntro
		ptr TitleMenu
		ptr TailsSpecial				; $10
		ptr Bridge
		ptr GiantEmerald				; unused beta leftover
		ptr WaterfallHiddenPalace			; unused beta leftover
		ptr Seesaw					; $14
		ptr SwingingPlatform				; ARZ, MCZ
		ptr Tram					; HTZ ziplines/lifts/trams
		ptr Helix					; unused Sonic 1 leftover: GHZ spiked log
		ptr Platform1					; $18; ARZ & EHZ
		ptr Platform2					; CPZ, OOZ, & WFZ
		ptr CollapseLedge				; unused beta leftover, used by HPZ collapsing platform, same object as S1 GHZ collapsing ledges
		ptr SpeedBooster				; CPZ Speed Boosters
		ptr Scenery1					; $1C; EHZ bridge stakes, HTZ tram stakes, OOZ falling oil
		ptr BlueBalls
		ptr SpinTube
		ptr CollapseFloor				; ARZ, MCZ, OOZ
		ptr LavaBubble					; $20
		ptr TwoPlayerResultsDisplay
		ptr ArrowShooter
		ptr FallingPillar
		ptr Bubble					; $24
		ptr Ring
		ptr Monitor
		ptr ExplosionItem
		ptr Animals					; $28
		ptr Points
		ptr Stomper
		ptr RisingPillar
		ptr LeafGenerator				; $2C
		ptr AutoDoor
		ptr PowerUp
		ptr SmashGround
		ptr RisingLava					; $30
		ptr LavaTag
		ptr SmashBlock
		ptr BurnerPlatform
		ptr TitleCard					; $34
		ptr InvincibiltyStars
		ptr Spikes
		ptr RingLoss
		ptr ShieldItem					; $38
		ptr GameOverCard
		ptr GotThroughCard
		ptr PurpleRock					; unused Sonic 1 leftover
		ptr SmashWall					; $3C; mostly unused Sonic 1 leftover; fragment subroutine is used, but object itself is not
		ptr LauncherBlock				; smashable lanucher block in OOZ
		ptr Prison
		ptr Fan
		ptr Springboard					; $40
		ptr Springs
		ptr SteamSpring
		ptr RailSpikes
		ptr Bumper					; $44; CNZ round bumpers (all others except the hexagonal one are run by the SpecialCNZBumpers psuedoobject)
		ptr PressureSpring
		ptr GiantBall					; unused OOZ beta leftover
		ptr Button
		ptr LauncherBall				; $48
		ptr WaterfallEmeraldHill
		ptr Octus
		ptr Buzzer
		ptr Obj4C					; $4C; used to be the BBat badnik
		ptr Obj4D					; used to be the Stego badnik
		ptr Obj4E					; used to be the Gator badnik
		ptr Obj4F					; used to be the Redz badnik
		ptr Aquis					; $50
		ptr BossCasinoNight
		ptr BossHillTop
		ptr BossMetropolisOrb
		ptr BossMetropolis				; $54
		ptr BossOilOcean
		ptr BossEmeraldHill
		ptr BossMysticCave
		ptr ExplosionBomb				; $58
		ptr EmeraldSpecial
		ptr MessageSpecial
		ptr RingLossSpecial
		ptr Masher					; $5C
		ptr BossChemicalPlant
		ptr HUDSpecial
		ptr StartBannerSpecial
		ptr RingsSpecial				; $60
		ptr BombSpecial
		ptr Obj62					; unknown
		ptr ShadowSpecial				; not Shads, but rather the character's shadows in the Special Stages :P
		ptr TwinStompers				; $64
		ptr Platform5
		ptr SpringWall
		ptr Teleporter
		ptr SpikeBlock					; $68
		ptr Nut
		ptr Platform3
		ptr Platform4
		ptr Conveyer					; $6C
		ptr FloorSpike
		ptr LargeRotatingPlatform
		ptr SSResult
		ptr Cog						; $70
		ptr Scenery2					; MTZ Lava Bubble, HPZ bridge stake, HPZ pulsing orb
		ptr ConveyerBelt
		ptr MysticCaveRotatingRings			; unused in normal gameplay, but accessible in debug mode
		ptr Invisibarrier				; $74
		ptr BrickAndSpikeChain
		ptr SlidingSpikePlat
		ptr DoubleDrawbridge
		ptr StairBlocks					; $78
		ptr Starpost
		ptr TrackPlatform
		ptr SpinTubeLid
		ptr Pylon					; $7C
		ptr HiddenBonus					; unused Sonic 1 leftover
		ptr SuperSonicStars
		ptr VineSwitch
		ptr VineHook					; $80
		ptr SingleDrawbridge
		ptr PillarPlatform
		ptr CirclingPlatform
		ptr PinballMode					; $84
		ptr PinballLauncher
		ptr Flipper
		ptr RingCountSpecial
		ptr TailsTailsSpecial				; $88
		ptr BossAquaticRuin
		ptr S1_STP_Credits				; unused Sonic 1 leftover
		ptr PalSwitcherWingFortress
		ptr Whisp					; $8C
		ptr GrounderInWall
		ptr GrounderOnGround
		ptr GrounderWall
		ptr GrounderRocks				; $90
		ptr ChopChop
		ptr Spiker
		ptr SpikerDrill
		ptr Rexon_Dup					; $94
		ptr Sol
		ptr Rexon
		ptr RexonHead
		ptr Projectile					; $98 ; Coconuts' coconuts, Nebulas' bombs, Turtloid, Clucker, Spiny, and Wall Turret shots
		ptr Nebula
		ptr Turtloid
		ptr TurtloidRider
		ptr BalkTurtJet					; $9C
		ptr Coconuts
		ptr Crawlton
		ptr Shellcracker
		ptr ShellcrackerClaw				; $A0
		ptr Slicer
		ptr SlicerPincers
		ptr Flasher
		ptr Asteron					; $A4
		ptr Spiny
		ptr SpinyWall
		ptr Grabber
		ptr GrabberLegs					; $A8
		ptr GrabberBox
		ptr GrabberString
		ptr Unknown1					; unused, vestigial remnants of some object embedded in the Grabber objects
		ptr Balkiry					; $AC
		ptr CluckerBase
		ptr Clucker
		ptr MechaSonic
		ptr SonicSegaScreen				; $B0
		ptr SegaHideTM					; hides the TM symbol on Japanese and Korean consoles
		ptr Tornado
		ptr Cloud
		ptr VerticalPropeller				; $B4
		ptr HorizontalPropeller
		ptr TiltingPlatform
		ptr VerticalLaser				; unused
		ptr WallTurret					; $B8
		ptr HorizontalLaser				; laser that shoots down the Tornado at the start of WFZ
		ptr ConveyerPulley				; WFZ conveyer wheel
		ptr StaticHook					; unused, unknown
		ptr ShipExhaust					; $BC ; exhaust from Eggman's getaway ship in the WFZ/DEZ transition
		ptr ConveyerPlatforms				; WFZ conveyer platforms
		ptr GunPlatform
		ptr PropellerShaft
		ptr Catapult					; $C0
		ptr BreakablePlating
		ptr Rivet
		ptr TornadoSmoke
		ptr TornadoSmoke				; $C4
		ptr BossWingFortress
		ptr Eggman
		ptr EggRobo
		ptr Crawl					; $C8
		ptr PalChanger					; title screen palette changing handler
		ptr Cutscene					; ending cutscene manager
		ptr EndingClouds
		ptr EndingTrigger				; $CC ; trigger for birds and Tornado rescue in ending cutscene
		ptr EndingFlickies
		ptr EndingSonicTails
		ptr TornadoHelicies
		ptr ObjD0					; $D0
		ptr ObjD1
		ptr SnakePlatform				; CNZ snake platform
		ptr BombPenalty					; penalty spikeballs from CNZ slot machines
		ptr LargeMovingBlock				; $D4
		ptr Elevator
		ptr Cage					; CNZ cages
		ptr HexagonalBumper				; CNZ moving hexagonal bumper
		ptr SaucerBumper				; $D8
		ptr InvisibleGrabBlock
		ptr ContScrItem
		ptr ContinueCharacters
		ptr RingPrize					; $DC

; ----------------------------------------------------------------------------
; Object 4C, 4D, 4E, 4F, 62, D0, and D1
; Objects removed from the game. All it does is deallocate its array.
; ----------------------------------------------------------------------------
Obj4C:
Obj4D:
Obj4E:
Obj4F:
Obj62:
ObjD0:
ObjD1:
NullObject:
		bra.w	DeleteObject

; ---------------------------------------------------------------------------
; Subroutine to	make an	object fall downwards, increasingly fast
; Also updates its position

;	uses d0.l, d2.l, d3.l
; ---------------------------------------------------------------------------

ObjectFall:
		move.l	ost_x_pos(a0),d2			; load x position
		move.l	ost_y_pos(a0),d3			; load y position
		move.w	ost_x_vel(a0),d0			; load x speed
		ext.l	d0
		asl.l	#8,d0					; shift velocity to line up with the middle 16 bits of the 32-bit position
		add.l	d0,d2					; add x speed to x position	; note this affects the subpixel position x_sub(a0) = 2+x_pos(a0)
		move.w	ost_y_vel(a0),d0			; load y speed
		addi.w	#$38,ost_y_vel(a0)			; increase vertical speed (apply gravity)
		ext.l	d0
		asl.l	#8,d0					; shift velocity to line up with the middle 16 bits of the 32-bit position
		add.l	d0,d3					; add old y speed to y position	; note this affects the subpixel position y_sub(a0) = 2+y_pos(a0)
		move.l	d2,ost_x_pos(a0)			; store new x position
		move.l	d3,ost_y_pos(a0)			; store new y position
		rts


; ---------------------------------------------------------------------------
; Subroutine translating object	speed to update	object position

;	uses d0.l, d2.l, d3.l
; ---------------------------------------------------------------------------

SpeedToPos:
		move.l	ost_x_pos(a0),d2			; load x position
		move.l	ost_y_pos(a0),d3			; load y position
		move.w	ost_x_vel(a0),d0			; load horizontal speed
		ext.l	d0
		asl.l	#8,d0					; shift velocity to line up with the middle 16 bits of the 32-bit position
		add.l	d0,d2					; add to x-axis position	; note this affects the subpixel position x_sub(a0) = 2+x_pos(a0)
		move.w	ost_y_vel(a0),d0			; load vertical speed
		ext.l	d0
		asl.l	#8,d0					; shift velocity to line up with the middle 16 bits of the 32-bit position
		add.l	d0,d3					; add to y-axis position	; note this affects the subpixel position y_sub(a0) = 2+y_pos(a0)
		move.l	d2,ost_x_pos(a0)			; update x-axis position
		move.l	d3,ost_y_pos(a0)			; update y-axis position
		rts

; ---------------------------------------------------------------------------
; Subroutine to check if object is still on-screen:
; display if yes, delete if not

;	uses d0.l, d1.l, a1, a2
; ---------------------------------------------------------------------------

DespawnObject:
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not2P					; branch if not
		bra.w	DisplaySprite

	.not2P:
		out_of_range.w	.offscreen,ost_x_pos(a0)	; branch if object moves off screen (could be .s)
		bra.w	DisplaySprite				; display instead of despawn

	.offscreen:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0			; get respawn id
		beq.s	.delete					; branch if not set
		bclr	#respawn_bit,v_respawn_data-v_respawn_list(a2,d0.w) ; clear high bit of respawn entry (i.e. object was despawned not broken)

	.delete:
		bra.w	DeleteObject				; delete the object


; ---------------------------------------------------------------------------
; Same as DespawnObject, but object x-pos is already in d0

;	uses d0.l, d1.l, a1, a2
; ---------------------------------------------------------------------------

DespawnObject2:
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not2P					; branch if not
		bra.w	DisplaySprite

	.not2P:
		out_of_range.w	.offscreen			; branch if object moves off screen (could be .s)
		bra.w	DisplaySprite				; display instead of despawn

	.offscreen:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0			; get respawn id
		beq.s	.delete					; branch if not set
		bclr	#respawn_bit,v_respawn_data-v_respawn_list(a2,d0.w) ; clear high bit of respawn entry (i.e. object was despawned not broken)

	.delete:
		bra.w	DeleteObject

; ---------------------------------------------------------------------------
; Same as DespawnObject, but does nothing if object is onscreen

;	uses d0.l, d1.l, a1, a2
; ---------------------------------------------------------------------------

DespawnObject3:
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.not2P					; branch if not
		rts

	.not2P:
		out_of_range.w	.offscreen,ost_x_pos(a0)	; branch if object moves off screen (could be .s)
		rts

	.offscreen:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0			; get respawn id
		beq.s	.delete					; branch if not set
		bclr	#respawn_bit,v_respawn_data-v_respawn_list(a2,d0.w) ; clear high bit of respawn entry (i.e. object was despawned not broken)

	.delete:
		bra.w	DeleteObject

; ---------------------------------------------------------------------------
; For objects used in 2P mode zones that do NOT participate in the 12-slot
; block system. Used only by the Buzzer and Flasher badniks.

;	uses d0.l, d1.l, a1, a2
; ---------------------------------------------------------------------------

DespawnObject4:
		tst.w	(f_two_player).w			; is it 2P mode?
		bne.s	.2p_mode				; branch if so

		out_of_range.w	.offscreen,ost_x_pos(a0)	; branch if offscreen (could be .s)
		bra.w	DisplaySprite

	.offscreen:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0			; get respawn id
		beq.s	.delete					; branch if not set
		bclr	#respawn_bit,v_respawn_data-v_respawn_list(a2,d0.w) ; clear high bit of respawn entry (i.e. object was despawned not broken)

	.delete:
		bra.w	DeleteObject

; ---------------------------------------------------------------------------
; The Buzzer and Flasher badniks are managed separate from the 12-slot block
; system due to their potential to wander far beyond a 256 pixel radius. The
; range check here nevertheless accounts for this system, allowing these
; objects a range of 768 pixels (3 blocks) within which they can stay spawned.
; ---------------------------------------------------------------------------

.2p_mode:
		move.w	ost_x_pos(a0),d0			; get object x pos
		andi.w	#-$100,d0				; round down to nearest $100
		move.w	d0,d1
		sub.w	(v_camera_x_pos_coarse).w,d0		; get screen position for player 1; d0 = approx distance between object and screen (negative if object is left of screen)
		cmpi.w	#256+256+256,d0				; 256 pixel wide block. plus two adjacent blocks
		bhi.w	.chkp2					; branch if out of range (could be optimized to .s)
		bra.w	DisplaySprite

	.chkp2:
		sub.w	(v_camera_x_pos_coarse_p2).w,d1		; get screen position for player 2; d0 = approx distance between object and screen (negative if object is left of screen)
		cmpi.w	#256+256+256,d1				; 256 pixel wide block. plus two adjacent blocks
		bhi.w	.offscreen2				; branch if out of range (could be optimized to .s)
		bra.w	DisplaySprite

	.offscreen2:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0			; get respawn id
		beq.s	.delete2				; branch if not set
		bclr	#respawn_bit,v_respawn_data-v_respawn_list(a2,d0.w) ; clear high bit of respawn entry (i.e. object was despawned not broken)

	.delete2:
		bra.w	DeleteObject				; useless branch...

; ---------------------------------------------------------------------------
; Subroutine to	delete an object

; input:
;	a0 = address of OST of object (DeleteObject only)
;	a1 = address of OST of object (DeleteChild only)

; output:
;	a1 = address of next OST

;	uses d0.l, d1.l
; ---------------------------------------------------------------------------

DeleteObject:
		movea.l	a0,a1					; move object RAM address to (a1)

DeleteChild:							; child objects are already in (a1)
		moveq	#0,d1
		moveq	#(sizeof_ost/4)-1,d0

	.loop:
		move.l	d1,(a1)+				; clear	the object RAM
		dbf	d0,.loop				; repeat for length of object RAM
		rts

; ---------------------------------------------------------------------------
; Subroutine to add an object to the sprite queue for display by BuildSprites
;
; input:
;	a0 = address of OST for object

;	uses d0.w, a1
; ---------------------------------------------------------------------------

DisplaySprite:
		lea	(v_sprite_queue).w,a1
		move.w	ost_priority(a0),d0			; get sprite priority (as high byte of a word)
		lsr.w	#8-priority_size_bits,d0		; d0 = priority * sizeof_priority
		andi.w	#((1<<priority_count_bits)-1)<<priority_size_bits,d0
		adda.w	d0,a1					; jump to priority section in queue
		cmpi.w	#sizeof_priority-2,(a1)			; is this section full? ($7E)
		bcc.s	.full					; if yes, branch
		addq.w	#2,(a1)					; increment sprite count
		adda.w	(a1),a1					; jump to empty position
		move.w	a0,(a1)					; insert RAM address for OST of object

	.full:
		rts

; ---------------------------------------------------------------------------
; Subroutine to add a child object to the sprite queue
;
; input:
;	a1 = address of OST for object

;	uses d0.w, a2
; ---------------------------------------------------------------------------

DisplaySprite2:
		lea	(v_sprite_queue).w,a2
		move.w	ost_priority(a1),d0			; get sprite priority (as high byte of a word)
		lsr.w	#8-priority_size_bits,d0		; d0 = priority * sizeof_priority
		andi.w	#((1<<priority_count_bits)-1)<<priority_size_bits,d0
		adda.w	d0,a2					; jump to priority section in queue
		cmpi.w	#sizeof_priority-2,(a2)			; is this section full? ($7E)
		bcc.s	.full					; if yes, branch
		addq.w	#2,(a2)					; increment sprite count
		adda.w	(a2),a2					; jump to empty position
		move.w	a1,(a2)					; insert RAM address for OST of object

	.full:
		rts

; ---------------------------------------------------------------------------
; Subroutine to add a component sprite of a multisprite object to the sprite
; queue
;
; input:
;	d0 = priority of sprite * sizeof_priority
;	a1 = address of OST for object

;	uses a2
; ---------------------------------------------------------------------------

DisplaySprite3:
		lea	(v_sprite_queue).w,a1
		adda.w	d0,a1					; jump to priority section in queue
		cmpi.w	#sizeof_priority-2,(a1)			; is this section full? ($7E)
		bcc.s	.full					; if yes, branch
		addq.w	#2,(a1)					; increment sprite count
		adda.w	(a1),a1					; jump to empty position
		move.w	a0,(a1)					; insert RAM address for OST of object

	.full:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	animate	a sprite using an animation script
;
; input:
;	a1 = animation script index (e.g. Ani_Crab)

; output:
;	a1 = animation script (e.g. ani_crab_stand)

;	uses d0.l, d1.l

; usage:
;		lea	Ani_Sonic(pc),a1
;		bsr.w	AnimateSprite
; ---------------------------------------------------------------------------

AnimateSprite:
		moveq	#0,d0
		move.b	ost_anim(a0),d0				; move animation number to d0
		cmp.b	ost_anim_restart(a0),d0			; is animation set to change?
		beq.s	Anim_Run				; if not, branch

		move.b	d0,ost_anim_restart(a0)			; set prev ost_anim to current current
		move.b	#0,ost_anim_frame(a0)			; reset animation
		move.b	#0,ost_anim_time(a0)			; reset frame duration

Anim_Run:
		subq.b	#1,ost_anim_time(a0)			; subtract 1 from frame duration
		bpl.s	Anim_Wait				; if time remains, branch
		add.w	d0,d0
		adda.w	(a1,d0.w),a1				; calculate address of appropriate animation script
		move.b	(a1),ost_anim_time(a0)			; load frame duration
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1			; load current frame number
		move.b	1(a1,d1.w),d0				; read sprite number from script
		bmi.s	Anim_End_FF				; if animation is complete, branch

Anim_Next:
		andi.b	#$7F,d0					; clear sign bit
		move.b	d0,ost_frame(a0)			; load sprite number
		move.b	ost_primary_status(a0),d1		;* match the orientaion dictated by the object
		andi.b	#status_xflip+status_yflip,d1		;* with the orientation used by the object engine
		andi.b	#$FF-render_xflip-render_yflip,ost_render(a0) ;*
		or.b	d1,ost_render(a0)			;*
		addq.b	#1,ost_anim_frame(a0)			; next frame number

Anim_Wait:
		rts
; ===========================================================================

Anim_End_FF:
		addq.b	#1,d0					; is the end flag = $FF?
		bne.s	Anim_End_FE				; if not, branch
		move.b	#0,ost_anim_frame(a0)			; restart the animation
		move.b	ost_render(a1),d0			; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FE:
		addq.b	#1,d0					; is the end flag = $FE?
		bne.s	Anim_End_FD				; if not, branch
		move.b	2(a1,d1.w),d0				; read the next byte in the script
		sub.b	d0,ost_anim_frame(a0)			; jump back d0 bytes in the script
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0				; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FD:
		addq.b	#1,d0					; is the end flag = $FD?
		bne.s	Anim_End_FC				; if not, branch
		move.b	2(a1,d1.w),ost_anim(a0)			; read next byte, run that animation
		rts
; ===========================================================================

Anim_End_FC:
		addq.b	#1,d0					; is the end flag = $FC?
		bne.s	Anim_End_FB				; if not, branch
		addq.b	#2,ost_primary_routine(a0)		; jump to next routine
		move.b	#0,ost_anim_time(a0)
		addq.b	#1,ost_anim_frame(a0)
		rts
; ===========================================================================

Anim_End_FB:
		addq.b	#1,d0					; is the end flag = $FB?
		bne.s	Anim_End_FA				; if not, branch
		move.b	#0,ost_anim_frame(a0)			; reset animation
		clr.b	ost_secondary_routine(a0)		; reset 2nd routine counter
		rts
; ===========================================================================

Anim_End_FA:
		addq.b	#1,d0					; is the end flag = $FA?
		bne.s	Anim_End_F9				; if not, branch
		addq.b	#2,ost_secondary_routine(a0)		; jump to next routine
		rts
; ===========================================================================

Anim_End_F9:
		addq.b	#1,d0					; is the end flag = $F9?
		bne.s	Anim_End				; if not, branch
		addq.b	#2,$2A(a0)				; Actually obj89_arrow_routine

Anim_End:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	convert	objects into proper Mega Drive sprites

; output:
;	a2 = address of last sprite in sprite buffer

;	uses d0.l, d1.w, d2.w, d3.w, d4.w, d5.l, d6.l, d7.l, a0, a1, a3, a4
; ---------------------------------------------------------------------------

BuildSprites:
		tst.w	(f_two_player).w			; is it 2P mode?
		bne.w	BuildSprites_2P				; if so, use the 2P version of this function
		lea	(v_sprite_buffer).w,a2			; set address for sprite table - $280 bytes, copied to VRAM at VBlank
		moveq	#0,d5					; initial link value
		moveq	#0,d4					; holds copy of render flags
		tst.b	(f_level_started).w			; has the level started?
		beq.s	.notstarted				; if not, branch
		jsrto	BuildHUD, JmpTo_BuildHUD		; render the HUD
		bsr.w	BuildRings				; render rings

	.notstarted:
		lea	(v_sprite_queue).w,a4			; address of sprite queue - $400 bytes, 8 sections of $80 bytes (1 word for count, $3F words for OST addresses)
		moveq	#countof_priority-1,d7			; 8 priority levels


	BuildSprites_PriorityLoop:
		tst.w	(a4)					; are there objects left in current section?
		beq.w	BuildSprites_NextPriority		; if not, branch
		moveq	#2,d6					; index to start address within current section (1st word is object count)

	BuildSprites_ObjectLoop:
		movea.w	(a4,d6.w),a0				; load address of OST of object

    if Revision=0
		; These are sanity checks to detect invalid objects which should not
		; have been queued for display. Revision 1 and S3K get rid of them compeletely,
		; since they shouldn't be needed and they just slow this code down.
		; In REV00, it appears that these checks were used for debugging, as
		; they deliberately crash the console if they detect an invalid object.
		tst.b	ost_id(a0)
		beq.w	BuildSprites_Crash			; if object id is 0, branch
		tst.l	ost_mappings(a0)
		beq.w	BuildSprites_Crash			; branch if no mappings pointer is set
    else
		tst.b	ost_id(a0)
		beq.w	BuildSprites_NextObject			; if object id is 0, branch
    endc

		andi.b	#(~render_onscreen)&$FF,ost_render(a0)	; set as not visible
		move.b	ost_render(a0),d0
		move.b	d0,d4
		btst	#render_subsprites_bit,d0		; is this a multisprite object?
		bne.w	BuildSprites_MultiDraw			; if so, branch
		andi.w	#render_rel+render_bg,d0		; get drawing coordinate system
		beq.s	.abs_screen_coords			; branch if 0 (absolute screen coordinates)
		lea	(v_camera_x_pos_copy2).w,a1		; get address for camera x position (or background x position if render_bg is used)

		; check if object is visible
		moveq	#0,d0
		move.b	ost_displaywidth(a0),d0
		move.w	ost_x_pos(a0),d3
		sub.w	(a1),d3
		move.w	d3,d1
		add.w	d0,d1					; d1 = x pos of object's right edge on screen
		bmi.w	BuildSprites_NextObject			; branch if object is outside left side of screen
		move.w	d3,d1
		sub.w	d0,d1					; d1 = x pos of object's left edge on screen
		cmpi.w	#screen_width,d1
		bge.w	BuildSprites_NextObject			; branch if object is outside right side of screen
		addi.w	#screen_left,d3				; d3 = x pos of object on screen, +128px for VDP sprite coordinate

		btst	#render_useheight_bit,d4		; is use height flag on?
		beq.s	.assume_height				; if not, branch
		moveq	#0,d0
		move.b	ost_height(a0),d0
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos_copy2-v_camera_x_pos_copy2(a1),d2
		move.w	d2,d1
		add.w	d0,d1					; d1 = y pos of object's bottom edge on screen
		bmi.s	BuildSprites_NextObject			; branch if object is outside top side of screen
		move.w	d2,d1
		sub.w	d0,d1					; d1 = y pos of object's top edge on screen
		cmpi.w	#screen_height,d1
		bge.s	BuildSprites_NextObject			; branch if object is outside bottom side of screen
		addi.w	#screen_top,d2				; d2 = y pos of object on screen, +128px for VDP sprite coordinate
		bra.s	.draw_object
; ===========================================================================

	.abs_screen_coords:
		move.w	ost_y_screen(a0),d2			; d2 = y pos
		move.w	ost_x_screen(a0),d3			; d3 = x pos
		bra.s	.draw_object
; ===========================================================================

	.assume_height:
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos_copy2-v_camera_x_pos_copy2(a1),d2 ; d2 = y pos of object on screen
		addi.w	#screen_top,d2
		andi.w	#$7FF,d2
		cmpi.w	#screen_top-32,d2			; assume y radius to be 32 pixels
		bcs.s	BuildSprites_NextObject			; branch if > 32px outside top side of screen
		cmpi.w	#screen_bottom+32,d2
		bcc.s	BuildSprites_NextObject			; branch if > 32px outside bottom side of screen

	.draw_object:
		movea.l	ost_mappings(a0),a1			; get address of mappings
		moveq	#0,d1
		btst	#render_rawmap_bit,d4			; is raw mappings flag on?
		bne.s	.draw_now				; if so, branch

		move.b	ost_frame(a0),d1			; get currrent frame
		add.w	d1,d1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loop counter
		bmi.s	.skip_draw				; branch if frame contained 0 sprite pieces

	.draw_now:
		bsr.w	BuildSpr_Draw				; write data from sprite pieces to buffer

	.skip_draw:
		ori.b	#render_onscreen,ost_render(a0)		; set object as visible

	BuildSprites_NextObject:
		addq.w	#2,d6					; read next object in sprite queue
		subq.w	#2,(a4)					; decrement number of objects left
		bne.w	BuildSprites_ObjectLoop			; branch if not 0

	BuildSprites_NextPriority:
		lea	sizeof_priority(a4),a4			; next priority section ($80)
		dbf	d7,BuildSprites_PriorityLoop		; repeat for all sections
		move.b	d5,(v_spritecount).w			; set sprite count

		; Terminate the sprite list.
		; If the sprite list is full, then set the link field of the last
		; entry to 0. Otherwise, push the next sprite offscreen and set its
		; link field to 0. You might be thinking why this doesn't just do the
		; first one no matter what? Well, think about what if the sprite list
		; was empty: then it would access data before the start of the list.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		beq.s	.max_sprites				; branch if at max
		move.l	#0,(a2)					; set next sprite to link to first (could be clr.l)
		rts
; ===========================================================================

	.max_sprites:
		move.b	#0,-sizeof_sprite+sprite_link(a2)	; set current sprite to link to first (could be clr.b)
		rts
; ===========================================================================

    if Revision=0
		; In the Simon Wai prototype, these two lines weren't here.
		; This may have been a debugging feature for helping the
		; devs detect when an object tried to display with a blank ID or
		; mappings pointer. This "display after free" was actually an
		; issue that plagued Sonic 1, but is (almost) completely absent in
		; this game.
BuildSprites_Crash:
		move.w	(1).w,d0				; causes an address exception
		bra.s	BuildSprites_NextPriority
    endc
; ===========================================================================

BuildSprites_MultiDraw:
		pushr.l	a4					; back up sprite queue address
		lea	(v_camera_x_pos).w,a4
		movea.w	ost_tile(a0),a3
		movea.l	ost_mappings(a0),a5
		moveq	#0,d0

		; check if object is within X bounds
		move.b	ost_mainspr_width(a0),d0		; load pixel width
		move.w	ost_x_pos(a0),d3			; load x pos
		sub.w	(a4),d3
		move.w	d3,d1
		add.w	d0,d1					; d1 = x pos of object's right edge on screen
		bmi.w	.next_object				; branch if object is outside left side of screen
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#screen_width,d1			; d1 = x pos of object's left edge on screen
		bge.w	.next_object				; branch if object is outside right side of screen
		addi.w	#screen_left,d3				; d3 = x pos of object on screen, +128px for VDP sprite coordinate

		; check if object is within Y bounds
		btst	#render_useheight_bit,d4		; is use height flag on?
		beq.s	.assume_height				; if so, branch
		moveq	#0,d0
		move.b	ost_mainspr_height(a0),d0		; load pixel height
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a4),d2	; d2 = y pos of object on screen
		move.w	d2,d1
		add.w	d0,d1					; d1 = y pos of object's bottom edge on screen
		bmi.w	.next_object				; branch if object is outside top side of screen
		move.w	d2,d1
		sub.w	d0,d1					; d1 = y pos of object's top edge on screen
		cmpi.w	#screen_height,d1
		bge.w	.next_object				; branch if object is outside bottom side of screen
		addi.w	#screen_top,d2				; d2 = y pos of object on screen, +128px for VDP sprite coordinate
		bra.s	.draw_parent
; ===========================================================================

	.assume_height:
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a4),d2	; d2 = y pos of object on screen
		addi.w	#screen_top,d2
		andi.w	#$7FF,d2
		cmpi.w	#screen_top-32,d2			; assume y radius to be 32 pixels
		bcs.s	.next_object				; branch if > 32px outside top side of screen
		cmpi.w	#screen_bottom+32,d2
		bcc.s	.next_object				; branch if > 32px outside bottom side of screen

	.draw_parent:
		moveq	#0,d1
		move.b	ost_mainspr_frame(a0),d1		; get current frame of parent sprite
		beq.s	.skip_parent				; branch if zero
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loops
		bmi.s	.skip_parent				; branch if frame contained 0 sprite pieces
		pushr.w	d4					; back up render flags copy
		bsr.w	BuildSpr_DrawCheck			; write data from sprite pieces to buffer
		popr.w	d4					; restore render flags

	.skip_parent:
		ori.b	#render_onscreen,ost_render(a0)		; set object as visible
		lea	ost_subspr2_x_pos(a0),a6		; a6 = x pos of first child sprite
		moveq	#0,d0
		move.b	ost_mainspr_childsprites(a0),d0		; get child sprite count
		subq.w	#1,d0					; subtract 1 for loops
		bcs.s	.next_object				; branch if there are no child sprites

	.childsprite_loop:
		swap	d0					; stash loop counter in high word of d0
		move.w	(a6)+,d3
		sub.w	(a4),d3
		addi.w	#screen_left,d3				; d3 = x pos of child sprite on screen, +128px for VDP sprite coordinate
		move.w	(a6)+,d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a4),d2
		addi.w	#screen_top,d2				; d2 = y pos of child sprite on screen, +128px for VDP sprite coordinate
		andi.w	#$7FF,d2
		addq.w	#1,a6					; skip over mainsprite height or unused variable
		moveq	#0,d1
		move.b	(a6)+,d1				; get current frame of child
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loops
		bmi.s	.skip_draw_child			; branch if frame contained 0 sprite pieces
		pushr.w	d4					; back up render flags copy
		bsr.w	BuildSpr_DrawCheck			; write data from sprite pieces to buffer
		popr.w	d4					; restore render flags

	.skip_draw_child:
		swap	d0					; restore loop counter
		dbf	d0,.childsprite_loop			; repeat for number of child sprites

	.next_object:
		popr.l	a4					; a4 = v_sprite_queue
		bra.w	BuildSprites_NextObject			; all children processed; proceed to next discreet object
; ===========================================================================

    if FixBugs=0
	BuildSpr_DrawCheck:
		; This check has been moved, so it is redundant.
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcs.s	BuildSpr_Cont				; branch if not at max
		rts						; otherwise, return
    endc

; ---------------------------------------------------------------------------
; Subroutine to	convert	and add sprite mappings to the sprite buffer

; input:
;	d1.w = number of sprite pieces
;	d2.w = VDP y position
;	d3.w = VDP x position
;	d4.b = render flags (ost_render)
;	d5.b = current sprite count
;	a1 = current address in sprite mappings
;	a2 = current address in sprite buffer
;	a3 = VRAM tile setting (used as source for add instruction)

;	uses d0.w, d1.w, d4.w, d5.b, a1, a2
; ---------------------------------------------------------------------------

BuildSpr_Draw:
		movea.w	ost_tile(a0),a3				; get VRAM setting (tile, x/yflip, palette, priority)

   if FixBugs=0
		; This check has been moved, so it is redundant.
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcc.s	BuildSpr_Done				; branch if at max
    endc

    if FixBugs
BuildSpr_DrawCheck:
    else
BuildSpr_Cont:
    endc

		btst	#render_xflip_bit,d4			; is the sprite to be X-flipped?
		bne.s	BuildSpr_FlipX				; if so, branch
		btst	#render_yflip_bit,d4			; is the sprite to be Y-flipped?
		bne.w	BuildSpr_FlipY				; if so, branch

BuildSpr_Normal:
    if FixBugs
    	; Hey look, it's the bug that Ashura the Hedgehog and Surge the Tenrec
    	; owe their existence to. In a rather overzealous optimization,
    	; the game doesn't check if the sprite limit has been reached after
    	; processing each sprite piece. This means that a multisprite object may be
    	; processed even if there is not enough room left in 'v_sprite_buffer', leading
    	; to a buffer overflow. To prevent this from causing harm, the developers placed
    	; an $80 byte buffer after 'v_sprite_buffer' to 'catch' the overflow.

		; Unfortunately, $80 bytes is not big enough to catch all overflow:
		; when placed in debug mode, the EHZ waterfalls can blow clean past this
		; and overwrite the first part of Sonic's palette in v_pal_dry_line1.
		; This oversight is responsible for the famous 'Ashura' glitch, where
		; waterfall sprite data is interpreted as color data.

		; To fix this, we'll just undo this optimistaion. Sonic 3 & Knuckles undid
		; this optimistaion too, but heavily optimized the rest of 'BuildSprites'
		; to make up for it.
		cmpi.b	#countof_max_sprites,d5			; has the sprite limit been reached?
		bcc.s	BuildSpr_Done				; branch if at max
    endc

		move.b	(a1)+,d0				; get relative y pos from mappings
		ext.w	d0
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,(a2)+				; write sprite size to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		move.w	d0,(a2)+				; write to buffer

		addq.w	#2,a1					; skip 2P mode specific data
		move.w	(a1)+,d0				; get relative x pos from mappings
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if x pos isn't 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,BuildSpr_Normal			; next sprite piece

	BuildSpr_Done:
		rts
; ===========================================================================

BuildSpr_FlipX:
		btst	#render_yflip_bit,d4			; is it to be Y-flipped as well?
		bne.w	BuildSpr_FlipXY				; if so, branch

	.loop:
    if FixBugs
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; has the sprite limit been reached?
		bcc.s	.return					; if it has, branch
    endc
		move.b	(a1)+,d0				; get relative y pos from mappings
		ext.w	d0
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,d4				; get sprite size (copy in d4 will be used later)
		move.b	d4,(a2)+				; write to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		eori.w	#sprite_xflip,d0			; toggle xflip in VDP
		move.w	d0,(a2)+				; write to buffer

		addq.w	#2,a1					; skip 2P mode specific data
		move.w	(a1)+,d0				; get relative x pos from mappings
		neg.w	d0					; negate it
		move.b	CellOffsets_XFlip(pc,d4.w),d4		; get x offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if x pos isn't 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,.loop				; next sprite piece

	.return:
		rts

; ---------------------------------------------------------------------------
; Lookup tables of offsets for mirrored sprite pieces. In Sonic 1, these were
; calculated. Multiple copies of these tables are used so that PC-relative
; with index can be used for all sprite flip operations.
; ---------------------------------------------------------------------------

CellOffsets_XFlip:
		dc.b   8,  8,  8,  8				; 4
		dc.b $10,$10,$10,$10				; 8
		dc.b $18,$18,$18,$18				; 12
		dc.b $20,$20,$20,$20				; 16

CellOffsets_YFlip:
		dc.b   8,$10,$18,$20				; 4
		dc.b   8,$10,$18,$20				; 8
		dc.b   8,$10,$18,$20				; 12
		dc.b   8,$10,$18,$20				; 16
; ===========================================================================

BuildSpr_FlipY:
    if FixBugs
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; has the sprite limit been reached?
		bcc.s	.return					; if it has, branch
    endc
		move.b	(a1)+,d0				; get relative y pos from mappings
		move.b	(a1),d4					; get size
		ext.w	d0
		neg.w	d0					; negate y pos
		move.b	CellOffsets_YFlip(pc,d4.w),d4		; get y offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,(a2)+				; write sprite size to buffer
		addq.b	#1,d5
		move.b	d5,(a2)+				; write link to next sprite in buffer

		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		eori.w	#sprite_yflip,d0			; toggle yflip in VDP
		move.w	d0,(a2)+				; write to buffer

		addq.w	#2,a1					; skip 2P mode specific data
		move.w	(a1)+,d0				; get relative x pos from mappings
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if x pos isn't 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,BuildSpr_FlipY			; next sprite piece

	.return:
		rts
; ===========================================================================

CellOffsets_YFlip2:
		dc.b   8,$10,$18,$20				; 4
		dc.b   8,$10,$18,$20				; 8
		dc.b   8,$10,$18,$20				; 12
		dc.b   8,$10,$18,$20				; 16
; ===========================================================================

BuildSpr_FlipXY:
    if FixBugs
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; has the sprite limit been reached?
		bcc.s	.return					; if it has, branch
    endc
		move.b	(a1)+,d0				; get relative y pos from mappings
		move.b	(a1),d4					; get size
		ext.w	d0
		neg.w	d0					; negate y pos
		move.b	CellOffsets_YFlip2(pc,d4.w),d4		; get y offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,d4				; get sprite size (copy in d4 will be used later)
		move.b	d4,(a2)+				; write to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		eori.w	#sprite_xflip|sprite_yflip,d0		; toggle xflip and yflip in VDP
		move.w	d0,(a2)+				; write to buffer

		addq.w	#2,a1					; skip 2P mode specific data
		move.w	(a1)+,d0				; get relative x pos from mappings
		neg.w	d0					; negate it
		move.b	CellOffsets_XFlip2(pc,d4.w),d4		; get x offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if x pos isn't 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,BuildSpr_FlipXY			; next sprite piece

	.return:
		rts
; ===========================================================================

CellOffsets_XFlip2:
		dc.b   8,  8,  8,  8				; 4
		dc.b $10,$10,$10,$10				; 8
		dc.b $18,$18,$18,$18				; 12
		dc.b $20,$20,$20,$20				; 16
; ===========================================================================

BuildSprites_2P:
	if FixBugs
		; Like in Sonic 3, the sprite tables are page-flipped in two-player mode.
		; This fixes a race condition where incomplete sprite tables can be uploaded
		; to the VDP on lag frames, causing corrupted sprites to appear.
		lea	(v_sprite_buffer).w,a2
		tst.b	(f_sprite_buffer_page).w
		beq.s	.useprimary				; branch if we're using the primary page
		lea	(v_sprite_buffer_alt).w,a2
	else
		lea	(v_sprite_buffer).w,a2
	endc
		moveq	#2,d5					; initial link value
		moveq	#0,d4					; holds copy of render flags

		; Sprite table in 2P mode is prefaced by two dummy sprites that mask everything between 216-248px.
		move.l	#($1D8<<16)|(sprite_width_4<<10)|(sprite_height_4<<8)|1,(a2)+ ; $1D80F01; y pos $1D8, size 4x4 tiles, link 1
		move.l	#1,(a2)+				; tile = 0, x pos 1
		move.l	#($1D8<<16)|(sprite_width_4<<10)|(sprite_height_4<<8)|2,(a2)+ ; $1D80F02; y pos $1D8, size 4x4 tiles, link 1
		move.l	#0,(a2)+				; tile = 0, x pos 0
		tst.b	(f_level_started).w			; has the level started?
		beq.s	.notstarted				; if not, branch
		jsrto	BuildHUD_P1,JmpTo_BuildHUD_P1		; render player 1's HUD
		bsr.w	BuildRings_P1				; render player 1's rings

	.notstarted:
		lea	(v_sprite_queue).w,a4			; address of sprite queue - $400 bytes, 8 sections of $80 bytes (1 word for count, $3F words for OST addresses)
		moveq	#countof_priority-1,d7			; 8 priority levels

	BuildSprites_P1_PriorityLoop:
		move.w	(a4),d0					; are there objects left in current section?
		beq.w	BuildSprites_P1_NextPriority		; if not, branch
		pushr.w	d0					; (sp) =  remaining objects in queue
		moveq	#2,d6					; index to start address within current section (1st word is object count)

	BuildSprites_P1_ObjectLoop:
		movea.w	(a4,d6.w),a0				; load address of OST of object
		tst.b	ost_id(a0)
		beq.w	BuildSprites_P1_NextObject		; if object id is 0, branch

		andi.b	#(~render_onscreen)&$FF,ost_render(a0)	; set as not visible
		move.b	ost_render(a0),d0
		move.b	d0,d4
		btst	#render_subsprites_bit,d0		; is this a multisprite object?
		bne.w	BuildSprites_P1_MultiDraw		; if so, branch
		andi.w	#render_rel|render_bg,d0		; get drawing coordinate system
		beq.s	.abs_screen_coords			; branch if 0 (absolute screen coordinates)
		lea	(v_camera_x_pos).w,a1			; get address for camera x position (or background x position if render_bg is used)

		; check if object is visible
		moveq	#0,d0
		move.b	ost_displaywidth(a0),d0
		move.w	ost_x_pos(a0),d3
		sub.w	(a1),d3
		move.w	d3,d1
		add.w	d0,d1					; d1 = x pos of object's right edge on screen
		bmi.w	BuildSprites_P1_NextObject		; branch if object is outside left side of screen
		move.w	d3,d1
		sub.w	d0,d1					; d1 = x pos of object's left edge on screen
		cmpi.w	#screen_width,d1
		bge.s	BuildSprites_P1_NextObject		; branch if object is outside right side of screen
		addi.w	#screen_left,d3				; d3 = x pos of object on screen, +128px for VDP sprite coordinate

		btst	#render_useheight_bit,d4		; is use height flag on?
		beq.s	.assume_height				; if not, branch
		moveq	#0,d0
		move.b	ost_height(a0),d0
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a1),d2
		move.w	d2,d1
		add.w	d0,d1					; d1 = y pos of object's bottom edge on screen
		bmi.s	BuildSprites_P1_NextObject		; branch if object is outside top side of screen
		move.w	d2,d1
		sub.w	d0,d1					; d1 = y pos of object's top edge on screen
		cmpi.w	#screen_height,d1
		bge.s	BuildSprites_P1_NextObject		; branch if object is outside bottom side of player 1's viewport
		addi.w	#screen_top*2,d2			; d2 = y pos of object on screen, +256px for VDP sprite coordinate
		bra.s	.draw_object
; ===========================================================================

	.abs_screen_coords:
		move.w	ost_y_screen(a0),d2			; d2 = y pos
		move.w	ost_x_screen(a0),d3			; d3 = x pos
		addi.w	#screen_top,d2				; adjust y pos
		bra.s	.draw_object
; ===========================================================================

	.assume_height:
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a1),d2	; d2 = y pos of object on screen
		addi.w	#screen_top,d2
		cmpi.w	#screen_top-32,d2			; assume y radius to be 32 pixels
		bcs.s	BuildSprites_P1_NextObject		; branch if > 32px outside top side of screen
		cmpi.w	#screen_bottom+32,d2
		bcc.s	BuildSprites_P1_NextObject		; branch if > 32px outside bottom of player 1's viewport
		addi.w	#screen_top,d2				; d2 = y pos of object on screen, +128px for VDP sprite coordinate

	.draw_object:
		movea.l	ost_mappings(a0),a1			; get address of mappings
		moveq	#0,d1
		btst	#render_rawmap_bit,d4			; is raw mappings flag on?
		bne.s	.draw_now				; if so, branch

		move.b	ost_frame(a0),d1			; get currrent frame
		add.w	d1,d1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loop counter
		bmi.s	.skip_draw				; branch if frame contained 0 sprite pieces

	.draw_now:
		bsr.w	BuildSpr_Draw_2P			; write data from sprite pieces to buffer

	.skip_draw:
		ori.b	#render_onscreen,ost_render(a0)		; set object as visible

	BuildSprites_P1_NextObject:
		addq.w	#2,d6					; read next object in sprite queue
		subq.w	#2,(sp)					; decrement number of objects left
		bne.w	BuildSprites_P1_ObjectLoop		; branch if not 0
		addq.w	#2,sp					; all done; deallocate word on stack

	BuildSprites_P1_NextPriority:
		lea	sizeof_priority(a4),a4			; next priority section ($80)
		dbf	d7,BuildSprites_P1_PriorityLoop		; repeat for all sections
		move.b	d5,(v_spritecount).w			; set sprite count
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcc.s	.max_sprites				; branch if at max
		move.l	#0,(a2)					; set next sprite to link to first (could be clr.l)
		bra.s	BuildSprites_P2
; ===========================================================================

.max_sprites:
		move.b	#0,-sizeof_sprite+sprite_link(a2)

BuildSprites_P2:
	if FixBugs
		; Like in Sonic 3, the sprite tables are page-flipped in two-player mode.
		; This fixes a race condition where incomplete sprite tables can be uploaded
		; to the VDP on lag frames, causing corrupted sprites to appear.
		lea	(v_sprite_buffer_2).w,a2
		tst.b	(f_sprite_buffer_page).w
		beq.s	.useprimary				; branch if we're using the primary page
		lea	(v_sprite_buffer_alt_2).w,a2
	else
		tst.w	(f_hblank).w				; has HBlank run?
		bne.s	BuildSprites_P2				; if not, wait
		lea	(v_sprite_buffer_2).w,a2
	endc
		moveq	#0,d5					; initial link value
		moveq	#0,d4					; holds copy of render flags
		tst.b	(f_level_started).w			; has the level started?
		beq.s	.notstarted				; if not, branch
		jsrto	BuildHUD_P2,JmpTo_BuildHUD_P2		; render player 2's HUD
		bsr.w	loc_1720E				; render player 2's rings

	.notstarted:
		lea	(v_sprite_queue).w,a4			; address of sprite queue - $400 bytes, 8 sections of $80 bytes (1 word for count, $3F words for OST addresses)
		moveq	#countof_priority-1,d7			; 8 priority levels

	BuildSprites_P2_PriorityLoop:
		move.w	(a4),d0					; are there objects left in current section?
		beq.w	BuildSprites_P2_NextPriority		; if not, branch
		pushr.w	d0					; (sp) =  remaining objects in queue
		moveq	#2,d6					; index to start address within current section (1st word is object count)

	BuildSprites_P2_ObjectLoop:
		movea.w	(a4,d6.w),a0				; load address of OST of object
		tst.b	ost_id(a0)
		beq.w	BuildSprites_P2_NextObject		; if object id is 0, branch

		move.b	ost_render(a0),d0
		move.b	d0,d4
		btst	#render_subsprites_bit,d0		; is this a multisprite object?
		bne.w	BuildSprites_P2_MultiDraw		; if so, branch
		andi.w	#render_rel|render_bg,d0		; get drawing coordinate system
		beq.s	.abs_screen_coords			; branch if 0 (absolute screen coordinates)
		lea	(v_camera_x_pos_p2).w,a1		; get address for camera x position (or background x position if render_bg is used)

		; check if object is visible
		moveq	#0,d0
		move.b	ost_displaywidth(a0),d0
		move.w	ost_x_pos(a0),d3
		sub.w	(a1),d3
		move.w	d3,d1
		add.w	d0,d1					; d1 = x pos of object's right edge on screen
		bmi.w	BuildSprites_P2_NextObject		; branch if object is outside left side of screen
		move.w	d3,d1
		sub.w	d0,d1					; d1 = x pos of object's left edge on screen
		cmpi.w	#screen_width,d1
		bge.s	BuildSprites_P2_NextObject		; branch if object is outside right side of screen
		addi.w	#screen_left,d3				; d3 = x pos of object on screen, +128px for VDP sprite coordinate

		btst	#render_useheight_bit,d4		; is use height flag on?
		beq.s	.assume_height				; if not, branch
		moveq	#0,d0
		move.b	ost_height(a0),d0
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos_p2-v_camera_x_pos_p2(a1),d2
		move.w	d2,d1
		add.w	d0,d1					; d1 = y pos of object's bottom edge on screen
		bmi.s	BuildSprites_P2_NextObject		; branch if object is outside top of player 2's viewport
		move.w	d2,d1
		sub.w	d0,d1					; d1 = y pos of object's top edge on screen
		cmpi.w	#screen_height,d1
		bge.s	BuildSprites_P2_NextObject		; branch if object is outside bottom side of screen
		addi.w	#(screen_top*2)+screen_height,d2	; d2 = y pos of object on screen, +256px for VDP sprite coordinate, +224px for bottom viewport
		bra.s	.draw_object
; ===========================================================================

	.abs_screen_coords:
		move.w	ost_y_screen(a0),d2			; d2 = y pos
		move.w	ost_x_screen(a0),d3			; d3 = x pos
		addi.w	#screen_top+screen_height,d2		; adjust y pos
		bra.s	.draw_object
; ===========================================================================

	.assume_height:
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos_p2-v_camera_x_pos_p2(a1),d2 ; d2 = y pos of object on screen
		addi.w	#screen_top,d2
		cmpi.w	#screen_top-32,d2			; assume y radius to be 32 pixels
		bcs.s	BuildSprites_P2_NextObject
		cmpi.w	#screen_bottom+32,d2
		bcc.s	BuildSprites_P2_NextObject		; branch if > 32px outside bottom side of screen
		addi.w	#screen_top+screen_height,d2		; d2 = y pos of object on screen, +128px for VDP sprite coordinate

	.draw_object:
		movea.l	ost_mappings(a0),a1			; get address of mappings
		moveq	#0,d1
		btst	#render_rawmap_bit,d4			; is raw mappings flag on?
		bne.s	.draw_now				; if so, branch

		move.b	ost_frame(a0),d1			; get currrent frame
		add.w	d1,d1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loop counter
		bmi.s	.skip_draw				; branch if frame contained 0 sprite pieces

	.draw_now:
		bsr.w	BuildSpr_Draw_2P			; write data from sprite pieces to buffer

	.skip_draw:
		ori.b	#render_onscreen,ost_render(a0)		; set object as visible

	BuildSprites_P2_NextObject:
		addq.w	#2,d6					; read next object in sprite queue
		subq.w	#2,(sp)					; decrement number of objects left
		bne.w	BuildSprites_P2_ObjectLoop		; branch if not 0
		addq.w	#2,sp					; all done; deallocate word on stack

		tst.b	(f_teleport).w				; is a teleport in progress?
		bne.s	BuildSprites_P2_NextPriority		; branch if so
		move.w	#0,(a4)					; clear count of objects for this priority section

BuildSprites_P2_NextPriority:
		lea	sizeof_priority(a4),a4			; next priority section ($80)
		dbf	d7,BuildSprites_P2_PriorityLoop		; repeat for all sections
		move.b	d5,(v_spritecount).w			; set sprite count

	if FixBugs
		; The new sprite tables are complete: signal a page flip to
		; allow them to be uploaded to the VDP!
		st.b	(f_sprite_buffer_pageflip).w		; mark sprite tables as complete
	endc

		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		beq.s	.max_sprites				; branch if at max
		move.l	#0,(a2)					; set next sprite to link to first (could be clr.l)
		rts
; ===========================================================================

.max_sprites:
		move.b	#0,-sizeof_sprite+sprite_link(a2)	; set current sprite to link to first (could be clr.b)
		rts
; ===========================================================================

BuildSprites_P1_MultiDraw:
		pushr.l	a4					; back up sprite queue address
		lea	(v_camera_x_pos).w,a4
		movea.w	ost_tile(a0),a3
		movea.l	ost_mappings(a0),a5
		moveq	#0,d0

		; check if object is within X bounds
		move.b	ost_mainspr_width(a0),d0		; load pixel width
		move.w	ost_x_pos(a0),d3			; load x pos
		sub.w	(a4),d3
		move.w	d3,d1
		add.w	d0,d1					; d1 = x pos of object's right edge on screen
		bmi.w	.next_object				; branch if object is outside left side of screen
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#screen_width,d1			; d1 = x pos of object's left edge on screen
		bge.w	.next_object				; branch if object is outside right side of screen
		addi.w	#screen_left,d3				; d3 = x pos of object on screen, +128px for VDP sprite coordinate

		; check if object is within Y bounds
		btst	#render_useheight_bit,d4		; is use height flag on?
		beq.s	.assume_height				; if so, branch
		moveq	#0,d0
		move.b	ost_mainspr_height(a0),d0		; load pixel height
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a4),d2	; d2 = y pos of object on screen
		move.w	d2,d1
		add.w	d0,d1					; d1 = y pos of object's bottom edge on screen
		bmi.w	.next_object				; branch if object is outside top side of screen
		move.w	d2,d1
		sub.w	d0,d1					; d1 = y pos of object's top edge on screen
		cmpi.w	#screen_height,d1
		bge.w	.next_object				; branch if object is outside bottom side of screen
		addi.w	#screen_top*2,d2			; d2 = y pos of object on screen, +128px for VDP sprite coordinate
		bra.s	.draw_parent
; ===========================================================================

	.assume_height:
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a4),d2	; d2 = y pos of object on screen
		addi.w	#screen_top,d2
		cmpi.w	#screen_top-32,d2			; assume y radius to be 32 pixels
		bcs.s	.next_object				; branch if > 32px outside top side of screen
		cmpi.w	#screen_bottom+32,d2
		bcc.s	.next_object				; branch if > 32px outside bottom of player 1's viewport
		addi.w	#screen_top,d2				; d2 = y pos of object on screen, +128px for VDP sprite coordinate

	.draw_parent:
		moveq	#0,d1
		move.b	ost_mainspr_frame(a0),d1		; get current frame of parent sprite
		beq.s	.skip_parent				; branch if zero
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loops
		bmi.s	.skip_parent				; branch if frame contained 0 sprite pieces
		pushr.w	d4					; back up render flags copy
		bsr.w	BuildSpr_DrawCheck_2P			; write data from sprite pieces to buffer
		popr.w	d4					; restore render flags

	.skip_parent:
		ori.b	#render_onscreen,ost_render(a0)		; set object as visible
		lea	ost_subspr2_x_pos(a0),a6		; a6 = x pos of first child sprite
		moveq	#0,d0
		move.b	ost_mainspr_childsprites(a0),d0		; get child sprite count
		subq.w	#1,d0					; subtract 1 for loops
		bcs.s	.next_object				; branch if there are no child sprites

	.childsprite_loop:
		swap	d0					; stash loop counter in high word of d0
		move.w	(a6)+,d3
		sub.w	(a4),d3
		addi.w	#screen_left,d3				; d3 = x pos of child sprite on screen, +128px for VDP sprite coordinate
		move.w	(a6)+,d2
		sub.w	v_camera_y_pos-v_camera_x_pos(a4),d2
		addi.w	#screen_top*2,d2			; d2 = y pos of child sprite on screen, +256px for VDP sprite coordinate
		addq.w	#1,a6					; skip over mainsprite height or unused variable
		moveq	#0,d1
		move.b	(a6)+,d1				; get current frame of child
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loops
		bmi.s	.skip_draw_child			; branch if frame contained 0 sprite pieces
		pushr.w	d4					; back up render flags copy
		bsr.w	BuildSpr_DrawCheck_2P			; write data from sprite pieces to buffer
		popr.w	d4					; restore render flags

	.skip_draw_child:
		swap	d0					; restore loop counter
		dbf	d0,.childsprite_loop			; repeat for number of child sprites

	.next_object:
		popr.l	a4					; a4 = v_sprite_queue
		bra.w	BuildSprites_P1_NextObject
; ===========================================================================

BuildSprites_P2_MultiDraw:
		pushr.l	a4					; back up sprite queue address
		lea	(v_camera_x_pos_p2).w,a4
		movea.w	ost_tile(a0),a3
		movea.l	ost_mappings(a0),a5
		moveq	#0,d0

		; check if object is within X bounds
		move.b	ost_mainspr_width(a0),d0		; load pixel width
		move.w	ost_x_pos(a0),d3			; load x pos
		sub.w	(a4),d3
		move.w	d3,d1
		add.w	d0,d1					; d1 = x pos of object's right edge on screen
		bmi.w	.next_object				; branch if object is outside left side of screen
		move.w	d3,d1
		sub.w	d0,d1
		cmpi.w	#screen_width,d1			; d1 = x pos of object's left edge on screen
		bge.w	.next_object				; branch if object is outside right side of screen
		addi.w	#screen_left,d3				; d3 = x pos of object on screen, +128px for VDP sprite coordinate

		; check if object is within Y bounds
		btst	#render_useheight_bit,d4		; is use height flag on?
		beq.s	.assume_height				; if so, branch
		moveq	#0,d0
		move.b	ost_mainspr_height(a0),d0		; load pixel height
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos_p2-v_camera_x_pos_p2(a4),d2 ; d2 = y pos of object on screen
		move.w	d2,d1
		add.w	d0,d1					; d1 = y pos of object's bottom edge on screen
		bmi.w	.next_object				; branch if object is outside top of player 2's viewport
		move.w	d2,d1
		sub.w	d0,d1					; d1 = y pos of object's top edge on screen
		cmpi.w	#screen_height,d1
		bge.w	.next_object				; branch if object is outside bottom side of screen
		addi.w	#(screen_top*2)+screen_height,d2	; d2 = y pos of object on screen, +256px for VDP sprite coordinate, +224px for bottom viewport
		bra.s	.draw_parent
; ===========================================================================

	.assume_height:
		move.w	ost_y_pos(a0),d2
		sub.w	v_camera_y_pos_p2-v_camera_x_pos_p2(a4),d2 ; d2 = y pos of object on screen
		addi.w	#screen_top,d2
		cmpi.w	#screen_top-32,d2			; assume y radius to be 32 pixels
		bcs.s	.next_object
		cmpi.w	#screen_bottom+32,d2
		bcc.s	.next_object				; branch if > 32px outside bottom side of screen
		addi.w	#screen_top+screen_height,d2		; d2 = y pos of object on screen, +128px for VDP sprite coordinate

	.draw_parent:
		moveq	#0,d1
		move.b	ost_mainspr_frame(a0),d1		; get current frame of parent sprite
		beq.s	.skip_parent				; branch if zero
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loops
		bmi.s	.skip_parent				; branch if frame contained 0 sprite pieces
		pushr.w	d4					; back up render flags copy
		bsr.w	BuildSpr_DrawCheck_2P			; write data from sprite pieces to buffer
		popr.w	d4					; restore render flags

	.skip_parent:
		ori.b	#render_onscreen,ost_render(a0)		; set object as visible
		lea	ost_subspr2_x_pos(a0),a6		; a6 = x pos of first child sprite
		moveq	#0,d0
		move.b	ost_mainspr_childsprites(a0),d0		; get child sprite count
		subq.w	#1,d0					; subtract 1 for loops
		bcs.s	.next_object				; branch if there are no child sprites

	.childsprite_loop:
		swap	d0					; stash loop counter in high word of d0
		move.w	(a6)+,d3
		sub.w	(a4),d3
		addi.w	#screen_left,d3				; d3 = x pos of child sprite on screen, +128px for VDP sprite coordinate
		move.w	(a6)+,d2
		sub.w	v_camera_y_pos_p2-v_camera_x_pos_p2(a4),d2
		addi.w	#(screen_top*2)+screen_height,d2	; d2 = y pos of child sprite on screen, +256px for VDP sprite coordinate, +224px for bottom viewport
		addq.w	#1,a6
		moveq	#0,d1
		move.b	(a6)+,d1				; get current frame of child
		add.w	d1,d1
		movea.l	a5,a1
		adda.w	(a1,d1.w),a1				; jump to frame within mappings
		move.w	(a1)+,d1				; number of sprite pieces
		subq.w	#1,d1					; subtract 1 for loops
		bmi.s	.skip_draw_child			; branch if frame contained 0 sprite pieces
		pushr.w	d4					; back up render flags copy
		bsr.w	BuildSpr_DrawCheck_2P			; write data from sprite pieces to buffer
		popr.w	d4					; restore render flags

	.skip_draw_child:
		swap	d0					; restore loop counter
		dbf	d0,.childsprite_loop			; repeat for number of child sprites

	.next_object:
		popr.l	a4					; a4 = v_sprite_queue
		bra.w	BuildSprites_P2_NextObject

; ---------------------------------------------------------------------------
; Subroutine to adjust an object's VRAM pointer for two-player mode

; input:
;	a0 = OST of object

;	uses d0.w
; ---------------------------------------------------------------------------

AdjustVRAM2P:
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.s	.return					; if not, return
		move.w	ost_tile(a0),d0				; get tile OST
		andi.w	#tile_vram,d0				; only need VRAM assignment
		lsr.w	#1,d0					; shift VRAM assignment right by 1 bit
		andi.w	#tile_settings,ost_tile(a0)		; clear VRAM assignment in OST
		add.w	d0,ost_tile(a0)				; replace with adjusted assignment

	.return:
		rts

; ---------------------------------------------------------------------------
; As above, except a1 = object
; ---------------------------------------------------------------------------

AdjustVRAM2P2:
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.s	.return					; if not, return
		move.w	ost_tile(a1),d0				; get tile OST
		andi.w	#tile_vram,d0				; only need VRAM assignment
		lsr.w	#1,d0					; shift VRAM assignment right by 1 bit
		andi.w	#tile_settings,ost_tile(a1)		; clear VRAM assignment in OST
		add.w	d0,ost_tile(a1)				; replace with adjusted assignment

	.return:
		rts

; ===========================================================================

	if FixBugs=0
BuildSpr_DrawCheck_2P:
		; This branch skips the xflip and yflip checks, causing
		; multi-sprite objects to not properly mirror in two player mode.
		; An easy place to see this is Mystic Case Zone: the Crawltons
		; badnik's body segments will always face in one direction, and only
		; the head will be properly flipped. This is fixed by moving the draw
		; check to a more appropriate location as part of another fix;
		; see the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcs.s	BuildSpr_DrawLoop_2P			; branch if not at max
		rts
	endc
; ===========================================================================

BuildSpr_Draw_2P:
		movea.w	ost_tile(a0),a3

	if FixBugs=0
		; This check has been moved, so it is redundant.
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcc.s	BuildSpr_Draw_2P_Done			; branch if not at max
	endc
	if FixBugs
BuildSpr_DrawCheck_2P:
	endc
		btst	#render_xflip_bit,d4			; is the sprite to be X-flipped?
		bne.s	BuildSpr_2P_FlipX			; if so, branch
		btst	#render_yflip_bit,d4			; is the sprite to be Y-flipped?
		bne.w	BuildSpr_2P_FlipY			; if so, branch

	BuildSpr_DrawLoop_2P:
	if FixBugs
		; See the bugfix under 'DrawSprite_Loop'.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcc.s	BuildSpr_Draw_2P_Done			; branch if not at max
	endc
		move.b	(a1)+,d0				; get relative y pos from mappings
		ext.w	d0
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,d4				; get sprite size
		move.b	SpriteSizes_2P(pc,d4.w),(a2)+		; get adjusted size for 2P mode and write to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		addq.w	#2,a1					; skip 1P mode specific data
		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		move.w	d0,(a2)+				; write to buffer

		move.w	(a1)+,d0				; get relative x pos from mappings
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if not 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,BuildSpr_DrawLoop_2P			; next sprite piece

	BuildSpr_Draw_2P_Done:
		rts

; ---------------------------------------------------------------------------
; Adjusted sprite sizes for 2P mode. Cells are double height in 2P mode
; (double height interlace), so we halve the number of rows.
; As with the xflip and yflip values, this table is duplicated so that
; PC-relative with index can be used for all sprite flip operations.
; ---------------------------------------------------------------------------

SpriteSizes_2P:
		dc.b   0,0
		dc.b   1,1
		dc.b   4,4
		dc.b   5,5
		dc.b   8,8
		dc.b   9,9
		dc.b  $C,$C
		dc.b  $D,$D
; ===========================================================================

BuildSpr_2P_FlipX:
		btst	#render_yflip_bit,d4			; is it to be Y-flipped as well?
		bne.w	BuildSpr_2P_FlipXY			; if so, branch

	if FixBugs
		; See the bugfix under 'DrawSprite_Loop'.
		cmpi.b	#countof_max_sprites,d5			; max displayable sprites ($50)
		bcc.s	.return					; branch if not at max
	endc

	.loop:
		move.b	(a1)+,d0				; get relative y pos from mappings
		ext.w	d0
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,d4				; get sprite size
		move.b	SpriteSizes_2P(pc,d4.w),(a2)+		; get adjusted size for 2P mode and write to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		addq.w	#2,a1					; skip 1P mode specific data
		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		eori.w	#sprite_xflip,d0			; toggle xflip in VDP
		move.w	d0,(a2)+				; write to buffer

		move.w	(a1)+,d0				; get relative x pos from mappings
		neg.w	d0					; negate it
		move.b	CellOffsets_XFlip3(pc,d4.w),d4		; get x offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if x pos isn't 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,.loop				; next sprite piece

	.return:
		rts
; ===========================================================================

CellOffsets_XFlip3:
		dc.b   8,  8,  8,  8				; 4
		dc.b $10,$10,$10,$10				; 8
		dc.b $18,$18,$18,$18				; 12
		dc.b $20,$20,$20,$20				; 16

CellOffsets_YFlip3:
		dc.b   8,$10,$18,$20				; 4
		dc.b   8,$10,$18,$20				; 8
		dc.b   8,$10,$18,$20				; 12
		dc.b   8,$10,$18,$20				; 16
; ===========================================================================

BuildSpr_2P_FlipY:
    if FixBugs
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; has the sprite limit been reached?
		bcc.s	.return					; if it has, branch
    endc
		move.b	(a1)+,d0				; get relative y pos from mappings
		move.b	(a1),d4					; get sprite size
		ext.w	d0
		neg.w	d0					; negate y pos
		move.b	CellOffsets_YFlip3(pc,d4.w),d4		; get y offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,d4				; get sprite size
		move.b	SpriteSizes_2P_2(pc,d4.w),(a2)+		; get adjusted size for 2P mode and write to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		addq.w	#2,a1					; skip 1P mode specific data
		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		eori.w	#sprite_yflip,d0			; toggle yflip in VDP
		move.w	d0,(a2)+				; write to buffer

		move.w	(a1)+,d0				; get relative x pos from mappings
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if not 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,BuildSpr_2P_FlipY			; next sprite piece

	.return:
		rts
; ===========================================================================

SpriteSizes_2P_2:
		dc.b   0,0
		dc.b   1,1					; 2
		dc.b   4,4					; 4
		dc.b   5,5					; 6
		dc.b   8,8					; 8
		dc.b   9,9					; 10
		dc.b  $C,$C					; 12
		dc.b  $D,$D					; 14

CellOffsets_YFlip4:
		dc.b   8,$10,$18,$20				; 4
		dc.b   8,$10,$18,$20				; 8
		dc.b   8,$10,$18,$20				; 12
		dc.b   8,$10,$18,$20				; 16
; ===========================================================================

BuildSpr_2P_FlipXY:
    if FixBugs
		; See the bugfix under 'BuildSpr_Normal'.
		cmpi.b	#countof_max_sprites,d5			; has the sprite limit been reached?
		bcc.s	.return					; if it has, branch
    endc
		move.b	(a1)+,d0				; get relative y pos from mappings
		move.b	(a1),d4					; get sprite size
		ext.w	d0
		neg.w	d0					; negate y pos
		move.b	CellOffsets_YFlip4(pc,d4.w),d4		; get y offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d2,d0					; add VDP y pos
		move.w	d0,(a2)+				; write y pos to sprite buffer

		move.b	(a1)+,d4				; get sprite size
		move.b	SpriteSizes_2P_2(pc,d4.w),(a2)+		; get adjusted size for 2P mode and write to buffer
		addq.b	#1,d5					; increment sprite counter
		move.b	d5,(a2)+				; write link to next sprite in buffer

		addq.w	#2,a1					; skip 1P mode specific data
		move.w	(a1)+,d0				; get high byte of tile number from mappings
		add.w	a3,d0					; add VRAM setting
		eori.w	#sprite_xflip|sprite_yflip,d0		; toggle xflip and yflip in VDP
		move.w	d0,(a2)+				; write to buffer

		move.w	(a1)+,d0				; get relative x pos from mappings
		neg.w	d0					; negate it
		move.b	CellOffsets_XFlip4(pc,d4.w),d4		; get x offset based on size
		sub.w	d4,d0					; subtract offset
		add.w	d3,d0					; add VDP x pos
		andi.w	#$1FF,d0				; keep within 512px
		bne.s	.x_not_0				; branch if x pos isn't 0
		addq.w	#1,d0					; add 1 to prevent sprite masking (sprites at x pos 0 act as masks)

	.x_not_0:
		move.w	d0,(a2)+				; write to buffer
		dbf	d1,BuildSpr_2P_FlipXY			; next sprite piece

	.return:
		rts
; ===========================================================================

CellOffsets_XFlip4:
		dc.b   8,  8,  8,  8				; 4
		dc.b $10,$10,$10,$10				; 8
		dc.b $18,$18,$18,$18				; 12
		dc.b $20,$20,$20,$20				; 16

; ---------------------------------------------------------------------------
; Unused Sonic 1 leftover: subroutine to check if an object is off screen

; output:
;	d0.l = flag set if object is off screen
;	d1.w = y pos of object relative to screen

; usage:
;		bsr.w	CheckOffScreen
;		bne.s	.offscreen				; branch if off screen
; ---------------------------------------------------------------------------

CheckOffScreen:
		move.w	ost_x_pos(a0),d0			; get object x position
		sub.w	(v_camera_x_pos).w,d0			; subtract screen x position
		bmi.s	.offscreen				; branch if off left side of screen
		cmpi.w	#screen_width,d0
		bge.s	.offscreen				; branch if off right side of screen

		move.w	ost_y_pos(a0),d1			; get object y position
		sub.w	(v_camera_y_pos).w,d1			; subtract screen y position
		bmi.s	.offscreen				; branch if off top of screen
		cmpi.w	#screen_height,d1
		bge.s	.offscreen				; branch if off bottom of screen

		moveq	#0,d0					; set flag to 0
		rts

	.offscreen:
		moveq	#1,d0					; set flag to 1
		rts

; ---------------------------------------------------------------------------
; Unused Sonic 1 leftover: Subroutine to check if an object is off screen
; More precise than above subroutine, taking width into account

; output:
;	d0.l = flag set if object is off screen
;	d1.w = y pos of object relative to screen

;	uses d1.l

; usage:
;		bsr.w	CheckOffScreen_Wide
;		bne.s	.offscreen				; branch if off screen
; ---------------------------------------------------------------------------

CheckOffScreen_Wide:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		move.w	ost_x_pos(a0),d0			; get object x position
		sub.w	(v_camera_x_pos).w,d0			; subtract screen x position
		add.w	d1,d0					; d0 = x pos of object's right edge relative to screen
		bmi.s	.offscreen				; branch if off left side of screen
		add.w	d1,d1
		sub.w	d1,d0					; d0 = x pos of object's left edge relative to screen
		cmpi.w	#screen_width,d0
		bge.s	.offscreen				; branch if off right side of screen

		move.w	ost_y_pos(a0),d1
		sub.w	(v_camera_y_pos).w,d1
		bmi.s	.offscreen				; branch if off top of screen
		cmpi.w	#screen_height,d1
		bge.s	.offscreen				; branch if off bottom of screen

		moveq	#0,d0					; set flag to 0
		rts

	.offscreen:
		moveq	#1,d0					; set flag to 1
		rts
; ===========================================================================

    if Revision=1
		nop
    endc

    if RemoveJmpTos=0
JmpTo_BuildHUD:							; JmpTo
		jmp	(BuildHUD).l
JmpTo_BuildHUD_P1:						; JmpTo
		jmp	(BuildHUD_P1).l
JmpTo_BuildHUD_P2:						; JmpTo
		jmp	(BuildHUD_P2).l

		align 4
    endc


; ----------------------------------------------------------------------------
; Pseudo-object that manages where rings are placed onscreen
; as you move through the level, and otherwise updates them.
; ----------------------------------------------------------------------------
RingsManager:
		moveq	#0,d0
		move.b	(v_ring_manager_routine).w,d0
		move.w	off_16F96(pc,d0.w),d0
		jmp	off_16F96(pc,d0.w)
; ===========================================================================
off_16F96:	index offset(*),,2
		ptr loc_16F9A					; 0
		ptr loc_16FDE					; 2
; ===========================================================================

loc_16F9A:
		addq.b	#2,(v_ring_manager_routine).w
		bsr.w	loc_172A4
		lea	(v_ring_positions).w,a1
		move.w	(v_camera_x_pos).w,d4
		subq.w	#8,d4
		bhi.s	loc_16FB6
		moveq	#1,d4
		bra.s	loc_16FB6
; ===========================================================================

loc_16FB2:
		lea	6(a1),a1

loc_16FB6:
		cmp.w	2(a1),d4
		bhi.s	loc_16FB2
		move.w	a1,(v_ring_start).w
		move.w	a1,(v_ring_start_p2).w
		addi.w	#$150,d4
		bra.s	loc_16FCE
; ===========================================================================

loc_16FCA:
		lea	6(a1),a1

loc_16FCE:
		cmp.w	2(a1),d4
		bhi.s	loc_16FCA
		move.w	a1,(v_ring_end).w
		move.w	a1,(v_ring_end_p2).w
		rts
; ===========================================================================

loc_16FDE:
		lea	(v_ring_consumption_table).w,a2
		move.w	(a2)+,d1
		subq.w	#1,d1
		bcs.s	loc_17014

loc_16FE8:
		move.w	(a2)+,d0
		beq.s	loc_16FE8
		movea.w	d0,a1
		subq.b	#1,(a1)
		bne.s	loc_17010
		move.b	#6,(a1)
		addq.b	#1,1(a1)
		cmpi.b	#8,1(a1)
		bne.s	loc_17010
		move.w	#-1,(a1)
		move.w	#0,-2(a2)
		subq.w	#1,(v_ring_consumption_table).w

loc_17010:
		dbf	d1,loc_16FE8

loc_17014:
		movea.w	(v_ring_start).w,a1
		move.w	(v_camera_x_pos).w,d4
		subq.w	#8,d4
		bhi.s	loc_17028
		moveq	#1,d4
		bra.s	loc_17028
; ===========================================================================

loc_17024:
		lea	6(a1),a1

loc_17028:
		cmp.w	2(a1),d4
		bhi.s	loc_17024
		bra.s	loc_17032
; ===========================================================================

loc_17030:
		subq.w	#6,a1

loc_17032:
		cmp.w	-4(a1),d4
		bls.s	loc_17030
		move.w	a1,(v_ring_start).w
		movea.w	(v_ring_end).w,a2
		addi.w	#$150,d4
		bra.s	loc_1704A
; ===========================================================================

loc_17046:
		lea	6(a2),a2

loc_1704A:
		cmp.w	2(a2),d4
		bhi.s	loc_17046
		bra.s	loc_17054
; ===========================================================================

loc_17052:
		subq.w	#6,a2

loc_17054:
		cmp.w	-4(a2),d4
		bls.s	loc_17052
		move.w	a2,(v_ring_end).w

loc_1705E:
		tst.w	(f_two_player).w
		bne.s	loc_1706E
		move.w	a1,(v_ring_start_p2).w
		move.w	a2,(v_ring_end_p2).w
		rts
; ===========================================================================

loc_1706E:
		movea.w	(v_ring_start_p2).w,a1
		move.w	(v_camera_x_pos_p2).w,d4
		subq.w	#8,d4
		bhi.s	loc_17082
		moveq	#1,d4
		bra.s	loc_17082
; ===========================================================================

loc_1707E:
		lea	6(a1),a1

loc_17082:
		cmp.w	2(a1),d4
		bhi.s	loc_1707E
		bra.s	loc_1708C
; ===========================================================================

loc_1708A:
		subq.w	#6,a1

loc_1708C:
		cmp.w	-4(a1),d4
		bls.s	loc_1708A
		move.w	a1,(v_ring_start_p2).w
		movea.w	(v_ring_end_p2).w,a2
		addi.w	#$150,d4
		bra.s	loc_170A4
; ===========================================================================

loc_170A0:
		lea	6(a2),a2

loc_170A4:
		cmp.w	2(a2),d4
		bhi.s	loc_170A0
		bra.s	loc_170AE
; ===========================================================================

loc_170AC:
		subq.w	#6,a2

loc_170AE:
		cmp.w	-4(a2),d4
		bls.s	loc_170AC
		move.w	a2,(v_ring_end_p2).w
		rts
; ===========================================================================
; loc_170BA:
Touch_Rings:
		movea.w	(v_ring_start).w,a1
		movea.w	(v_ring_end).w,a2
		cmpa.w	#-$5000,a0
		beq.s	loc_170D0
		movea.w	(v_ring_start_p2).w,a1
		movea.w	(v_ring_end_p2).w,a2

loc_170D0:
		cmpa.l	a1,a2
		beq.w	locret_17166
		cmpi.w	#$5A,$30(a0)
		bcc.w	locret_17166
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		subi_.w	#8,d2
		moveq	#0,d5
		move.b	ost_height(a0),d5
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$4D,ost_frame(a0)
		bne.s	loc_17104
		addi.w	#$C,d3
		moveq	#$A,d5

loc_17104:
		move.w	#6,d1
		move.w	#$C,d6
		move.w	#$10,d4
		add.w	d5,d5

loc_17112:
		tst.w	(a1)
		bne.w	loc_1715C
		move.w	2(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_1712A
		add.w	d6,d0
		bcs.s	loc_17130
		bra.w	loc_1715C
; ===========================================================================

loc_1712A:
		cmp.w	d4,d0
		bhi.w	loc_1715C

loc_17130:
		move.w	4(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_17142
		add.w	d6,d0
		bcs.s	loc_17148
		bra.w	loc_1715C
; ===========================================================================

loc_17142:
		cmp.w	d5,d0
		bhi.w	loc_1715C

loc_17148:
		move.w	#$604,(a1)
		bsr.s	loc_17168
		lea	(v_ring_consumption_table+2).w,a3

loc_17152:
		tst.w	(a3)+
		bne.s	loc_17152
		move.w	a1,-(a3)
		addq.w	#1,(v_ring_consumption_table).w

loc_1715C:
		lea	6(a1),a1
		cmpa.l	a1,a2
		bne.w	loc_17112

locret_17166:
		rts
; ===========================================================================

loc_17168:
		subq.w	#1,(v_perfect_rings_left).w
		cmpa.w	#v_ost_player1,a0
		beq.w	loc_11FC8
		bra.w	loc_1201E
; ===========================================================================

BuildRings:
		movea.w	(v_ring_start).w,a0
		movea.w	(v_ring_end).w,a4
		cmpa.l	a0,a4
		bne.s	loc_17186
		rts
; ===========================================================================

loc_17186:
	if FixBugs
		; This fixes screen shaking not being applied to rings.
		lea	(v_camera_x_pos_copy2).w,a3
	else
		lea	(v_camera_x_pos).w,a3
	endc

loc_1718A:
		tst.w	(a0)
		bmi.w	loc_171EC
		move.w	2(a0),d3
		sub.w	(a3),d3
		addi.w	#$80,d3
		move.w	4(a0),d2
		sub.w	4(a3),d2

	if FixBugs
		addi_.w	#8,d2
		andi.w	#$7FF,d2
    else
		; Note that this 'andi' occurs *before* an 'addi'. This can cause
		; 'd2' to wrap incorrectly. This defect is the reason why rings
		; disappear when they go halfway off the top of the screen.
		andi.w	#$7FF,d2
		addi_.w	#8,d2
    endc

		bmi.s	loc_171EC
		cmpi.w	#$F0,d2
		bge.s	loc_171EC
		addi.w	#$78,d2
		lea	(Map_Rings).l,a1
		moveq	#0,d1
		move.b	1(a0),d1
		bne.s	loc_171C8
		move.b	(v_syncani_1_frame).w,d1

loc_171C8:
		add.w	d1,d1
		adda.w	(a1,d1.w),a1
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.w	(a1)+,d0
		addi.w	#$26BC,d0
		move.w	d0,(a2)+
		addq.w	#2,a1
		move.w	(a1)+,d0
		add.w	d3,d0
		move.w	d0,(a2)+

loc_171EC:
		lea	6(a0),a0
		cmpa.l	a0,a4
		bne.w	loc_1718A
		rts
; ===========================================================================

BuildRings_P1:
		lea	(v_camera_x_pos).w,a3
		move.w	#$78,d6
		movea.w	(v_ring_start).w,a0
		movea.w	(v_ring_end).w,a4
		cmpa.l	a0,a4
		bne.s	loc_17224
		rts
; ===========================================================================

loc_1720E:
		lea	(v_camera_x_pos_p2).w,a3
		move.w	#$158,d6
		movea.w	(v_ring_start_p2).w,a0
		movea.w	(v_ring_end_p2).w,a4
		cmpa.l	a0,a4
		bne.s	loc_17224
		rts
; ===========================================================================

loc_17224:
		tst.w	(a0)
		bmi.w	loc_17288
		move.w	2(a0),d3
		sub.w	(a3),d3
		addi.w	#$80,d3
		move.w	4(a0),d2
		sub.w	4(a3),d2
		andi.w	#$7FF,d2
		addi.w	#$88,d2
		bmi.s	loc_17288
		cmpi.w	#$170,d2
		bge.s	loc_17288
		add.w	d6,d2
		lea	(Map_Rings).l,a1
		moveq	#0,d1
		move.b	1(a0),d1
		bne.s	loc_17260
		move.b	(v_syncani_1_frame).w,d1

loc_17260:
		add.w	d1,d1
		adda.w	(a1,d1.w),a1
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	byte_17294(pc,d4.w),(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		addq.w	#2,a1
		move.w	(a1)+,d0
		addi.w	#$235E,d0
		move.w	d0,(a2)+
		move.w	(a1)+,d0
		add.w	d3,d0
		move.w	d0,(a2)+

loc_17288:
		lea	6(a0),a0
		cmpa.l	a0,a4
		bne.w	loc_17224
		rts
; ===========================================================================
byte_17294:
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b   1					; 2
		dc.b   1					; 3
		dc.b   4					; 4
		dc.b   4					; 5
		dc.b   5					; 6
		dc.b   5					; 7
		dc.b   8					; 8
		dc.b   8					; 9
		dc.b   9					; 10
		dc.b   9					; 11
		dc.b  $C					; 12
		dc.b  $C					; 13
		dc.b  $D					; 14
		dc.b  $D					; 15
; ===========================================================================

loc_172A4:
		lea	(v_ring_positions).w,a1
		moveq	#0,d0
		move.w	#$17F,d1

loc_172AE:
		move.l	d0,(a1)+
		dbf	d1,loc_172AE
		lea	(v_ring_consumption_table).w,a1
		move.w	#$F,d1

loc_172BC:
		move.l	d0,(a1)+
		dbf	d1,loc_172BC
		moveq	#0,d5
		moveq	#0,d0
		move.w	(v_zone).w,d0
		ror.b	#1,d0
		lsr.w	#6,d0
		lea	(RingPos_Index).l,a1
		move.w	(a1,d0.w),d0
		lea	(a1,d0.w),a1
		lea	($FFFFE806).w,a2

loc_172E0:
		move.w	(a1)+,d2
		bmi.s	loc_17328
		move.w	(a1)+,d3
		bmi.s	loc_17308
		move.w	d3,d0
		rol.w	#4,d0
		andi.w	#7,d0
		andi.w	#$FFF,d3

loc_172F4:
		move.w	#0,(a2)+
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		addi.w	#$18,d2
		addq.w	#1,d5
		dbf	d0,loc_172F4
		bra.s	loc_172E0
; ===========================================================================

loc_17308:
		move.w	d3,d0
		rol.w	#4,d0
		andi.w	#7,d0
		andi.w	#$FFF,d3

loc_17314:
		move.w	#0,(a2)+
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		addi.w	#$18,d3
		addq.w	#1,d5
		dbf	d0,loc_17314
		bra.s	loc_172E0
; ===========================================================================

loc_17328:
		move.w	d5,(v_perfect_rings_left).w
		move.w	#0,(f_ss_perfect).w
		moveq	#-1,d0
		move.l	d0,(a2)+
		lea	($FFFFE802).w,a1
		move.w	#$FE,d3

loc_1733E:
		move.w	d3,d4
		lea	6(a1),a2
		move.w	(a1),d0

loc_17346:
		tst.w	(a2)
		beq.s	loc_17358
		cmp.w	(a2),d0
		bls.s	loc_17358
		move.l	(a1),d1
		move.l	(a2),d0
		move.l	d0,(a1)
		move.l	d1,(a2)
		swap	d0

loc_17358:
		lea	6(a2),a2
		dbf	d4,loc_17346
		lea	6(a1),a1
		dbf	d3,loc_1733E
		rts
; ===========================================================================

		include	"mappings/sprite/Rings.asm"

; ===========================================================================

	if RemoveJmpTos=0
		align 4
	endc


; ---------------------------------------------------------------------------
; Psuedoobject that initialize, runs, and handles collision with the special
; bumpers in Casino Night Zone. These are the bumpers whose graphics are part
; of the level art (that is, everything other than the round and hexagonal
; ones).
; ---------------------------------------------------------------------------

SpecialCNZBumpers:
		moveq	#0,d0
		move.b	(v_cnz_bumper_routine).w,d0
		move.w	SpecBump_Index(pc,d0.w),d0
		jmp	SpecBump_Index(pc,d0.w)
; ===========================================================================
SpecBump_Index:	index offset(*),,2
		ptr SpecBump_Init				; 0
		ptr SpecBump_Main				; 2
; ===========================================================================

SpecBump_Init:
		addq.b	#2,(v_cnz_bumper_routine).w		; go to SpecBump_Main next
		lea	(SpecBumps_CNZ1).l,a1			; special bumper layout for act 1
		tst.b	(v_act).w
		beq.s	.is_act1				; branch if it is act 1
		lea	(SpecBumps_CNZ2).l,a1			; special bumper layout for act 2

	.is_act1:
		move.w	(v_camera_x_pos).w,d4			; get camera x pos
		subq.w	#8,d4					; subtract 8
		bhi.s	.find_left_init				; branch if result is less than 8 (we're starting in the middle of a level)
		moveq	#1,d4					; otherwise, start from left boundary of level
		bra.s	.find_left_init
; ===========================================================================

.loop_find_left_init:
		lea	sizeof_specbump(a1),a1			; go to next bumper in list

.find_left_init:
		cmp.w	specbump_xpos(a1),d4			; d4 = left limit of visible bumpers
		bhi.s	.loop_find_left_init			; branch if bumper is offscreen

	;found_left:
		move.l	a1,(v_cnz_visible_bumpers_start).w	; set pointer to first visible bumper
		move.l	a1,(v_cnz_visible_bumpers_start_p2).w
		addi.w	#$150,d4				; jump ahead 336 pixels
		bra.s	.find_right_init
; ===========================================================================

.loop_find_right_init:
		lea	sizeof_specbump(a1),a1			; go to next bumper in list

	.find_right_init:
		cmp.w	specbump_xpos(a1),d4			; d4 = left limit of visible bumpers
		bhi.s	.loop_find_right_init			; branch if bumper is onscreen
		move.l	a1,(v_cnz_visible_bumpers_end).w	; set pointer to last visible bumper
		move.l	a1,(v_cnz_visible_bumpers_end_p2).w
		move.b	#1,(f_unused_cnz_bumper).w		; set unused flag
		rts
; ===========================================================================

SpecBump_Main:
		movea.l	(v_cnz_visible_bumpers_start).w,a1	; a1 = pointer to first visible bumper in layout list
		move.w	(v_camera_x_pos).w,d4			; get camera x pos
		subq.w	#8,d4					; subtract 8
		bhi.s	.find_left1				; branch if result is less than 8 (we're in the middle of a level)
		moveq	#1,d4					; otherwise, start from left boundary of level
		bra.s	.find_left1
; ===========================================================================

.loop_find_left1:
		lea	sizeof_specbump(a1),a1			; go to next bumper in list

	.find_left1:
		cmp.w	specbump_xpos(a1),d4			; d4 = left limit of visible bumpers
		bhi.s	.loop_find_left1			; branch if bumper is offscreen
		bra.s	.find_left2
; ===========================================================================

.loop_find_left2:
		subq.w	#sizeof_specbump,a1

.find_left2:
		cmp.w	-sizeof_specbump+specbump_xpos(a1),d4
		bls.s	.loop_find_left2
		move.l	a1,(v_cnz_visible_bumpers_start).w
		movea.l	(v_cnz_visible_bumpers_end).w,a2
		addi.w	#$150,d4
		bra.s	loc_17458
; ===========================================================================

loc_17454:
		lea	6(a2),a2

loc_17458:
		cmp.w	2(a2),d4
		bhi.s	loc_17454
		bra.s	loc_17462
; ===========================================================================

loc_17460:
		subq.w	#6,a2

loc_17462:
		cmp.w	-4(a2),d4
		bls.s	loc_17460
		move.l	a2,(v_cnz_visible_bumpers_end).w
		tst.w	(f_two_player).w
		bne.s	loc_1747C
		move.l	a1,(v_cnz_visible_bumpers_start_p2).w
		move.l	a2,(v_cnz_visible_bumpers_end_p2).w
		rts
; ===========================================================================

loc_1747C:
		movea.l	(v_cnz_visible_bumpers_start_p2).w,a1
		move.w	(v_camera_x_pos_p2).w,d4
		subq.w	#8,d4
		bhi.s	loc_17490
		moveq	#1,d4
		bra.s	loc_17490
; ===========================================================================

loc_1748C:
		lea	6(a1),a1

loc_17490:
		cmp.w	2(a1),d4
		bhi.s	loc_1748C
		bra.s	loc_1749A
; ===========================================================================

loc_17498:
		subq.w	#6,a1

loc_1749A:
		cmp.w	-4(a1),d4
		bls.s	loc_17498
		move.l	a1,(v_cnz_visible_bumpers_start_p2).w
		movea.l	(v_cnz_visible_bumpers_end_p2).w,a2
		addi.w	#$150,d4
		bra.s	loc_174B2
; ===========================================================================

loc_174AE:
		lea	6(a2),a2

loc_174B2:
		cmp.w	2(a2),d4
		bhi.s	loc_174AE
		bra.s	loc_174BC
; ===========================================================================

loc_174BA:
		subq.w	#6,a2

loc_174BC:
		cmp.w	-4(a2),d4
		bls.s	loc_174BA
		move.l	a2,(v_cnz_visible_bumpers_end_p2).w
		rts
; ===========================================================================

React_CNZBumpers:
		movea.l	(v_cnz_visible_bumpers_start).w,a1
		movea.l	(v_cnz_visible_bumpers_end).w,a2
		cmpa.w	#-$5000,a0
		beq.s	loc_174DE
		movea.l	(v_cnz_visible_bumpers_start_p2).w,a1
		movea.l	(v_cnz_visible_bumpers_end_p2).w,a2

loc_174DE:
		cmpa.l	a1,a2
		beq.w	locret_17578
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		subi.w	#9,d2
		moveq	#0,d5
		move.b	ost_height(a0),d5
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$4D,ost_frame(a0)
		bne.s	loc_17508
		addi.w	#$C,d3
		moveq	#$A,d5

loc_17508:
		move.w	#$12,d4
		add.w	d5,d5

loc_1750E:
		move.w	(a1),d0
		andi.w	#$E,d0
		lea	byte_17558(pc,d0.w),a3
		moveq	#0,d1
		move.b	(a3)+,d1
		move.w	2(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_17530
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_17536
		bra.w	loc_1756E
; ===========================================================================

loc_17530:
		cmp.w	d4,d0
		bhi.w	loc_1756E

loc_17536:
		moveq	#0,d1
		move.b	(a3)+,d1
		move.w	4(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_17550
		add.w	d1,d1
		add.w	d1,d0
		bcs.w	loc_17564
		bra.w	loc_1756E
; ===========================================================================

loc_17550:
		cmp.w	d5,d0
		bhi.w	loc_1756E
		bra.s	loc_17564
; ===========================================================================
byte_17558:
		dc.b $20					; 0
		dc.b $20					; 1
		dc.b $20					; 2
		dc.b $20					; 3
		dc.b $40					; 4
		dc.b   8					; 5
		dc.b $40					; 6
		dc.b   8					; 7
		dc.b   8					; 8
		dc.b $40					; 9
		dc.b   8					; 10
		dc.b $40					; 11
; ===========================================================================

loc_17564:
		move.w	(a1),d0
		move.w	off_1757A(pc,d0.w),d0
		jmp	off_1757A(pc,d0.w)
; ===========================================================================

loc_1756E:
		lea	6(a1),a1
		cmpa.l	a1,a2
		bne.w	loc_1750E

locret_17578:
		rts
; ===========================================================================
off_1757A:	index offset(*),,2
		ptr loc_17586					; 0
		ptr loc_17638					; 2
		ptr loc_1769E					; 4
		ptr loc_176F6					; 6
		ptr loc_1774C					; 8
		ptr loc_177A4					; $A
; ===========================================================================

loc_17586:
		move.w	4(a1),d0
		sub.w	ost_y_pos(a0),d0
		neg.w	d0
		cmpi.w	#$20,d0
		blt.s	loc_175A0
		move.w	#$A00,ost_y_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_175A0:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		neg.w	d0
		cmpi.w	#$20,d0
		blt.s	loc_175BA
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_175BA:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmpi.w	#$20,d0
		blt.s	loc_175CC
		move.w	#$20,d0

loc_175CC:
		add.w	4(a1),d0
		subq.w	#8,d0
		move.w	ost_y_pos(a0),d1
		addi.w	#$E,d1
		sub.w	d1,d0
		bcc.s	locret_175E8
		move.w	#$20,d3
		bsr.s	loc_175EA
		bra.w	loc_177FA
; ===========================================================================

locret_175E8:
		rts
; ===========================================================================

loc_175EA:
		move.w	ost_x_vel(a0),d1
		move.w	ost_y_vel(a0),d2
		jsr	(CalcAngle).l
		move.b	d0,(v_cnz_bumper_debug1).w
		sub.w	d3,d0
		move.w	d0,d1
		bpl.s	loc_17604
		neg.w	d1

loc_17604:
		neg.w	d0
		add.w	d3,d0
		move.b	d0,(v_cnz_bumper_debug2).w
		move.b	d1,(v_cnz_bumper_debug4).w
		cmpi.b	#$38,d1
		bcs.s	loc_17618
		move.w	d3,d0

loc_17618:
		move.b	d0,(v_cnz_bumper_debug3).w
		jsr	(CalcSine).l
		muls.w	#-$A00,d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a0)
		muls.w	#-$A00,d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a0)
		rts
; ===========================================================================

loc_17638:
		move.w	4(a1),d0
		sub.w	ost_y_pos(a0),d0
		neg.w	d0
		cmpi.w	#$20,d0
		blt.s	loc_17652
		move.w	#$A00,ost_y_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_17652:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmpi.w	#$20,d0
		blt.s	loc_1766A
		move.w	#-$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_1766A:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		neg.w	d0
		cmpi.w	#$20,d0
		blt.s	loc_1767E
		move.w	#$20,d0

loc_1767E:
		add.w	4(a1),d0
		subq.w	#8,d0
		move.w	ost_y_pos(a0),d1
		addi.w	#$E,d1
		sub.w	d1,d0
		bcc.s	locret_1769C
		move.w	#$60,d3
		bsr.w	loc_175EA
		bra.w	loc_177FA
; ===========================================================================

locret_1769C:
		rts
; ===========================================================================

loc_1769E:
		move.w	4(a1),d0
		sub.w	ost_y_pos(a0),d0
		neg.w	d0
		cmpi.w	#8,d0
		blt.s	loc_176B8
		move.w	#$A00,ost_y_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_176B8:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmpi.w	#$40,d0
		blt.s	loc_176D0
		move.w	#-$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_176D0:
		neg.w	d0
		cmpi.w	#$40,d0
		blt.s	loc_176E2
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_176E2:
		move.w	#$38,d3
		tst.w	d0
		bmi.s	loc_176EE
		move.w	#$48,d3

loc_176EE:
		bsr.w	loc_175EA
		bra.w	loc_177FA
; ===========================================================================

loc_176F6:
		move.w	4(a1),d0
		sub.w	ost_y_pos(a0),d0
		cmpi.w	#8,d0
		blt.s	loc_1770E
		move.w	#-$A00,ost_y_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_1770E:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmpi.w	#$40,d0
		blt.s	loc_17726
		move.w	#-$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_17726:
		neg.w	d0
		cmpi.w	#$40,d0
		blt.s	loc_17738
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_17738:
		move.w	#$C8,d3
		tst.w	d0
		bmi.s	loc_17744
		move.w	#$B8,d3

loc_17744:
		bsr.w	loc_175EA
		bra.w	loc_177FA
; ===========================================================================

loc_1774C:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		neg.w	d0
		cmpi.w	#8,d0
		blt.s	loc_17766
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_17766:
		move.w	4(a1),d0
		sub.w	ost_y_pos(a0),d0
		cmpi.w	#$40,d0
		blt.s	loc_1777E
		move.w	#-$A00,ost_y_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_1777E:
		neg.w	d0
		cmpi.w	#$40,d0
		blt.s	loc_17790
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_17790:
		move.w	#8,d3
		tst.w	d0
		bmi.s	loc_1779C
		move.w	#$F8,d3

loc_1779C:
		bsr.w	loc_175EA
		bra.w	loc_177FA
; ===========================================================================

loc_177A4:
		move.w	2(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmpi.w	#8,d0
		blt.s	loc_177BC
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_177BC:
		move.w	4(a1),d0
		sub.w	ost_y_pos(a0),d0
		cmpi.w	#$40,d0
		blt.s	loc_177D4
		move.w	#-$A00,ost_y_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_177D4:
		neg.w	d0
		cmpi.w	#$40,d0
		blt.s	loc_177E6
		move.w	#$A00,ost_x_vel(a0)
		bra.w	loc_177FA
; ===========================================================================

loc_177E6:
		move.w	#$78,d3
		tst.w	d0
		bmi.s	loc_177F2
		move.w	#$88,d3

loc_177F2:
		bsr.w	loc_175EA
		bra.w	*+4

loc_177FA:
		bset	#1,ost_primary_status(a0)
		bclr	#4,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a0)
		clr.b	$3C(a0)
		move.w	#$D9,d0
		; This line unintentionally acts as a boundary marker for the below
		; bumper data. Changes to this instruction, or the location of
		; `PlaySound`, may cause Casino Night Zone Act 1 to crash. Fix the
		; below bug to prevent this.
		jmp	(PlaySound).l
; ===========================================================================

SpecBumps_CNZ1:
    if FixBugs
		; Sonic Team forgot to start this file with a boundary marker,
		; meaning the game could potentially read past the start of the file
		; and load random bumpers.
		dc.w	$0000, $0000, $0000
   	endc
		incbin	"level/objects/CNZ 1 Bumpers.bin"

SpecBumps_CNZ2:
		incbin	"level/objects/CNZ 2 Bumpers.bin"
; ===========================================================================

	if Revision<2
		nop
	endc


; ---------------------------------------------------------------------------
; Subroutine to	load a level's objects

;	uses d0.l, d1.w, d2.l, d6.l, a0, a1, a2
; ---------------------------------------------------------------------------

; loc_17AA4: ObjectsManager:
ObjPosLoad:
		moveq	#0,d0
		move.b	(v_opl_routine).w,d0
		move.w	OPL_Index(pc,d0.w),d0
		jmp	OPL_Index(pc,d0.w)
; ===========================================================================
; ObjectsManager_States:
OPL_Index:	index offset(*),,2
		ptr OPL_Init					; 0
		ptr OPL_Main					; 2
		ptr OPL_2P_Main					; 4
; ===========================================================================
; loc_17AB8: ObjectsManager_Init:
OPL_Init:
		addq.b	#2,(v_opl_routine).w			; go to OPL_Main next
		move.w	(v_zone).w,d0				; get zone/act numbers
		ror.b	#1,d0
		lsr.w	#6,d0					; combine zone/act into single number
		lea	(ObjPos_Index).l,a0
		movea.l	a0,a1					; copy index pointer to a1
		adda.w	(a0,d0.w),a0				; jump to objpos list for specified zone/act
		tst.w	(f_two_player).w
		beq.s	.not2P					; branch if not 2p mode
		cmpi.b	#id_CNZ,(v_zone).w
		bne.s	.not2P					; branch if not CNZ
		lea	(ObjPos_CNZ_1_2P).l,a0			; modified layout for CNZ 1 in 2P mode
		tst.b	(v_act).w
		beq.s	.not2P					; branch if act 2
		lea	(ObjPos_CNZ_2_2P).l,a0			; modified layout for CNZ 2 in 2P mode

.not2P:
		move.l	a0,(v_opl_ptr_right).w			; copy objpos list address
		move.l	a0,(v_opl_ptr_left).w
		move.l	a0,(v_opl_ptr_right_p2).w
		move.l	a0,(v_opl_ptr_left_p2).w
		lea	(v_respawn_list).w,a2
		move.w	#$101,(a2)+				; start respawn counters at 1

	if FixBugs
		move.w	#(sizeof_v_respawn_data/4)-1,d0
	else
		; The loop counter mistakenly uses the number of loops to clear the data using
		; words, not longwords! This causes it to clear $17C bytes rather than $BE.
		move.w	#(sizeof_v_respawn_data/2)-1,d0
	endc

	.clear_respawn_list:
		clr.l	(a2)+
		dbf	d0,.clear_respawn_list			; clear object respawn list

    if FixBugs
		; Clear the last word, since the above loop only does longwords.
    	if sizeof_v_respawn_data&2
		clr.w	(a2)+
    	endc
    endc

		lea	(v_respawn_list).w,a2
		moveq	#0,d2
		move.w	(v_camera_x_pos).w,d6
		subi.w	#128,d6					; d6 = 128px to left of screen
		bcc.s	.use_screen_x				; branch if camera is > 128px from left boundary
		moveq	#0,d6					; assume 0 if camera is close to left boundary

	.use_screen_x:
		andi.w	#-$80,d6				; round down to nearest $80
		movea.l	(v_opl_ptr_right).w,a0			; get objpos data pointer

.loop_find_right_init:
		cmp.w	objpos_x_pos(a0),d6			; (a0) = x pos of object; d6 = edge of spawn window
		bls.s	.found_right				; branch if object is right of edge (1st object outside spawn window)
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; 2(a0) = object id and remember state flag
		bpl.s	.no_respawn				; branch if no remember flag found
		move.b	respawn_count_1(a2),d2			; d2 = index to respawn table entry
		addq.b	#1,respawn_count_1(a2)			; increment first respawn index

	.no_respawn:
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		bra.s	.loop_find_right_init			; loop until object is found within window
; ===========================================================================

.found_right:
		move.l	a0,(v_opl_ptr_right).w			; save pointer for objpos, 128px left of screen
		move.l	a0,(v_opl_ptr_right_p2).w		; same for player 2
		movea.l	(v_opl_ptr_left).w,a0			; get first objpos in list again
		subi.w	#128,d6					; d6 = 256px to left of screen
		bcs.s	.found_left

.loop_find_left_init:
		cmp.w	objpos_x_pos(a0),d6			; (a0) = x pos of object; d6 = edge of spawn window
		bls.s	.found_left				; branch if object is right of edge (1st object inside spawn window)
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn2				; branch if not
		addq.b	#1,respawn_count_2(a2)			; increment second respawn index

	.no_respawn2:
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		bra.s	.loop_find_left_init			; loop until object is found within window
; ===========================================================================

.found_left:
		move.l	a0,(v_opl_ptr_left).w			; save pointer for objpos, 256px left of screen
		move.l	a0,(v_opl_ptr_left_p2).w		; same for player 2
		move.w	#-1,(v_opl_screen_x_pos).w		; start screen at -1 so OPL_Main thinks it's moving right
		move.w	#-1,(v_opl_screen_x_pos_p2).w		; same for player 2
		tst.w	(f_two_player).w
		beq.s	OPL_Main				; branch if not 2P mode
		addq.b	#2,(v_opl_routine).w			; if we're in 2P mode, go to OPL_2P_Main next
		bra.w	OPL_2P_Init				; continue to 2P mode-specific init routine
; ===========================================================================

OPL_Main:
		move.w	(v_camera_x_pos).w,d1			; get camera x pos
		subi.w	#$80,d1					; minus $80
		andi.w	#-$80,d1				; round down to nearest $80
		move.w	d1,(v_camera_x_pos_coarse).w		; used for despawn checks (this was calculated at every check in Sonic 1)

		lea	(v_respawn_list).w,a2
		moveq	#0,d2
		move.w	(v_camera_x_pos).w,d6
		andi.w	#-$80,d6				; d6 = camera x pos rounded down to nearest $80
		cmp.w	(v_opl_screen_x_pos).w,d6		; compare to previous screen position
		beq.w	OPL_NoMove				; branch if screen hasn't moved
		bge.s	OPL_MovedRight				; branch if screen is right of previous position (or if level just started)

;OPL_MovedLeft:
		move.w	d6,(v_opl_screen_x_pos).w		; update screen position
		movea.l	(v_opl_ptr_left).w,a0			; jump to objpos on left side of window
		subi.w	#$80,d6					; d6 = 128px to left of screen
		bcs.s	.found_left				; branch if camera is close to left boundary

.loop_find_left:
		cmp.w	-sizeof_objpos+objpos_x_pos(a0),d6	; read objpos backwards
		bge.s	.found_left				; branch if object is outside spawn window
		subq.w	#sizeof_objpos,a0			; update pointer
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn				; branch if not
		subq.b	#1,respawn_count_2(a2)			; decrement second respawn index
		move.b	respawn_count_2(a2),d2			; d2 = index to respawn table entry

	.no_respawn:
		bsr.w	OPL_SpawnObj				; check respawn flag and spawn object
		bne.s	.fail					; branch if spawn failed (no free OST slots left)
		subq.w	#sizeof_objpos,a0			; go to previous object in objpos list
		bra.s	.loop_find_left				; loop until object is found outside window
; ===========================================================================

.fail:
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn2				; branch if not
		addq.b	#1,respawn_count_2(a2)			; undo the decrement of the respawn counter

	.no_respawn2:
		addq.w	#sizeof_objpos,a0

.found_left:
		move.l	a0,(v_opl_ptr_left).w			; save pointer for objpos
		movea.l	(v_opl_ptr_right).w,a0			; jump to previous objpos on right side of window
		addi.w	#128+screen_width+320,d6		; d6 = 320px to right of screen

.loop_find_right:
		cmp.w	-sizeof_objpos+objpos_x_pos(a0),d6	; read objpos backwards
		bgt.s	.found_right				; branch if object is within spawn window
		tst.b	-sizeof_objpos+objpos_respawn_flip_y_pos_hi(a0) ; is remember flag set?
		bpl.s	.no_respawn3				; branch if not
		subq.b	#1,respawn_count_1(a2)			; decrement first respawn index

.no_respawn3:
		subq.w	#sizeof_objpos,a0			; go to previous object in objpos list
		bra.s	.loop_find_right			; loop until object is found within window
; ===========================================================================

.found_right:
		move.l	a0,(v_opl_ptr_right).w			; save pointer for objpos
		rts
; ===========================================================================

OPL_MovedRight:
		move.w	d6,(v_opl_screen_x_pos).w		; update screen position
		movea.l	(v_opl_ptr_right).w,a0			; jump to objpos on right side of window
		addi.w	#screen_width+320,d6			; d6 = 320px to right of screen

.loop_find_right:
		cmp.w	objpos_x_pos(a0),d6			; (a0) = x pos of object; d6 = right edge of spawn window
		bls.s	.found_right				; branch if object is outside spawn window
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn				; branch if not
		move.b	respawn_count_1(a2),d2			; d2 = index to respawn table entry
		addq.b	#1,respawn_count_1(a2)			; increment respawn list index

	.no_respawn:
		bsr.w	OPL_SpawnObj				; check respawn flag and spawn object
		beq.s	.loop_find_right			; branch if it spawned successfully or was skipped because it was broken (looping until object is found outside window)

	if FixBugs
		; The game forgets to do this if the right edge is "found" as of result of running
		; out of OST slots. This can lead to destroyed objects reappearing and vice versa
		; due to the respawn indices desyncing.
	;.fail:
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.found_right				; if not, branch
		subq.b	#1,respawn_count_1(a2)			; undo increment of respawn index
	endc

	.found_right:
		move.l	a0,(v_opl_ptr_right).w			; save pointer for objpos
		movea.l	(v_opl_ptr_left).w,a0			; jump to objpos on left side of window
		subi.w	#128+screen_width+320,d6
		bcs.s	.found_left				; branch if camera is close to left boundary

.loop_find_left:
		cmp.w	objpos_x_pos(a0),d6			; (a0) = x pos of object; d6 = left edge of spawn window
		bls.s	.found_left				; branch if object is within spawn window
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn2				; branch if not
		addq.b	#1,respawn_count_2(a2)			; increment first respawn index

.no_respawn2:
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		bra.s	.loop_find_left				; loop until object is found within window
; ===========================================================================

.found_left:
		move.l	a0,(v_opl_ptr_left).w			; save pointer for objpos

OPL_NoMove:
		rts

; ---------------------------------------------------------------------------
; In two player mode, objects are managed by grouping them into blocks that
; represent 256 pixel wide vertical strips (that is, two level chunks), three
; blocks per player (the one the player is in, one ahead, and one behind),
; for a total of 6 blocks, with up to 12 objects per block. The x pos checks
; for spawning objects are rounded to multiples of 256, with objects being
; spawned and deleted en mass when a new block is loaded or unloaded.

; Note that this only applies to objects within the object layouts; objects
; loaded by other objects, e.g., projectiles, will still use ordinary
; dynamic OST slots. Additionally, objects can exempt themselves from this
; system by having bit 4 of the render flags/respawn flag/y pos high byte
; of their objpos entry set, in which case they will be loaded in a dynamic
; OST slot instead. The only objects that do this are the Buzzer and Flasher
; badniks, presumably because they can potentially wander beyond the block
; boundaries.

; (Thank you to MoDule for the excellent explanation.)
; ---------------------------------------------------------------------------

OPL_2P_Init:
		moveq	#-1,d0					; fill all of the 2P object manager variables with 1s

		; Generate an unrolled loop of instructions which fill
		; the 2P object manager variables with 1s.
		c: = 0
  		rept sizeof_object_manager_2p/4
		move.l	d0,(v_opl_block_indices+c).w
		c: = c+4
		endr

		if (sizeof_object_manager_2p)&2
		move.w	d0,(v_opl_block_indices+c).w
		c: = c+2
    	endc

		if (sizeof_object_manager_2p)&1
		move.b	d0,(v_opl_block_indices+c).w
   		endc

		move.w	#0,(v_opl_screen_x_pos).w
		move.w	#0,(v_opl_screen_x_pos_p2).w
		lea	(v_respawn_list).w,a2
		move.w	(a2),(v_respawn_list_p2).w		; start respawn counters at 1
		moveq	#0,d2

		; Initialize Player 1's blocks.
		lea	(v_respawn_list).w,a5			; load player 1's data
		lea	(v_opl_ptr_right).w,a4
		lea	(v_opl_loaded_blocks_p1).w,a1
		lea	(v_opl_loaded_blocks_p2).w,a6
		moveq	#-2,d6					; do block 0
		bsr.w	OPL_2P_MovedRight
		lea	(v_opl_loaded_blocks_p1).w,a1
		moveq	#-1,d6					; do block 1
		bsr.w	OPL_2P_MovedRight
		lea	(v_opl_loaded_blocks_p1).w,a1
		moveq	#0,d6					; do block 2
		bsr.w	OPL_2P_MovedRight

		; Initialize Player 2's blocks.
		lea	(v_respawn_list_p2).w,a5		; load player 2's data
		lea	(v_opl_ptr_right_p2).w,a4
		lea	(v_opl_loaded_blocks_p2).w,a1
		lea	(v_opl_loaded_blocks_p1).w,a6
		moveq	#-2,d6					; do block 0
		bsr.w	OPL_2P_MovedRight
		lea	(v_opl_loaded_blocks_p2).w,a1
		moveq	#-1,d6					; do block 1
		bsr.w	OPL_2P_MovedRight
		lea	(v_opl_loaded_blocks_p2).w,a1
		moveq	#0,d6					; do block 2
		bsr.w	OPL_2P_MovedRight

OPL_2P_Main:
		move.w	(v_camera_x_pos).w,d1			; get player 1's camera x pos
		andi.w	#-$100,d1				; round down to nearest $100
		move.w	d1,(v_camera_x_pos_coarse).w		; used for player 1's despawn checks
		move.w	(v_camera_x_pos_p2).w,d1		; get player 1's camera x pos
		andi.w	#-$100,d1				; round down to nearest $100
		move.w	d1,(v_camera_x_pos_coarse_p2).w		; used for player 2's despawn checks

	;.doplayer1:
		move.b	(v_camera_x_pos).w,d6			; get high byte of player 1's camera x pos
		andi.w	#$FF,d6					; d6 = block id and x range
		move.w	(v_opl_screen_x_pos).w,d0		; back up current x range (used for checking left or right later)
		cmp.w	(v_opl_screen_x_pos).w,d6		; compare to previous x range
		beq.s	.doplayer2				; branch if x range hasn't changed
		move.w	d6,(v_opl_screen_x_pos).w		; save new x range
		lea	(v_respawn_list).w,a5			; load player 1's data
		lea	(v_opl_ptr_right).w,a4
		lea	(v_opl_loaded_blocks_p1).w,a1
		lea	(v_opl_loaded_blocks_p2).w,a6
		bsr.s	OPL_2P_Run				; run OPL for player 1

	.doplayer2:
		move.b	(v_camera_x_pos_p2).w,d6		; get high byte of player 1's camera x pos
		andi.w	#$FF,d6					; d6 = block id and x range
		move.w	(v_opl_screen_x_pos_p2).w,d0		; back up current x range (used for checking left or right later)
		cmp.w	(v_opl_screen_x_pos_p2).w,d6		; compare to previous x range
		beq.s	.done					; branch if x range hasn't changed
		move.w	d6,(v_opl_screen_x_pos_p2).w		; save new x range
		lea	(v_respawn_list_p2).w,a5
		lea	(v_opl_ptr_right_p2).w,a4
		lea	(v_opl_loaded_blocks_p2).w,a1
		lea	(v_opl_loaded_blocks_p1).w,a6
		bsr.s	OPL_2P_Run				; run OPL for player 2

	.done:
		rts
; ===========================================================================

OPL_2P_Run:
		lea	(v_respawn_list).w,a2
		moveq	#0,d2
		cmp.w	d0,d6
		beq.w	OPL_NoMove				; branch if screen hasn't moved (will never be taken as this was already checked for)
		bge.w	OPL_2P_MovedRight			; branch if screen is right of previous position

;OPL_2P_MovedLeft:
		; Shift the object block indices to the right, loading the new one at the left,
		; and unloading the rightmost one if it's not in use.
		move.b	opl_2p_block3(a1),d2			; d2 = object block to be unloaded
		move.b	opl_2p_block2(a1),opl_2p_block3(a1)	; shift blocks to the right
		move.b	opl_2p_block1(a1),opl_2p_block2(a1)
		move.b	d6,(a1)					; load new block at the left

		c: = opl_2p_block1
		rept countof_ost_2p_blocks/2			; check all three blocks assigned to other player
		cmp.b	c(a6),d2				; does other player have the to-be-unloaded block loaded?
		beq.s	.skip_unload				; branch if so (we can't unload it)
		c: = c+1					; check next block
		endr

		bsr.w	OPL_2P_UnloadBlock			; unload block if it's not in use by other player
		bra.s	.got_free_block
; ===========================================================================

.skip_unload:
		bsr.w	OPL_2P_FindFreeBlock			; find free OST block

.got_free_block:
		bsr.w	OPL_2P_CheckBlockLoad			; check if the new block is already loaded
		bne.s	.loadblock				; branch if it's not

;.already_loaded:
		movea.l	v_opl_ptr_left-v_opl_ptr_right(a4),a0	; jump to objpos on left side of window

.loop_find_left:
		cmp.b	-sizeof_objpos+objpos_x_pos(a0),d6	; read objpos backward; doing this as a byte operation effectively rounds the x pos to next lowest 256
		bne.s	.found_left				; branch if object is outside current x range
		tst.b	-sizeof_objpos+objpos_respawn_flip_y_pos_hi(a0) ; is remember flag set?
		bpl.s	.no_respawn				; branch if not
		subq.b	#1,respawn_count_2(a5)			; decrement second respawn index

.no_respawn:
		subq.w	#sizeof_objpos,a0			; go to previous object in objpos list
		bra.s	.loop_find_left				; loop until object is found outside window
; ===========================================================================

.found_left:
		move.l	a0,v_opl_ptr_left-v_opl_ptr_right(a4)	; save pointer for objpos
		bra.s	.unload_right
; ===========================================================================

.loadblock:
		movea.l	v_opl_ptr_left-v_opl_ptr_right(a4),a0	; jump to objpos on left side of window
		move.b	d6,(a1)					; mark this block as loaded

.loop_find_left2:
		cmp.b	-sizeof_objpos+objpos_x_pos(a0),d6	; read objpos backwards; doing this as a byte operation effectively rounds the x pos to next lowest 256
		bne.s	.found_left2				; branch if object is outside current x range
		subq.w	#sizeof_objpos,a0			; previous object in objpos list
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn2				; branch if not
		subq.b	#1,respawn_count_2(a5)			; decrement respawn index
		move.b	respawn_count_2(a5),d2			; d2 = respawn state

.no_respawn2:
		bsr.w	OPL_2P_SpawnObj				; check respawn flag and spawn object
		bne.s	.fail					; branch if spawn failed (no free OST slots left)
		subq.w	#sizeof_objpos,a0			; go to previous object in objpos list
		bra.s	.loop_find_left2			; loop until object is found outside x range
; ===========================================================================

.fail:
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn3				; branch if not
		addq.b	#1,respawn_count_2(a5)			; undo last decrement of respawn index

	.no_respawn3:
		addq.w	#sizeof_objpos,a0			; undo last decrement of objpos pointer

	.found_left2:
		move.l	a0,v_opl_ptr_left-v_opl_ptr_right(a4)	; save new left pointer

.unload_right:
		movea.l	(a4),a0					; get previous right pointer
		addq.w	#3,d6					; forward to the block that was just unloaded

	.loop_unload_right:
		cmp.b	-sizeof_objpos+objpos_x_pos(a0),d6	; read objpos backwards; doing this as a byte operation effectively rounds the x pos to next lowest 256
		bne.s	.found_right				; branch if object is outside current x range (and within current spawn window)
		tst.b	-sizeof_objpos+objpos_respawn_flip_y_pos_hi(a0) ; is remember flag set?
		bpl.s	.no_respawn4				; branch if not
		subq.b	#1,respawn_count_1(a5)			; decrement respawn index

	.no_respawn4:
		subq.w	#sizeof_objpos,a0			; go to previous object in objpos list
		bra.s	.loop_unload_right			; loop until object is found outside x range (and within current spawn window)
; ===========================================================================

.found_right:
		move.l	a0,(a4)					; save new right pointer
		rts
; ===========================================================================

OPL_2P_MovedRight:
		addq.w	#2,d6					; d6 = new block to load

		; Shift the object block indices to the left, loading the new one at the right,
		; and unloading the leftmost one if it's not in use.
		move.b	opl_2p_block1(a1),d2			; d2 = object block to be unloaded
		move.b	opl_2p_block2(a1),opl_2p_block1(a1)	; shift blocks to the left
		move.b	opl_2p_block3(a1),opl_2p_block2(a1)
		move.b	d6,opl_2p_block3(a1)			; load new block at right

		cmp.b	opl_2p_block1(a6),d2			; does other player have the to-be-unloaded block loaded?
		beq.s	.skip_unload				; branch if so (we can't unload it)
		cmp.b	opl_2p_block2(a6),d2			; (check all three of their blocks)
		beq.s	.skip_unload
		cmp.b	opl_2p_block3(a6),d2
		beq.s	.skip_unload

		bsr.w	OPL_2P_UnloadBlock			; unload block if it's not in use by other player
		bra.s	.got_free_block
; ===========================================================================

.skip_unload:
		bsr.w	OPL_2P_FindFreeBlock			; find free OST block

.got_free_block:
		bsr.w	OPL_2P_CheckBlockLoad			; check if the new block is already loaded
		bne.s	.loadblock				; branch if it's not

;.already_loaded:
		; If already loaded, update the pointer and respawn index, but don't load anything.
		movea.l	(a4),a0					; (a0) = previous right edge of spawn window

.loop_find_right:
		cmp.b	objpos_x_pos(a0),d6			; doing this as a byte operation effectively rounds the x pos to next lowest 256
		bne.s	.found_right				; branch if object is outside current x range
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn				; branch if not
		addq.b	#1,respawn_count_1(a5)			; increment respawn index

.no_respawn:
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		bra.s	.loop_find_right			; loop until object is found outside x range
; ===========================================================================

.found_right:
		move.l	a0,(a4)					; save pointer for objpos
		bra.s	.unload_left
; ===========================================================================

.loadblock:
		movea.l	(a4),a0					; jump to objpos on right side of window
		move.b	d6,(a1)					; mark this block as loaded

.loop_find_right2:
		cmp.b	objpos_x_pos(a0),d6			; doing this as a byte operation effectively rounds the x pos to next lowest 256
		bne.s	.found_right2				; branch if object is outside spawn window
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn2				; branch if not
		move.b	(a5),d2					; d2 = respawn state
		addq.b	#1,respawn_count_1(a5)			; increment respawn index

	.no_respawn2:
		bsr.w	OPL_2P_SpawnObj				; check respawn flag and spawn object
		beq.s	.loop_find_right2			; loop until object is found outside x range

	if FixBugs
		; Same bug as in OPL_MovedRight.no_respawn, but for 2P mode.
	;.fail:
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.found_right				; if not, branch
		subq.b	#1,respawn_count_1(a2)			; undo increment of respawn index
	endc

	.found_right2:
		move.l	a0,(a4)					; save new right pointer

.unload_left:
		movea.l	v_opl_ptr_left-v_opl_ptr_right(a4),a0	; jump to previous objpos on left side of window
		subq.w	#3,d6					; back to the block that was just unloaded
		bcs.s	.done					; branch if beyond level's left boundary

	.loop_unload_left:
		cmp.b	objpos_x_pos(a0),d6			; doing this as a byte operation effectively rounds the x pos to next lowest 256
		bne.s	.done					; branch if object is outside x range (and within the current spawn window of three blocks)
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember flag set?
		bpl.s	.no_respawn3				; branch if not
		addq.b	#1,respawn_count_2(a5)			; increment respawn index

	.no_respawn3:
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		bra.s	.loop_unload_left			; loop until object is found outside x range (and within current spawn window)
; ===========================================================================

.done:
		move.l	a0,v_opl_ptr_left-v_opl_ptr_right(a4)	; save new left pointer
		rts

; ---------------------------------------------------------------------------
; Subroutine to	check if a 2P object block is already loaded

; input:
;	d6.w = index of block to check

; output:
;	d0.l = 1 is block is not already loaded

;	uses d0.l
; ---------------------------------------------------------------------------

OPL_2P_CheckBlockLoad:
		pushr.l	a1					; back up a1
		lea	(v_opl_block_indices).w,a1		; a1 = indices of loaded blocks

		rept countof_ost_2p_blocks			; check all six indices (three per player)
		cmp.b	(a1)+,d6				; get index
		beq.s	.already_loaded				; branch if it matches (block is already loaded)
		endr

		moveq	#1,d0

	.already_loaded:
		popr.l	a1					; restore a1
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find an empty 2P object block

; output:
;	a1 = index of empty block
;	a3 = start of empty block

;	uses a1, a3
; ---------------------------------------------------------------------------

OPL_2P_FindFreeBlock:
		lea	(v_opl_block_indices).w,a1

		c: = v_ost_2P_blocks				; address of first block
		rept countof_ost_2p_blocks			; repeat until found
		lea	(c).w,a3				; a3 = start of block
		tst.b	(a1)+					; is this block empty?
		bmi.s	.gotblock				; branch if so
		c: = c+(sizeof_ost*12)				; address of next block
		endr

		nop						; this should never be reached
		nop

	.gotblock:
		subq.w	#1,a1					; undo post-increment so a1 points to the index of empty block
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find the block matching an index and unload it (set respawn
; entries and delete all objects in the block)

; This replaces the functionality of DespawnObject in 2P mode.

; input:
;	d2 = index of block to unload
;	a2 = v_respawn_list

;	uses d0.l, d1.l, d2.l, a1, a3
; ---------------------------------------------------------------------------

OPL_2P_UnloadBlock:
		lea	(v_opl_block_indices).w,a1

		c: = v_ost_2P_blocks				; address of first block
		rept countof_ost_2p_blocks			; repeat until found
		lea	(c).w,a3				; load block
		cmp.b	(a1)+,d2				; is this the block to unload?
		beq.s	.gotblock				; branch if so
		c: = c+(sizeof_ost*12)				; address of next block
		endr

		nop						; this should not be reached
		nop

	.gotblock:
		move.b	#-1,-(a1)				; mark block as empty
		pushr.l	a1/a3					; back up a1 and a3
		moveq	#0,d1
		moveq	#countof_ost_per_2pblock-1,d2

.despawn_loop:
		tst.b	(a3)
		beq.s	.skip					; branch if this slot is empty
		movea.l	a3,a1					; a1 = object

		moveq	#0,d0
		move.b	ost_respawn(a1),d0			; get respawn id
		beq.s	.delete					; branch if not set
		bclr	#respawn_bit,v_respawn_data-v_respawn_list(a2,d0.w) ; clear high bit of respawn entry (i.e. object was despawned not broken)

	.delete:
		; Essentially an inlined call to DeleteChild.
		moveq	#(sizeof_ost/4)-1,d0

	.clearloop:
		move.l	d1,(a1)+				; clear	the object RAM
		dbf	d0,.clearloop				; repeat for length of object RAM

	.skip:
		lea	sizeof_ost(a3),a3			; next OST slot
		dbf	d2,.despawn_loop			; repeat for all objects in block

		moveq	#0,d2					; clear block index
		popr.l	a1/a3					; restore a1 and a3
		rts

; ---------------------------------------------------------------------------
; Subroutine to	load an object

; input:
;	d2.w = position in respawn list
;	a0 = pointer to specific object in objpos list
;	a2 = v_respawn_list

; output:
;	d0.l = 0 if object is spawned (or skipped because it was broken)
;	a1 = address of OST of spawned object

;	uses d1.w, a0
; ---------------------------------------------------------------------------

OPL_SpawnObj:
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember respawn flag set?
		bpl.s	OPL_MakeItem				; if not, branch
	if FixBugs
		; Part of the bugfix in OPL_MovedRight.no_respawn.
		btst	#respawn_bit,v_respawn_data-v_respawn_list(a2,d2.w) ; check respawn flag
	else
		; This should not be set here; it will not be undone if the spawn fails due to
		; running out of OST slots.
		bset	#respawn_bit,v_respawn_data-v_respawn_list(a2,d2.w) ; set flag so it isn't loaded more than once
	endc
		beq.s	OPL_MakeItem				; branch if object hasn't already been destroyed
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		moveq	#0,d0					; mark operation as successful
		rts
; ===========================================================================

OPL_MakeItem:
		bsr.w	FindFreeObj				; find free OST slot
		bne.s	.fail					; branch if not found
		move.w	(a0)+,ost_x_pos(a1)			; set x pos
		move.w	(a0)+,d0				; get respawn flag, x/y flip flags, and y pos
		bpl.s	.no_respawn_bit				; branch if remember respawn bit is not set
	if FixBugs
		; The respawn flag should only be set if the object is successfully spawned.
		bset	#respawn_bit,v_respawn_data-v_respawn_list(a2,d2.w) ; set flag so it isn't loaded more than once
	endc
		move.b	d2,ost_respawn(a1)			; give object its place in the respawn table

	.no_respawn_bit:
		move.w	d0,d1					; copy for setting x/y flip flags later
		andi.w	#$FFF,d0				; lower three nybbles are y pos
		move.w	d0,ost_y_pos(a1)			; set y pos
		rol.w	#3,d1					; adjust x/y flip bits to correct position
		andi.b	#render_xflip+render_yflip,d1
		move.b	d1,ost_render(a1)			; apply x/y flip
		move.b	d1,ost_primary_status(a1)
		_move.b	(a0)+,ost_id(a1)			; load object
		move.b	(a0)+,ost_subtype(a1)			; set subtype
		moveq	#0,d0					; mark operation as successful

	.fail:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	load an object in 2P mode

; input:
;	d2.w = position in respawn list
;	a0 = pointer to specific object in objpos list
;	a2 = v_respawn_list

; output:
;	d0.l = 0 if object is spawned (or skipped because it was broken)
;	a1 = address of OST of spawned object

;	uses d1.w, a0
; ---------------------------------------------------------------------------

OPL_2P_SpawnObj:
		tst.b	objpos_respawn_flip_y_pos_hi(a0)	; is remember respawn flag set?
		bpl.s	OPL_2P_MakeItem				; if not, branch

	if FixBugs
		; Same fix as in OPL_SpawnObj.
		btst	#respawn_bit,v_respawn_data-v_respawn_list(a2,d2.w) ; check respawn flag
	else
		bset	#respawn_bit,v_respawn_data-v_respawn_list(a2,d2.w) ; set flag so it isn't loaded more than once
	endc

		beq.s	OPL_2P_MakeItem				; branch if object hasn't already been destroyed
		addq.w	#sizeof_objpos,a0			; go to next object in objpos list
		moveq	#0,d0					; mark operation as successful
		rts
; ===========================================================================

OPL_2P_MakeItem:
		btst	#load_dyn_bit,objpos_respawn_flip_y_pos_hi(a0) ; is this object to be loaded in a normal OST slot rather than the special blocks? (EHZ Buzzer and MCZ Flasher are the only ones)
		beq.s	.load_in_block				; branch if not
		bsr.w	FindFreeObj				; find free OST slot (within the dynamic OST)
		bne.s	.fail					; branch if not found
		bra.s	.load_objdata
; ===========================================================================

.load_in_block:
		bsr.w	FindFreeObjInBlock			; find free OST slot within the current block
		bne.s	.fail					; branch if not found

.load_objdata:
		move.w	(a0)+,ost_x_pos(a1)			; set x pos
		move.w	(a0)+,d0				; get respawn flag, x/y flip flags, and y pos
		bpl.s	.no_respawn_bit				; branch if remember respawn bit is not set
	if FixBugs
		; Same fix as in OPL_MakeItem.
		bset	#respawn_bit,v_respawn_data-v_respawn_list(a2,d2.w) ; set flag so it isn't loaded more than once
	endc
		move.b	d2,ost_respawn(a1)			; give object its place in the respawn table

	.no_respawn_bit:
		move.w	d0,d1					; copy for setting x/y flip flags later
		andi.w	#$FFF,d0				; lower three nybbles are y pos
		move.w	d0,ost_y_pos(a1)			; set y pos
		rol.w	#3,d1					; adjust x/y flip bits to correct position
		andi.b	#render_xflip+render_yflip,d1
		move.b	d1,ost_render(a1)			; apply x/y flip
		move.b	d1,ost_primary_status(a1)
		_move.b	(a0)+,ost_id(a1)			; load object
		move.b	(a0)+,ost_subtype(a1)			; set subtype
		moveq	#0,d0					; mark operation as successful

	.fail:
		rts

; ---------------------------------------------------------------------------
; Subroutine to find a free OST

; output:
;	a1 = address of free OST slot

;	uses d0.w

; usage:
;		bsr.w	FindFreeObj
;		bne.s	.fail					; branch if empty slot isn't found
;		move.b	#id_Buzzer,ost_id(a1)			; load Buzzer object
; ---------------------------------------------------------------------------
; loc_17FDA: ; allocObject:
FindFreeObj:
		lea	(v_ost_dynamic).w,a1			; a1=object
		move.w	#countof_ost_dynamic-1,d0		; search to end of table
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.s	.loop					; if not, branch
		move.w	#countof_ost_dynamic_2P-1,d0		; only search to $BE00

	.loop:
		tst.b	ost_id(a1)				; is OST slot slot empty?
		beq.s	.found					; if yes, branch
		lea	sizeof_ost(a1),a1			; go to next OST
		dbf	d0,.loop				; repeat until end

	.found:
		rts

; ---------------------------------------------------------------------------
; Subroutine to find a free OST AFTER the current one

; input:
;	a0 = address of current OST slot

; output:
;	a1 = address of next free OST slot

;	uses d0.w

; usage:
;		bsr.w	FindNextFreeObj
;		bne.s	.fail					; branch if empty slot isn't found
;		move.b	#id_Bomb,ost_id(a1)			; load Bomb object
; ---------------------------------------------------------------------------
; loc_17FFA: ; allocObjectAfterCurrent:
FindNextFreeObj:
		movea.l	a0,a1					; address of OST of current object
		move.w	#v_ost_dynamic_end,d0			; end of OSTs
		sub.w	a0,d0					; d0 = space between current OST and end
		lsr.w	#6,d0					; divide by $40
		subq.w	#1,d0
		bcs.s	.use_current				; branch if current OST is final

	.loop:
		tst.b	ost_id(a1)				; is OST slot empty?
		beq.s	.found					; if yes, branch
		lea	sizeof_ost(a1),a1			; go to next OST
		dbf	d0,.loop				; repeat until end

	.use_current:
	.found:
		rts

; ---------------------------------------------------------------------------
; Subroutine to find a free OST within the current 2P mode OST block

; input:
;	a3 = current 2P OST block

; output:
;	a1 = address of next free OST slot

;	uses d0.w
; ---------------------------------------------------------------------------
; loc_18016:
FindFreeObjInBlock:
		movea.l	a3,a1					; a1 = current OST block
		move.w	#countof_ost_per_2pblock-1,d0		; 12 slots per block

	.loop:
		tst.b	ost_id(a1)				; is OST slot empty?
		beq.s	.found					; if yes, branch
		lea	sizeof_ost(a1),a1			; go to next OST
		dbf	d0,.loop				; repeat until end

	.found:
		rts

; ===========================================================================

    if FixBugs
	; Sonic Team forgot to put a boundary marker here, meaning the game
	; could potentially read past the start of the file and load random
	; objects.
		endobj
    endc

	if Revision=0
		include	"level/objects/CNZ_1_2P_(REV00).asm"
	else
		; a Crawl badnik was moved slightly further away from a ledge
		; 2 flippers were moved closer to a wall
		include	"level/objects/CNZ_1_2P.asm"
	endc

	if Revision=0
		include	"level/objects/CNZ_2_2P_(REV00).asm"
	else
		; 4 Crawl badniks were slightly moved, placing them closer/farther away from ledges
		; 2 flippers were moved away from a wall to keep players from getting stuck behind them
		include	"level/objects/CNZ_2_2P.asm"
	endc

; ----------------------------------------------------------------------------
; Object 41 - Spring
; ----------------------------------------------------------------------------

Springs:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Spring_Index(pc,d0.w),d1
		jsr	Spring_Index(pc,d1.w)
		jmp	(DespawnObject).l
; ===========================================================================
Spring_Index:	index offset(*),,2
		ptr Spring_Main					; 0
		ptr Spring_Up					; 2
		ptr Spring_LR					; 4
		ptr Spring_Dwn					; 6
		ptr Spring_DiagUp				; 8
		ptr Spring_DiagDwn				; $A
; ===========================================================================

Spring_Main:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_RedSpring,ost_mappings(a0)
		move.w	#tile_Nem_VrtclSprng,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		move.w	Spring_Init_Subtype(pc,d0.w),d0
		jmp	Spring_Init_Subtype(pc,d0.w)
; ===========================================================================
Spring_Init_Subtype:	index offset(*),,2
		ptr .init_up					; 0
		ptr .init_horiz					; 2
		ptr .init_down					; 4
		ptr .init_diag_up				; 6
		ptr .init_diag_dwn				; 8
; ===========================================================================

.init_horiz:
		move.b	#id_Spring_LR,ost_primary_routine(a0)
		move.b	#2,ost_anim(a0)
		move.b	#3,ost_frame(a0)
		move.w	#tile_Nem_HrzntlSprng,ost_tile(a0)
		move.b	#8,ost_displaywidth(a0)
		bra.s	.init_common
; ===========================================================================

.init_down:
		move.b	#id_Spring_Dwn,ost_primary_routine(a0)
		move.b	#6,ost_frame(a0)
		bset	#1,ost_primary_status(a0)
		bra.s	.init_common
; ===========================================================================

.init_diag_up:
		move.b	#id_Spring_DiagUp,ost_primary_routine(a0)
		move.b	#4,ost_anim(a0)
		move.b	#7,ost_frame(a0)
		move.w	#tile_Nem_DignlSprng,ost_tile(a0)
		bra.s	.init_common
;		bra.s	.init_diag_common
; ===========================================================================

.init_diag_dwn:
		move.b	#id_Spring_DiagDwn,ost_primary_routine(a0)
		move.b	#4,ost_anim(a0)
		move.b	#$A,ost_frame(a0)
		move.w	#tile_Nem_DignlSprng,ost_tile(a0)	; could be moved below for common diag init
		bset	#1,ost_primary_status(a0)

;.init_diag_common:
;		move.w	#tile_Nem_DignlSprng,ost_tile(a0)

.init_common:
.init_up:
		move.b	ost_subtype(a0),d0
		andi.w	#2,d0
		move.w	Spring_Powers(pc,d0.w),$30(a0)
		btst	#1,d0					; is spring subtype $x2 (yellow)?
		beq.s	.red					; if not, branch
		bset	#tile_pal12_bit,ost_tile(a0)
		move.l	#Map_YellowSpring,ost_mappings(a0)

	.red:
		bsr.w	AdjustVRAM2P				; could be bra.w
		rts
; ===========================================================================
Spring_Powers:
		dc.w -spring_power_red
		dc.w -spring_power_yellow
; ===========================================================================

Spring_Up:
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	ost_x_pos(a0),d4
		lea	(v_ost_player1).w,a1
		moveq	#3,d6
		pushr.l	d1-d4
		bsr.w	SolidObject_NoRenderChk_SingleCharacter
		btst	#3,ost_primary_status(a0)
		beq.s	loc_189A8
		bsr.s	loc_189CA

loc_189A8:
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#4,d6
		bsr.w	SolidObject_NoRenderChk_SingleCharacter
		btst	#4,ost_primary_status(a0)
		beq.s	loc_189C0
		bsr.s	loc_189CA

loc_189C0:
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

loc_189CA:
		move.w	#$100,ost_anim(a0)
		addq.w	#8,ost_y_pos(a1)
		move.w	$30(a0),ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#$10,ost_anim(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_189FE
		move.w	#0,ost_x_vel(a1)

loc_189FE:
		btst	#0,d0
		beq.s	loc_18A3E
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#0,$2C(a1)
		move.b	#4,$2D(a1)
		btst	#1,d0
		bne.s	loc_18A2E
		move.b	#1,$2C(a1)

loc_18A2E:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_18A3E
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_18A3E:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_18A54
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_18A54:
		cmpi.b	#8,d0
		bne.s	loc_18A66
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_18A66:
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================

Spring_LR:
		move.w	#$13,d1
		move.w	#$E,d2
		move.w	#$F,d3
		move.w	ost_x_pos(a0),d4
		lea	(v_ost_player1).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SolidObject_NoRenderChk_SingleCharacter
		btst	#5,ost_primary_status(a0)
		beq.s	loc_18AB0
		move.b	ost_primary_status(a0),d1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcs.s	loc_18AA8
		eori.b	#1,d1

loc_18AA8:
		andi.b	#1,d1
		bne.s	loc_18AB0
		bsr.s	loc_18AEE

loc_18AB0:
		movem.l	(sp)+,d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#4,d6
		bsr.w	SolidObject_NoRenderChk_SingleCharacter
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_18AE0
		move.b	ost_primary_status(a0),d1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcs.s	loc_18AD8
		eori.b	#1,d1

loc_18AD8:
		andi.b	#1,d1
		bne.s	loc_18AE0
		bsr.s	loc_18AEE

loc_18AE0:
		bsr.w	loc_18BC6
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

loc_18AEE:
		move.w	#$300,ost_anim(a0)
		move.w	$30(a0),ost_x_vel(a1)
		addq.w	#8,ost_x_pos(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_18B1C
		bclr	#status_xflip_bit,ost_primary_status(a1)
		subi.w	#$10,ost_x_pos(a1)
		neg.w	ost_x_vel(a1)

loc_18B1C:
		move.w	#$F,$2E(a1)
		move.w	ost_x_vel(a1),ost_inertia(a1)
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_18B36
		move.b	#0,ost_anim(a1)

loc_18B36:
		move.b	ost_subtype(a0),d0
		bpl.s	loc_18B42
		move.w	#0,ost_y_vel(a1)

loc_18B42:
		btst	#0,d0
		beq.s	loc_18B82
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#1,$2C(a1)
		move.b	#8,$2D(a1)
		btst	#1,d0
		bne.s	loc_18B72
		move.b	#3,$2C(a1)

loc_18B72:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_18B82
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_18B82:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_18B98
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_18B98:
		cmpi.b	#8,d0
		bne.s	loc_18BAA
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_18BAA:
		bclr	#5,ost_primary_status(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_18BC6:
		cmpi.b	#3,ost_anim(a0)
		beq.w	locret_18C7E
		move.w	ost_x_pos(a0),d0
		move.w	d0,d1
		addi.w	#$28,d1
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_18BE8
		move.w	d0,d1
		subi.w	#$28,d0

loc_18BE8:
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		subi.w	#$18,d2
		addi.w	#$18,d3
		lea	($FFFFB000).w,a1
		btst	#1,ost_primary_status(a1)
		bne.s	loc_18C3C
		move.w	ost_inertia(a1),d4
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_18C10
		neg.w	d4

loc_18C10:
		tst.w	d4
		bmi.s	loc_18C3C
		move.w	ost_x_pos(a1),d4
		cmp.w	d0,d4
		bcs.w	loc_18C3C
		cmp.w	d1,d4
		bcc.w	loc_18C3C
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.w	loc_18C3C
		cmp.w	d3,d4
		bcc.w	loc_18C3C
		move.w	d0,-(sp)
		bsr.w	loc_18AEE
		move.w	(sp)+,d0

loc_18C3C:
		lea	($FFFFB040).w,a1
		btst	#1,ost_primary_status(a1)
		bne.s	locret_18C7E
		move.w	ost_inertia(a1),d4
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_18C56
		neg.w	d4

loc_18C56:
		tst.w	d4
		bmi.s	locret_18C7E
		move.w	ost_x_pos(a1),d4
		cmp.w	d0,d4
		bcs.w	locret_18C7E
		cmp.w	d1,d4
		bcc.w	locret_18C7E
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.w	locret_18C7E
		cmp.w	d3,d4
		bcc.w	locret_18C7E
		bsr.w	loc_18AEE

locret_18C7E:
		rts
; ===========================================================================

Spring_Dwn:
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	ost_x_pos(a0),d4
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SolidObject_NoRenderChk_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	loc_18CA6
		bsr.s	loc_18CC6

loc_18CA6:
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		moveq	#4,d6
		bsr.w	SolidObject_NoRenderChk_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	loc_18CBC
		bsr.s	loc_18CC6

loc_18CBC:
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

loc_18CC6:
		move.w	#$100,ost_anim(a0)
		subq.w	#8,ost_y_pos(a1)
		move.w	$30(a0),ost_y_vel(a1)
		neg.w	ost_y_vel(a1)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_18CE6
		move.w	#0,ost_x_vel(a1)

loc_18CE6:
		btst	#0,d0
		beq.s	loc_18D26
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#0,$2C(a1)
		move.b	#4,$2D(a1)
		btst	#1,d0
		bne.s	loc_18D16
		move.b	#1,$2C(a1)

loc_18D16:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_18D26
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_18D26:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_18D3C
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_18D3C:
		cmpi.b	#8,d0
		bne.s	loc_18D4E
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_18D4E:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================

Spring_DiagUp:
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	ost_x_pos(a0),d4
		lea	byte_18FAA(pc),a2
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SolidObject_Heightmap_SingleCharacter
		btst	#3,ost_primary_status(a0)
		beq.s	loc_18D92
		bsr.s	loc_18DB4

loc_18D92:
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		moveq	#4,d6
		bsr.w	SolidObject_Heightmap_SingleCharacter
		btst	#4,ost_primary_status(a0)
		beq.s	loc_18DAA
		bsr.s	loc_18DB4

loc_18DAA:
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================

loc_18DB4:
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_18DCA
		move.w	ost_x_pos(a0),d0
		subq.w	#4,d0
		cmp.w	ost_x_pos(a1),d0
		bcs.s	loc_18DD8
		rts
; ===========================================================================

loc_18DCA:
		move.w	ost_x_pos(a0),d0
		addq.w	#4,d0
		cmp.w	ost_x_pos(a1),d0
		bcc.s	loc_18DD8
		rts
; ===========================================================================

loc_18DD8:
		move.w	#$500,ost_anim(a0)
		move.w	$30(a0),ost_y_vel(a1)
		move.w	$30(a0),ost_x_vel(a1)
		addq.w	#6,ost_y_pos(a1)
		addq.w	#6,ost_x_pos(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_18E10
		bclr	#status_xflip_bit,ost_primary_status(a1)
		subi.w	#$C,ost_x_pos(a1)
		neg.w	ost_x_vel(a1)

loc_18E10:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#$10,ost_anim(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	ost_subtype(a0),d0
		btst	#0,d0
		beq.s	loc_18E6C
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#1,$2C(a1)
		move.b	#8,$2D(a1)
		btst	#1,d0
		bne.s	loc_18E5C
		move.b	#3,$2C(a1)

loc_18E5C:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_18E6C
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_18E6C:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_18E82
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_18E82:
		cmpi.b	#8,d0
		bne.s	loc_18E94
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_18E94:
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================

Spring_DiagDwn:
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	ost_x_pos(a0),d4
		lea	byte_18FC6(pc),a2
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.w	SolidObject_Heightmap_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	loc_18EC4
		bsr.s	loc_18EE6

loc_18EC4:
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		moveq	#4,d6
		bsr.w	SolidObject_Heightmap_SingleCharacter
		cmpi.w	#-2,d4
		bne.s	loc_18EDA
		bsr.s	loc_18EE6

loc_18EDA:
		lea	(off_18FE2).l,a1
		bra.w	AnimateSprite
; ===========================================================================
		rts
; ===========================================================================

loc_18EE6:
		move.w	#$500,ost_anim(a0)
		move.w	$30(a0),ost_y_vel(a1)
		neg.w	ost_y_vel(a1)
		move.w	$30(a0),ost_x_vel(a1)
		subq.w	#6,ost_y_pos(a1)
		addq.w	#6,ost_x_pos(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_18F22
		bclr	#status_xflip_bit,ost_primary_status(a1)
		subi.w	#$C,ost_x_pos(a1)
		neg.w	ost_x_vel(a1)

loc_18F22:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	ost_subtype(a0),d0
		btst	#0,d0
		beq.s	loc_18F78
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#1,$2C(a1)
		move.b	#8,$2D(a1)
		btst	#1,d0
		bne.s	loc_18F68
		move.b	#3,$2C(a1)

loc_18F68:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_18F78
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_18F78:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_18F8E
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_18F8E:
		cmpi.b	#8,d0
		bne.s	loc_18FA0
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_18FA0:
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================
byte_18FAA:
		dc.b $10,$10,$10,$10,$10,$10,$10,$10,$10,$10,$10,$10, $E, $C, $A,  8 ; 0
		dc.b   6,  4,  2,  0,$FE,$FC,$FC,$FC,$FC,$FC,$FC,$FC ; 16

byte_18FC6:
		dc.b $F4,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F2,$F4,$F6,$F8 ; 0
		dc.b $FA,$FC,$FE,  0,  2,  4,  4,  4,  4,  4,  4,  4 ; 16

off_18FE2:	index offset(*)
		ptr byte_18FEE					; 0
		ptr byte_18FF1					; 1
		ptr byte_18FFD					; 2
		ptr byte_19000					; 3
		ptr byte_1900C					; 4
		ptr byte_1900F					; 5
byte_18FEE:	dc.b  $F					; 0
		dc.b   0					; 1
		dc.b $FF					; 2
byte_18FF1:	dc.b   0					; 0
		dc.b   1					; 1
		dc.b   0					; 2
		dc.b   0					; 3
		dc.b   2					; 4
		dc.b   2					; 5
		dc.b   2					; 6
		dc.b   2					; 7
		dc.b   2					; 8
		dc.b   2					; 9
		dc.b $FD					; 10
		dc.b   0					; 11
byte_18FFD:	dc.b  $F					; 0
		dc.b   3					; 1
		dc.b $FF					; 2
byte_19000:	dc.b   0					; 0
		dc.b   4					; 1
		dc.b   3					; 2
		dc.b   3					; 3
		dc.b   5					; 4
		dc.b   5					; 5
		dc.b   5					; 6
		dc.b   5					; 7
		dc.b   5					; 8
		dc.b   5					; 9
		dc.b $FD					; 10
		dc.b   2					; 11
byte_1900C:	dc.b  $F					; 0
		dc.b   7					; 1
		dc.b $FF					; 2
byte_1900F:	dc.b   0					; 0
		dc.b   8					; 1
		dc.b   7					; 2
		dc.b   7					; 3
		dc.b   9					; 4
		dc.b   9					; 5
		dc.b   9					; 6
		dc.b   9					; 7
		dc.b   9					; 8
		dc.b   9					; 9
		dc.b $FD					; 10
		dc.b   4					; 11
		dc.b   0					; 12

; ===========================================================================

		include "mappings/sprite/Springs.asm"

; ===========================================================================

    if Revision<2
		nop
    endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0D - End of level sign post
; ----------------------------------------------------------------------------

Signpost:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Sign_Index(pc,d0.w),d1
		jsr	Sign_Index(pc,d1.w)
		lea	(Ani_Sign).l,a1
		bsr.w	AnimateSprite
		bsr.w	loc_19534
		bra.w	DespawnObject
; ===========================================================================
Sign_Index:	index offset(*),,2
		ptr loc_191DC					; 0
		ptr loc_1924C					; 2
; ===========================================================================

loc_191DC:
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	loc_19208				; if not, branch
		move.l	#Map_Sign_2P,ost_mappings(a0)		; use 2P mode mappings...
		move.w	#(vram_2P_Signpost/sizeof_cell),ost_tile(a0) ; ...and tiles
		move.b	#-1,(v_signpost_prev_frame).w
		moveq	#0,d1
		move.w	#$1020,d1
		move.w	#-$80,d4
		moveq	#0,d5
		bsr.w	loc_19564
		bra.s	loc_1922C
; ===========================================================================

loc_19208:
		cmpi.w	#id_MTZ_act2,(v_zone).w			; is it MTZ Act 2?
		beq.s	loc_1921E				; if so, branch
		tst.b	(v_act).w				; is it Act 1 of any other level?
		beq.s	loc_1921E				; if it is, branch
		move.w	#0,ost_x_pos(a0)
		rts
; ===========================================================================

loc_1921E:
		move.l	#Map_Sign,ost_mappings(a0)
		move.w	#tile_Nem_Signpost,ost_tile(a0)

loc_1922C:
		addq.b	#2,ost_primary_routine(a0)
		bsr.w	AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	#(60<<8)|countof_ntsc_fps,(v_loser_time_left).w ; 60 seconds, 60 frames per second

loc_1924C:
		tst.b	(f_hud_time_update).w
		beq.w	loc_192D6
		lea	(v_ost_player1).w,a1
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		bcs.s	loc_192D6
		cmpi.w	#$20,d0
		bcc.s	loc_192D6
		move.w	#$CF,d0
		jsr	(PlayMusic).l
		clr.b	(f_hud_time_update).w
		move.w	#1,ost_anim(a0)
		move.w	#0,$30(a0)
		move.w	(v_boundary_right).w,(v_boundary_left).w
		move.b	#2,ost_secondary_routine(a0)
		cmpi.b	#time_warning_2P,(v_loser_time_left).w
		bhi.s	loc_192A0

loc_19296:
		move.w	(v_level_music).w,d0
		jsr	(PlayMusic).l

loc_192A0:
		tst.b	$36(a0)
		bne.w	loc_19350
		move.b	#3,$36(a0)
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_192BC
		move.b	#4,$36(a0)

loc_192BC:
		tst.w	(f_two_player).w
		beq.w	loc_19350
		move.w	#(60<<8)|countof_ntsc_fps,(v_loser_time_left).w ; 60 seconds, 60 frames per second
		move.w	#$D3,d0
		jsr	(PlaySound).l
		bra.s	loc_19350
; ===========================================================================

loc_192D6:
		tst.w	(f_two_player).w
		beq.s	loc_19350
		tst.b	(f_hud_time_update_p2).w
		beq.s	loc_19350
		lea	($FFFFB040).w,a1
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		bcs.s	loc_19350
		cmpi.w	#$20,d0
		bcc.s	loc_19350
		move.w	#$CF,d0
		jsr	(PlayMusic).l
		clr.b	(f_hud_time_update_p2).w
		move.w	#1,ost_anim(a0)
		move.w	#0,$30(a0)
		move.w	(v_boundary_right_p2).w,(v_boundary_left_p2).w
		move.b	#2,ost_secondary_routine(a0)
		cmpi.b	#time_warning_2P,(v_loser_time_left).w
		bhi.s	loc_1932E
		move.w	(v_level_music).w,d0
		jsr	(PlayMusic).l

loc_1932E:
		tst.b	$36(a0)
		bne.s	loc_19350
		move.b	#4,$36(a0)
		tst.w	(f_two_player).w
		beq.s	loc_19350
		move.w	#(60<<8)|countof_ntsc_fps,(v_loser_time_left).w ; 60 seconds, 60 frames per second
		move.w	#$D3,d0
		jsr	(PlaySound).l

loc_19350:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_1935E(pc,d0.w),d1
		jmp	off_1935E(pc,d1.w)
; ===========================================================================
off_1935E:	index offset(*),,2
		ptr locret_19366				; 0
		ptr loc_19368					; 2
		ptr loc_19418					; 4
		ptr loc_194FC					; 6
; ===========================================================================

locret_19366:
		rts
; ===========================================================================

loc_19368:
		subq.w	#1,$30(a0)
		bpl.s	loc_19398
		move.w	#$3C,$30(a0)
		addq.b	#1,ost_anim(a0)
		cmpi.b	#3,ost_anim(a0)
		bne.s	loc_19398
		move.b	#4,ost_secondary_routine(a0)
		move.b	$36(a0),ost_anim(a0)
		tst.w	(f_two_player).w
		beq.s	loc_19398
		move.b	#6,ost_secondary_routine(a0)

loc_19398:
		subq.w	#1,$32(a0)
		bpl.s	locret_19406
		move.w	#$B,$32(a0)
		moveq	#0,d0
		move.b	$34(a0),d0
		addq.b	#2,$34(a0)
		andi.b	#$E,$34(a0)
		lea	byte_19408(pc,d0.w),a2
		bsr.w	FindFreeObj
		bne.s	locret_19406
		_move.b	#id_Ring,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	ost_x_pos(a0),d0
		move.w	d0,ost_x_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	ost_y_pos(a0),d0
		move.w	d0,ost_y_pos(a1)
		move.l	#Map_Ring,ost_mappings(a1)
		move.w	#tile_Nem_Ring+tile_pal2,ost_tile(a1)
		bsr.w	AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#2,ost_priority(a1)
		move.b	#8,ost_displaywidth(a1)

locret_19406:
		rts
; ===========================================================================
byte_19408:
		dc.b $E8					; 0
		dc.b $F0					; 1
		dc.b   8					; 2
		dc.b   8					; 3
		dc.b $F0					; 4
		dc.b   0					; 5
		dc.b $18					; 6
		dc.b $F8					; 7
		dc.b   0					; 8
		dc.b $F8					; 9
		dc.b $10					; 10
		dc.b   0					; 11
		dc.b $E8					; 12
		dc.b   8					; 13
		dc.b $18					; 14
		dc.b $10					; 15
; ===========================================================================

loc_19418:
		tst.w	(v_debug_active).w
		bne.w	locret_194D0
		btst	#1,($FFFFB022).w
		bne.s	loc_19434
		move.b	#1,(f_lock_controls).w
		move.w	#$800,(v_joypad_hold).w

loc_19434:
		tst.b	($FFFFB000).w
		beq.s	loc_1944C
		move.w	($FFFFB008).w,d0
		move.w	(v_boundary_right).w,d1
		addi.w	#$128,d1
		cmp.w	d1,d0
		bcs.w	locret_194D0

loc_1944C:
		move.b	#0,ost_secondary_routine(a0)

loc_19452:
		lea	(v_ost_player1).w,a1
		clr.b	$2B(a1)
		clr.b	(f_hud_time_update).w
		bsr.w	FindFreeObj
		bne.s	loc_19468
		move.b	#id_GotThroughCard,ost_id(a1)

loc_19468:
		moveq	#$26,d0
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_19474
		moveq	#$42,d0

loc_19474:
		jsr	(NewPLC).l
		move.b	#1,(f_pass_bonus_update).w
		moveq	#0,d0
		move.b	(v_time_min).w,d0
		mulu.w	#$3C,d0
		moveq	#0,d1
		move.b	(v_time_sec).w,d1
		add.w	d1,d0
		divu.w	#$F,d0
		moveq	#$14,d1
		cmp.w	d1,d0
		bcs.s	loc_1949E
		move.w	d1,d0

loc_1949E:
		add.w	d0,d0
		move.w	word_194D2(pc,d0.w),(v_bonus_count_1).w
		move.w	(v_rings).w,d0
		mulu.w	#$A,d0
		move.w	d0,(v_bonus_count_2).w
		clr.w	(v_total_bonus_countdown).w
		clr.w	(v_bonus_count_3).w
		tst.w	(v_perfect_rings_left).w
		bne.s	loc_194C6
		move.w	#$1388,(v_bonus_count_3).w

loc_194C6:
		move.w	#$9A,d0
		jsr	(PlayMusic).l

locret_194D0:
		rts
; ===========================================================================
word_194D2:
		dc.w $1388					; 0
		dc.w $1388					; 1
		dc.w  $3E8					; 2
		dc.w  $1F4					; 3
		dc.w  $190					; 4
		dc.w  $190					; 5
		dc.w  $12C					; 6
		dc.w  $12C					; 7
		dc.w   $C8					; 8
		dc.w   $C8					; 9
		dc.w   $C8					; 10
		dc.w   $C8					; 11
		dc.w   $64					; 12
		dc.w   $64					; 13
		dc.w   $64					; 14
		dc.w   $64					; 15
		dc.w   $32					; 16
		dc.w   $32					; 17
		dc.w   $32					; 18
		dc.w   $32					; 19
		dc.w	 0					; 20
; ===========================================================================

loc_194FC:
		subq.w	#1,$30(a0)
		bpl.s	locret_19532
		tst.b	(f_time_over).w
		bne.s	locret_19532
		tst.b	(f_time_over_p2).w
		bne.s	locret_19532
		tst.b	(f_hud_time_update).w
		bne.s	locret_19532
		tst.b	(f_hud_time_update_p2).w
		bne.s	locret_19532
		move.b	#0,(v_last_lamppost).w
		move.b	#0,(v_last_lamppost_p2).w
		move.b	#$18,(v_gamemode).w
		move.w	#0,(v_results_screen_2p).w

locret_19532:
		rts
; ===========================================================================

loc_19534:
		tst.w	(f_two_player).w
		beq.s	locret_1958C
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		cmp.b	(v_signpost_prev_frame).w,d0
		beq.s	locret_1958C
		move.b	d0,(v_signpost_prev_frame).w
		lea	(DynPLC_Signpost).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_1958C
		move.w	#-$4300,d4

loc_19560:
		moveq	#0,d1
		move.w	(a2)+,d1

loc_19564:
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		addi.l	#Art_Signpost,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(AddDMA).l
		dbf	d5,loc_19560

locret_1958C:
		rts
; ===========================================================================
Ani_Sign:	index offset(*)
		ptr byte_19598					; 0
		ptr byte_1959B					; 1
		ptr byte_195A9					; 2
		ptr byte_195B7					; 3
		ptr byte_195BA					; 4
byte_19598:	dc.b  $F,  2,$FF				; 0
byte_1959B:	dc.b   1,  2,  3,  4,  5,  1,  3,  4,  5,  0,  3,  4,  5,$FF ; 0

byte_195A9:	dc.b   1,  2,  3,  4,  5,  1,  3,  4,  5,  0,  3,  4,  5,$FF ; 0

byte_195B7:	dc.b  $F,  0,$FF				; 0
byte_195BA:	dc.b  $F,  1,$FF,  0				; 0


		include "mappings/sprite/Signpost.asm"
		include "mappings/sprite/Signpost 2P.asm"
		include "mappings/spriteDPLC/Signpost.asm"

; ===========================================================================

    if Revision<2
		nop
    endc


; ---------------------------------------------------------------------------
; Solid object subroutines (includes spikes, blocks, rocks etc)

; input:
;	d1.w = object half width
;	d2.w = object half height (initial collision)
;	d3.w = object half height (when stood on object)
;	d4.w = object x position (when stood on object)
;	a0 = the object to check collision with
;	a1 = Sonic or Tails (set inside these subroutines)

; output (after running a single character):
;	d3.w = y distance of player from nearest top/bottom edge (-ve if on bottom)
;	d4.l = collision type: 0 = none/no change; 1 = side collision; -1 = top collision; -2 = bottom collision
;	d5.w = x distance of player from nearest left/right edge
;	d6.l = high word is bitfield indicating top/bottom/side collision (see Constants.asm)

;	uses d0.l, d1.l, d2.w, a2
; ---------------------------------------------------------------------------

SolidObject:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	.singlecharacter			; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		tst.b	ost_render(a1)				; is player 2 onscreen?
		bpl.w	.done					; if not, exit
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	.singlecharacter:
		btst	d6,ost_primary_status(a0)		; is player standing on the object?
		beq.w	Solid_ChkCollision			; if not, branch
		move.w	d1,d2
		add.w	d2,d2
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.s	.leave					; if so, branch
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.s	.leave					; if player moves off the left, branch
		cmp.w	d2,d0					; has player moved off the right?
		bcs.s	.stand					; if not, branch

	.leave:
		bclr	#status_platform_bit,ost_primary_status(a1) ; clear player's standing flag
		bset	#status_air_bit,ost_primary_status(a1)	; set their air bit
		bclr	d6,ost_primary_status(a0)		; clear object's standing flag
		moveq	#0,d4					; clear flag for no collision
		rts

	.stand:
		move.w	d4,d2
		bsr.w	MoveWithPlatform			; move player with platform
		moveq	#0,d4					; clear flag for no new collision

	.done:
		rts

; ---------------------------------------------------------------------------
; As above, but the object and player 2's on-screen statuses are not checked
; ---------------------------------------------------------------------------

SolidObject_NoRenderChk:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	SolidObject_NoRenderChk_SingleCharacter	; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	SolidObject_NoRenderChk_SingleCharacter:
		btst	d6,ost_primary_status(a0)		; is player standing on the object?
		beq.w	Solid_SkipRenderChk			; if not, branch
		move.w	d1,d2
		add.w	d2,d2
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.s	.leave					; if so, branch
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.s	.leave					; if player moves off the left, branch
		cmp.w	d2,d0					; has player moved off the right?
		bcs.s	.stand					; if not, branch

	.leave:
		bclr	#status_platform_bit,ost_primary_status(a1) ; clear player's standing flag
		bset	#status_air_bit,ost_primary_status(a1)	; set their air bit
		bclr	d6,ost_primary_status(a0)		; clear object's standing flag
		moveq	#0,d4					; clear flag for no collision
		rts

	.stand:
		move.w	d4,d2
		bsr.w	MoveWithPlatform			; move player with platform
		moveq	#0,d4					; clear flag for no new collision
		rts

; ---------------------------------------------------------------------------
; Solid	object with heightmap subroutine

; input:
;	d1.w = object half width
;	d2.w = object half height
;	d4.w - platform x pos (for passing to MoveOnSlope)
;	a2 = address of heightmap data
;
; output:
;	d3.w = y distance of player from nearest top/bottom edge (-ve if on bottom)
;	d4.l = collision type: 0 = none/no change; 1 = side collision; -1 = top collision; -2 = bottom collision
;	d5.w = x distance of player from nearest left/right edge
;	d6.l = high word is bitfield indicating top/bottom/side collision (see Constants.asm)

;	uses d0.l, d1.l, d2.w, d3.w, d6.l, a2
; ---------------------------------------------------------------------------

SolidObject_Heightmap:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	SolidObject_Heightmap_SingleCharacter	; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

SolidObject_Heightmap_SingleCharacter:
		btst	d6,ost_primary_status(a0)		; is player standing on the object?
		beq.w	SolidObject_Heightmap_ChkCollision	; if not, branch
		move.w	d1,d2
		add.w	d2,d2
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.s	.leave					; if so, branch
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.s	.leave					; if player moves off the left, branch
		cmp.w	d2,d0					; has character moved off the right?
		bcs.s	.stand					; if not, branch

	.leave:
		bclr	#status_platform_bit,ost_primary_status(a1) ; clear players's standing flag
		bset	#status_air_bit,ost_primary_status(a1)	; set their air bit
		bclr	d6,ost_primary_status(a0)		; clear object's standing flag
		moveq	#0,d4					; clear flag for no collision
		rts
; ===========================================================================

.stand:
		move.w	d4,d2
		bsr.w	MoveOnSlope				; move player on slope
		moveq	#0,d4					; clear flag for no new collision
		rts

; ---------------------------------------------------------------------------
; Unused subroutine to handle a solid object with heightmaps on both top and
; bottom
; ---------------------------------------------------------------------------

SolidObject_Heightmap_Double:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	.singlecharacter			; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	.singlecharacter:
		btst	d6,ost_primary_status(a0)		; is player standing on the object?
		beq.w	SolidObject_Heightmap_Double_cont	; if not, branch
		move.w	d1,d2
		add.w	d2,d2
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.s	.leave					; if so, branch
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.s	.leave					; if player moves off the left, branch
		cmp.w	d2,d0					; has character moved off the right?
		bcs.s	.stand					; if not, branch

	.leave:
		bclr	#status_platform_bit,ost_primary_status(a1) ; clear players's standing flag
		bset	#status_air_bit,ost_primary_status(a1)	; set their air bit
		bclr	d6,ost_primary_status(a0)		; clear object's standing flag
		moveq	#0,d4					; clear flag for no collision
		rts
; ===========================================================================

.stand:
		move.w	d4,d2
		bsr.w	MoveOnDoubleSlope			; move player with sloped platform
		moveq	#0,d4					; clear flag for no new collision
		rts

; ---------------------------------------------------------------------------
; Unused custom collision subroutine for the unused vertical subtype of Oil
; Ocean's pressure springs (Object 45)
; Almost identical to SolidObject, expect it branches to a custom
; MoveWithPlatform routine.

; input:
;	d1.w = spring half width
;	d2.w = spring half height (initial collision)
;	d3.w = distance in pixels that spring has compressed (derived by doubling sprite frame ID)
;	d4.w = spring x position (when stood on object)
; ---------------------------------------------------------------------------

SolidObject_OOZSpring:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	.singlecharacter			; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	.singlecharacter:
		btst	d6,ost_primary_status(a0)		; is player standing on the object?
		beq.w	SolidObject_OOZSpring_ChkCollision	; if not, branch
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.s	.leave					; if so, branch
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.s	.leave					; if player moves off the left, branch
		add.w	d1,d1					; d1 = full width of object
		cmp.w	d1,d0					; has character moved off the right?
		bcs.s	.stand					; if not, branch

	.leave:
		bclr	#status_platform_bit,ost_primary_status(a1) ; clear players's standing flag
		bset	#status_air_bit,ost_primary_status(a1)	; set their air bit
		bclr	d6,ost_primary_status(a0)		; clear object's standing flag
		moveq	#0,d4					; clear flag for no new collision
		rts

; ---------------------------------------------------------------------------
; Unused custom variant of MoveWithPlatform used by vertical
; OOZ pressure springs
; This routine could be condensed down to this:

;		move.w	ost_y_pos(a0),d0
;		sub.w	d2,d0
;		add.w	d3,d0
;		move.w	d4,d2
;		bsr.w	MoveWithPlatform3	; update player position
;		moveq	#0,d4				; clear flag for no new collision
;		rts
; ---------------------------------------------------------------------------

.stand:
		move.w	ost_y_pos(a0),d0
		sub.w	d2,d0
		add.w	d3,d0					; d0 = y pos of top of spring
		moveq	#0,d1
		move.b	ost_height(a1),d1
		sub.w	d1,d0					; subtract player's height
		move.w	d0,ost_y_pos(a1)			; update player's y position
		sub.w	ost_x_pos(a0),d4
		sub.w	d4,ost_x_pos(a1)			; update player's x position
		moveq	#0,d4					; clear flag for no new collision
		rts
; ===========================================================================

SolidObject_OOZSpring_ChkCollision:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on spring
		bmi.w	Solid_NoCollision			; branch if player is outside left edge

		move.w	d1,d4
		add.w	d4,d4					; d4 = full width of spring
		cmp.w	d4,d0
		bhi.w	Solid_NoCollision			; branch if player is outside right edge
		move.w	ost_y_pos(a0),d5
		add.w	d3,d5					; d5 = spring y pos + distance spring has compressed
		move.b	ost_height(a1),d3
		ext.w	d3
		add.w	d3,d2					; d2 = combined player + object half height (maximum distance for a top collision)
		move.w	ost_y_pos(a1),d3
		sub.w	d5,d3					; d3 = y pos of player on spring (0 is center)
		addq.w	#4,d3
		add.w	d2,d3					; d3 = y pos of player's feet on spring (0 is top)
		bmi.w	Solid_NoCollision			; branch if player is outside upper edge
		move.w	d2,d4
		add.w	d4,d4					; d4 = combined player + object full height
		cmp.w	d4,d3
		bcc.w	Solid_NoCollision			; branch if player is outside lower edge
		bra.w	Solid_Collision
; ===========================================================================

SolidObject_Heightmap_ChkCollision:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.w	Solid_NoCollision			; branch if player is outside left edge
		move.w	d1,d3
		add.w	d3,d3					; d3 = full width of object
		cmp.w	d3,d0
		bhi.w	Solid_NoCollision			; branch if player is outside right edge

		move.w	d0,d5
		btst	#render_xflip_bit,ost_render(a0)	; is object horizontally flipped?
		beq.s	.no_xflip				; if not, branch
		not.w	d5
		add.w	d3,d5					; d5 = x pos of player on object, xflipped if needed

	.no_xflip:
		lsr.w	#1,d5
		move.b	(a2,d5.w),d3				; get heightmap value based on player's x pos on object
		sub.b	(a2),d3					; subtract baseline
		ext.w	d3
		move.w	ost_y_pos(a0),d5
		sub.w	d3,d5					; d5 = y pos of top of object
		move.b	ost_height(a1),d3
		ext.w	d3
		add.w	d3,d2					; d2 = combined player + object half height baseline
		move.w	ost_y_pos(a1),d3
		sub.w	d5,d3					; d3 = y pos of player on object (0 is center)
		addq.w	#4,d3
		add.w	d2,d3					; d3 = y pos of player's feet on object (0 is top)
		bmi.w	Solid_NoCollision			; branch if player is outside upper edge
		move.w	d2,d4
		add.w	d4,d4					; d4 = combined player + object full height
		cmp.w	d4,d3
		bcc.w	Solid_NoCollision			; branch if player is outside lower edge
		bra.w	Solid_Collision

; ---------------------------------------------------------------------------
; Part of unused double-sloped solid collision routine
; ---------------------------------------------------------------------------

SolidObject_Heightmap_Double_cont:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.w	Solid_NoCollision			; branch if player is outside left edge
		move.w	d1,d3
		add.w	d3,d3					; d3 = full width of object
		cmp.w	d3,d0
		bhi.w	Solid_NoCollision			; branch if player is outside right edge

		move.w	d0,d5
		btst	#render_xflip_bit,ost_render(a0)	; is object horizontally flipped?
		beq.s	.no_xflip				; if not, branch
		not.w	d5
		add.w	d3,d5					; d5 = x pos of player on object, xflipped if needed

	.no_xflip:
		andi.w	#$FFFE,d5				; round to next lowest even
		move.b	(a2,d5.w),d3				; get heightmap values based on player's x pos on object
		move.b	1(a2,d5.w),d2				; d3 = top, d2 = bottom
		ext.w	d2
		ext.w	d3
		move.w	ost_y_pos(a0),d5
		sub.w	d3,d5					; d5 = y pos of top of object
		move.w	ost_y_pos(a1),d3
		sub.w	d5,d3
		move.b	ost_height(a1),d5
		ext.w	d5
		add.w	d5,d3					; d3 = y pos of player on object (0 is center)
		addq.w	#4,d3					; d3 = y pos of player's feet on object (0 is top)
		bmi.w	Solid_NoCollision			; branch if player is outside upper edge
		add.w	d5,d2
		move.w	d2,d4
		add.w	d5,d4					; d4 = combined player + object full height
		cmp.w	d4,d3
		bcc.w	Solid_NoCollision			; branch if player is outside lower edge
		bra.w	Solid_Collision
; ===========================================================================

Solid_ChkCollision:
		tst.b	ost_render(a0)				; is object onscreen?
		bpl.w	Solid_NoCollision			; if not, branch

Solid_SkipRenderChk:
		; Perform the X portion of a bounding box check. To do this, we assume a
		; coordinate system where the X origin is at the object's left edge.
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = x pos of player on object
		bmi.w	Solid_NoCollision			; branch if player is outside left edge

		; Perform the y portion of a bounding box check. To do this, we assume a
		; coordinate system where the y origin is at the highest y position relative to the object
		; at which the player would still collide with it. This point is
		; ost_y_pos(a0) - ost_width(a0)/2 - (ost_height(a1)/2) - 4,
		; where (a0) = object, (a1) = player, and ost_height(a1)/2 in d2. This way
		; of doing it causes the object's hitbox to be vertically off-center by -4 pixels.
		move.w	d1,d3
		add.w	d3,d3					; d3 = object's width
		cmp.w	d3,d0
		bhi.w	Solid_NoCollision			; branch if player is outside right edge
		move.b	ost_height(a1),d3
		ext.w	d3
		add.w	d3,d2					; d2 = combined player + object half height (maximum distance for a top collision)
		move.w	ost_y_pos(a1),d3
		sub.w	ost_y_pos(a0),d3			; d3 = y pos of player on object (0 is center)
		addq.w	#4,d3
		add.w	d2,d3					; d3 = y pos of player's feet on object (0 is top)
		bmi.w	Solid_NoCollision			; branch if player is outside upper edge
		andi.w	#$7FF,d3
		move.w	d2,d4
		add.w	d4,d4					; d4 = combined player + object full height
		cmp.w	d4,d3
		bcc.w	Solid_NoCollision			; branch if player is outside lower edge

Solid_Collision:
		tst.b	ost_obj_control(a1)			; are controls locked?
		bmi.w	Solid_NoCollision			; if so, branch
		cmpi.b	#id_Death,ost_primary_routine(a1)	; is player dying?
		bcc.w	Solid_Debug				; if so, branch
		tst.w	(v_debug_active).w			; is debug mode being used?
		bne.w	Solid_Debug				; if so, branch
		move.w	d0,d5					; d0/d5 = x pos of player on object
		cmp.w	d0,d1					; d1 = object half width
		bcc.s	.player_left				; branch if player is on left side

	;.player_right:
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5					; d5 = x dist of player from left/right edge (nearest)

	.player_left:
		move.w	d3,d1					; d1/d3 = y pos of player's feet on object
		cmp.w	d3,d2					; d2 = object half height
		bcc.s	.player_top				; branch if player is on top half

	;.player_bottom:
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1					; d1 = y dist of player from top/bottom edge (nearest)

	.player_top:
		cmp.w	d1,d5
		bhi.w	Solid_TopBottom				; branch if player is nearer top/bottom than left/right

Solid_LeftRight:
		cmpi.w	#4,d1
		bls.s	Solid_SideAir				; branch if player is nearer top/bottom than left/right
		tst.w	d0					; d0 = x dist of player from left/right edge (-ve if on right)
		beq.s	Solid_AlignToSide			; branch if on the edge
		bmi.s	Solid_OnRight				; branch if nearer right side

		tst.w	ost_x_vel(a1)
		bmi.s	Solid_AlignToSide			; branch if player is moving left
		bra.s	Solid_StopX
; ===========================================================================

Solid_OnRight:
		tst.w	ost_x_vel(a1)
		bpl.s	Solid_AlignToSide			; branch if player is moving right

Solid_StopX:
		move.w	#0,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)			; stop player moving

Solid_AlignToSide:
		sub.w	d0,ost_x_pos(a1)			; correct player's position
		btst	#status_air_bit,ost_primary_status(a1)
		bne.s	Solid_SideAir				; branch if player is in the air
		move.l	d6,d4
		addq.b	#status_p1_pushing_bit-status_p1_platform_bit,d4 ; d4 = pushing bit for current player
		bset	d4,ost_primary_status(a0)		; make object be pushed
		bset	#status_pushing_bit,ost_primary_status(a1) ; make player push object
		move.w	d6,d4
		addi.b	#($10-status_p1_platform_bit+p1_touch_side_bit),d4 ; d4 = side touch bit for current player
		bset	d4,d6					; mark player as having side collision
		moveq	#1,d4					; return side collision
		rts
; ===========================================================================

Solid_SideAir:
		bsr.s	Solid_NotPushing			; don't push if player is jumping or close to top/bottom edges
		move.w	d6,d4
		addi.b	#($10-status_p1_platform_bit+p1_touch_side_bit),d4 ; d4 = side touch bit for current player
		bset	d4,d6					; mark player as having side collision
		moveq	#1,d4					; return side collision
		rts
; ===========================================================================

Solid_NoCollision:
		move.l	d6,d4
		addq.b	#status_p1_pushing_bit-status_p1_platform_bit,d4 ; d4 = pushing bit for current player
		btst	d4,ost_primary_status(a0)		; is player pushing?
		beq.s	Solid_Debug				; branch if not
		cmpi.b	#id_Ani_Roll1,ost_anim(a1)		; is player rolling?
		beq.s	Solid_NotPushing			; branch if so
	if FixBugs
		; Prevent Sonic or Tails from entering their running animation when
		; stood next to solid objects while charging a Spin Dash, dying, or
		; drowning. One way to see this bug is by charging a Spin Dash while
		; next to one of Mystic Cave Zone's crushing pillars.
		cmpi.b	#id_Ani_Spindash,ost_anim(a1)		; branch if charging a spindash
		beq.s	Solid_NotPushing
		cmpi.b	#id_Ani_Death,ost_anim(a1)		; branch if player is dying
		beq.s	Solid_NotPushing
		cmpi.b	#id_Ani_Drown,ost_anim(a1)		; branch if player is drowning
		beq.s	Solid_NotPushing
	endc
		move.w	#(id_Ani_Walk<<8)|id_Ani_Run,ost_anim(a1) ; use running animation

Solid_NotPushing:
		move.l	d6,d4
		addq.b	#status_p1_pushing_bit-status_p1_platform_bit,d4 ; d4 = pushing bit for current player
		bclr	d4,ost_primary_status(a0)		; clear player's pushing flag
		bclr	#status_pushing_bit,ost_primary_status(a1) ; clear object's pushing flag

Solid_Debug:
		moveq	#0,d4					; return no collision
		rts
; ===========================================================================

Solid_TopBottom:
		tst.w	d3					; d3 = y dist of player from top/bottom edge (-ve if on bottom)
		bmi.s	Solid_Below				; branch if player is nearer bottom

;Solid_Above:
		cmpi.w	#$10,d3
		bcs.s	Solid_Landed				; branch if within 16px of top edge
		cmpi.b	#id_PinballLauncher,ost_id(a0)		; is calling object the pinball launcher spring?
		bne.s	Solid_NoCollision			; if so, branch
		cmpi.w	#$14,d3
		bcs.s	Solid_Landed				; branch if within 20px of top edge
		bra.s	Solid_NoCollision
; ===========================================================================

Solid_Below:
		tst.w	ost_y_vel(a1)
		beq.s	Solid_Squash				; branch if player isn't moving up/down
		bpl.s	Solid_TopBtmAir				; branch if moving downwards
		tst.w	d3
		bpl.s	Solid_TopBtmAir				; branch if nearer top (they can't be)
	if FixBugs=0
		; This is in the wrong place: the player will not be pushed out of an object
		; from above if they're not moving upwards against it!
		; This is much more noticeable when playing as Knuckles, as he'll be
		; able to phase through objects when climbing up walls.
		; 'Knuckles in Sonic 2' and 'Sonic 3 & Knuckles' tried to fix this,
		; but didn't do it very well.
		sub.w	d3,ost_y_pos(a1)			; correct player's position
	endc
		move.w	#0,ost_y_vel(a1)			; stop player moving

Solid_TopBtmAir:
	if FixBugs
		; See the bug above.
		sub.w	d3,ost_y_pos(a1)			; correct player's position
	endc
		move.w	d6,d4
		addi.b	#($10-status_p1_platform_bit+p1_touch_bottom_bit),d4 ; d4 = bottom touch bit for current player
		bset	d4,d6					; mark player as having bottom collision
		moveq	#-2,d4					; return bottom collision
		rts
; ===========================================================================

Solid_Squash:
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.s	Solid_TopBtmAir				; branch if so
		mvabs.w	d0,d4

		; Hey, look: it's the two lines of code that the Taxman/Stealth
		; remasters forgot to copy.
		; If Sonic/Tails is near the left or right edge of the object, then don't
		; kill him, instead just push him away horizontally.
		cmpi.w	#$10,d4
		bcs.w	Solid_LeftRight				; branch if player is within 16px of edge of object
		pushr.l	a0					; save address of OST of current object to stack
	if FixBugs
		; a2 needs to be set here, otherwise KillCharacter
		; will access a dangling pointer!
		movea.l	a0,a2					; set a2 to current object so KillCharacter knows what killed them
	endc
		movea.l	a1,a0					; temporarily make the player the current object
		jsr	(KillCharacter).l			; the player is crushed to death
		popr.l	a0					; restore address of OST of current object from stack
		move.w	d6,d4
		addi.b	#($10-status_p1_platform_bit+p1_touch_bottom_bit),d4 ; d4 = bottom touch bit for current player
		bset	d4,d6					; mark player as having bottom collision (even if it killed them)
		moveq	#-2,d4					; return bottom collision
		rts
; ===========================================================================

Solid_Landed:
		subq.w	#4,d3
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		move.w	d1,d2
		add.w	d2,d2					; d2 = full width of object
		add.w	ost_x_pos(a1),d1
		sub.w	ost_x_pos(a0),d1			; d1 = x pos of Sonic on object
		bmi.s	Solid_Miss				; branch if player is outside left edge
		cmp.w	d2,d1
		bcc.s	Solid_Miss				; branch if player is outside right edge
		tst.w	ost_y_vel(a1)
		bmi.s	Solid_Miss				; branch if player is moving upwards
		sub.w	d3,ost_y_pos(a1)			; correct Sonic's position
		subq.w	#1,ost_y_pos(a1)			; move player up 1px
		bsr.w	Plat_NoCheck				; make player stand on object
		move.w	d6,d4
		addi.b	#($10-status_p1_platform_bit+p1_touch_top_bit),d4 ; d4 = top touch bit for current player
		bset	d4,d6					; mark player as having top collision
		moveq	#-1,d4					; return top collision
		rts
; ===========================================================================

Solid_Miss:
		moveq	#0,d4					; return no collision
		rts

; ---------------------------------------------------------------------------
; Subroutine to	update Sonic/Tails' position when standing on a platform

; input:
;	d2.w = platform x position
;	d3.w = platform height (MoveWithPlatform only)

; output:
;	d1.l = player's height
;	a1 = address of OST of player

;	uses d0.w, d2.w

; usage (if object only moves vertically):
;		move.w	ost_x_pos(a0),d2
;		move.w	#$10,d3
;		bsr.w	MoveWithPlatform

; usage (if object moves horizontally):
;		pushr.w	ost_x_pos(a0)				; save x pos before moving
;		bsr.w	MoveObject				; move object
;		popr.w	d2					; retrieve previous x pos
;		move.w	#$10,d3
;		bsr.w	MoveWithPlatform
; ---------------------------------------------------------------------------

MoveWithPlatform:
		move.w	ost_y_pos(a0),d0
		sub.w	d3,d0					; d0 = y position of top of platform
		bra.s	.moveplayer

;MoveWithPlatform2:
		; Unused Sonic 1 leftover; use standard height (9)
		move.w	ost_y_pos(a0),d0
		subi.w	#9,d0					; d0 = y position of top of platform

	.moveplayer:
		tst.b	ost_obj_control(a1)			; is object collision disabled?
		bmi.s	.exit					; if so, exit
		cmpi.b	#id_Death,ost_primary_routine(a1)	; is player dying?
		bcc.s	.exit					; if so, exit
		tst.w	(v_debug_active).w			; is debug mode active?
		bne.s	.exit					; if so, exit

;MoveWithPlatform3:
		; Skip height and col checks; could be used with OOZ's custom solid routine
		moveq	#0,d1
		move.b	ost_height(a1),d1
		sub.w	d1,d0					; subtract player's height
		move.w	d0,ost_y_pos(a1)			; update player's y position
		sub.w	ost_x_pos(a0),d2
		sub.w	d2,ost_x_pos(a1)			; update player's x position

	.exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	update Sonic/Tails' position when standing on a sloped object

; input:
;	d2.w = platform x position

; output:
;	d1.l = player's height
;	a1 = address of OST of player

;	uses d0.w, d2.w
; ---------------------------------------------------------------------------

MoveOnSlope:
		btst	#status_platform_bit,ost_primary_status(a1) ; is player standing on the object?
		beq.s	MoveOnSlope_Done			; exit if not
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0			; object x pos is already in d2; could be sub.w d2,d0
		add.w	d1,d0					; d0 = x pos of player on object
		lsr.w	#1,d0					; divide by 2
		btst	#render_xflip_bit,ost_render(a0)	; is object horizontally flipped?
		beq.s	MoveOnSlope_Do
		not.w	d0
		add.w	d1,d0					; d5 = x pos of player on object, divided by 2 and xflipped if needed

MoveOnSlope_Do:
		move.b	(a2,d0.w),d1				; get heightmap value based on player's position on object
		ext.w	d1
		move.w	ost_y_pos(a0),d0
		sub.w	d1,d0					; subtract heightmap value from object y pos
		moveq	#0,d1
		move.b	ost_height(a1),d1
		sub.w	d1,d0					; subtract player's height
		move.w	d0,ost_y_pos(a1)			; set player's new y pos
		sub.w	ost_x_pos(a0),d2			; subtract x pos from itself?
		sub.w	d2,ost_x_pos(a1)			; subtract to set player's new x pos

	MoveOnSlope_Done:
		rts

; ---------------------------------------------------------------------------
; Unused subroutine to update Sonic/Tails' position when standing on a
; double-sloped object

; input:
;	d2.w = platform x position

;	uses d0.w, d2.w
; ---------------------------------------------------------------------------

MoveOnDoubleSlope:
		btst	#status_platform_bit,ost_primary_status(a1) ; is player standing on the object?
		beq.s	MoveOnSlope_Done			; exit if not
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0			; object x pos is already in d2; could be sub.w d2,d0
		add.w	d1,d0					; d0 = x pos of player on object
		btst	#render_xflip_bit,ost_render(a0)	; is object horizontally flipped?
		beq.s	.no_xflip
		not.w	d0
		add.w	d1,d0					; d5 = x pos of player on object, xflipped if needed

	.no_xflip:
		andi.w	#-2,d0
		bra.s	MoveOnSlope_Do

; ---------------------------------------------------------------------------
; Subroutine to detect collision with a platform, and update relevant flags

; input:
;	d1.w = platform half width
;	d3.w = platform half height
;	d4.w - platform x pos (for passing to MoveWithPlatform)

;	uses d0.l, d1.w

; usage:
;		moveq	#0,d1
;		move.b	ost_displaywidth(a0),d1
;		move.w	#2,d3
;		move.w	ost_x_pos(a0),d4
;		bsr.w	DetectPlatform
; ---------------------------------------------------------------------------

DetectPlatform:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	DetectPlatform_SingleCharacter		; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	DetectPlatform_SingleCharacter:
		btst	d6,ost_primary_status(a0)		; is player already on platform?
		beq.w	Plat_XCheck				; branch if not
		move.w	d1,d2
		add.w	d2,d2					; d2 = full width of platform
		btst	#status_air_bit,ost_primary_status(a1)
		bne.s	.exitplat				; branch if player is in the air
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = player's distance from center of platform (-ve if left of center)
		bmi.s	.exitplat				; branch if player is left of the platform
		cmp.w	d2,d0
		bcs.s	.stillonplat				; branch if player is not right of platform

	.exitplat:
		bclr	#status_platform_bit,ost_primary_status(a1)
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)		; clear object's platform flag
		moveq	#0,d4
		rts
; ===========================================================================

	.stillonplat:
		move.w	d4,d2
		bsr.w	MoveWithPlatform			; move player with platform
		moveq	#0,d4
		rts

; ---------------------------------------------------------------------------
; Subroutine to detect collision with a sloped platform, and update relevant
; flags

; input:
;	d1.w = platform half width
;	d3.w = platform half height
;	d4.w - platform x pos (for passing to MoveOnSlope)
;	a2 = address of heightmap data

;	uses d0.l, d1.w, a2

; usage:
;		move.w	#$30,d1					; width
;		move.w	#2,d3					; height
;		move.w	ost_x_pos(a0),d4		; x pos
;		lea	Ledge_SlopeData(pc),a2			; heightmap
;		bsr.w	SlopeObject
; ---------------------------------------------------------------------------

SlopeObject:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	.singlecharacter			; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	.singlecharacter:
		btst	d6,ost_primary_status(a0)		; is player already on platform?
		beq.w	SlopePlat_XCheck			; branch if not
		move.w	d1,d2
		add.w	d2,d2					; d2 = full width of platform
		btst	#status_air_bit,ost_primary_status(a1)
		bne.s	.exitplat				; branch if player is in the air
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = player's distance from center of platform (-ve if left of center)
		bmi.s	.exitplat				; branch if player is left of the platform
		cmp.w	d2,d0
		bcs.s	.stillonplat				; branch if player is not right of platfor,

	.exitplat:
		bclr	#status_platform_bit,ost_primary_status(a1)
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)		; clear object's platform flag
		moveq	#0,d4
		rts
; ===========================================================================

	.stillonplat:
		move.w	d4,d2
		bsr.w	MoveOnSlope				; move player with platform
		moveq	#0,d4
		rts

; ---------------------------------------------------------------------------
; Duplicate of DetectPlatform that uses a different X check routine. It
; behaves identically to DetectPlatform, and is present in this form as far
; back as the Nick Arcade proto, so it begs the question as to why this
; routine even exists...
; ---------------------------------------------------------------------------

DetectPlatform2:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	.singlecharacter			; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	.singlecharacter:
		btst	d6,ost_primary_status(a0)		; is player already on platform?
		beq.w	Plat2_XCheck				; branch if not
		move.w	d1,d2
		add.w	d2,d2					; d2 = full width of platform
		btst	#status_air_bit,ost_primary_status(a1)
		bne.s	.exitplat				; branch if player is in the air
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = player's distance from center of platform (-ve if left of center)
		bmi.s	.exitplat				; branch if player is left of the platform
		cmp.w	d2,d0
		bcs.s	.stillonplat				; branch if player is not right of platform

	.exitplat:
		bclr	#status_platform_bit,ost_primary_status(a1)
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)		; clear object's platform flag
		moveq	#0,d4
		rts
; ===========================================================================

	.stillonplat:
		move.w	d4,d2
		bsr.w	MoveWithPlatform			; move player with platform
		moveq	#0,d4
		rts

; ---------------------------------------------------------------------------
; Almost identical to DetectPlatform, except that this function does nothing
; if the player is already standing on a different platform. Used only by the
; CNZ elevators.
; ---------------------------------------------------------------------------

DetectPlatform3:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		bsr.s	.singlecharacter			; run for player 1
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1			; run for player 2
		addq.b	#status_p2_platform_bit-status_p1_platform_bit,d6

	.singlecharacter:
		btst	d6,ost_primary_status(a0)		; is player already on this platform?
		bne.s	.chk_on_plat				; branch if so
		btst	#status_platform_bit,ost_primary_status(a1) ; is player on a different platform?
		bne.s	.donothing				; branch if so
		bra.w	Plat_XCheck
; ===========================================================================

	.chk_on_plat:
		move.w	d1,d2
		add.w	d2,d2					; d2 = full width of platform
		btst	#status_air_bit,ost_primary_status(a1)
		bne.s	.exitplat				; branch if player is in the air
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d1,d0					; d0 = player's distance from center of platform (-ve if left of center)
		bmi.s	.exitplat				; branch if player is left of the platform
		cmp.w	d2,d0
		bcs.s	.stillonplat				; branch if player is not right of platform

	.exitplat:
		bclr	#status_platform_bit,ost_primary_status(a1)
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)		; clear object's platform flag

	.donothing:
		moveq	#0,d4
		rts
; ===========================================================================

	.stillonplat:
		move.w	d4,d2
		bsr.w	MoveWithPlatform			; move player with platform
		moveq	#0,d4
		rts

; ---------------------------------------------------------------------------
; Almost identical to Plat_XCheck, expect d2 already has the full width of
; the object. Used only by EHZ and HPZ bridges.
; ---------------------------------------------------------------------------

DetectPlatform_FullWidth:
		tst.w	ost_y_vel(a1)				; is player moving up/jumping?
		bmi.w	Plat_Exit				; branch if so

		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0			; d0 = player's distance from center of platform (-ve if left of center)
		add.w	d1,d0
		bmi.w	Plat_Exit				; branch if player is left of the platform
		cmp.w	d2,d0					; d2 = full width of platform
		bcc.w	Plat_Exit				; branch if player is left of the platform
		bra.s	Plat_NoXCheck
; ===========================================================================

Plat_XCheck:
		; perform x-axis range check
		tst.w	ost_y_vel(a1)				; is player moving up/jumping?
		bmi.w	Plat_Exit				; branch if so
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0			; d0 = player's distance from center of platform (-ve if left of center)
		add.w	d1,d0
		bmi.w	Plat_Exit				; branch if player is left of the platform
		add.w	d1,d1
		cmp.w	d1,d0					; d1 = full width of platform
		bcc.w	Plat_Exit				; branch if player is right of the platform

	Plat_NoXCheck:						; jump here to skip x position check
		move.w	ost_y_pos(a0),d0
		sub.w	d3,d0

	Plat_NoXCheck_AltY:					; jump here to skip x position check and use custom y position

		; perform y-axis range chec
		move.w	ost_y_pos(a1),d2
		move.b	ost_height(a1),d1
		ext.w	d1
		add.w	d2,d1					; d1 = y pos of player's bottom edge
		addq.w	#4,d1
		sub.w	d1,d0					; d0 = distance between top of platform and player's bottom edge (-ve if below platform)
		bhi.w	Plat_Exit				; branch if player is above platform
		cmpi.w	#-16,d0
		bcs.w	Plat_Exit				; branch if player is more than 16px below top of platform

		tst.b	ost_obj_control(a1)			; is object collision off?
		bmi.w	Plat_Exit				; if yes, branch
		cmpi.b	#id_Death,ost_primary_routine(a1)	; is Sonic dying?
		bcc.w	Plat_Exit				; if yes, branch
		add.w	d0,d2
		addq.w	#3,d2
		move.w	d2,ost_y_pos(a1)

Plat_NoCheck:
		btst	#status_platform_bit,ost_primary_status(a1) ; is player on a platform already?
		beq.s	.no
		moveq	#0,d0
		move.b	ost_interact(a1),d0			; get OST index for that platform
		lsl.w	#6,d0
		addi.l	#v_ost_all,d0				; convert index to RAM address
		movea.l	d0,a3					; point a3 to that address
		bclr	d6,ost_primary_status(a3)		; clear object's platform bit for this player

	.no:
		move.w	a0,d0
		subi.w	#v_ost_all,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,ost_interact(a1)			; convert current platform OST address to index and store it
		move.b	#0,ost_angle(a1)
		move.w	#0,ost_y_vel(a1)			; stop player moving vertically
		move.w	ost_x_vel(a1),ost_inertia(a1)
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air/jumping?
		beq.s	.notinair				; branch if not

		pushr.l	a0
		movea.l	a1,a0					; player is temporarily the current object
		move.w	a0,d1
		subi.w	#v_ost_all,d1
		bne.s	.tails					; branch if its player 2 (why not use cmpa?)
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	.tails					; branch if it's a Tails alone game
		jsr	(Sonic_ResetOnFloor_2).l		; make Sonic land
		bra.s	.restorea0
; ===========================================================================

	.tails:
		jsr	(Tails_ResetOnFloor_2).l		; make Tails land

	.restorea0:
		popr.l	a0					; restore a0

	.notinair:
		bset	#status_platform_bit,ost_primary_status(a1) ; player is on platform
		bclr	#status_air_bit,ost_primary_status(a1)
		bset	d6,ost_primary_status(a0)		; set object's platform flag

Plat_Exit:
		rts
; ===========================================================================

SlopePlat_XCheck:
		tst.w	ost_y_vel(a1)				; is player moving up/jumping?
		bmi.w	Plat_Exit				; branch if so (could be .s)
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0			; d0 = player's distance from center of platform (-ve if left of center)
		add.w	d1,d0
		bmi.s	Plat_Exit				; branch if player is left of the platform
		add.w	d1,d1
		cmp.w	d1,d0					; d1 = full width of platform
		bcc.s	Plat_Exit				; branch if player is right of the platform

		btst	#render_xflip_bit,ost_render(a0)	; is object horizontally flipped?
		beq.s	.no_xflip				; branch if not
		not.w	d0
		add.w	d1,d0

	.no_xflip:
		lsr.w	#1,d0
		move.b	(a2,d0.w),d3				; get heightmap value based on player's position on platform
		ext.w	d3
		move.w	ost_y_pos(a0),d0
		sub.w	d3,d0					; subtract heightmap value from object y pos
		bra.w	Plat_NoXCheck_AltY
; ===========================================================================

Plat2_XCheck:
		tst.w	ost_y_vel(a1)				; is player moving up/jumping?
		bmi.w	Plat_Exit				; branch if so
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0			; d0 = player's distance from center of platform (-ve if left of center)
		add.w	d1,d0
		bmi.w	Plat_Exit				; branch if player is left of the platform
		add.w	d1,d1
		cmp.w	d1,d0					; d1 = full width of platform
		bcc.w	Plat_Exit				; branch if player is left of the platform
		move.w	ost_y_pos(a0),d0
		sub.w	d3,d0					; d3 = platform height / 2
		bra.w	Plat_NoXCheck_AltY

; ---------------------------------------------------------------------------
; Subroutine to drop Sonic/Tails on the floor if an object attempts to drag
; them into it. Used only by HTZ's rising lava.

;	uses d1.w, d4.l, a1
; ---------------------------------------------------------------------------

DropOnFloor:
		lea	(v_ost_player1).w,a1
		btst	#status_p1_platform_bit,ost_primary_status(a0) ; is player 1 on object?
		beq.s	.chk_p2					; branch if not
		jsr	(FindFloorObj_ChkCol2).l		; find floor, accounting for both collision planes
		tst.w	d1
		beq.s	.drop_p1				; branch if player is on the floor
		bpl.s	.chk_p2					; branch if player is above the floor

	.drop_p1:
		lea	(v_ost_player1).w,a1			; (a1 was trashed by the call to FindFloorObj_ChkCol2)
		bclr	#status_platform_bit,ost_primary_status(a1) ; drop player 1 on floor
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	#status_p1_platform_bit,ost_primary_status(a0) ; clear object's platform flag

.chk_p2:
		lea	(v_ost_player2).w,a1
		btst	#status_p2_platform_bit,ost_primary_status(a0) ; is player 2 on object?
		beq.s	.done					; branch if not
		jsr	(FindFloorObj_ChkCol2).l		; find floor, accounting for both collision planes
		tst.w	d1
		beq.s	.drop_p2				; branch if player is on the floor
		bpl.s	.done					; branch if player is above the floor

	.drop_p2:
		lea	(v_ost_player2).w,a1			; (a1 was trashed by the call to FindFloorObj_ChkCol2)
		bclr	#status_platform_bit,ost_primary_status(a1) ; drop player 1 on floor
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	#status_p2_platform_bit,ost_primary_status(a0) ; clear object's platform flag

	.done:
		moveq	#0,d4
		rts

; ----------------------------------------------------------------------------
; Object 01 - Sonic
; ----------------------------------------------------------------------------

SonicPlayer:
		tst.w	(v_debug_active).w			; is debug mode	being used?
		beq.s	Sonic_Normal				; if not, branch
		jmp	(DebugMode).l				; run the debug mode psuedoobject
; ===========================================================================

Sonic_Normal:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Sonic_Index(pc,d0.w),d1
		jmp	Sonic_Index(pc,d1.w)
; ===========================================================================

SonicRoutines:	macro	routinename
		ptr	Sonic_\routinename
		endm

Sonic_Index:	index offset(*),,2
		CharacterRoutines	SonicRoutines		; generate pointers and IDs for Sonic's primary routines
; ===========================================================================

Sonic_Main:	; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to Sonic_Control next
		move.b	#sonic_height,ost_height(a0)
		move.b	#sonic_width,ost_width(a0)
		move.l	#Map_Sonic,ost_mappings(a0)
		move.b	#2,ost_priority(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#render_rel,ost_render(a0)

	if FixBugs
		; Speed fixes. See ApplySpeedSettings.
		lea	(v_sonic_max_speed).w,a2
		bsr.w	ApplySpeedSettings
	else
		move.w	#sonic_max_speed,(v_sonic_max_speed).w
		move.w	#sonic_acceleration,(v_sonic_acceleration).w
		move.w	#sonic_deceleration,(v_sonic_deceleration).w
	endc
		tst.b	(v_last_lamppost).w			; are we starting from a starpost?
		bne.s	.lamppost				; branch if so
		move.w	#tile_Sonic,ost_tile(a0)		; set tile
		bsr.w	AdjustVRAM2P				; adjust tile for 2P mode if necessary
		move.b	#$C,ost_top_solid_bit(a0)		; set solidity bits
		move.b	#$D,ost_lrb_solid_bit(a0)
		move.w	ost_x_pos(a0),(v_x_pos_lampcopy).w	; initialize lampcopies of position tile, and top solid variables
		move.w	ost_y_pos(a0),(v_y_pos_lampcopy).w
		move.w	ost_tile(a0),(v_ost_tile_lampcopy).w
		move.w	ost_top_solid_bit(a0),(v_ost_top_solid_bit_lampcopy).w

	.lamppost:
		move.b	#0,ost_flips_remaining(a0)
		move.b	#4,ost_flip_speed(a0)
		move.b	#0,(f_super).w
		move.b	#air_full,ost_air_left(a0)
		subi.w	#$20,ost_x_pos(a0)
		addi_.w	#4,ost_y_pos(a0)
		move.w	#0,(v_sonic_pos_tracker_num).w

		move.w	#(sizeof_v_sonic_pos_tracker/4)-1,d2

	.init_pos_tracker:
		bsr.w	Sonic_RecordPosition			; initialize one entry in Sonic's position tracker
		subq.w	#4,a1					; a1 = entry _sonic_stat_tracker
		move.l	#0,(a1)					; undo the writes that above call made to v_sonic_stat_tracker
		dbf	d2,.init_pos_tracker			; repeat for entire position tracker

		addi.w	#$20,ost_x_pos(a0)
		subi_.w	#4,ost_y_pos(a0)

Sonic_Control:	; Routine 2
		tst.w	(f_debug_enable).w			; is debug cheat enabled?
		beq.s	.no_debug				; if not, branch
		btst	#bitB,(v_joypad_press_actual).w		; is button B pressed?
		beq.s	.no_debug				; if not, branch
		move.w	#1,(v_debug_active).w			; enable debug placement mode
		clr.b	(f_lock_controls).w
		rts
; ===========================================================================

.no_debug:
		tst.b	(f_lock_controls).w			; are controls locked?
		bne.s	.lock
		move.w	(v_joypad_hold_actual).w,(v_joypad_hold).w ; enable joypad control

	.lock:
		btst	#0,ost_obj_control(a0)			; are controls and position locked?
		bne.s	.lock2					; branch if so
		moveq	#0,d0
		move.b	ost_primary_status(a0),d0
		andi.w	#status_air+status_jump,d0		; read status bits 1 and 2
		move.w	Sonic_Modes(pc,d0.w),d1
		jsr	Sonic_Modes(pc,d1.w)			; controls, physics, update position

	.lock2:
		cmpi.w	#-$100,(v_boundary_top).w		; is y-wrapping enabled?
		bne.s	.no_y_wrap				; if not, branch
		andi.w	#$7FF,ost_y_pos(a0)			; wrap Sonic's y pos

	.no_y_wrap:
		bsr.s	Sonic_Display				; display sprite, update invincibility/speed shoes
		bsr.w	Sonic_Super				; handle extra logic for Sonic's super form
		bsr.w	Sonic_RecordPosition			; save position for invincibility stars
		bsr.w	Sonic_Water				; water physics, drowning, splashes
		move.b	(v_angle_right).w,ost_angle_right(a0)
		move.b	(v_angle_left).w,ost_angle_left(a0)
		tst.b	(f_wind_tunnel_now).w			; is Sonic in a WFZ wind tunnel?
		beq.s	.no_tunnel				; if not, branch
		tst.b	ost_anim(a0)				; is Sonic using walking animation?
		bne.s	.no_tunnel				; if not, branch
		move.b	ost_anim_restart(a0),ost_anim(a0)	; update animation

	.no_tunnel:
		bsr.w	Sonic_Animate
		tst.b	ost_obj_control(a0)			; is object collision disabled?
		bmi.s	.no_collision				; branch if so
		jsr	(ReactToItem).l				; run collisions with enemies or anything that uses ost_col_type

	.no_collision:
		bra.w	Sonic_LoadGFX				; load new gfx when Sonic's frame changes
; ===========================================================================

Sonic_Modes:	index offset(*),,2
		ptr Sonic_Mode_Normal				; 0
		ptr Sonic_Mode_Air				; 2
		ptr Sonic_Mode_Roll				; 4
		ptr Sonic_Mode_Jump				; 6

; ---------------------------------------------------------------------------
; Subroutine to display Sonic and update invincibility/speed shoes
; ---------------------------------------------------------------------------

Sonic_Display:
		move.w	ost_flash_time(a0),d0			; is Sonic flashing?
		beq.s	.display				; if not, branch
		subq.w	#1,ost_flash_time(a0)			; decrement timer
		lsr.w	#3,d0					; are any of bits 0-2 set?
		bcc.s	.chkinvincible				; if not, branch (Sonic is invisible every 8th frame)

	.display:
		jsr	(DisplaySprite).l

	.chkinvincible:
		btst	#status_invincible_bit,ost_secondary_status(a0) ; does Sonic have invincibility?
		beq.s	.chkshoes				; branch if not
		tst.w	ost_invincible_time(a0)			; check invinciblity timer
		beq.s	.chkshoes				; branch if 0 (expired)
		subq.w	#1,ost_invincible_time(a0)		; decrement timer
		bne.s	.chkshoes				; branch if time remains
		tst.b	(v_current_boss).w			; are we at a boss?
		bne.s	.removeinvincible			; if so, don't change the music
		cmpi.b	#air_alert,ost_air_left(a0)		; is air < $C?
		bcs.s	.removeinvincible			; if so, don't change the music
		move.w	(v_level_music).w,d0
		jsr	(PlayMusic).l				; restore the level music

	.removeinvincible:
		bclr	#status_invincible_bit,ost_secondary_status(a0) ; cancel invincibility

	.chkshoes:
		btst	#status_speedshoes_bit,ost_secondary_status(a0) ; does Sonic have speed	shoes?
		beq.s	.exit					; if not, branch
		tst.w	ost_speedshoe_time(a0)			; check	time remaining
		beq.s	.exit					; if 0, branch
		subq.w	#1,ost_speedshoe_time(a0)		; decrement timer
		bne.s	.exit					; branch if time remains

	if FixBugs
		; Speed fixes. See ApplySpeedSettings.
		lea	(v_sonic_max_speed).w,a2
		bsr.w	ApplySpeedSettings			; restore Sonic's speed
	else
		move.w	#sonic_max_speed,(v_sonic_max_speed).w	; restore Sonic's speed
		move.w	#sonic_acceleration,(v_sonic_acceleration).w ; restore Sonic's acceleration
		move.w	#sonic_deceleration,(v_sonic_deceleration).w ; restore Sonic's deceleration
		tst.b	(f_super).w				; is Sonic super?
		beq.s	.removeshoes				; branch if not
		move.w	#sonic_max_speed_super,(v_sonic_max_speed).w ; use the values for Super Sonic instead
		move.w	#sonic_acceleration_super,(v_sonic_acceleration).w
		move.w	#sonic_deceleration_super,(v_sonic_deceleration).w
	endc

	.removeshoes:
		bclr	#status_speedshoes_bit,ost_secondary_status(a0) ; cancel speed shoes
		move.w	#cmd_SlowDown,d0			; run music at normal speed
		jmp	(PlayMusic).l
; ===========================================================================

	.exit:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	record Sonic's previous positions for invincibility stars
; and record his joypad state and status flags for use by Tails' AI
; ---------------------------------------------------------------------------

Sonic_RecordPosition:
		move.w	(v_sonic_pos_tracker_num).w,d0		; d0 = index into v_sonic_pos_tracker and v_sonic_stat_tracker
		lea	(v_sonic_pos_tracker).w,a1		; address to record position data to
		lea	(a1,d0.w),a1				; jump to current index
		move.w	ost_x_pos(a0),(a1)+			; save x/y position
		move.w	ost_y_pos(a0),(a1)+
		addq.b	#4,(v_sonic_pos_tracker_num_low).w	; next index (wraps to 0 after $FC)
		lea	(v_sonic_stat_tracker).w,a1		; address to record joypad hold and status data to
		lea	(a1,d0.w),a1				; jump to current index
		move.w	(v_joypad_hold).w,(a1)+			; save held joypad buttons
		move.w	ost_primary_status(a0),(a1)+		; save status flags
		rts

; ---------------------------------------------------------------------------
; Subroutine to handle Sonic entering and exiting water
; ---------------------------------------------------------------------------

Sonic_Water:
		tst.b	(f_water).w				; does level have water?
		bne.s	.haswater				; branch if so

	.exit:
		rts
; ===========================================================================

	.haswater:
		move.w	(v_water_height_actual).w,d0
		cmp.w	ost_y_pos(a0),d0			; is Sonic above the water?
		bge.s	.abovewater				; branch if so

	if FixBugs
		; If Sonic jumps when he is just above the point where he would be considered submerged,
		; his position may briefly fall under the water's surface again.
		; This causes the physics code that would normally simulate the water's surface tension
		; to instead reduce his jump strength, as his y-velocity is quartered,
		; then doubled upon exiting, leaving him with only half his intended jump strength.
		; The following two lines fix this issue by skipping the physics if Sonic
		; is moving upwards.
		tst.w	ost_y_vel(a0)				; is Sonic moving upwards?
		bmi.s	.exit					; if so, branch
	endc

		bset	#status_underwater_bit,ost_primary_status(a0) ; set underwater flag in status
		bne.s	.exit					; branch if already set

		movea.l	a0,a1					; a1 = player
		bsr.w	ResumeMusic				; reset air count
		move.b	#id_DrownCount,(v_ost_lo_sonic_breathingbubbles+ost_id).w ; load drowning countdown manager (also spawns bubbles from Sonic's mouth)
		move.b	#type_drowncount_manager,(v_ost_lo_sonic_breathingbubbles+ost_subtype).w ; set subtype
		move.l	a0,(v_ost_lo_sonic_breathingbubbles+ost_drown_parent).w ; set Sonic as parent of countdown manager

	if FixBugs
		; Speed fixes. See ApplySpeedSettings.
		lea	(v_sonic_max_speed).w,a2
		bsr.w	ApplySpeedSettings			; reduce Sonic's speed
	else
		move.w	#sonic_max_speed_water,(v_sonic_max_speed).w ; change Sonic's top speed
		move.w	#sonic_acceleration_water,(v_sonic_acceleration).w ; change Sonic's acceleration
		move.w	#sonic_deceleration_water,(v_sonic_deceleration).w ; change Sonic's deceleration
		tst.b	(f_super).w				; is Sonic super?
		beq.s	.not_super				; branch if not
		move.w	#sonic_max_speed_water+$200,(v_sonic_max_speed).w ; use these values instead
		move.w	#sonic_acceleration_water*4,(v_sonic_acceleration).w
		move.w	#sonic_deceleration_water*2,(v_sonic_deceleration).w

	.not_super:
	endc
		asr	ost_x_vel(a0)				; halve Sonic's x vel
		asr	ost_y_vel(a0)				; quarter his y vel
		asr	ost_y_vel(a0)
		beq.s	.exit					; branch if Sonic stops moving vertically
		move.w	#(id_Ani_SplashDust_Splash1<<8)|id_Ani_SplashDust_Blank,(v_ost_lo_sonic_dust+ost_anim).w ; use splash animation
		move.w	#sfx_Splash,d0				; play splash sound
		jmp	(PlaySound).l
; ===========================================================================

.abovewater:
		bclr	#status_underwater_bit,ost_primary_status(a0) ; clear underwater flag in status
		beq.s	.exit					; branch if already clear

		movea.l	a0,a1					; a1 = player
		bsr.w	ResumeMusic				; reset air count and restore music if necessary

	if FixBugs
		; Speed fixes. See ApplySpeedSettings.
		lea	(v_sonic_max_speed).w,a2
		bsr.w	ApplySpeedSettings			; restore Sonic's speed
	else
		move.w	#sonic_max_speed,(v_sonic_max_speed).w	; restore Sonic's speed
		move.w	#sonic_acceleration,(v_sonic_acceleration).w ; restore Sonic's acceleration
		move.w	#sonic_deceleration,(v_sonic_deceleration).w ; restore Sonic's deceleration
		tst.b	(f_super).w				; is Sonic super?
		beq.s	.not_super2				; branch if not
		move.w	#sonic_max_speed_super,(v_sonic_max_speed).w ; use super speed values
		move.w	#sonic_acceleration_super,(v_sonic_acceleration).w
		move.w	#sonic_deceleration_super,(v_sonic_deceleration).w

	.not_super2:
	endc

	if WaterPhysicsFixes=0
		; If Sonic exits water due to knockback from getting hurt, the usual speed increase
		; is not applied. Deleting these lines will allow the speed increase to apply.
		cmpi.b	#id_Sonic_Hurt,ost_primary_routine(a0)	; is Sonic hurt
		beq.s	.hurt
	endc
		asl	ost_y_vel(a0)				; double Sonic's y_vel
	.hurt:
		tst.w	ost_y_vel(a0)
		beq.w	.exit					; branch if Sonic stops moving vertically
		move.w	#(id_Ani_SplashDust_Splash1<<8)|id_Ani_SplashDust_Blank,(v_ost_lo_sonic_dust+ost_anim).w ; use splash animation
		movea.l	a0,a1
		bsr.w	ResumeMusic				; not sure why this is called again
		cmpi.w	#-sonic_max_speed_surface,ost_y_vel(a0)	; is upward y vel greater than $1000?
		bgt.s	.belowmaxspeed				; branch if not
		move.w	#-sonic_max_speed_surface,ost_y_vel(a0)	; limit speed on exiting water to $1000

	.belowmaxspeed:
		move.w	#sfx_Splash,d0				; play splash sound
		jmp	(PlaySound).l

; ---------------------------------------------------------------------------
; Modes	for controlling	Sonic
; ---------------------------------------------------------------------------

Sonic_Mode_Normal:
		; If Sonic has been waiting for a while, and is tapping his foot
		; impatiently, then make him blink once the player starts moving
		; again. Likewise, if he's been waiting for so long that he's laying
		; down, then make him play an animation of standing up.
		move.b	(v_joypad_press).w,d0			; d0 = joypad state
		andi.b	#btnABC,d0
		bne.s	.run_normal				; branch if A, B or C are pressed

		cmpi.b	#id_Ani_Son_Blink,ost_anim(a0)		; is Sonic blinking?
		beq.s	.return					; if so, exit

		cmpi.b	#id_Ani_Son_GetUp,ost_anim(a0)		; is Sonic standing up?
		beq.s	.return					; if so, exit

		cmpi.b	#id_Ani_Son_Wait,ost_anim(a0)		; is Sonic waiting?
		bne.s	.run_normal				; branch if not

		cmpi.b	#id_Frame_Sonic_Walk32,ost_anim_frame(a0) ; frame where Sonic is heading straight up on a loop
		bcs.s	.run_normal				; branch if anim frame is less than this

		move.b	(v_joypad_hold).w,d0			; d0 = joypad state
		andi.b	#btnABC|btnDir,d0
		beq.s	.return					; branch if there's no joypad input

		move.b	#id_Ani_Son_Blink,ost_anim(a0)		; make Sonic blink before he's ready to move again
		cmpi.b	#id_Frame_SuperSonic_Walk38_QuillUp,ost_anim_frame(a0) ; frame where Super Sonic is heading straight up on a loop
		bcs.s	.return					; branch if anim frame is less than this

		move.b	#id_Ani_Son_GetUp,ost_anim(a0)		; make Sonic stand up before he can move again
		bra.s	.return
; ===========================================================================

.run_normal:
		bsr.w	Sonic_CheckSpindash
		bsr.w	Sonic_Jump
		bsr.w	Sonic_SlopeResist
		bsr.w	Sonic_Move
		bsr.w	Sonic_Roll
		bsr.w	Sonic_LevelBound
		jsr	(SpeedToPos).l
		bsr.w	Player_AnglePos
		bsr.w	Sonic_SlopeRepel

	.return:
		rts
; ===========================================================================

Sonic_Mode_Air:
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_JumpDirection
		bsr.w	Sonic_LevelBound
		jsr	(ObjectFall).l
		btst	#status_underwater_bit,ost_primary_status(a0) ; is Sonic underwater?
		beq.s	.notwater				; if not, branch
		subi.w	#sonic_buoyancy,ost_y_vel(a0)		; apply upward force

	.notwater:
		bsr.w	Sonic_JumpAngle
		bsr.w	Sonic_JumpCollision
		rts
; ===========================================================================

Sonic_Mode_Roll:
		tst.b	ost_pinball_flag(a0)
		bne.s	.pinball
		bsr.w	Sonic_Jump

	.pinball:
		bsr.w	Sonic_RollRepel
		bsr.w	Sonic_RollSpeed
		bsr.w	Sonic_LevelBound
		jsr	(SpeedToPos).l
		bsr.w	Player_AnglePos
		bsr.w	Sonic_SlopeRepel
		rts
; ===========================================================================

Sonic_Mode_Jump:
		bsr.w	Sonic_JumpHeight
		bsr.w	Sonic_JumpDirection
		bsr.w	Sonic_LevelBound
		jsr	(ObjectFall).l
		btst	#status_underwater_bit,ost_primary_status(a0) ; is Sonic underwater?
		beq.s	.notwater				; if not, branch
		subi.w	#sonic_buoyancy,ost_y_vel(a0)		; apply upward force

	.notwater:
		bsr.w	Sonic_JumpAngle
		bsr.w	Sonic_JumpCollision
		rts
; ===========================================================================

Sonic_Move:
		move.w	(v_sonic_max_speed).w,d6
		move.w	(v_sonic_acceleration).w,d5
		move.w	(v_sonic_deceleration).w,d4
	if status_sliding_bit=7
		tst.b	ost_secondary_status(a0)
		bmi.w	Sonic_InertiaLR				; branch if Sonic is on an oil slide
	else
		btst	#status_sliding_bit,ost_secondary_status(a0)
		bne.w	Sonic_InertiaLR				; branch if Sonic is on an oil slide
	endc
		tst.w	ost_lock_time(a0)			; are controls locked?
		bne.w	Sonic_ResetScr				; if yes, branch
		btst	#bitL,(v_joypad_hold).w			; is left being pressed?
		beq.s	.notleft				; if not, branch
		bsr.w	Sonic_MoveLeft

	.notleft:
		btst	#bitR,(v_joypad_hold).w			; is right being pressed?
		beq.s	.notright				; if not, branch
		bsr.w	Sonic_MoveRight

	.notright:
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0					; is Sonic on a	slope?
		bne.w	Sonic_ResetScr				; if yes, branch
		tst.w	ost_inertia(a0)				; is Sonic moving?
		bne.w	Sonic_ResetScr				; if yes, branch
		bclr	#status_pushing_bit,ost_primary_status(a0)
		move.b	#id_Ani_Son_Wait,ost_anim(a0)		; use "standing" animation
		btst	#status_platform_bit,ost_status(a0)	; is Sonic on a platform?
		beq.w	Sonic_Balance				; if not, branch

		moveq	#0,d0
		move.b	ost_interact(a0),d0			; get OST index of platform or object
		lsl.w	#6,d0
		lea	(v_ost_all).w,a1
		lea	(a1,d0.w),a1				; a1 = actual address of OST of object being stood on
		tst.b	ost_primary_status(a1)			; has object been broken?
		bmi.w	Sonic_LookUp				; if yes, branch

		moveq	#0,d1
		move.b	ost_displaywidth(a1),d1			; d1 = half of width of platform or object
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#2,d2					; d2 = width of platform -2
		add.w	ost_x_pos(a0),d1			; add Sonic's x pos
		sub.w	ost_x_pos(a1),d1			; d1 = Sonic's position - object's position + half object's width

		tst.b	(f_super).w				; is Sonic super?
		bne.w	SuperSonic_Balance			; if so, use the super balancing routines instead (could be bne.s)
		cmpi.w	#2,d1					; is Sonic within 2px of left edge?
		blt.s	Sonic_BalLeft				; if so, branch
		cmp.w	d2,d1					; is Sonic within 2px of right edge?
		bge.s	Sonic_BalRight				; if so, branch
		bra.w	Sonic_LookUp
; ===========================================================================

SuperSonic_Balance:
		cmpi.w	#2,d1					; is Super Sonic within 2px of left edge?
		blt.w	SuperSonic_BalLeft			; if so, branch
		cmp.w	d2,d1					; is Super Sonic within 2px of right edge?
		bge.w	SuperSonic_BalRight			; if so, branch
		bra.w	Sonic_LookUp
; ===========================================================================

Sonic_BalRight:
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	.facingleft				; branch if Sonic is facing left
		move.b	#id_Ani_Son_BalanceOut1,ost_anim(a0)
		addq.w	#6,d2					; d2 = display width of platform +4
		cmp.w	d2,d1					; is Sonic greater than 4 pixels beyond right edge?
		blt.w	Sonic_ResetScr				; branch if not
		move.b	#id_Ani_Son_BalanceOut2,ost_anim(a0)
		bra.w	Sonic_ResetScr
; ===========================================================================

	.facingleft:
		move.b	#id_Ani_Son_BalanceIn1,ost_anim(a0)
		addq.w	#6,d2					; d2 = display width of platform +4
		cmp.w	d2,d1					; is Sonic greater than 4 pixels beyond right edge?
		blt.w	Sonic_ResetScr				; branch if not
		move.b	#id_Ani_Son_BalanceIn2,ost_anim(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0) ; Sonic faces out from platform
		bra.w	Sonic_ResetScr
; ===========================================================================

Sonic_BalLeft:
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	.facingright				; branch if Sonic is facing right
		move.b	#id_Ani_Son_BalanceOut1,ost_anim(a0)
		cmpi.w	#-4,d1					; is Sonic greater than 4 pixels beyond left edge?
		bge.w	Sonic_ResetScr				; branch if not
		move.b	#id_Ani_Son_BalanceOut2,ost_anim(a0)
		bra.w	Sonic_ResetScr
; ===========================================================================

	.facingright:
		move.b	#id_Ani_Son_BalanceIn1,ost_anim(a0)
		cmpi.w	#-4,d1					; is Sonic greater than 4 pixels beyond left edge?
		bge.w	Sonic_ResetScr				; branch if not
		move.b	#id_Ani_Son_BalanceIn2,ost_anim(a0)
		bset	#status_xflip_bit,ost_primary_status(a0) ; Sonic faces out from platform
		bra.w	Sonic_ResetScr
; ===========================================================================

Sonic_Balance:
		jsr	(FindFloorObj_ChkCol).l
		cmpi.w	#$C,d1
		blt.w	Sonic_LookUp
		tst.b	(f_super).w
		bne.w	loc_1A55E
		cmpi.b	#3,$36(a0)
		bne.s	loc_1A500
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_1A4D6
		move.b	#6,ost_anim(a0)
		move.w	ost_x_pos(a0),d3
		subq.w	#6,d3
		jsr	(FindFloorObj_ChkCol_NoX).l
		cmpi.w	#$C,d1
		blt.w	Sonic_ResetScr
		move.b	#$C,ost_anim(a0)
		bra.w	Sonic_ResetScr
; ===========================================================================

loc_1A4D6:
		move.b	#$1D,ost_anim(a0)
		move.w	ost_x_pos(a0),d3
		subq.w	#6,d3
		jsr	(FindFloorObj_ChkCol_NoX).l
		cmpi.w	#$C,d1
		blt.w	Sonic_ResetScr
		move.b	#$1E,ost_anim(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0)
		bra.w	Sonic_ResetScr
; ===========================================================================

loc_1A500:
		cmpi.b	#3,$37(a0)
		bne.s	Sonic_LookUp
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1A534
		move.b	#6,ost_anim(a0)
		move.w	ost_x_pos(a0),d3
		addq.w	#6,d3
		jsr	(FindFloorObj_ChkCol_NoX).l
		cmpi.w	#$C,d1
		blt.w	Sonic_ResetScr
		move.b	#$C,ost_anim(a0)
		bra.w	Sonic_ResetScr
; ===========================================================================

loc_1A534:
		move.b	#$1D,ost_anim(a0)
		move.w	ost_x_pos(a0),d3
		addq.w	#6,d3
		jsr	(FindFloorObj_ChkCol_NoX).l
		cmpi.w	#$C,d1
		blt.w	Sonic_ResetScr
		move.b	#$1E,ost_anim(a0)
		bset	#status_xflip_bit,ost_primary_status(a0)
		bra.w	Sonic_ResetScr
; ===========================================================================

loc_1A55E:
		cmpi.b	#3,$36(a0)
		bne.s	loc_1A56E

SuperSonic_BalRight:
		bclr	#status_xflip_bit,ost_primary_status(a0)
		bra.s	loc_1A57C
; ===========================================================================

loc_1A56E:
		cmpi.b	#3,$37(a0)
		bne.s	Sonic_LookUp

SuperSonic_BalLeft:
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_1A57C:
		move.b	#6,ost_anim(a0)
		bra.s	Sonic_ResetScr
; ===========================================================================

Sonic_LookUp:
		btst	#0,(v_joypad_hold).w
		beq.s	loc_1A5B2
		move.b	#7,ost_anim(a0)
		addq.w	#1,(v_sonic_look_delay_counter).w
		cmpi.w	#$78,(v_sonic_look_delay_counter).w
		bcs.s	loc_1A5E6
		move.w	#$78,(v_sonic_look_delay_counter).w
		cmpi.w	#$C8,(v_camera_y_shift).w
		beq.s	loc_1A5F8
		addq.w	#2,(v_camera_y_shift).w
		bra.s	loc_1A5F8
; ===========================================================================

loc_1A5B2:
		btst	#1,(v_joypad_hold).w
		beq.s	Sonic_ResetScr
		move.b	#8,ost_anim(a0)
		addq.w	#1,(v_sonic_look_delay_counter).w
		cmpi.w	#$78,(v_sonic_look_delay_counter).w
		bcs.s	loc_1A5E6
		move.w	#$78,(v_sonic_look_delay_counter).w
		cmpi.w	#8,(v_camera_y_shift).w
		beq.s	loc_1A5F8
		subq.w	#2,(v_camera_y_shift).w
		bra.s	loc_1A5F8
; ===========================================================================

Sonic_ResetScr:
		move.w	#0,(v_sonic_look_delay_counter).w

loc_1A5E6:
		cmpi.w	#$60,(v_camera_y_shift).w
		beq.s	loc_1A5F8
		bcc.s	loc_1A5F4
		addq.w	#4,(v_camera_y_shift).w

loc_1A5F4:
		subq.w	#2,(v_camera_y_shift).w

loc_1A5F8:
		tst.b	(f_super).w
		beq.w	loc_1A604
		move.w	#$C,d5

loc_1A604:
		move.b	(v_joypad_hold).w,d0
		andi.b	#$C,d0
		bne.s	Sonic_InertiaLR
		move.w	ost_inertia(a0),d0
		beq.s	Sonic_InertiaLR
		bmi.s	loc_1A624
		sub.w	d5,d0
		bcc.s	loc_1A61E
		move.w	#0,d0

loc_1A61E:
		move.w	d0,ost_inertia(a0)
		bra.s	Sonic_InertiaLR
; ===========================================================================

loc_1A624:
		add.w	d5,d0
		bcc.s	loc_1A62C
		move.w	#0,d0

loc_1A62C:
		move.w	d0,ost_inertia(a0)

Sonic_InertiaLR:
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	ost_inertia(a0),d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a0)
		muls.w	ost_inertia(a0),d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a0)

loc_1A64E:
		move.b	ost_angle(a0),d0
		addi.b	#$40,d0
		bmi.s	locret_1A6BE
		move.b	#$40,d1
		tst.w	ost_inertia(a0)
		beq.s	locret_1A6BE
		bmi.s	loc_1A666
		neg.w	d1

loc_1A666:
		move.b	ost_angle(a0),d0
		add.b	d1,d0
		pushr.w	d0
		bsr.w	Player_CalcRoomAhead
		popr.w	d0
		tst.w	d1
		bpl.s	locret_1A6BE
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#-$40,d0
		beq.s	loc_1A6BA
		cmpi.b	#$40,d0
		beq.s	loc_1A6A8
		cmpi.b	#-$80,d0
		beq.s	loc_1A6A2
		add.w	d1,ost_x_vel(a0)
		bset	#5,ost_primary_status(a0)
		move.w	#0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1A6A2:
		sub.w	d1,ost_y_vel(a0)
		rts
; ===========================================================================

loc_1A6A8:
		sub.w	d1,ost_x_vel(a0)
		bset	#5,ost_primary_status(a0)
		move.w	#0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1A6BA:
		add.w	d1,ost_y_vel(a0)

locret_1A6BE:
		rts
; ===========================================================================

Sonic_MoveLeft:
		move.w	ost_inertia(a0),d0
		beq.s	loc_1A6C8
		bpl.s	loc_1A6FA

loc_1A6C8:
		bset	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_1A6DC
		bclr	#5,ost_primary_status(a0)
		move.b	#1,ost_anim_restart(a0)

loc_1A6DC:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_1A6EE
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc_1A6EE
		move.w	d1,d0

loc_1A6EE:
		move.w	d0,ost_inertia(a0)
		move.b	#0,ost_anim(a0)
		rts
; ===========================================================================

loc_1A6FA:
		sub.w	d4,d0
		bcc.s	loc_1A702
		move.w	#-$80,d0

loc_1A702:
		move.w	d0,ost_inertia(a0)
	if FixBugs
		move.b	ost_angle(a0),d1
		addi.b	#$20,d1
		andi.b	#$C0,d1
	else
		; These three instructions partially overwrite the inertia value in
		; 'd0'! This causes the character to trigger their skidding
		; animation at different speeds depending on whether they're going
		; right or left. To fix this, make these instructions use 'd1'
		; instead.
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
	endc
		bne.s	locret_1A744
		cmpi.w	#$400,d0
		blt.s	locret_1A744
		move.b	#$D,ost_anim(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0)
		move.w	#$A4,d0
		jsr	(PlaySound).l
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	locret_1A744
		move.b	#6,($FFFFD124).w
		move.b	#$15,($FFFFD11A).w

locret_1A744:
		rts
; ===========================================================================

Sonic_MoveRight:
		move.w	ost_inertia(a0),d0
		bmi.s	loc_1A77A
		bclr	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1A760
		bclr	#5,ost_primary_status(a0)
		move.b	#1,ost_anim_restart(a0)

loc_1A760:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1A76E
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc_1A76E
		move.w	d6,d0

loc_1A76E:
		move.w	d0,ost_inertia(a0)
		move.b	#0,ost_anim(a0)
		rts
; ===========================================================================

loc_1A77A:
		add.w	d4,d0
		bcc.s	loc_1A782
		move.w	#$80,d0

loc_1A782:
		move.w	d0,ost_inertia(a0)
	if FixBugs
		move.b	ost_angle(a0),d1
		addi.b	#$20,d1
		andi.b	#$C0,d1
	else
		; These three instructions partially overwrite the inertia value in
		; 'd0'! This causes the character to trigger their skidding
		; animation at different speeds depending on whether they're going
		; right or left. To fix this, make these instructions use 'd1'
		; instead.
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
	endc
		bne.s	locret_1A7C4
		cmpi.w	#-$400,d0
		bgt.s	locret_1A7C4
		move.b	#$D,ost_anim(a0)
		bset	#status_xflip_bit,ost_primary_status(a0)
		move.w	#$A4,d0
		jsr	(PlaySound).l
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	locret_1A7C4
		move.b	#6,($FFFFD124).w
		move.b	#$15,($FFFFD11A).w

locret_1A7C4:
		rts
; ===========================================================================

Sonic_RollSpeed:
		move.w	(v_sonic_max_speed).w,d6
		asl.w	#1,d6
		move.w	(v_sonic_acceleration).w,d5
		asr.w	#1,d5
		move.w	#$20,d4
		tst.b	$2B(a0)
		bmi.w	loc_1A85A
		tst.w	$2E(a0)
		bne.s	loc_1A7FC
		btst	#2,(v_joypad_hold).w
		beq.s	loc_1A7F0
		bsr.w	loc_1A8A2

loc_1A7F0:
		btst	#3,(v_joypad_hold).w
		beq.s	loc_1A7FC
		bsr.w	loc_1A8C6

loc_1A7FC:
		move.w	ost_inertia(a0),d0
		beq.s	loc_1A81E
		bmi.s	loc_1A812
		sub.w	d5,d0
		bcc.s	loc_1A80C
		move.w	#0,d0

loc_1A80C:
		move.w	d0,ost_inertia(a0)
		bra.s	loc_1A81E
; ===========================================================================

loc_1A812:
		add.w	d5,d0
		bcc.s	loc_1A81A
		move.w	#0,d0

loc_1A81A:
		move.w	d0,ost_inertia(a0)

loc_1A81E:
		tst.w	ost_inertia(a0)
		bne.s	loc_1A85A
		tst.b	$39(a0)
		bne.s	loc_1A848
		bclr	#status_jump_bit,ost_primary_status(a0)
		move.b	#$13,ost_height(a0)
		move.b	#9,ost_width(a0)
		move.b	#5,ost_anim(a0)
		subq.w	#5,ost_y_pos(a0)
		bra.s	loc_1A85A
; ===========================================================================

loc_1A848:
		move.w	#$400,ost_inertia(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1A85A
		neg.w	ost_inertia(a0)

loc_1A85A:
		cmpi.w	#$60,(v_camera_y_shift).w
		beq.s	loc_1A86C
		bcc.s	loc_1A868
		addq.w	#4,(v_camera_y_shift).w

loc_1A868:
		subq.w	#2,(v_camera_y_shift).w

loc_1A86C:
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	ost_inertia(a0),d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a0)
		muls.w	ost_inertia(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc_1A890
		move.w	#$1000,d1

loc_1A890:
		cmpi.w	#-$1000,d1
		bge.s	loc_1A89A
		move.w	#-$1000,d1

loc_1A89A:
		move.w	d1,ost_x_vel(a0)
		bra.w	loc_1A64E
; ===========================================================================

loc_1A8A2:
		move.w	ost_inertia(a0),d0
		beq.s	loc_1A8AA
		bpl.s	loc_1A8B8

loc_1A8AA:
		bset	#status_xflip_bit,ost_primary_status(a0)
		move.b	#2,ost_anim(a0)
		rts
; ===========================================================================

loc_1A8B8:
		sub.w	d4,d0
		bcc.s	loc_1A8C0
		move.w	#-$80,d0

loc_1A8C0:
		move.w	d0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1A8C6:
		move.w	ost_inertia(a0),d0
		bmi.s	loc_1A8DA
		bclr	#status_xflip_bit,ost_primary_status(a0)
		move.b	#2,ost_anim(a0)
		rts
; ===========================================================================

loc_1A8DA:
		add.w	d4,d0
		bcc.s	loc_1A8E2
		move.w	#$80,d0

loc_1A8E2:
		move.w	d0,ost_inertia(a0)
		rts
; ===========================================================================

Sonic_JumpDirection:
		move.w	(v_sonic_max_speed).w,d6
		move.w	(v_sonic_acceleration).w,d5
		asl.w	#1,d5
		btst	#4,ost_primary_status(a0)
		bne.s	loc_1A932
		move.w	ost_x_vel(a0),d0
		btst	#2,(v_joypad_hold).w
		beq.s	loc_1A918
		bset	#status_xflip_bit,ost_primary_status(a0)
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_1A918
		move.w	d1,d0

loc_1A918:
		btst	#3,(v_joypad_hold).w
		beq.s	loc_1A92E
		bclr	#status_xflip_bit,ost_primary_status(a0)
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1A92E
		move.w	d6,d0

loc_1A92E:
		move.w	d0,ost_x_vel(a0)

loc_1A932:
		cmpi.w	#$60,(v_camera_y_shift).w
		beq.s	loc_1A944
		bcc.s	loc_1A940
		addq.w	#4,(v_camera_y_shift).w

loc_1A940:
		subq.w	#2,(v_camera_y_shift).w

loc_1A944:
		cmpi.w	#-$400,ost_y_vel(a0)
		bcs.s	locret_1A972
		move.w	ost_x_vel(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret_1A972
		bmi.s	loc_1A966
		sub.w	d1,d0
		bcc.s	loc_1A960
		move.w	#0,d0

loc_1A960:
		move.w	d0,ost_x_vel(a0)
		rts
; ===========================================================================

loc_1A966:
		sub.w	d1,d0
		bcs.s	loc_1A96E
		move.w	#0,d0

loc_1A96E:
		move.w	d0,ost_x_vel(a0)

locret_1A972:
		rts
; ===========================================================================

Sonic_LevelBound:
		move.l	ost_x_pos(a0),d1
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	(v_boundary_left).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0
		bhi.s	loc_1A9BA
		move.w	(v_boundary_right).w,d0
		addi.w	#$128,d0
		tst.b	(v_current_boss).w
		bne.s	loc_1A9A2
		addi.w	#$40,d0

loc_1A9A2:
		cmp.w	d1,d0
		bls.s	loc_1A9BA

loc_1A9A6:
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		blt.s	loc_1A9B6
		rts
; ===========================================================================

loc_1A9B6:
		jmpto	KillCharacter, JmpTo_KillCharacter
; ===========================================================================

loc_1A9BA:
		move.w	d0,ost_x_pos(a0)
		move.w	#0,ost_x_sub(a0)			; 2+x_pos
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_inertia(a0)
		bra.s	loc_1A9A6
; ===========================================================================

Sonic_Roll:
		tst.b	$2B(a0)
		bmi.s	locret_1A9F8
		move.w	ost_inertia(a0),d0
		bpl.s	loc_1A9E0
		neg.w	d0

loc_1A9E0:
		cmpi.w	#$80,d0
		bcs.s	locret_1A9F8
		move.b	(v_joypad_hold).w,d0
		andi.b	#$C,d0
		bne.s	locret_1A9F8
		btst	#1,(v_joypad_hold).w
		bne.s	loc_1A9FA

locret_1A9F8:
		rts
; ===========================================================================

loc_1A9FA:
		btst	#status_jump_bit,ost_primary_status(a0)
		beq.s	loc_1AA04
		rts
; ===========================================================================

loc_1AA04:
		bset	#status_jump_bit,ost_primary_status(a0)
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.b	#2,ost_anim(a0)
		addq.w	#5,ost_y_pos(a0)
		move.w	#$BE,d0
		jsr	(PlaySound).l
		tst.w	ost_inertia(a0)
		bne.s	locret_1AA36
		move.w	#$200,ost_inertia(a0)

locret_1AA36:
		rts
; ===========================================================================

Sonic_Jump:
		move.b	(v_joypad_press).w,d0
		andi.b	#$70,d0
		beq.w	locret_1AAE6
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		addi.b	#-$80,d0
		bsr.w	Player_CalcHeadroom
		cmpi.w	#6,d1
		blt.w	locret_1AAE6
		move.w	#$680,d2
		tst.b	(f_super).w
		beq.s	loc_1AA68
		move.w	#$800,d2

loc_1AA68:
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1AA74
		move.w	#$380,d2

loc_1AA74:
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,ost_x_vel(a0)
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,ost_y_vel(a0)
		bset	#1,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$A0,d0
		jsr	(PlaySound).l
		move.b	#$13,ost_height(a0)
		move.b	#9,ost_width(a0)
		btst	#status_jump_bit,ost_primary_status(a0)
		bne.s	loc_1AAE8
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.b	#2,ost_anim(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		addq.w	#5,ost_y_pos(a0)

locret_1AAE6:
		rts
; ===========================================================================

loc_1AAE8:
		bset	#4,ost_primary_status(a0)
		rts
; ===========================================================================

Sonic_JumpHeight:
		tst.b	$3C(a0)
		beq.s	loc_1AB22
		move.w	#-$400,d1
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1AB06
		move.w	#-$200,d1

loc_1AB06:
		cmp.w	ost_y_vel(a0),d1
		ble.s	loc_1AB1A
		move.b	(v_joypad_hold).w,d0
		andi.b	#$70,d0
		bne.s	loc_1AB1A
		move.w	d1,ost_y_vel(a0)

loc_1AB1A:
		tst.b	ost_y_vel(a0)
		beq.s	loc_1AB38
		rts
; ===========================================================================

loc_1AB22:
		tst.b	$39(a0)
		bne.s	locret_1AB36
		cmpi.w	#-$FC0,ost_y_vel(a0)
		bge.s	locret_1AB36
		move.w	#-$FC0,ost_y_vel(a0)

locret_1AB36:
		rts
; ===========================================================================

loc_1AB38:
		tst.b	(f_super).w
		bne.s	locret_1ABA4
		cmpi.b	#countof_emeralds,(v_emeralds).w
		bne.s	locret_1ABA4
		cmpi.w	#50,(v_rings).w
		bcs.s	locret_1ABA4

	if (Revision=2)|FixBugs
		; Fixes a bug where the player can get stuck if transforming at the end of a level
		tst.b	(f_hud_time_update).w
		beq.s	locret_1ABA4
	endc

	if FixBugs
		; If Sonic was executing a roll-jump when he turned Super, then this
		; will remove him from that state. The original code forgot to do
		; this.
		andi.b	#~(status_jump|status_rolljump),ost_primary_status(a0) ; clear the jump and rolljump status bits
		move.b	#$13,ost_height(a0)
		move.b	#9,ost_width(a0)
	endc

		move.b	#1,(v_super_sonic_palette).w
		move.b	#$F,(v_palette_timer).w
		move.b	#1,(f_super).w
		move.b	#-$7F,$2A(a0)
		move.b	#$1F,ost_anim(a0)
		move.b	#$7E,($FFFFD040).w
		move.w	#$A00,(v_sonic_max_speed).w
		move.w	#$30,(v_sonic_acceleration).w
		move.w	#$100,(v_sonic_deceleration).w
		move.w	#0,$32(a0)
		bset	#1,$2B(a0)
		move.w	#$DF,d0
		jsr	(PlaySound).l
		move.w	#$96,d0
		jmp	(PlayMusic).l
; ===========================================================================

locret_1ABA4:
		rts
; ===========================================================================

Sonic_Super:
		tst.b	(f_super).w
		beq.w	locret_1AC3C
		tst.b	(f_hud_time_update).w
		beq.s	loc_1ABF2
		subq.w	#1,(v_super_sonic_frame_count).w
		bpl.w	locret_1AC3C
		move.w	#$3C,(v_super_sonic_frame_count).w
		tst.w	(v_rings).w
		beq.s	loc_1ABF2
		ori.b	#1,(v_hud_rings_update).w
		cmpi.w	#1,(v_rings).w
		beq.s	loc_1ABE6
		cmpi.w	#$A,(v_rings).w
		beq.s	loc_1ABE6
		cmpi.w	#$64,(v_rings).w
		bne.s	loc_1ABEC

loc_1ABE6:
		ori.b	#$80,(v_hud_rings_update).w

loc_1ABEC:
		subq.w	#1,(v_rings).w
		bne.s	locret_1AC3C

loc_1ABF2:
		move.b	#2,(v_super_sonic_palette).w
		move.w	#$28,(v_palette_frame).w
		move.b	#0,(f_super).w
		move.b	#1,ost_anim_restart(a0)
		move.w	#1,$32(a0)
		move.w	#$600,(v_sonic_max_speed).w
		move.w	#$C,(v_sonic_acceleration).w
		move.w	#$80,(v_sonic_deceleration).w
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	locret_1AC3C
		move.w	#$300,(v_sonic_max_speed).w
		move.w	#6,(v_sonic_acceleration).w
		move.w	#$40,(v_sonic_deceleration).w

locret_1AC3C:
		rts
; ===========================================================================

Sonic_CheckSpindash:
		tst.b	$39(a0)
		bne.s	loc_1AC8E
		cmpi.b	#8,ost_anim(a0)
		bne.s	locret_1AC8C
		move.b	(v_joypad_press).w,d0
		andi.b	#$70,d0
		beq.w	locret_1AC8C
		move.b	#9,ost_anim(a0)
		move.w	#$E0,d0
		jsr	(PlaySound).l
		addq.l	#4,sp
		move.b	#1,$39(a0)
		move.w	#0,$3A(a0)
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	loc_1AC84
		move.b	#2,($FFFFD11C).w

loc_1AC84:
		bsr.w	Sonic_LevelBound
		bsr.w	Player_AnglePos

locret_1AC8C:
		rts
; ===========================================================================

loc_1AC8E:
		move.b	(v_joypad_hold).w,d0
		btst	#1,d0
		bne.w	loc_1AD30
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.b	#2,ost_anim(a0)
		addq.w	#5,ost_y_pos(a0)
		move.b	#0,$39(a0)
		moveq	#0,d0
		move.b	$3A(a0),d0
		add.w	d0,d0
		move.w	word_1AD0C(pc,d0.w),ost_inertia(a0)
		tst.b	(f_super).w
		beq.s	loc_1ACD0
		move.w	word_1AD1E(pc,d0.w),ost_inertia(a0)

loc_1ACD0:
		move.w	ost_inertia(a0),d0
		subi.w	#$800,d0
		add.w	d0,d0
		andi.w	#$1F00,d0
		neg.w	d0
		addi.w	#$2000,d0
		move.w	d0,(v_hscroll_delay_val).w
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1ACF4
		neg.w	ost_inertia(a0)

loc_1ACF4:
		bset	#status_jump_bit,ost_primary_status(a0)
		move.b	#0,($FFFFD11C).w
		move.w	#$BC,d0
		jsr	(PlaySound).l
		bra.s	loc_1AD78
; ===========================================================================
word_1AD0C:
		dc.w  $800					; 0
		dc.w  $880					; 1
		dc.w  $900					; 2
		dc.w  $980					; 3
		dc.w  $A00					; 4
		dc.w  $A80					; 5
		dc.w  $B00					; 6
		dc.w  $B80					; 7
		dc.w  $C00					; 8
word_1AD1E:
		dc.w  $B00					; 0
		dc.w  $B80					; 1
		dc.w  $C00					; 2
		dc.w  $C80					; 3
		dc.w  $D00					; 4
		dc.w  $D80					; 5
		dc.w  $E00					; 6
		dc.w  $E80					; 7
		dc.w  $F00					; 8
; ===========================================================================

loc_1AD30:
		tst.w	$3A(a0)
		beq.s	loc_1AD48
		move.w	$3A(a0),d0
		lsr.w	#5,d0
		sub.w	d0,$3A(a0)
		bcc.s	loc_1AD48
		move.w	#0,$3A(a0)

loc_1AD48:
		move.b	(v_joypad_press).w,d0
		andi.b	#$70,d0
		beq.w	loc_1AD78
		move.w	#$900,ost_anim(a0)
		move.w	#$E0,d0
		jsr	(PlaySound).l
		addi.w	#$200,$3A(a0)
		cmpi.w	#$800,$3A(a0)
		bcs.s	loc_1AD78
		move.w	#$800,$3A(a0)

loc_1AD78:
		addq.l	#4,sp
		cmpi.w	#$60,(v_camera_y_shift).w
		beq.s	loc_1AD8C
		bcc.s	loc_1AD88
		addq.w	#4,(v_camera_y_shift).w

loc_1AD88:
		subq.w	#2,(v_camera_y_shift).w

loc_1AD8C:
		bsr.w	Sonic_LevelBound
		bsr.w	Player_AnglePos
		rts
; ===========================================================================

Sonic_SlopeResist:
		move.b	ost_angle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_1ADCA
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	ost_inertia(a0)
		beq.s	locret_1ADCA
		bmi.s	loc_1ADC6
		tst.w	d0
		beq.s	locret_1ADC4
		add.w	d0,ost_inertia(a0)

locret_1ADC4:
		rts
; ===========================================================================

loc_1ADC6:
		add.w	d0,ost_inertia(a0)

locret_1ADCA:
		rts
; ===========================================================================

Sonic_RollRepel:
		move.b	ost_angle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_1AE06
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	ost_inertia(a0)
		bmi.s	loc_1ADFC
		tst.w	d0
		bpl.s	loc_1ADF6
		asr.l	#2,d0

loc_1ADF6:
		add.w	d0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1ADFC:
		tst.w	d0
		bmi.s	loc_1AE02
		asr.l	#2,d0

loc_1AE02:
		add.w	d0,ost_inertia(a0)

locret_1AE06:
		rts
; ===========================================================================

Sonic_SlopeRepel:
		nop
		tst.b	$38(a0)
		bne.s	locret_1AE42
		tst.w	$2E(a0)
		bne.s	loc_1AE44
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#-$40,d0
		beq.s	locret_1AE42
		move.w	ost_inertia(a0),d0
		bpl.s	loc_1AE2C
		neg.w	d0

loc_1AE2C:
		cmpi.w	#$280,d0
		bcc.s	locret_1AE42
		clr.w	ost_inertia(a0)
		bset	#1,ost_primary_status(a0)
		move.w	#$1E,$2E(a0)

locret_1AE42:
		rts
; ===========================================================================

loc_1AE44:
		subq.w	#1,$2E(a0)
		rts
; ===========================================================================

Sonic_JumpAngle:
		move.b	ost_angle(a0),d0
		beq.s	loc_1AE64
		bpl.s	loc_1AE5A
		addq.b	#2,d0
		bcc.s	loc_1AE58
		moveq	#0,d0

loc_1AE58:
		bra.s	loc_1AE60
; ===========================================================================

loc_1AE5A:
		subq.b	#2,d0
		bcc.s	loc_1AE60
		moveq	#0,d0

loc_1AE60:
		move.b	d0,ost_angle(a0)

loc_1AE64:
		move.b	ost_flip_angle(a0),d0
		beq.s	locret_1AEA8
		tst.w	ost_inertia(a0)
		bmi.s	loc_1AE88

loc_1AE70:
		move.b	$2D(a0),d1
		add.b	d1,d0
		bcc.s	loc_1AE86
		subq.b	#1,$2C(a0)
		bcc.s	loc_1AE86
		move.b	#0,$2C(a0)
		moveq	#0,d0

loc_1AE86:
		bra.s	loc_1AEA4
; ===========================================================================

loc_1AE88:
		tst.b	ost_flip_turned(a0)
		bne.s	loc_1AE70
		move.b	$2D(a0),d1
		sub.b	d1,d0
		bcc.s	loc_1AEA4
		subq.b	#1,$2C(a0)
		bcc.s	loc_1AEA4
		move.b	#0,$2C(a0)
		moveq	#0,d0

loc_1AEA4:
		move.b	d0,ost_flip_angle(a0)

locret_1AEA8:
		rts
; ===========================================================================

Sonic_JumpCollision:
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#$C,$3E(a0)
		beq.s	loc_1AEC2
		move.l	#v_secondary_collision,(v_collision_index_ptr).w

loc_1AEC2:
		move.b	$3F(a0),d5
		move.w	ost_x_vel(a0),d1
		move.w	ost_y_vel(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#-$40,d0
		cmpi.b	#$40,d0
		beq.w	loc_1AF8C
		cmpi.b	#-$80,d0
		beq.w	loc_1AFE8
		cmpi.b	#-$40,d0
		beq.w	loc_1B044
		bsr.w	Player_FindWallLeft_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1AF06
		sub.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1AF06:
		bsr.w	Player_FindWallRight_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1AF18
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1AF18:
		bsr.w	Player_FindFloor
		tst.w	d1
		bpl.s	locret_1AF8A
		move.b	ost_y_vel(a0),d2
		addq.b	#8,d2
		neg.b	d2
		cmp.b	d2,d1
		bge.s	loc_1AF30
		cmp.b	d2,d0
		blt.s	locret_1AF8A

loc_1AF30:
		add.w	d1,ost_y_pos(a0)
		move.b	d3,ost_angle(a0)
		bsr.w	Sonic_ResetOnFloor
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1AF68
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc_1AF5A
		asr	ost_y_vel(a0)
		bra.s	loc_1AF7C
; ===========================================================================

loc_1AF5A:
		move.w	#0,ost_y_vel(a0)
		move.w	ost_x_vel(a0),ost_inertia(a0)
		rts
; ===========================================================================

loc_1AF68:
		move.w	#0,ost_x_vel(a0)
		cmpi.w	#$FC0,ost_y_vel(a0)
		ble.s	loc_1AF7C
		move.w	#$FC0,ost_y_vel(a0)

loc_1AF7C:
		move.w	ost_y_vel(a0),ost_inertia(a0)
		tst.b	d3
		bpl.s	locret_1AF8A
		neg.w	ost_inertia(a0)

locret_1AF8A:
		rts
; ===========================================================================

loc_1AF8C:
		bsr.w	Player_FindWallLeft_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1AFA6
		sub.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	ost_y_vel(a0),ost_inertia(a0)
		rts
; ===========================================================================

loc_1AFA6:
		bsr.w	Player_FindCeiling
		tst.w	d1
		bpl.s	loc_1AFC0
		sub.w	d1,ost_y_pos(a0)
		tst.w	ost_y_vel(a0)
		bpl.s	locret_1AFBE
		move.w	#0,ost_y_vel(a0)

locret_1AFBE:
		rts
; ===========================================================================

loc_1AFC0:
		tst.w	ost_y_vel(a0)
		bmi.s	locret_1AFE6
		bsr.w	Player_FindFloor
		tst.w	d1
		bpl.s	locret_1AFE6
		add.w	d1,ost_y_pos(a0)
		move.b	d3,ost_angle(a0)
		bsr.w	Sonic_ResetOnFloor
		move.w	#0,ost_y_vel(a0)
		move.w	ost_x_vel(a0),ost_inertia(a0)

locret_1AFE6:
		rts
; ===========================================================================

loc_1AFE8:
		bsr.w	Player_FindWallLeft_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1AFFA
		sub.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1AFFA:
		bsr.w	Player_FindWallRight_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1B00C
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1B00C:
		bsr.w	Player_FindCeiling
		tst.w	d1
		bpl.s	locret_1B042
		sub.w	d1,ost_y_pos(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1B02C
		move.w	#0,ost_y_vel(a0)
		rts
; ===========================================================================

loc_1B02C:
		move.b	d3,ost_angle(a0)
		bsr.w	Sonic_ResetOnFloor
		move.w	ost_y_vel(a0),ost_inertia(a0)
		tst.b	d3
		bpl.s	locret_1B042
		neg.w	ost_inertia(a0)

locret_1B042:
		rts
; ===========================================================================

loc_1B044:
		bsr.w	Player_FindWallRight_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1B05E
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	ost_y_vel(a0),ost_inertia(a0)
		rts
; ===========================================================================

loc_1B05E:
		bsr.w	Player_FindCeiling
		tst.w	d1
		bpl.s	loc_1B078
		sub.w	d1,ost_y_pos(a0)
		tst.w	ost_y_vel(a0)
		bpl.s	locret_1B076
		move.w	#0,ost_y_vel(a0)

locret_1B076:
		rts
; ===========================================================================

loc_1B078:
		tst.w	ost_y_vel(a0)
		bmi.s	locret_1B09E
		bsr.w	Player_FindFloor
		tst.w	d1
		bpl.s	locret_1B09E
		add.w	d1,ost_y_pos(a0)
		move.b	d3,ost_angle(a0)
		bsr.w	Sonic_ResetOnFloor
		move.w	#0,ost_y_vel(a0)
		move.w	ost_x_vel(a0),ost_inertia(a0)

locret_1B09E:
		rts
; ===========================================================================

Sonic_ResetOnFloor:
		tst.b	$39(a0)
		bne.s	loc_1B0DA
		move.b	#0,ost_anim(a0)

Sonic_ResetOnFloor_2:
		_cmpi.b	#id_SonicPlayer,ost_id(a0)
		bne.w	Tails_ResetOnFloor_2
		btst	#status_jump_bit,ost_primary_status(a0)
		beq.s	loc_1B0DA
		bclr	#status_jump_bit,ost_primary_status(a0)
		move.b	#$13,ost_height(a0)
		move.b	#9,ost_width(a0)
		move.b	#0,ost_anim(a0)
		subq.w	#5,ost_y_pos(a0)

loc_1B0DA:
		bclr	#1,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a0)
		bclr	#4,ost_primary_status(a0)
		move.b	#0,$3C(a0)
		move.w	#0,(v_enemy_combo).w
		move.b	#0,ost_flip_angle(a0)
		move.b	#0,ost_flip_turned(a0)
		move.b	#0,$2C(a0)
		move.w	#0,(v_sonic_look_delay_counter).w
		cmpi.b	#$14,ost_anim(a0)
		bne.s	locret_1B11E
		move.b	#0,ost_anim(a0)

locret_1B11E:
		rts
; ===========================================================================

Sonic_Hurt:
		tst.w	(f_debug_enable).w
		beq.s	loc_1B13A
		btst	#4,(v_joypad_press_actual).w
		beq.s	loc_1B13A
		move.w	#1,(v_debug_active).w
		clr.b	(f_lock_controls).w
		rts
; ===========================================================================

loc_1B13A:
		tst.b	ost_secondary_routine(a0)
		bmi.w	loc_1B1CA
		jsr	(SpeedToPos).l
		addi.w	#$30,ost_y_vel(a0)
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1B15C
		subi.w	#$20,ost_y_vel(a0)

loc_1B15C:
		cmpi.w	#-$100,(v_boundary_top).w
		bne.s	loc_1B16A
		andi.w	#$7FF,ost_y_pos(a0)

loc_1B16A:
		bsr.w	loc_1B184
		bsr.w	Sonic_LevelBound
		bsr.w	Sonic_RecordPosition
		bsr.w	Sonic_Animate
		bsr.w	Sonic_LoadGFX
		jmp	(DisplaySprite).l
; ===========================================================================

loc_1B184:
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		blt.w	JmpTo_KillCharacter
		bsr.w	Sonic_JumpCollision
		btst	#1,ost_primary_status(a0)
		bne.s	locret_1B1C8
		moveq	#0,d0
		move.w	d0,ost_y_vel(a0)
		move.w	d0,ost_x_vel(a0)
		move.w	d0,ost_inertia(a0)
		move.b	d0,$2A(a0)
		move.b	#0,ost_anim(a0)
		subq.b	#2,ost_primary_routine(a0)
		move.w	#$78,$30(a0)
		move.b	#0,$39(a0)

locret_1B1C8:
		rts
; ===========================================================================

loc_1B1CA:
		subq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_secondary_routine(a0)
		bsr.w	Sonic_RecordPosition
		bsr.w	Sonic_Animate
		bsr.w	Sonic_LoadGFX
		jmp	(DisplaySprite).l
; ===========================================================================

Sonic_Death:
		tst.w	(f_debug_enable).w
		beq.s	loc_1B200
		btst	#4,(v_joypad_press_actual).w
		beq.s	loc_1B200
		move.w	#1,(v_debug_active).w
		clr.b	(f_lock_controls).w
		rts
; ===========================================================================

loc_1B200:
		bsr.w	loc_1B21C
		jsr	(ObjectFall).l
		bsr.w	Sonic_RecordPosition
		bsr.w	Sonic_Animate
		bsr.w	Sonic_LoadGFX
		jmp	(DisplaySprite).l
; ===========================================================================

loc_1B21C:
		move.b	#1,(f_disable_scroll_p1).w
		move.b	#0,$39(a0)
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$100,d0
		cmp.w	ost_y_pos(a0),d0
		bge.w	locret_1B31A
		move.b	#8,ost_primary_routine(a0)
		move.w	#$3C,$3A(a0)
		addq.b	#1,(f_hud_lives_update).w
		subq.b	#1,(v_lives).w
		bne.s	Sonic_RestartLevel
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w
		move.b	#$39,($FFFFB0C0).w
		move.b	#1,($FFFFB0DA).w
		move.w	a0,($FFFFB0BE).w
		clr.b	(f_time_over).w

loc_1B26E:
		clr.b	(f_hud_time_update).w
		clr.b	(f_hud_time_update_p2).w
		move.b	#8,ost_primary_routine(a0)
		move.w	#$9B,d0
		jsr	(PlayMusic).l
		moveq	#3,d0
		jmp	(AddPLC).l
; ===========================================================================

Sonic_RestartLevel:
		tst.b	(f_time_over).w
		beq.s	loc_1B2B8
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w
		move.b	#$39,($FFFFB0C0).w
		move.b	#2,($FFFFB09A).w
		move.b	#3,($FFFFB0DA).w
		move.w	a0,($FFFFB0BE).w
		bra.s	loc_1B26E
; ===========================================================================

loc_1B2B8:
		tst.w	(f_two_player).w
		beq.s	locret_1B31A
		move.b	#0,(f_disable_scroll_p1).w
		move.b	#$A,ost_primary_routine(a0)
		move.w	(v_x_pos_lampcopy).w,ost_x_pos(a0)
		move.w	(v_y_pos_lampcopy).w,ost_y_pos(a0)
		move.w	(v_ost_tile_lampcopy).w,ost_tile(a0)
		move.w	(v_ost_top_solid_bit_lampcopy).w,$3E(a0)
		clr.w	(v_rings).w
		clr.b	(v_ring_reward).w
		move.b	#0,$2A(a0)
		move.b	#5,ost_anim(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		move.w	#0,ost_inertia(a0)
		move.b	#2,ost_primary_status(a0)
		move.w	#0,$2E(a0)
		move.w	#0,$3A(a0)

locret_1B31A:
		rts
; ===========================================================================

Sonic_ResetLevel:
		tst.w	$3A(a0)
		beq.s	locret_1B32E
		subq.w	#1,$3A(a0)
		bne.s	locret_1B32E
		move.w	#1,(f_restart).w

locret_1B32E:
		rts
; ===========================================================================

Sonic_Respawn:
		tst.w	(v_camera_x_diff).w
		bne.s	loc_1B342
		tst.w	(v_camera_y_diff).w
		bne.s	loc_1B342
		move.b	#2,ost_primary_routine(a0)

loc_1B342:
		bsr.w	Sonic_Animate
		bsr.w	Sonic_LoadGFX
		jmp	(DisplaySprite).l

; ===========================================================================

	if FixBugs
		; The mechanism used to drown the player (namely, the drowning countdown object
		; manually overriding their control and setting their animation and movement)
		; relies on the assumption that the character is in their normal routine (Sonic_Control).
		; Unfortunately, this leads to some edge cases: if the character is in their hurt
		; routine when they drown, the gravity from that state will still apply, and they can
		; still interact with floors and walls before the reset timer forces them off
		; the bottom of the screen. This issue also occurred in Sonic 1 and Sonic CD;
		; S3&K fixes it by completely rewriting the drowning mechanism, making it
		; a distinct primary routine for the character. The addition here, and changes
		; in DrownCount, are more or less backported from Sonic 3.

; ---------------------------------------------------------------------------
; Sonic when he's drowning
; ---------------------------------------------------------------------------

Sonic_Drown:
		bsr.w	SpeedToPos
		addi.w	#$10,ost_y_vel(a0)
		bsr.w	Sonic_RecordPosition
		bsr.s	Sonic_Animate
		bsr.w	Sonic_LoadGFX
		bra.w	DisplaySprite
	endc
; ===========================================================================

Sonic_Animate:
		lea	(Ani_Sonic).l,a1
		tst.b	(f_super).w
		beq.s	loc_1B362
		lea	(Ani_SuperSonic).l,a1

loc_1B362:
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		cmp.b	ost_anim_restart(a0),d0
		beq.s	loc_1B384
		move.b	d0,ost_anim_restart(a0)
		move.b	#0,ost_anim_frame(a0)
		move.b	#0,ost_anim_time(a0)
		bclr	#5,ost_primary_status(a0)

loc_1B384:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1
		move.b	(a1),d0
		bmi.s	loc_1B3F4
		move.b	ost_primary_status(a0),d1
		andi.b	#1,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_1B3C2
		move.b	d0,ost_anim_time(a0)

loc_1B3AA:
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		cmpi.b	#-$10,d0
		bcc.s	loc_1B3C4

loc_1B3BA:
		move.b	d0,ost_frame(a0)
		addq.b	#1,ost_anim_frame(a0)

locret_1B3C2:
		rts
; ===========================================================================

loc_1B3C4:
		addq.b	#1,d0
		bne.s	loc_1B3D4
		move.b	#0,ost_anim_frame(a0)
		move.b	1(a1),d0
		bra.s	loc_1B3BA
; ===========================================================================

loc_1B3D4:
		addq.b	#1,d0
		bne.s	loc_1B3E8
		move.b	2(a1,d1.w),d0
		sub.b	d0,ost_anim_frame(a0)
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0
		bra.s	loc_1B3BA
; ===========================================================================

loc_1B3E8:
		addq.b	#1,d0
		bne.s	locret_1B3F2
		move.b	2(a1,d1.w),ost_anim(a0)

locret_1B3F2:
		rts
; ===========================================================================

loc_1B3F4:
		addq.b	#1,d0
		bne.w	loc_1B586
		moveq	#0,d0
		move.b	ost_flip_angle(a0),d0
		bne.w	loc_1B520
		moveq	#0,d1
		move.b	ost_angle(a0),d0
		bmi.s	loc_1B410
		beq.s	loc_1B410
		subq.b	#1,d0

loc_1B410:
		move.b	ost_primary_status(a0),d2
		andi.b	#1,d2
		bne.s	loc_1B41C
		not.b	d0

loc_1B41C:
		addi.b	#$10,d0
		bpl.s	loc_1B424
		moveq	#3,d1

loc_1B424:
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		eor.b	d1,d2
		or.b	d2,ost_render(a0)
		btst	#5,ost_primary_status(a0)
		bne.w	loc_1B5D2
		lsr.b	#4,d0
		andi.b	#6,d0
		move.w	ost_inertia(a0),d2
		bpl.s	loc_1B448
		neg.w	d2

loc_1B448:
		tst.b	$2B(a0)
		bpl.w	loc_1B452
		add.w	d2,d2

loc_1B452:
		tst.b	(f_super).w
		bne.s	loc_1B4AE
		lea	(Ani_Son_Run).l,a1
		cmpi.w	#$600,d2
		bcc.s	loc_1B46C
		lea	(Ani_Son_Walk).l,a1
		add.b	d0,d0

loc_1B46C:
		add.b	d0,d0
		move.b	d0,d3
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		cmpi.b	#-1,d0
		bne.s	loc_1B48A
		move.b	#0,ost_anim_frame(a0)
		move.b	1(a1),d0

loc_1B48A:
		move.b	d0,ost_frame(a0)
		add.b	d3,ost_frame(a0)
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_1B4AC
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc_1B4A2
		moveq	#0,d2

loc_1B4A2:
		lsr.w	#8,d2
		move.b	d2,ost_anim_time(a0)
		addq.b	#1,ost_anim_frame(a0)

locret_1B4AC:
		rts
; ===========================================================================

loc_1B4AE:
		lea	(Ani_SupSon_Run).l,a1

loc_1B4B4:
		cmpi.w	#$800,d2
		bcc.s	loc_1B4C6
		lea	(Ani_SupSon_Walk).l,a1
		add.b	d0,d0
		add.b	d0,d0
		bra.s	loc_1B4C8
; ===========================================================================

loc_1B4C6:
		lsr.b	#1,d0

loc_1B4C8:
		move.b	d0,d3
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		cmpi.b	#-1,d0
		bne.s	loc_1B4E4
		move.b	#0,ost_anim_frame(a0)
		move.b	1(a1),d0

loc_1B4E4:
		move.b	d0,ost_frame(a0)
		add.b	d3,ost_frame(a0)
		move.b	(v_frame_counter_low).w,d1
		andi.b	#3,d1
		bne.s	loc_1B504
		cmpi.b	#-$4B,ost_frame(a0)
		bcc.s	loc_1B504
		addi.b	#$20,ost_frame(a0)

loc_1B504:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_1B51E
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc_1B514
		moveq	#0,d2

loc_1B514:
		lsr.w	#8,d2
		move.b	d2,ost_anim_time(a0)
		addq.b	#1,ost_anim_frame(a0)

locret_1B51E:
		rts
; ===========================================================================

loc_1B520:
		move.b	ost_flip_angle(a0),d0
		moveq	#0,d1
		move.b	ost_primary_status(a0),d2
		andi.b	#1,d2
		bne.s	loc_1B54E

loc_1B530:
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		addi.b	#$B,d0
		divu.w	#$16,d0
		addi.b	#$5F,d0
		move.b	d0,ost_frame(a0)

loc_1B546:
		move.b	#0,ost_anim_time(a0)
		rts
; ===========================================================================

loc_1B54E:
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		tst.b	ost_flip_turned(a0)
		beq.s	loc_1B566
		ori.b	#render_xflip,ost_render(a0)

loc_1B560:
		addi.b	#$B,d0
		bra.s	loc_1B572
; ===========================================================================

loc_1B566:
		ori.b	#render_xflip|render_yflip,ost_render(a0)
		neg.b	d0
		addi.b	#-$71,d0

loc_1B572:
		divu.w	#$16,d0
		addi.b	#$5F,d0
		move.b	d0,ost_frame(a0)
		move.b	#0,ost_anim_time(a0)
		rts
; ===========================================================================

loc_1B586:
		subq.b	#1,ost_anim_time(a0)
		bpl.w	locret_1B3C2
		addq.b	#1,d0
		bne.s	loc_1B5D2
		move.w	ost_inertia(a0),d2
		bpl.s	loc_1B59A
		neg.w	d2

loc_1B59A:
		lea	(Ani_Son_Roll2).l,a1
		cmpi.w	#$600,d2
		bcc.s	loc_1B5AC
		lea	(Ani_Son_Roll1).l,a1

loc_1B5AC:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc_1B5B6
		moveq	#0,d2

loc_1B5B6:
		lsr.w	#8,d2
		move.b	d2,ost_anim_time(a0)
		move.b	ost_primary_status(a0),d1
		andi.b	#1,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		bra.w	loc_1B3AA
; ===========================================================================

loc_1B5D2:
		subq.b	#1,ost_anim_time(a0)
		bpl.w	locret_1B3C2
		move.w	ost_inertia(a0),d2
		bmi.s	loc_1B5E2
		neg.w	d2

loc_1B5E2:
		addi.w	#$800,d2
		bpl.s	loc_1B5EA
		moveq	#0,d2

loc_1B5EA:
		lsr.w	#6,d2
		move.b	d2,ost_anim_time(a0)
		lea	(Ani_Son_Pushing).l,a1
		tst.b	(f_super).w
		beq.s	loc_1B602
		lea	(Ani_SupSon_Pushing).l,a1

loc_1B602:
		move.b	ost_primary_status(a0),d1
		andi.b	#1,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		bra.w	loc_1B3AA
; ===========================================================================

Ani_Sonic:	index offset(*)

SonicAnimations:	macro	flag1,flag2,sonic,tails
		ptr	Ani_Son_\sonic
		endm

		CharacterAnimations		SonicAnimations	; generate pointers and IDs for Sonic's animations
; ===========================================================================

Ani_Son_Walk:
		dc.b $FF
		dc.b id_Frame_Sonic_Walk13
		dc.b id_Frame_Sonic_Walk14
		dc.b id_Frame_Sonic_Walk15
		dc.b id_Frame_Sonic_Walk16
		dc.b id_Frame_Sonic_Walk17
		dc.b id_Frame_Sonic_Walk18
		dc.b id_Frame_Sonic_Walk11
		dc.b id_Frame_Sonic_Walk12
		dc.b afEnd

Ani_Son_Run:
		dc.b $FF
		dc.b id_Frame_Sonic_Run11
		dc.b id_Frame_Sonic_Run12
		dc.b id_Frame_Sonic_Run13
		dc.b id_Frame_Sonic_Run14
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		rev02even

Ani_Son_Roll1:
		dc.b $FE
		dc.b id_Frame_Sonic_Roll1
		dc.b id_Frame_Sonic_Roll5
		dc.b id_Frame_Sonic_Roll2
		dc.b id_Frame_Sonic_Roll5
		dc.b id_Frame_Sonic_Roll3
		dc.b id_Frame_Sonic_Roll5
		dc.b id_Frame_Sonic_Roll4
		dc.b id_Frame_Sonic_Roll5
		dc.b afEnd
		rev02even

Ani_Son_Roll2:
		dc.b $FE
		dc.b id_Frame_Sonic_Roll1
		dc.b id_Frame_Sonic_Roll5
		dc.b id_Frame_Sonic_Roll2
		dc.b id_Frame_Sonic_Roll5
		dc.b id_Frame_Sonic_Roll3
		dc.b id_Frame_Sonic_Roll5
		dc.b id_Frame_Sonic_Roll4
		dc.b id_Frame_Sonic_Roll5
		dc.b afEnd
		rev02even

Ani_Son_Pushing:
		dc.b $FD
		dc.b id_Frame_Sonic_Push1
		dc.b id_Frame_Sonic_Push2
		dc.b id_Frame_Sonic_Push3
		dc.b id_Frame_Sonic_Push4
		dc.b afEnd

		; Pointless beyond here.
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		rev02even

Ani_Son_Wait:
		dc.b 5
		rept 30
		; Standing
		dc.b id_Frame_Sonic_Stand
		endr
		dc.b id_Frame_Sonic_Blink
		dc.b id_Frame_Sonic_Wait1
		dc.b id_Frame_Sonic_Wait1
		dc.b id_Frame_Sonic_Wait1
		dc.b id_Frame_Sonic_Wait1
		dc.b id_Frame_Sonic_Wait1
		rept 4
		; Looking at player and at watch
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait2
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait3
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		dc.b id_Frame_Sonic_Wait4
		endr
		; Laying down
		dc.b id_Frame_Sonic_LayDown
		backdest id_Frame_Sonic_Laying1
		dc.b id_Frame_Sonic_Laying1
		dc.b id_Frame_Sonic_Laying1
		dc.b id_Frame_Sonic_Laying2
		dc.b id_Frame_Sonic_Laying2
		dc.b id_Frame_Sonic_Laying2
		afBack
		rev02even

Ani_Son_BalanceOut1:
		dc.b 9
		dc.b id_Frame_Sonic_Balance21
		dc.b id_Frame_Sonic_Balance22
		dc.b id_Frame_Sonic_Balance23
		dc.b id_Frame_Sonic_Balance22
		dc.b afEnd
		rev02even

Ani_Son_LookUp:
		dc.b 5
		dc.b id_Frame_Sonic_LookUp1
		backdest id_Frame_Sonic_LookUp2
		afBack
		rev02even

Ani_Son_Duck:
		dc.b 5
		dc.b id_Frame_Sonic_Duck1
		backdest id_Frame_Sonic_Duck2
		afBack
		rev02even

Ani_Son_Spindash:
		dc.b 0
		dc.b id_Frame_Sonic_Spindash1
		dc.b id_Frame_Sonic_Spindash2
		dc.b id_Frame_Sonic_Spindash1
		dc.b id_Frame_Sonic_Spindash3
		dc.b id_Frame_Sonic_Spindash1
		dc.b id_Frame_Sonic_Spindash4
		dc.b id_Frame_Sonic_Spindash1
		dc.b id_Frame_Sonic_Spindash5
		dc.b id_Frame_Sonic_Spindash1
		dc.b id_Frame_Sonic_Spindash6
		dc.b afEnd
		rev02even

Ani_Son_Blink:
		dc.b 1
		dc.b id_Frame_Sonic_Blink
		dc.b afChange,id_Ani_Son_Walk
		rev02even

Ani_Son_GetUp:
		dc.b 3
		dc.b id_Frame_Sonic_GetUp
		dc.b afChange,id_Ani_Son_Walk
		rev02even

Ani_Son_BalanceOut2:
		dc.b 3
		dc.b id_Frame_Sonic_Balance11
		dc.b id_Frame_Sonic_Balance12
		dc.b id_Frame_Sonic_Balance13
		dc.b id_Frame_Sonic_Balance14
		dc.b afEnd
		rev02even

Ani_Son_Stop:
		dc.b 5
		dc.b id_Frame_Sonic_Stop1
		dc.b id_Frame_Sonic_Stop2
		dc.b id_Frame_Sonic_Stop3
		dc.b id_Frame_Sonic_TurnAround
		dc.b afChange,id_Ani_Son_Walk
		rev02even

Ani_Son_Float1:
		dc.b 7
		dc.b id_Frame_Sonic_Float1
		dc.b id_Frame_Sonic_Float6
		dc.b afEnd

		rev02even

Ani_Son_Float2:
		dc.b 7
		dc.b id_Frame_Sonic_Float1
		dc.b id_Frame_Sonic_Float2
		dc.b id_Frame_Sonic_Float3
		dc.b id_Frame_Sonic_Float4
		dc.b id_Frame_Sonic_Float5
		dc.b afEnd
		rev02even

Ani_Son_Spring:
		dc.b $2F
		dc.b id_Frame_Sonic_Spring
		dc.b afChange,id_Ani_Son_Walk
		rev02even

Ani_Son_Hang1:
		dc.b 1
		dc.b id_Frame_Sonic_Hang11
		dc.b id_Frame_Sonic_Hang12
		dc.b afEnd
		rev02even

Ani_Son_Spindash2:
		dc.b $F
		dc.b id_Frame_Sonic_Spindash2
		dc.b id_Frame_Sonic_Spindash2
		backdest id_Frame_Sonic_Spindash2
		afBack
		rev02even

Ani_Son_Spindash3:
		dc.b $F
		dc.b id_Frame_Sonic_Spindash2
		backdest id_Frame_Sonic_Spindash3
		afBack
		rev02even

Ani_Son_Hang2:
		dc.b $13
		dc.b id_Frame_Sonic_Vine1
		dc.b id_Frame_Sonic_Vine2
		dc.b afEnd
		rev02even

Ani_Son_Bubble:
		dc.b $B
		dc.b id_Frame_Sonic_GetAir
		dc.b id_Frame_Sonic_GetAir
		dc.b id_Frame_Sonic_Walk15
		dc.b id_Frame_Sonic_Walk16
		dc.b afChange,id_Ani_Son_Walk
		rev02even

Ani_Son_Burnt:
		dc.b $20
		dc.b id_Frame_Sonic_Burnt
		dc.b afEnd
		rev02even

Ani_Son_Drown:
		dc.b $20
		dc.b id_Frame_Sonic_Drown
		dc.b afEnd
		rev02even

Ani_Son_Death:
		dc.b $20
		dc.b id_Frame_Sonic_Death
		dc.b afEnd
		rev02even

Ani_Son_Hurt:
		dc.b $40
		dc.b id_Frame_Sonic_Injury
		dc.b afEnd
		rev02even

Ani_Son_OilSlide:
		dc.b 9
		dc.b id_Frame_Sonic_Injury
		dc.b id_Frame_Sonic_OilSlide
		dc.b afEnd
		rev02even

Ani_Son_Blank:
		dc.b $77
		dc.b id_Frame_Sonic_Blank
		dc.b afChange,id_Ani_Son_Walk
		rev02even

Ani_Son_BalanceIn1:
		dc.b $13
		dc.b id_Frame_Sonic_Balance31
		dc.b id_Frame_Sonic_Balance32
		dc.b afEnd
		rev02even

Ani_Son_BalanceIn2:
		dc.b 3
		dc.b id_Frame_Sonic_LoseFooting
		backdest id_Frame_Sonic_Balance11		; identical to Ani_Son_BalanceOut2 from here on; could have been implemented with afChange
		dc.b id_Frame_Sonic_Balance12
		dc.b id_Frame_Sonic_Balance13
		dc.b id_Frame_Sonic_Balance14
		afBack
		rev02even

Ani_Son_Lying:
		dc.b 9
		dc.b id_Frame_Sonic_Laying1
		dc.b id_Frame_Sonic_Laying2
		dc.b afEnd
		rev02even

Ani_Son_LieDown:
		dc.b 3
		dc.b id_Frame_Sonic_LayDown
		dc.b afChange,id_Ani_Son_Walk
		rev02even
; ===========================================================================

Ani_SuperSonic:	index offset(*)

SuperSonicAnimations:	macro		flag1,flag2,sonic,tails
		if stricmp ("\flag1","s")
		ptr Ani_SupSon_\sonic				; use separate script for Super Sonic
		elseif	stricmp ("\flag1","n")			; Super Sonic does not use this animation
		else
		ptr	Ani_Son_\sonic				; Super Sonic uses same animation as normal Sonic
		endc
		endm

		CharacterAnimations		SuperSonicAnimations ; generate pointers and IDs for Super Sonic's animations
; ===========================================================================

Ani_SupSon_Walk:
		dc.b $FF
		dc.b id_Frame_SuperSonic_Walk13
		dc.b id_Frame_SuperSonic_Walk14
		dc.b id_Frame_SuperSonic_Walk15
		dc.b id_Frame_SuperSonic_Walk16
		dc.b id_Frame_SuperSonic_Walk17
		dc.b id_Frame_SuperSonic_Walk18
		dc.b id_Frame_SuperSonic_Walk11
		dc.b id_Frame_SuperSonic_Walk12
		dc.b afEnd
		rev02even

Ani_SupSon_Run:
		dc.b $FF
		dc.b id_Frame_SuperSonic_Run1
		dc.b id_Frame_SuperSonic_Run1_QuillUp
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		rev02even

Ani_SupSon_Pushing:
		dc.b $FD
		dc.b id_Frame_SuperSonic_Push1
		dc.b id_Frame_SuperSonic_Push2
		dc.b id_Frame_SuperSonic_Push3
		dc.b id_Frame_SuperSonic_Push4
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		dc.b afEnd
		rev02even

Ani_SupSon_Wait:
		dc.b 7
		dc.b id_Frame_SuperSonic_Stand1
		dc.b id_Frame_SuperSonic_Stand2
		dc.b id_Frame_SuperSonic_Stand3
		dc.b id_Frame_SuperSonic_Stand2
		dc.b afEnd
		rev02even

Ani_SupSon_BalanceOut1:
		dc.b 9
		dc.b id_Frame_SuperSonic_Balance1
		dc.b id_Frame_SuperSonic_Balance2
		dc.b id_Frame_SuperSonic_Balance3
		dc.b id_Frame_SuperSonic_Balance2
		dc.b id_Frame_SuperSonic_Balance4
		dc.b id_Frame_SuperSonic_Balance5
		dc.b id_Frame_SuperSonic_Balance6
		dc.b id_Frame_SuperSonic_Balance5
		dc.b afEnd
		rev02even

Ani_SupSon_Duck:
		dc.b 5
		dc.b id_Frame_SuperSonic_Duck
		dc.b afEnd
		rev02even

Ani_Son_Transform:
		dc.b 2
		dc.b id_Frame_SuperSonic_Transform1
		dc.b id_Frame_SuperSonic_Transform1
		dc.b id_Frame_SuperSonic_Transform2
		dc.b id_Frame_SuperSonic_Transform2
		dc.b id_Frame_SuperSonic_Transform3
		rept 4
		dc.b id_Frame_SuperSonic_Transform4
		dc.b id_Frame_SuperSonic_Transform5
		endr
		dc.b afChange,id_Ani_SupSon_Walk

		even

		align 4
; ===========================================================================

Sonic_LoadGFX:
		moveq	#0,d0
		move.b	ost_frame(a0),d0

	Sonic_LoadGFX_2:
		cmp.b	(v_sonic_last_frame_id).w,d0
		beq.s	locret_1B89A
		move.b	d0,(v_sonic_last_frame_id).w
		lea	(DPLC_Sonic).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_1B89A
		move.w	#-$1000,d4

	loc_1B86E:
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		addi.l	#Art_Sonic,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(AddDMA).l
		dbf	d5,loc_1B86E

locret_1B89A:
		rts
; ===========================================================================

JmpTo_KillCharacter:
		jmp	(KillCharacter).l

	if RemoveJmpTos=0
		align 4
	endc


	if FixBugs
		; The game manually sets speeds whenever including changes to the character's
		; speeds are required, but not every possible case is covered, Speed Shoes while
		; underwater, Speed Shoes when Super, and Speed Shoes when Super while underwater
		; do not have any defined speeds, leading to erratic behavior in these circumstances.
		; Instead of manually setting the top speed, acceleration, and deceleration variables
		; manually, we can define all of the possible combination in an array and create a
		; subroutine that determines which speed to apply and applies it, branching to said
		; subroutine every time we need to change a character's speed.

; ---------------------------------------------------------------------------
; Subroutine to set the speed, acceleration, and deceleration for a character

; input:
; 	a0 = player's OST
;	a2 = player's maximum speed variable

;	uses d0.l, a1
; ---------------------------------------------------------------------------

ApplySpeedSettings:
		moveq	#0,d0
		tst.w	ost_speedshoe_time(a0)			; does player have speed shoes?
		beq.s	.nospeedshoes				; branch if not
		addq.b	#6,d0					; +6 for speed shoes

	.nospeedshoes:
		btst	#status_underwater_bit,ost_primary_status(a0) ; is the player underwater?
		beq.s	.notunderwater				; branch if not
		addi.b	#12,d0					; +12 for underwater

	.notunderwater:
		cmpa.w	#v_ost_player1,a0			; is it Tails?
		bne.s	.notsuper				; branch if so
		tst.b	(f_super).w				; is Sonic super?
		beq.s	.notsuper				;branch if not
		addi.b	#24,d0					; +24 for super form

	.notsuper:
		lea	SpeedSettings(pc,d0.w),a1		; a1 = pointer to speed settings
		move.l	(a1)+,(a2)+				; set player's new top speed and acceleration
		move.w	(a1),(a2)				; set player's deceleration
		rts

; ----------------------------------------------------------------------------
; Speed settings array
; Each entry is 6 bytes, containing the top speed, acceleration, and
; deceleration for each possible state
; ----------------------------------------------------------------------------

SpeedSettings:
		dc.w	sonic_max_speed,			sonic_acceleration,				sonic_deceleration ; 0 	; normal
		dc.w	sonic_max_speed_shoes,		sonic_acceleration_shoes,		sonic_deceleration_shoes ; 6		; normal speedshoes
		dc.w	sonic_max_speed_water,		sonic_acceleration_water,		sonic_deceleration_water ; $C	; normal underwater
		dc.w	sonic_max_speed,			sonic_acceleration,				sonic_deceleration_water ; $12	; normal underwater speedshoes
		dc.w	sonic_max_speed_super,		sonic_acceleration_super,		sonic_deceleration_super ; $18	; super
		dc.w	sonic_max_speed_shoes,		sonic_acceleration_super,		sonic_deceleration_super ; $1E	; super speedshoes
		dc.w	sonic_max_speed_super/2,	sonic_acceleration_super/2,		sonic_deceleration_super/2 ; $24	; super underwater
		dc.w	sonic_max_speed_shoes,		sonic_acceleration_super,		sonic_deceleration_super/2 ; $2A	; super underwater speedshoes
; ===========================================================================

	endc

; ----------------------------------------------------------------------------
; Object 02 - Tails
; ----------------------------------------------------------------------------

TailsPlayer:
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_1B8BE
		move.w	(v_boundary_left).w,(v_boundary_left_p2).w
		move.w	(v_boundary_right).w,(v_boundary_right_p2).w
		move.w	(v_boundary_bottom).w,(v_boundary_bottom_p2).w

loc_1B8BE:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Tails_Index(pc,d0.w),d1
		jmp	Tails_Index(pc,d1.w)
; ===========================================================================
TailsRoutines:	macro	routinename
		ptr	Tails_\routinename
		endm

Tails_Index:	index offset(*),,2
		CharacterRoutines	TailsRoutines		; generate pointers and IDs for Tails' primary routines
; ===========================================================================

Tails_Main:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$F,ost_height(a0)
		move.b	#9,ost_width(a0)
		move.l	#Map_Tails,ost_mappings(a0)
		move.b	#2,ost_priority(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#render_rel|render_onscreen,ost_render(a0)
		move.w	#$600,(v_tails_max_speed).w
		move.w	#$C,(v_tails_acceleration).w
		move.w	#$80,(v_tails_deceleration).w
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_1B952
		tst.b	(v_last_lamppost).w
		bne.s	loc_1B96E
		move.w	#tile_Tails,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#$C,$3E(a0)
		move.b	#$D,$3F(a0)
		move.w	ost_x_pos(a0),(v_x_pos_lampcopy).w
		move.w	ost_y_pos(a0),(v_y_pos_lampcopy).w
		move.w	ost_tile(a0),(v_ost_tile_lampcopy).w
		move.w	$3E(a0),(v_ost_top_solid_bit_lampcopy).w
		bra.s	loc_1B96E
; ===========================================================================

loc_1B952:
		move.w	#tile_Tails,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.w	(v_ost_player1+ost_top_solid_bit).w,$3E(a0)
		tst.w	(v_ost_player1+ost_tile).w
		bpl.s	loc_1B96E
		ori.w	#tile_hi,ost_tile(a0)

loc_1B96E:
		move.w	ost_x_pos(a0),(v_x_pos_p2_lampcopy).w
		move.w	ost_y_pos(a0),(v_y_pos_p2_lampcopy).w
		move.w	ost_tile(a0),(v_ost_tile_p2_lampcopy).w
		move.w	$3E(a0),(v_ost_top_solid_bit_p2_lampcopy).w
		move.b	#0,$2C(a0)
		move.b	#4,$2D(a0)
		move.b	#air_full,ost_air_left(a0)
		move.w	#0,(v_tails_cpu_routine).w
		move.w	#0,(v_tails_control_counter).w
		move.w	#0,(v_tails_respawn_counter).w
		move.b	#5,(v_ost_lo_tails_tails).w
		move.w	a0,(v_ost_lo_tails_tails+ost_parent1).w

Tails_Control:
		cmpa.w	#v_ost_player1,a0
		bne.s	loc_1B9D4
		move.w	(v_joypad_hold).w,(v_joypad2_hold).w
		tst.b	(f_lock_controls).w
		bne.s	loc_1B9EA
		move.w	(v_joypad_hold_actual).w,(v_joypad2_hold).w
		move.w	(v_joypad_hold_actual).w,(v_joypad_hold).w
		bra.s	loc_1B9EA
; ===========================================================================

loc_1B9D4:
		tst.b	(f_lock_controls_p2).w
		bne.s	loc_1B9E0
		move.w	(v_joypad2_hold_actual).w,(v_joypad2_hold).w

loc_1B9E0:
		tst.w	(f_two_player).w
		bne.s	loc_1B9EA
		bsr.w	loc_1BAD4

loc_1B9EA:
		btst	#0,$2A(a0)
		bne.s	loc_1BA04
		moveq	#0,d0
		move.b	ost_primary_status(a0),d0
		andi.w	#status_air+status_jump,d0
		move.w	Tails_Modes(pc,d0.w),d1
		jsr	Tails_Modes(pc,d1.w)

loc_1BA04:
		cmpi.w	#-$100,(v_boundary_top).w
		bne.s	loc_1BA12
		andi.w	#$7FF,ost_y_pos(a0)

loc_1BA12:
		bsr.s	loc_1BA56
		bsr.w	Tails_RecordPosition
		bsr.w	loc_1BF52
		move.b	(v_angle_right).w,$36(a0)
		move.b	(v_angle_left).w,$37(a0)
		tst.b	(f_wind_tunnel_now).w
		beq.s	loc_1BA3A
		tst.b	ost_anim(a0)
		bne.s	loc_1BA3A
		move.b	ost_anim_restart(a0),ost_anim(a0)

loc_1BA3A:
		bsr.w	Tails_Animate
		tst.b	$2A(a0)
		bmi.s	loc_1BA4A
		jsr	(ReactToItem).l

loc_1BA4A:
		bra.w	Tails_LoadGFX
; ===========================================================================
Tails_Modes:	index offset(*),,2
		ptr loc_1C00A					; 0
		ptr loc_1C032					; 2
		ptr loc_1C05C					; 4
		ptr loc_1C082					; 6
; ===========================================================================

loc_1BA56:
		move.w	$30(a0),d0
		beq.s	loc_1BA64
		subq.w	#1,$30(a0)
		lsr.w	#3,d0
		bcc.s	loc_1BA6A

loc_1BA64:
		jsr	(DisplaySprite).l

loc_1BA6A:
		btst	#1,$2B(a0)
		beq.s	loc_1BA9C
		tst.w	$32(a0)
		beq.s	loc_1BA9C
		subq.w	#1,$32(a0)
		bne.s	loc_1BA9C
		tst.b	(v_current_boss).w
		bne.s	loc_1BA96
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	loc_1BA96
		move.w	(v_level_music).w,d0
		jsr	(PlayMusic).l

loc_1BA96:
		bclr	#1,$2B(a0)

loc_1BA9C:
		btst	#2,$2B(a0)
		beq.s	locret_1BAD2
		tst.w	$34(a0)
		beq.s	locret_1BAD2
		subq.w	#1,$34(a0)
		bne.s	locret_1BAD2
		move.w	#$600,(v_tails_max_speed).w
		move.w	#$C,(v_tails_acceleration).w
		move.w	#$80,(v_tails_deceleration).w
		bclr	#2,$2B(a0)
		move.w	#$FC,d0
		jmp	(PlayMusic).l
; ===========================================================================

locret_1BAD2:
		rts
; ===========================================================================

loc_1BAD4:
		move.b	(v_joypad2_hold_actual).w,d0
		andi.b	#$7F,d0
		beq.s	loc_1BAE4
		move.w	#$258,(v_tails_control_counter).w

loc_1BAE4:
		lea	($FFFFB000).w,a1
		move.w	(v_tails_cpu_routine).w,d0
		move.w	off_1BAF4(pc,d0.w),d0
		jmp	off_1BAF4(pc,d0.w)
; ===========================================================================
off_1BAF4:	index offset(*),,2
		ptr loc_1BAFE					; 0
		ptr loc_1BB30					; 2
		ptr loc_1BB8A					; 4
		ptr loc_1BCE0					; 6
		ptr loc_1BEB8					; 8
; ===========================================================================

loc_1BAFE:
		move.w	#6,(v_tails_cpu_routine).w
		move.b	#0,$2A(a0)
		move.b	#0,ost_anim(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		move.w	#0,ost_inertia(a0)
		move.b	#0,ost_primary_status(a0)
		move.w	#0,(v_tails_respawn_counter).w
		rts
; ===========================================================================

loc_1BB30:
		move.b	(v_joypad2_hold).w,d0
		andi.b	#-$10,d0
		bne.s	loc_1BB54
		move.w	(v_frame_counter).w,d0
		andi.w	#$3F,d0
		bne.s	locret_1BB88
		tst.b	$2A(a1)
		bne.s	locret_1BB88
		move.b	ost_primary_status(a1),d0
		andi.b	#-$2E,d0
		bne.s	locret_1BB88

loc_1BB54:
		move.w	#4,(v_tails_cpu_routine).w
		move.w	ost_x_pos(a1),d0
		move.w	d0,ost_x_pos(a0)
		move.w	d0,(v_tails_cpu_x_target).w
		move.w	ost_y_pos(a1),d0
		move.w	d0,(v_tails_cpu_y_target).w
		subi.w	#$C0,d0
		move.w	d0,ost_y_pos(a0)
		ori.w	#tile_hi,ost_tile(a0)
		move.b	#0,$39(a0)
		move.w	#0,$3A(a0)

locret_1BB88:
		rts
; ===========================================================================

loc_1BB8A:
		tst.b	ost_render(a0)
		bmi.s	loc_1BBC8
		addq.w	#1,(v_tails_respawn_counter).w
		cmpi.w	#$12C,(v_tails_respawn_counter).w
		bcs.s	loc_1BBCE
		move.w	#0,(v_tails_respawn_counter).w
		move.w	#2,(v_tails_cpu_routine).w
		move.b	#-$7F,$2A(a0)
		move.b	#2,ost_primary_status(a0)
		move.w	#0,ost_x_pos(a0)
		move.w	#0,ost_y_pos(a0)
		move.b	#$20,ost_anim(a0)
		rts
; ===========================================================================

loc_1BBC8:
		move.w	#0,(v_tails_respawn_counter).w

loc_1BBCE:
		lea	(v_sonic_pos_tracker).w,a2
		move.w	#$10,d2
		lsl.b	#2,d2
		addq.b	#4,d2
		move.w	(v_sonic_pos_tracker_num).w,d3
		sub.b	d2,d3
		move.w	(a2,d3.w),(v_tails_cpu_x_target).w
		move.w	2(a2,d3.w),(v_tails_cpu_y_target).w
		tst.b	(f_water).w
		beq.s	loc_1BC04
		move.w	(v_water_height_actual).w,d0
		subi.w	#$10,d0
		cmp.w	(v_tails_cpu_y_target).w,d0
		bge.s	loc_1BC04
		move.w	d0,(v_tails_cpu_y_target).w

loc_1BC04:
		move.w	ost_x_pos(a0),d0
		sub.w	(v_tails_cpu_x_target).w,d0
		beq.s	loc_1BC54
		move.w	d0,d2
		bpl.s	loc_1BC14
		neg.w	d2

loc_1BC14:
		lsr.w	#4,d2
		cmpi.w	#$C,d2
		bcs.s	loc_1BC1E
		moveq	#$C,d2

loc_1BC1E:
		move.b	ost_x_vel(a1),d1
		bpl.s	loc_1BC26
		neg.b	d1

loc_1BC26:
		add.b	d1,d2
		addq.w	#1,d2
		tst.w	d0
		bmi.s	loc_1BC40
		bset	#status_xflip_bit,ost_primary_status(a0)
		cmp.w	d0,d2
		bcs.s	loc_1BC3C
		move.w	d0,d2
		moveq	#0,d0

loc_1BC3C:
		neg.w	d2
		bra.s	loc_1BC50
; ===========================================================================

loc_1BC40:
		bclr	#status_xflip_bit,ost_primary_status(a0)
		neg.w	d0
		cmp.w	d0,d2
		bcs.s	loc_1BC50
		move.b	d0,d2
		moveq	#0,d0

loc_1BC50:
		add.w	d2,ost_x_pos(a0)

loc_1BC54:
		moveq	#1,d2
		move.w	ost_y_pos(a0),d1
		sub.w	(v_tails_cpu_y_target).w,d1
		beq.s	loc_1BC68
		bmi.s	loc_1BC64
		neg.w	d2

loc_1BC64:
		add.w	d2,ost_y_pos(a0)

loc_1BC68:
		lea	(v_sonic_stat_tracker).w,a2
		move.b	2(a2,d3.w),d2
		andi.b	#-$2E,d2
		bne.s	locret_1BCDE
		or.w	d0,d1
		bne.s	locret_1BCDE
		move.w	#6,(v_tails_cpu_routine).w
		move.b	#0,$2A(a0)
		move.b	#0,ost_anim(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		move.w	#0,ost_inertia(a0)
		move.b	#2,ost_primary_status(a0)
		move.w	#0,$2E(a0)
		andi.w	#tile_draw,ost_tile(a0)
		tst.b	ost_tile(a1)
		bpl.s	loc_1BCBC
		ori.w	#tile_hi,ost_tile(a0)

loc_1BCBC:
		move.b	$3E(a1),$3E(a0)
		move.b	$3F(a1),$3F(a0)
		cmpi.b	#9,ost_anim(a1)
		beq.s	locret_1BCDE
		move.b	$39(a0),d0
		beq.s	locret_1BCDE
		move.b	d0,$39(a1)
		bsr.w	loc_212C4

locret_1BCDE:
		rts
; ===========================================================================

loc_1BCE0:
		cmpi.b	#6,($FFFFB024).w
		bcs.s	loc_1BD0E
		move.w	#4,(v_tails_cpu_routine).w
		move.b	#0,$39(a0)
		move.w	#0,$3A(a0)
		move.b	#-$7F,$2A(a0)
		move.b	#2,ost_primary_status(a0)
		move.b	#$20,ost_anim(a0)
		rts
; ===========================================================================

loc_1BD0E:
		bsr.w	loc_1BE66
		tst.w	(v_tails_control_counter).w
		bne.w	loc_1BE28
		tst.b	$2A(a0)
		bmi.w	loc_1BE28
		tst.w	$2E(a0)
		beq.s	loc_1BD34
		tst.w	ost_inertia(a0)
		bne.s	loc_1BD34
		move.w	#8,(v_tails_cpu_routine).w

loc_1BD34:
		lea	(v_sonic_pos_tracker).w,a1
		move.w	#$10,d1
		lsl.b	#2,d1
		addq.b	#4,d1
		move.w	(v_sonic_pos_tracker_num).w,d0
		sub.b	d1,d0
		move.w	(a1,d0.w),d2
		move.w	2(a1,d0.w),d3
		lea	(v_sonic_stat_tracker).w,a1
		move.w	(a1,d0.w),d1
		move.b	2(a1,d0.w),d4
		move.w	d1,d0
		btst	#5,ost_primary_status(a0)
		beq.s	loc_1BD6C
		btst	#5,d4
		beq.w	loc_1BE06

loc_1BD6C:
		sub.w	ost_x_pos(a0),d2
		beq.s	loc_1BDBA
		bpl.s	loc_1BD98
		neg.w	d2
		cmpi.w	#$10,d2
		bcs.s	loc_1BD84
		andi.w	#-$C0D,d1
		ori.w	#$404,d1

loc_1BD84:
		tst.w	ost_inertia(a0)
		beq.s	loc_1BDCE
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1BDCE
		subq.w	#1,ost_x_pos(a0)
		bra.s	loc_1BDCE
; ===========================================================================

loc_1BD98:
		cmpi.w	#$10,d2
		bcs.s	loc_1BDA6
		andi.w	#-$C0D,d1
		ori.w	#$808,d1

loc_1BDA6:
		tst.w	ost_inertia(a0)
		beq.s	loc_1BDCE
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_1BDCE
		addq.w	#1,ost_x_pos(a0)
		bra.s	loc_1BDCE
; ===========================================================================

loc_1BDBA:
		bclr	#status_xflip_bit,ost_primary_status(a0)
		move.b	d4,d0
		andi.b	#1,d0
		beq.s	loc_1BDCE
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_1BDCE:
		tst.b	(f_tails_cpu_jumping).w
		beq.s	loc_1BDE6
		ori.w	#$7000,d1
		btst	#1,ost_primary_status(a0)
		bne.s	loc_1BE22
		move.b	#0,(f_tails_cpu_jumping).w

loc_1BDE6:
		move.w	(v_frame_counter).w,d0
		andi.w	#$FF,d0
		beq.s	loc_1BDF6
		cmpi.w	#$40,d2
		bcc.s	loc_1BE22

loc_1BDF6:
		sub.w	ost_y_pos(a0),d3
		beq.s	loc_1BE22
		bpl.s	loc_1BE22
		neg.w	d3
		cmpi.w	#$20,d3
		bcs.s	loc_1BE22

loc_1BE06:
		move.b	(v_frame_counter_low).w,d0
		andi.b	#$3F,d0
		bne.s	loc_1BE22
		cmpi.b	#8,ost_anim(a0)
		beq.s	loc_1BE22
		ori.w	#$7070,d1
		move.b	#1,(f_tails_cpu_jumping).w

loc_1BE22:
		move.w	d1,(v_joypad2_hold).w
		rts
; ===========================================================================

loc_1BE28:
		tst.w	(v_tails_control_counter).w
		beq.s	locret_1BE32
		subq.w	#1,(v_tails_control_counter).w

locret_1BE32:
		rts
; ===========================================================================

loc_1BE34:
		move.w	#0,(v_tails_control_counter).w
		move.w	#0,(v_tails_respawn_counter).w
		move.w	#2,(v_tails_cpu_routine).w
		move.b	#-$7F,$2A(a0)
		move.b	#2,ost_primary_status(a0)
		move.w	#$4000,ost_x_pos(a0)
		move.w	#0,ost_y_pos(a0)			; could be clr.w
		move.b	#$20,ost_anim(a0)
		rts
; ===========================================================================

loc_1BE66:
		tst.b	ost_render(a0)
		bmi.s	loc_1BE9C
		btst	#3,ost_primary_status(a0)
		beq.s	loc_1BE8C
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a3
		move.b	(v_tails_interact_id).w,d0
		cmp.b	(a3),d0
		bne.s	loc_1BE98

loc_1BE8C:
		addq.w	#1,(v_tails_respawn_counter).w
		cmpi.w	#$12C,(v_tails_respawn_counter).w
		bcs.s	loc_1BEA2

loc_1BE98:
		bra.w	loc_1BE34
; ===========================================================================

loc_1BE9C:
		move.w	#0,(v_tails_respawn_counter).w

loc_1BEA2:
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a3
		move.b	(a3),(v_tails_interact_id).w
		rts
; ===========================================================================

loc_1BEB8:
		bsr.w	loc_1BE66
		tst.w	(v_tails_control_counter).w
		bne.w	locret_1BF36
		tst.w	$2E(a0)
		bne.s	locret_1BF36
		tst.b	$39(a0)
		bne.s	loc_1BF0C
		tst.w	ost_inertia(a0)
		bne.s	locret_1BF36
		bclr	#status_xflip_bit,ost_primary_status(a0)
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcs.s	loc_1BEEC
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_1BEEC:
		move.w	#$202,(v_joypad2_hold).w
		move.b	(v_frame_counter_low).w,d0
		andi.b	#$7F,d0
		beq.s	loc_1BF1C
		cmpi.b	#8,ost_anim(a0)
		bne.s	locret_1BF36
		move.w	#$7272,(v_joypad2_hold).w
		rts
; ===========================================================================

loc_1BF0C:
		move.w	#$202,(v_joypad2_hold).w
		move.b	(v_frame_counter_low).w,d0
		andi.b	#$7F,d0
		bne.s	loc_1BF2A

loc_1BF1C:
		move.w	#0,(v_joypad2_hold).w
		move.w	#6,(v_tails_cpu_routine).w
		rts
; ===========================================================================

loc_1BF2A:
		andi.b	#$1F,d0
		bne.s	locret_1BF36
		ori.w	#$7070,(v_joypad2_hold).w

locret_1BF36:
		rts
; ===========================================================================

Tails_RecordPosition:
		move.w	(v_tails_pos_tracker_num).w,d0
		lea	(v_tails_pos_tracker).w,a1
		lea	(a1,d0.w),a1
		move.w	ost_x_pos(a0),(a1)+
		move.w	ost_y_pos(a0),(a1)+
		addq.b	#4,($FFFFEED7).w
		rts
; ===========================================================================

loc_1BF52:
		tst.b	(f_water).w
		bne.s	loc_1BF5A

locret_1BF58:
		rts
; ===========================================================================

loc_1BF5A:
		move.w	(v_water_height_actual).w,d0
		cmp.w	ost_y_pos(a0),d0
		bge.s	loc_1BFB2
		bset	#status_underwater_bit,ost_primary_status(a0)
		bne.s	locret_1BF58
		movea.l	a0,a1
		bsr.w	ResumeMusic
		move.b	#$A,($FFFFD0C0).w
		move.b	#-$7F,($FFFFD0E8).w
		move.l	a0,($FFFFD0FC).w
		move.w	#$300,(v_tails_max_speed).w
		move.w	#6,(v_tails_acceleration).w
		move.w	#$40,(v_tails_deceleration).w
		asr	ost_x_vel(a0)
		asr	ost_y_vel(a0)
		asr	ost_y_vel(a0)
		beq.s	locret_1BF58
		move.w	#$100,($FFFFD15C).w
		move.w	#$AA,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_1BFB2:
		bclr	#status_underwater_bit,ost_primary_status(a0)
		beq.s	locret_1BF58
		movea.l	a0,a1
		bsr.w	ResumeMusic
		move.w	#$600,(v_tails_max_speed).w
		move.w	#$C,(v_tails_acceleration).w
		move.w	#$80,(v_tails_deceleration).w
		cmpi.b	#4,ost_primary_routine(a0)
		beq.s	loc_1BFDE
		asl	ost_y_vel(a0)

loc_1BFDE:
		tst.w	ost_y_vel(a0)
		beq.w	locret_1BF58
		move.w	#$100,($FFFFD15C).w
		movea.l	a0,a1
		bsr.w	ResumeMusic
		cmpi.w	#-$1000,ost_y_vel(a0)
		bgt.s	loc_1C000
		move.w	#-$1000,ost_y_vel(a0)

loc_1C000:
		move.w	#$AA,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_1C00A:
		bsr.w	loc_1C70E
		bsr.w	loc_1C61E
		bsr.w	loc_1C846
		bsr.w	loc_1C0AC
		bsr.w	loc_1C5B8
		bsr.w	loc_1C55A
		jsr	(SpeedToPos).l
		bsr.w	Player_AnglePos
		bsr.w	loc_1C8B8
		rts
; ===========================================================================

loc_1C032:
		bsr.w	loc_1C6CC
		bsr.w	loc_1C4CE
		bsr.w	loc_1C55A
		jsr	(ObjectFall).l
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1C052
		subi.w	#$28,ost_y_vel(a0)

loc_1C052:
		bsr.w	loc_1C8FA
		bsr.w	loc_1C95A
		rts
; ===========================================================================

loc_1C05C:
		tst.b	$39(a0)
		bne.s	loc_1C066
		bsr.w	loc_1C61E

loc_1C066:
		bsr.w	loc_1C87C
		bsr.w	loc_1C3AA
		bsr.w	loc_1C55A
		jsr	(SpeedToPos).l
		bsr.w	Player_AnglePos
		bsr.w	loc_1C8B8
		rts
; ===========================================================================

loc_1C082:
		bsr.w	loc_1C6CC
		bsr.w	loc_1C4CE
		bsr.w	loc_1C55A
		jsr	(ObjectFall).l
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1C0A2
		subi.w	#$28,ost_y_vel(a0)

loc_1C0A2:
		bsr.w	loc_1C8FA
		bsr.w	loc_1C95A
		rts
; ===========================================================================

loc_1C0AC:
		move.w	(v_tails_max_speed).w,d6
		move.w	(v_tails_acceleration).w,d5
		move.w	(v_tails_deceleration).w,d4
		tst.b	$2B(a0)
		bmi.w	loc_1C214
		tst.w	$2E(a0)
		bne.w	loc_1C1D0
		btst	#2,(v_joypad2_hold).w
		beq.s	loc_1C0D4
		bsr.w	loc_1C2A4

loc_1C0D4:
		btst	#3,(v_joypad2_hold).w
		beq.s	loc_1C0E0
		bsr.w	loc_1C32A

loc_1C0E0:
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#-$40,d0
		bne.w	loc_1C1D0
		tst.w	ost_inertia(a0)
		bne.w	loc_1C1D0
		bclr	#5,ost_primary_status(a0)
		move.b	#5,ost_anim(a0)
		btst	#3,ost_primary_status(a0)
		beq.s	loc_1C142
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFB000).w,a1
		lea	(a1,d0.w),a1
		tst.b	ost_primary_status(a1)
		bmi.s	loc_1C174
		moveq	#0,d1
		move.b	ost_displaywidth(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	ost_x_pos(a0),d1
		sub.w	ost_x_pos(a1),d1
		cmpi.w	#4,d1
		blt.s	loc_1C166
		cmp.w	d2,d1
		bge.s	loc_1C156
		bra.s	loc_1C174
; ===========================================================================

loc_1C142:
		jsr	(FindFloorObj_ChkCol).l
		cmpi.w	#$C,d1
		blt.s	loc_1C174
		cmpi.b	#3,$36(a0)
		bne.s	loc_1C15E

loc_1C156:
		bclr	#status_xflip_bit,ost_primary_status(a0)
		bra.s	loc_1C16C
; ===========================================================================

loc_1C15E:
		cmpi.b	#3,$37(a0)
		bne.s	loc_1C174

loc_1C166:
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_1C16C:
		move.b	#6,ost_anim(a0)
		bra.s	loc_1C1D0
; ===========================================================================

loc_1C174:
		btst	#0,(v_joypad2_hold).w
		beq.s	loc_1C1A2
		move.b	#7,ost_anim(a0)
		addq.w	#1,(v_tails_look_delay_counter).w
		cmpi.w	#$78,(v_tails_look_delay_counter).w
		bcs.s	loc_1C1D6
		move.w	#$78,(v_tails_look_delay_counter).w
		cmpi.w	#$C8,(v_camera_y_shift_p2).w
		beq.s	loc_1C1E8
		addq.w	#2,(v_camera_y_shift_p2).w
		bra.s	loc_1C1E8
; ===========================================================================

loc_1C1A2:
		btst	#1,(v_joypad2_hold).w
		beq.s	loc_1C1D0
		move.b	#8,ost_anim(a0)
		addq.w	#1,(v_tails_look_delay_counter).w
		cmpi.w	#$78,(v_tails_look_delay_counter).w
		bcs.s	loc_1C1D6
		move.w	#$78,(v_tails_look_delay_counter).w
		cmpi.w	#8,(v_camera_y_shift_p2).w
		beq.s	loc_1C1E8
		subq.w	#2,(v_camera_y_shift_p2).w
		bra.s	loc_1C1E8
; ===========================================================================

loc_1C1D0:
		move.w	#0,(v_tails_look_delay_counter).w

loc_1C1D6:
		cmpi.w	#$60,(v_camera_y_shift_p2).w
		beq.s	loc_1C1E8
		bcc.s	loc_1C1E4
		addq.w	#4,(v_camera_y_shift_p2).w

loc_1C1E4:
		subq.w	#2,(v_camera_y_shift_p2).w

loc_1C1E8:
		move.b	(v_joypad2_hold).w,d0
		andi.b	#$C,d0
		bne.s	loc_1C214
		move.w	ost_inertia(a0),d0
		beq.s	loc_1C214
		bmi.s	loc_1C208
		sub.w	d5,d0
		bcc.s	loc_1C202
		move.w	#0,d0

loc_1C202:
		move.w	d0,ost_inertia(a0)
		bra.s	loc_1C214
; ===========================================================================

loc_1C208:
		add.w	d5,d0
		bcc.s	loc_1C210
		move.w	#0,d0

loc_1C210:
		move.w	d0,ost_inertia(a0)

loc_1C214:
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	ost_inertia(a0),d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a0)
		muls.w	ost_inertia(a0),d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a0)

loc_1C232:
		move.b	ost_angle(a0),d0
		addi.b	#$40,d0
		bmi.s	locret_1C2A2
		move.b	#$40,d1
		tst.w	ost_inertia(a0)
		beq.s	locret_1C2A2
		bmi.s	loc_1C24A
		neg.w	d1

loc_1C24A:
		move.b	ost_angle(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr.w	Player_CalcRoomAhead
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret_1C2A2
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#-$40,d0
		beq.s	loc_1C29E
		cmpi.b	#$40,d0
		beq.s	loc_1C28C
		cmpi.b	#-$80,d0
		beq.s	loc_1C286
		add.w	d1,ost_x_vel(a0)
		bset	#5,ost_primary_status(a0)
		move.w	#0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1C286:
		sub.w	d1,ost_y_vel(a0)
		rts
; ===========================================================================

loc_1C28C:
		sub.w	d1,ost_x_vel(a0)
		bset	#5,ost_primary_status(a0)
		move.w	#0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1C29E:
		add.w	d1,ost_y_vel(a0)

locret_1C2A2:
		rts
; ===========================================================================

loc_1C2A4:
		move.w	ost_inertia(a0),d0
		beq.s	loc_1C2AC
		bpl.s	loc_1C2DE

loc_1C2AC:
		bset	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_1C2C0
		bclr	#5,ost_primary_status(a0)
		move.b	#1,ost_anim_restart(a0)

loc_1C2C0:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_1C2D2
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc_1C2D2
		move.w	d1,d0

loc_1C2D2:
		move.w	d0,ost_inertia(a0)
		move.b	#0,ost_anim(a0)
		rts
; ===========================================================================

loc_1C2DE:
		sub.w	d4,d0
		bcc.s	loc_1C2E6
		move.w	#-$80,d0

loc_1C2E6:
		move.w	d0,ost_inertia(a0)
	if FixBugs
		move.b	ost_angle(a0),d1
		addi.b	#$20,d1
		andi.b	#$C0,d1
	else
		; These three instructions partially overwrite the inertia value in
		; 'd0'! This causes the character to trigger their skidding
		; animation at different speeds depending on whether they're going
		; right or left. To fix this, make these instructions use 'd1'
		; instead.
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
	endc
		bne.s	locret_1C328
		cmpi.w	#$400,d0
		blt.s	locret_1C328
		move.b	#$D,ost_anim(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0)
		move.w	#$A4,d0
		jsr	(PlaySound).l
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	locret_1C328
		move.b	#6,($FFFFD164).w
		move.b	#$15,($FFFFD15A).w

locret_1C328:
		rts
; ===========================================================================

loc_1C32A:
		move.w	ost_inertia(a0),d0
		bmi.s	loc_1C35E
		bclr	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1C344
		bclr	#5,ost_primary_status(a0)
		move.b	#1,ost_anim_restart(a0)

loc_1C344:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1C352
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc_1C352
		move.w	d6,d0

loc_1C352:
		move.w	d0,ost_inertia(a0)
		move.b	#0,ost_anim(a0)
		rts
; ===========================================================================

loc_1C35E:
		add.w	d4,d0
		bcc.s	loc_1C366
		move.w	#$80,d0

loc_1C366:
		move.w	d0,ost_inertia(a0)
	if FixBugs
		move.b	ost_angle(a0),d1
		addi.b	#$20,d1
		andi.b	#$C0,d1
	else
		; These three instructions partially overwrite the inertia value in
		; 'd0'! This causes the character to trigger their skidding
		; animation at different speeds depending on whether they're going
		; right or left. To fix this, make these instructions use 'd1'
		; instead.
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
	endc
		bne.s	locret_1C3A8
		cmpi.w	#-$400,d0
		bgt.s	locret_1C3A8
		move.b	#$D,ost_anim(a0)
		bset	#status_xflip_bit,ost_primary_status(a0)
		move.w	#$A4,d0
		jsr	(PlaySound).l
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	locret_1C3A8
		move.b	#6,($FFFFD164).w
		move.b	#$15,($FFFFD15A).w

locret_1C3A8:
		rts
; ===========================================================================

loc_1C3AA:
		move.w	(v_tails_max_speed).w,d6
		asl.w	#1,d6
		move.w	(v_tails_acceleration).w,d5
		asr.w	#1,d5
		move.w	(v_tails_deceleration).w,d4
		asr.w	#2,d4
		tst.b	$2B(a0)
		bmi.w	loc_1C440
		tst.w	$2E(a0)
		bne.s	loc_1C3E2
		btst	#2,(v_joypad2_hold).w
		beq.s	loc_1C3D6
		bsr.w	loc_1C488

loc_1C3D6:
		btst	#3,(v_joypad2_hold).w
		beq.s	loc_1C3E2
		bsr.w	loc_1C4AC

loc_1C3E2:
		move.w	ost_inertia(a0),d0
		beq.s	loc_1C404
		bmi.s	loc_1C3F8
		sub.w	d5,d0
		bcc.s	loc_1C3F2
		move.w	#0,d0

loc_1C3F2:
		move.w	d0,ost_inertia(a0)
		bra.s	loc_1C404
; ===========================================================================

loc_1C3F8:
		add.w	d5,d0
		bcc.s	loc_1C400
		move.w	#0,d0

loc_1C400:
		move.w	d0,ost_inertia(a0)

loc_1C404:
		tst.w	ost_inertia(a0)
		bne.s	loc_1C440
		tst.b	$39(a0)
		bne.s	loc_1C42E
		bclr	#status_jump_bit,ost_primary_status(a0)
		move.b	#$F,ost_height(a0)
		move.b	#9,ost_width(a0)
		move.b	#5,ost_anim(a0)
		subq.w	#1,ost_y_pos(a0)
		bra.s	loc_1C440
; ===========================================================================

loc_1C42E:
		move.w	#$400,ost_inertia(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1C440
		neg.w	ost_inertia(a0)

loc_1C440:
		cmpi.w	#$60,(v_camera_y_shift_p2).w
		beq.s	loc_1C452
		bcc.s	loc_1C44E
		addq.w	#4,(v_camera_y_shift_p2).w

loc_1C44E:
		subq.w	#2,(v_camera_y_shift_p2).w

loc_1C452:
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	ost_inertia(a0),d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a0)
		muls.w	ost_inertia(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc_1C476
		move.w	#$1000,d1

loc_1C476:
		cmpi.w	#-$1000,d1
		bge.s	loc_1C480
		move.w	#-$1000,d1

loc_1C480:
		move.w	d1,ost_x_vel(a0)
		bra.w	loc_1C232
; ===========================================================================

loc_1C488:
		move.w	ost_inertia(a0),d0
		beq.s	loc_1C490
		bpl.s	loc_1C49E

loc_1C490:
		bset	#status_xflip_bit,ost_primary_status(a0)
		move.b	#2,ost_anim(a0)
		rts
; ===========================================================================

loc_1C49E:
		sub.w	d4,d0
		bcc.s	loc_1C4A6
		move.w	#-$80,d0

loc_1C4A6:
		move.w	d0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1C4AC:
		move.w	ost_inertia(a0),d0
		bmi.s	loc_1C4C0
		bclr	#status_xflip_bit,ost_primary_status(a0)
		move.b	#2,ost_anim(a0)
		rts
; ===========================================================================

loc_1C4C0:
		add.w	d4,d0
		bcc.s	loc_1C4C8
		move.w	#$80,d0

loc_1C4C8:
		move.w	d0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1C4CE:
		move.w	(v_tails_max_speed).w,d6
		move.w	(v_tails_acceleration).w,d5
		asl.w	#1,d5
		btst	#4,ost_primary_status(a0)
		bne.s	loc_1C518
		move.w	ost_x_vel(a0),d0
		btst	#2,(v_joypad2_hold).w
		beq.s	loc_1C4FE
		bset	#status_xflip_bit,ost_primary_status(a0)
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_1C4FE
		move.w	d1,d0

loc_1C4FE:
		btst	#3,(v_joypad2_hold).w
		beq.s	loc_1C514
		bclr	#status_xflip_bit,ost_primary_status(a0)
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1C514
		move.w	d6,d0

loc_1C514:
		move.w	d0,ost_x_vel(a0)

loc_1C518:
		cmpi.w	#$60,(v_camera_y_shift_p2).w
		beq.s	loc_1C52A
		bcc.s	loc_1C526
		addq.w	#4,(v_camera_y_shift_p2).w

loc_1C526:
		subq.w	#2,(v_camera_y_shift_p2).w

loc_1C52A:
		cmpi.w	#-$400,ost_y_vel(a0)
		bcs.s	locret_1C558
		move.w	ost_x_vel(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret_1C558
		bmi.s	loc_1C54C
		sub.w	d1,d0
		bcc.s	loc_1C546
		move.w	#0,d0

loc_1C546:
		move.w	d0,ost_x_vel(a0)
		rts
; ===========================================================================

loc_1C54C:
		sub.w	d1,d0
		bcs.s	loc_1C554
		move.w	#0,d0

loc_1C554:
		move.w	d0,ost_x_vel(a0)

locret_1C558:
		rts
; ===========================================================================

loc_1C55A:
		move.l	ost_x_pos(a0),d1
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1
		move.w	(v_boundary_left_p2).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0
		bhi.s	loc_1C5A0
		move.w	(v_boundary_right_p2).w,d0
		addi.w	#$128,d0
		tst.b	(v_current_boss).w
		bne.s	loc_1C588
		addi.w	#$40,d0

loc_1C588:
		cmp.w	d1,d0
		bls.s	loc_1C5A0

loc_1C58C:
		move.w	(v_boundary_bottom_p2).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		blt.s	loc_1C59C
		rts
; ===========================================================================

loc_1C59C:
		bra.w	JmpTo2_KillCharacter
; ===========================================================================

loc_1C5A0:
		move.w	d0,ost_x_pos(a0)
		move.w	#0,ost_x_sub(a0)			; 2+x_pos
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_inertia(a0)
		bra.s	loc_1C58C
; ===========================================================================

loc_1C5B8:
		tst.b	$2B(a0)
		bmi.s	locret_1C5DE
		move.w	ost_inertia(a0),d0
		bpl.s	loc_1C5C6
		neg.w	d0

loc_1C5C6:
		cmpi.w	#$80,d0
		bcs.s	locret_1C5DE
		move.b	(v_joypad2_hold).w,d0
		andi.b	#$C,d0
		bne.s	locret_1C5DE
		btst	#1,(v_joypad2_hold).w
		bne.s	loc_1C5E0

locret_1C5DE:
		rts
; ===========================================================================

loc_1C5E0:
		btst	#status_jump_bit,ost_primary_status(a0)
		beq.s	loc_1C5EA
		rts
; ===========================================================================

loc_1C5EA:
		bset	#status_jump_bit,ost_primary_status(a0)
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.b	#2,ost_anim(a0)
		addq.w	#1,ost_y_pos(a0)
		move.w	#$BE,d0
		jsr	(PlaySound).l
		tst.w	ost_inertia(a0)
		bne.s	locret_1C61C
		move.w	#$200,ost_inertia(a0)

locret_1C61C:
		rts
; ===========================================================================

loc_1C61E:
		move.b	(v_joypad2_press).w,d0
		andi.b	#$70,d0
		beq.w	locret_1C6C2
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		addi.b	#-$80,d0
		bsr.w	Player_CalcHeadroom
		cmpi.w	#6,d1
		blt.w	locret_1C6C2
		move.w	#$680,d2
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1C650
		move.w	#$380,d2

loc_1C650:
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,ost_x_vel(a0)
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,ost_y_vel(a0)
		bset	#1,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$A0,d0
		jsr	(PlaySound).l
		move.b	#$F,ost_height(a0)
		move.b	#9,ost_width(a0)
		btst	#status_jump_bit,ost_primary_status(a0)
		bne.s	loc_1C6C4
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.b	#2,ost_anim(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		addq.w	#1,ost_y_pos(a0)

locret_1C6C2:
		rts
; ===========================================================================

loc_1C6C4:
		bset	#4,ost_primary_status(a0)
		rts
; ===========================================================================

loc_1C6CC:
		tst.b	$3C(a0)
		beq.s	loc_1C6F8
		move.w	#-$400,d1
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1C6E2
		move.w	#-$200,d1

loc_1C6E2:
		cmp.w	ost_y_vel(a0),d1
		ble.s	locret_1C6F6
		move.b	(v_joypad2_hold).w,d0
		andi.b	#$70,d0
		bne.s	locret_1C6F6
		move.w	d1,ost_y_vel(a0)

locret_1C6F6:
		rts
; ===========================================================================

loc_1C6F8:
		tst.b	$39(a0)
		bne.s	locret_1C70C
		cmpi.w	#-$FC0,ost_y_vel(a0)
		bge.s	locret_1C70C
		move.w	#-$FC0,ost_y_vel(a0)

locret_1C70C:
		rts
; ===========================================================================

loc_1C70E:
		tst.b	$39(a0)
		bne.s	loc_1C75E
		cmpi.b	#8,ost_anim(a0)
		bne.s	locret_1C75C
		move.b	(v_joypad2_press).w,d0
		andi.b	#$70,d0
		beq.w	locret_1C75C
		move.b	#9,ost_anim(a0)
		move.w	#$E0,d0
		jsr	(PlaySound).l
		addq.l	#4,sp
		move.b	#1,$39(a0)
		move.w	#0,$3A(a0)
		cmpi.b	#air_alert,ost_air_left(a0)
		bcs.s	loc_1C754
		move.b	#2,($FFFFD15C).w

loc_1C754:
		bsr.w	loc_1C55A
		bsr.w	Player_AnglePos

locret_1C75C:
		rts
; ===========================================================================

loc_1C75E:
		move.b	(v_joypad2_hold).w,d0
		btst	#1,d0
		bne.s	loc_1C7E0
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.b	#2,ost_anim(a0)
		addq.w	#1,ost_y_pos(a0)
		move.b	#0,$39(a0)
		moveq	#0,d0
		move.b	$3A(a0),d0
		add.w	d0,d0
		move.w	word_1C7CE(pc,d0.w),ost_inertia(a0)
		move.w	ost_inertia(a0),d0
		subi.w	#$800,d0
		add.w	d0,d0
		andi.w	#$1F00,d0
		neg.w	d0
		addi.w	#$2000,d0
		move.w	d0,(v_hscroll_delay_val_p2).w
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_1C7B6
		neg.w	ost_inertia(a0)

loc_1C7B6:
		bset	#status_jump_bit,ost_primary_status(a0)
		move.b	#0,($FFFFD15C).w
		move.w	#$BC,d0
		jsr	(PlaySound).l
		bra.s	loc_1C828
; ===========================================================================
word_1C7CE:
		dc.w  $800					; 0
		dc.w  $880					; 1
		dc.w  $900					; 2
		dc.w  $980					; 3
		dc.w  $A00					; 4
		dc.w  $A80					; 5
		dc.w  $B00					; 6
		dc.w  $B80					; 7
		dc.w  $C00					; 8
; ===========================================================================

loc_1C7E0:
		tst.w	$3A(a0)
		beq.s	loc_1C7F8
		move.w	$3A(a0),d0
		lsr.w	#5,d0
		sub.w	d0,$3A(a0)
		bcc.s	loc_1C7F8
		move.w	#0,$3A(a0)

loc_1C7F8:
		move.b	(v_joypad2_press).w,d0
		andi.b	#$70,d0
		beq.w	loc_1C828
		move.w	#$900,ost_anim(a0)
		move.w	#$E0,d0
		jsr	(PlaySound).l
		addi.w	#$200,$3A(a0)
		cmpi.w	#$800,$3A(a0)
		bcs.s	loc_1C828
		move.w	#$800,$3A(a0)

loc_1C828:
		addq.l	#4,sp
		cmpi.w	#$60,(v_camera_y_shift_p2).w
		beq.s	loc_1C83C
		bcc.s	loc_1C838
		addq.w	#4,(v_camera_y_shift_p2).w

loc_1C838:
		subq.w	#2,(v_camera_y_shift_p2).w

loc_1C83C:
		bsr.w	loc_1C55A
		bsr.w	Player_AnglePos
		rts
; ===========================================================================

loc_1C846:
		move.b	ost_angle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_1C87A
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	ost_inertia(a0)
		beq.s	locret_1C87A
		bmi.s	loc_1C876
		tst.w	d0
		beq.s	locret_1C874
		add.w	d0,ost_inertia(a0)

locret_1C874:
		rts
; ===========================================================================

loc_1C876:
		add.w	d0,ost_inertia(a0)

locret_1C87A:
		rts
; ===========================================================================

loc_1C87C:
		move.b	ost_angle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_1C8B6
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	ost_inertia(a0)
		bmi.s	loc_1C8AC
		tst.w	d0
		bpl.s	loc_1C8A6
		asr.l	#2,d0

loc_1C8A6:
		add.w	d0,ost_inertia(a0)
		rts
; ===========================================================================

loc_1C8AC:
		tst.w	d0
		bmi.s	loc_1C8B2
		asr.l	#2,d0

loc_1C8B2:
		add.w	d0,ost_inertia(a0)

locret_1C8B6:
		rts
; ===========================================================================

loc_1C8B8:
		nop
		tst.b	$38(a0)
		bne.s	locret_1C8F2
		tst.w	$2E(a0)
		bne.s	loc_1C8F4
		move.b	ost_angle(a0),d0
		addi.b	#$20,d0
		andi.b	#-$40,d0
		beq.s	locret_1C8F2
		move.w	ost_inertia(a0),d0
		bpl.s	loc_1C8DC
		neg.w	d0

loc_1C8DC:
		cmpi.w	#$280,d0
		bcc.s	locret_1C8F2
		clr.w	ost_inertia(a0)
		bset	#1,ost_primary_status(a0)
		move.w	#$1E,$2E(a0)

locret_1C8F2:
		rts
; ===========================================================================

loc_1C8F4:
		subq.w	#1,$2E(a0)
		rts
; ===========================================================================

loc_1C8FA:
		move.b	ost_angle(a0),d0
		beq.s	loc_1C914
		bpl.s	loc_1C90A
		addq.b	#2,d0
		bcc.s	loc_1C908
		moveq	#0,d0

loc_1C908:
		bra.s	loc_1C910
; ===========================================================================

loc_1C90A:
		subq.b	#2,d0
		bcc.s	loc_1C910
		moveq	#0,d0

loc_1C910:
		move.b	d0,ost_angle(a0)

loc_1C914:
		move.b	ost_flip_angle(a0),d0
		beq.s	locret_1C958
		tst.w	ost_inertia(a0)
		bmi.s	loc_1C938

loc_1C920:
		move.b	$2D(a0),d1
		add.b	d1,d0
		bcc.s	loc_1C936
		subq.b	#1,$2C(a0)
		bcc.s	loc_1C936
		move.b	#0,$2C(a0)
		moveq	#0,d0

loc_1C936:
		bra.s	loc_1C954
; ===========================================================================

loc_1C938:
		tst.b	ost_flip_turned(a0)
		bne.s	loc_1C920
		move.b	$2D(a0),d1
		sub.b	d1,d0
		bcc.s	loc_1C954
		subq.b	#1,$2C(a0)
		bcc.s	loc_1C954
		move.b	#0,$2C(a0)
		moveq	#0,d0

loc_1C954:
		move.b	d0,ost_flip_angle(a0)

locret_1C958:
		rts
; ===========================================================================

loc_1C95A:
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#$C,$3E(a0)
		beq.s	loc_1C972
		move.l	#v_secondary_collision,(v_collision_index_ptr).w

loc_1C972:
		move.b	$3F(a0),d5
		move.w	ost_x_vel(a0),d1
		move.w	ost_y_vel(a0),d2
		jsr	(CalcAngle).l
		subi.b	#$20,d0
		andi.b	#-$40,d0
		cmpi.b	#$40,d0
		beq.w	loc_1CA3C
		cmpi.b	#-$80,d0
		beq.w	loc_1CA98
		cmpi.b	#-$40,d0
		beq.w	loc_1CAF4
		bsr.w	Player_FindWallLeft_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1C9B6
		sub.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1C9B6:
		bsr.w	Player_FindWallRight_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1C9C8
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1C9C8:
		bsr.w	Player_FindFloor
		tst.w	d1
		bpl.s	locret_1CA3A
		move.b	ost_y_vel(a0),d2
		addq.b	#8,d2
		neg.b	d2
		cmp.b	d2,d1
		bge.s	loc_1C9E0
		cmp.b	d2,d0
		blt.s	locret_1CA3A

loc_1C9E0:
		add.w	d1,ost_y_pos(a0)
		move.b	d3,ost_angle(a0)
		bsr.w	loc_1CB50
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1CA18
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc_1CA0A
		asr	ost_y_vel(a0)
		bra.s	loc_1CA2C
; ===========================================================================

loc_1CA0A:
		move.w	#0,ost_y_vel(a0)
		move.w	ost_x_vel(a0),ost_inertia(a0)
		rts
; ===========================================================================

loc_1CA18:
		move.w	#0,ost_x_vel(a0)
		cmpi.w	#$FC0,ost_y_vel(a0)
		ble.s	loc_1CA2C
		move.w	#$FC0,ost_y_vel(a0)

loc_1CA2C:
		move.w	ost_y_vel(a0),ost_inertia(a0)
		tst.b	d3
		bpl.s	locret_1CA3A
		neg.w	ost_inertia(a0)

locret_1CA3A:
		rts
; ===========================================================================

loc_1CA3C:
		bsr.w	Player_FindWallLeft_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1CA56
		sub.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	ost_y_vel(a0),ost_inertia(a0)
		rts
; ===========================================================================

loc_1CA56:
		bsr.w	Player_FindCeiling
		tst.w	d1
		bpl.s	loc_1CA70
		sub.w	d1,ost_y_pos(a0)
		tst.w	ost_y_vel(a0)
		bpl.s	locret_1CA6E
		move.w	#0,ost_y_vel(a0)

locret_1CA6E:
		rts
; ===========================================================================

loc_1CA70:
		tst.w	ost_y_vel(a0)
		bmi.s	locret_1CA96
		bsr.w	Player_FindFloor
		tst.w	d1
		bpl.s	locret_1CA96
		add.w	d1,ost_y_pos(a0)
		move.b	d3,ost_angle(a0)
		bsr.w	loc_1CB50
		move.w	#0,ost_y_vel(a0)
		move.w	ost_x_vel(a0),ost_inertia(a0)

locret_1CA96:
		rts
; ===========================================================================

loc_1CA98:
		bsr.w	Player_FindWallLeft_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1CAAA
		sub.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1CAAA:
		bsr.w	Player_FindWallRight_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1CABC
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)

loc_1CABC:
		bsr.w	Player_FindCeiling
		tst.w	d1
		bpl.s	locret_1CAF2
		sub.w	d1,ost_y_pos(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1CADC
		move.w	#0,ost_y_vel(a0)
		rts
; ===========================================================================

loc_1CADC:
		move.b	d3,ost_angle(a0)
		bsr.w	loc_1CB50
		move.w	ost_y_vel(a0),ost_inertia(a0)
		tst.b	d3
		bpl.s	locret_1CAF2
		neg.w	ost_inertia(a0)

locret_1CAF2:
		rts
; ===========================================================================

loc_1CAF4:
		bsr.w	Player_FindWallRight_Quick_UsePos
		tst.w	d1
		bpl.s	loc_1CB0E
		add.w	d1,ost_x_pos(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	ost_y_vel(a0),ost_inertia(a0)
		rts
; ===========================================================================

loc_1CB0E:
		bsr.w	Player_FindCeiling
		tst.w	d1
		bpl.s	loc_1CB28
		sub.w	d1,ost_y_pos(a0)
		tst.w	ost_y_vel(a0)
		bpl.s	locret_1CB26
		move.w	#0,ost_y_vel(a0)

locret_1CB26:
		rts
; ===========================================================================

loc_1CB28:
		tst.w	ost_y_vel(a0)
		bmi.s	locret_1CB4E
		bsr.w	Player_FindFloor
		tst.w	d1
		bpl.s	locret_1CB4E
		add.w	d1,ost_y_pos(a0)
		move.b	d3,ost_angle(a0)
		bsr.w	loc_1CB50
		move.w	#0,ost_y_vel(a0)
		move.w	ost_x_vel(a0),ost_inertia(a0)

locret_1CB4E:
		rts
; ===========================================================================

loc_1CB50:
		tst.b	$39(a0)
		bne.s	loc_1CB80
		move.b	#0,ost_anim(a0)

Tails_ResetOnFloor_2:
		btst	#status_jump_bit,ost_primary_status(a0)
		beq.s	loc_1CB80
		bclr	#status_jump_bit,ost_primary_status(a0)
		move.b	#$F,ost_height(a0)
		move.b	#9,ost_width(a0)
		move.b	#0,ost_anim(a0)
		subq.w	#1,ost_y_pos(a0)

loc_1CB80:
		bclr	#1,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a0)
		bclr	#4,ost_primary_status(a0)
		move.b	#0,$3C(a0)
		move.w	#0,(v_enemy_combo).w
		move.b	#0,ost_flip_angle(a0)
		move.b	#0,ost_flip_turned(a0)
		move.b	#0,$2C(a0)
		move.w	#0,(v_tails_look_delay_counter).w
		cmpi.b	#$14,ost_anim(a0)
		bne.s	locret_1CBC4
		move.b	#0,ost_anim(a0)

locret_1CBC4:
		rts
; ===========================================================================

Tails_Hurt:
		jsr	(SpeedToPos).l
		addi.w	#$30,ost_y_vel(a0)
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_1CBE0
		subi.w	#$20,ost_y_vel(a0)

loc_1CBE0:
		cmpi.w	#-$100,(v_boundary_top).w
		bne.s	loc_1CBEE
		andi.w	#$7FF,ost_y_pos(a0)

loc_1CBEE:
		bsr.w	loc_1CC08
		bsr.w	loc_1C55A
		bsr.w	Tails_RecordPosition
		bsr.w	Tails_Animate
		bsr.w	Tails_LoadGFX
		jmp	(DisplaySprite).l			; could be bra.w
; ===========================================================================

loc_1CC08:
		move.w	(v_boundary_bottom_p2).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		blt.w	JmpTo2_KillCharacter
		bsr.w	loc_1C95A
		btst	#1,ost_primary_status(a0)
		bne.s	locret_1CC4E
		moveq	#0,d0
		move.w	d0,ost_y_vel(a0)
		move.w	d0,ost_x_vel(a0)
		move.w	d0,ost_inertia(a0)
		move.b	d0,$2A(a0)
		move.b	#0,ost_anim(a0)
		move.b	#2,ost_primary_routine(a0)
		move.w	#$78,$30(a0)
		move.b	#0,$39(a0)

locret_1CC4E:
		rts
; ===========================================================================

Tails_Death:
		bsr.w	loc_1CC6C
		jsr	(ObjectFall).l				; could be bsr.w
		bsr.w	Tails_RecordPosition
		bsr.w	Tails_Animate
		bsr.w	Tails_LoadGFX
		jmp	(DisplaySprite).l			; could be bra.w
; ===========================================================================

loc_1CC6C:
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.w	loc_1B21C
		move.b	#1,(f_disable_scroll_p2).w
		move.b	#0,$39(a0)
		move.w	(v_boundary_bottom_p2).w,d0
		addi.w	#$100,d0
		cmp.w	ost_y_pos(a0),d0
		bge.w	locret_1CD8E
		move.b	#2,ost_primary_routine(a0)
		tst.w	(f_two_player).w
		bne.s	loc_1CCA2
		bra.w	loc_1BE34
; ===========================================================================

loc_1CCA2:
		addq.b	#1,(f_hud_lives_update_p2).w
		subq.b	#1,(v_lives_p2).w
		bne.s	Tails_RestartLevel
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w
		move.b	#$39,($FFFFB0C0).w
		move.b	#1,($FFFFB0DA).w
		move.w	a0,($FFFFB0BE).w
		clr.b	(f_time_over_p2).w

loc_1CCCC:
		clr.b	(f_hud_time_update).w
		clr.b	(f_hud_time_update_p2).w
		move.b	#8,ost_primary_routine(a0)
		move.w	#$9B,d0
		jsr	(PlayMusic).l
		moveq	#3,d0
		jmp	(AddPLC).l
; ===========================================================================

Tails_RestartLevel:
		tst.b	(f_time_over).w				; did player 1 get a Time Over?
	if Revision=0
		bne.s	Tails_RestartLevel_3			; if so, branch
	else
		beq.s	Tails_RestartLevel_2			; if not, branch
		tst.b	(f_time_over_p2).w			; did player 2 get a Time Over?
		beq.s	Tails_RestartLevel_3			; if not, branch
		move.w	#0,$3A(a0)
		clr.b	(f_hud_time_update).w
		clr.b	(f_hud_time_update_p2).w
		move.b	#8,ost_primary_routine(a0)
		rts
	endc
; ===========================================================================

	Tails_RestartLevel_2:
		tst.b	(f_time_over_p2).w			; did player 2 get a Time Over?
		beq.s	Tails_RestartLevel_3			; if not, branch
		move.w	#0,$3A(a0)
		move.b	#$39,($FFFFB080).w
		move.b	#$39,($FFFFB0C0).w
		move.b	#2,($FFFFB09A).w
		move.b	#3,($FFFFB0DA).w
		move.w	a0,($FFFFB0BE).w
		bra.s	loc_1CCCC
; ===========================================================================

	Tails_RestartLevel_3:
		move.b	#0,(f_disable_scroll_p2).w
		move.b	#$A,ost_primary_routine(a0)
		move.w	(v_x_pos_p2_lampcopy).w,ost_x_pos(a0)
		move.w	(v_y_pos_p2_lampcopy).w,ost_y_pos(a0)
		move.w	(v_ost_tile_p2_lampcopy).w,ost_tile(a0)
		move.w	(v_ost_top_solid_bit_p2_lampcopy).w,$3E(a0)
		clr.w	(v_rings_p2).w
		clr.b	(v_ring_reward_p2).w
		move.b	#0,$2A(a0)
		move.b	#5,ost_anim(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		move.w	#0,ost_inertia(a0)
		move.b	#2,ost_primary_status(a0)
		move.w	#0,$2E(a0)

locret_1CD8E:
		rts
; ===========================================================================

Tails_ResetLevel:
		tst.w	$3A(a0)
		beq.s	locret_1CDA2
		subq.w	#1,$3A(a0)
		bne.s	locret_1CDA2
		move.w	#1,(f_restart).w

locret_1CDA2:
		rts
; ===========================================================================

Tails_Respawn:
		tst.w	(v_camera_x_diff_p2).w
		bne.s	loc_1CDB6
		tst.w	(v_camera_y_diff_p2).w
		bne.s	loc_1CDB6
		move.b	#2,ost_primary_routine(a0)

loc_1CDB6:
		bsr.w	Tails_Animate
		bsr.w	Tails_LoadGFX
		jmp	(DisplaySprite).l			; could be bra.w
; ===========================================================================
	if FixBugs
		; Drowning fixes. See Sonic_Drown for more information
; ---------------------------------------------------------------------------
; Tails when he's drowning
; ---------------------------------------------------------------------------
Tails_Drown:
		bsr.w	SpeedToPos
		addi.w	#$10,ost_y_vel(a0)
		bsr.w	Tails_RecordPosition
		bsr.s	Tails_Animate
		bsr.w	Tails_LoadGFX
		bra.w	DisplaySprite
	endc
; ===========================================================================
Tails_Animate:
		lea	(Ani_Tails).l,a1

loc_1CDCA:
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		cmp.b	ost_anim_restart(a0),d0
		beq.s	loc_1CDEC
		move.b	d0,ost_anim_restart(a0)
		move.b	#0,ost_anim_frame(a0)
		move.b	#0,ost_anim_time(a0)
		bclr	#5,ost_primary_status(a0)

loc_1CDEC:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1
		move.b	(a1),d0
		bmi.s	loc_1CE5C
		move.b	ost_primary_status(a0),d1
		andi.b	#1,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_1CE2A
		move.b	d0,ost_anim_time(a0)

loc_1CE12:
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		cmpi.b	#-$10,d0
		bcc.s	loc_1CE2C

loc_1CE22:
		move.b	d0,ost_frame(a0)
		addq.b	#1,ost_anim_frame(a0)

locret_1CE2A:
		rts
; ===========================================================================

loc_1CE2C:
		addq.b	#1,d0
		bne.s	loc_1CE3C
		move.b	#0,ost_anim_frame(a0)
		move.b	ost_render(a1),d0
		bra.s	loc_1CE22
; ===========================================================================

loc_1CE3C:
		addq.b	#1,d0
		bne.s	loc_1CE50
		move.b	2(a1,d1.w),d0
		sub.b	d0,ost_anim_frame(a0)
		sub.b	d0,d1
		move.b	1(a1,d1.w),d0
		bra.s	loc_1CE22
; ===========================================================================

loc_1CE50:
		addq.b	#1,d0
		bne.s	locret_1CE5A
		move.b	2(a1,d1.w),ost_anim(a0)

locret_1CE5A:
		rts
; ===========================================================================

loc_1CE5C:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_1CE2A
		addq.b	#1,d0
		bne.w	loc_1CF6E
		moveq	#0,d0
		move.b	ost_flip_angle(a0),d0
		bne.w	loc_1CF08
		moveq	#0,d1
		move.b	ost_angle(a0),d0
		bmi.s	loc_1CE7E
		beq.s	loc_1CE7E
		subq.b	#1,d0

loc_1CE7E:
		move.b	ost_primary_status(a0),d2
		andi.b	#1,d2
		bne.s	loc_1CE8A
		not.b	d0

loc_1CE8A:
		addi.b	#$10,d0
		bpl.s	loc_1CE92
		moveq	#3,d1

loc_1CE92:
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		eor.b	d1,d2
		or.b	d2,ost_render(a0)
		btst	#5,ost_primary_status(a0)
		bne.w	loc_1CFB2
		lsr.b	#4,d0
		andi.b	#6,d0
		move.w	ost_inertia(a0),d2
		bpl.s	loc_1CEB6
		neg.w	d2

loc_1CEB6:
		tst.b	$2B(a0)
		bpl.w	loc_1CEC0
		add.w	d2,d2

loc_1CEC0:
		move.b	d0,d3
		add.b	d3,d3
		add.b	d3,d3
		lea	(Ani_Tails_Walk).l,a1
		cmpi.w	#$600,d2
		bcs.s	loc_1CEEE
		lea	(Ani_Tails_Run).l,a1
		move.b	d0,d1
		lsr.b	#1,d1
		add.b	d1,d0
		add.b	d0,d0
		move.b	d0,d3
		cmpi.w	#$700,d2
		bcs.s	loc_1CEEE
		lea	(Ani_Tails_HaulAss).l,a1

loc_1CEEE:
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc_1CEF8
		moveq	#0,d2

loc_1CEF8:
		lsr.w	#8,d2
		move.b	d2,ost_anim_time(a0)
		bsr.w	loc_1CE12
		add.b	d3,ost_frame(a0)
		rts
; ===========================================================================

loc_1CF08:
		move.b	ost_flip_angle(a0),d0
		moveq	#0,d1
		move.b	ost_primary_status(a0),d2
		andi.b	#1,d2
		bne.s	loc_1CF36
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		addi.b	#$B,d0
		divu.w	#$16,d0
		addi.b	#$75,d0
		move.b	d0,ost_frame(a0)
		move.b	#0,ost_anim_time(a0)
		rts
; ===========================================================================

loc_1CF36:
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		tst.b	ost_flip_turned(a0)
		beq.s	loc_1CF4E
		ori.b	#render_xflip,ost_render(a0)
		addi.b	#$B,d0
		bra.s	loc_1CF5A
; ===========================================================================

loc_1CF4E:
		ori.b	#render_xflip|render_yflip,ost_render(a0)
		neg.b	d0
		addi.b	#-$71,d0

loc_1CF5A:
		divu.w	#$16,d0
		addi.b	#$75,d0
		move.b	d0,ost_frame(a0)
		move.b	#0,ost_anim_time(a0)
		rts
; ===========================================================================

loc_1CF6E:
		addq.b	#1,d0
		bne.s	loc_1CFE4
		move.w	ost_inertia(a0),d2
		bpl.s	loc_1CF7A
		neg.w	d2

loc_1CF7A:
		lea	(Ani_Tails_Roll2).l,a1
		cmpi.w	#$600,d2
		bcc.s	loc_1CF8C
		lea	(Ani_Tails_Roll1).l,a1

loc_1CF8C:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc_1CF96
		moveq	#0,d2

loc_1CF96:
		lsr.w	#8,d2
		move.b	d2,ost_anim_time(a0)
		move.b	ost_primary_status(a0),d1
		andi.b	#status_xflip,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		bra.w	loc_1CE12
; ===========================================================================

loc_1CFB2:
		move.w	ost_inertia(a0),d2
		bmi.s	loc_1CFBA
		neg.w	d2

loc_1CFBA:
		addi.w	#$800,d2
		bpl.s	loc_1CFC2
		moveq	#0,d2

loc_1CFC2:
		lsr.w	#6,d2
		move.b	d2,ost_anim_time(a0)
		lea	(Ani_Tails_Pushing).l,a1
		move.b	ost_primary_status(a0),d1
		andi.b	#status_xflip,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		bra.w	loc_1CE12
; ===========================================================================

loc_1CFE4:
		move.w	ost_x_vel(a2),d1
		move.w	ost_y_vel(a2),d2
		jsr	(CalcAngle).l
		moveq	#0,d1
		move.b	ost_primary_status(a0),d2
		andi.b	#1,d2
		bne.s	loc_1D002
		not.b	d0
		bra.s	loc_1D006
; ===========================================================================

loc_1D002:
		addi.b	#-$80,d0

loc_1D006:
		addi.b	#$10,d0
		bpl.s	loc_1D00E
		moveq	#3,d1

loc_1D00E:
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		eor.b	d1,d2
		or.b	d2,ost_render(a0)
		lsr.b	#3,d0
		andi.b	#$C,d0
		move.b	d0,d3
		lea	(byte_1D2E8).l,a1
		move.b	#3,ost_anim_time(a0)
		bsr.w	loc_1CE12
		add.b	d3,ost_frame(a0)
		rts
; ===========================================================================

Ani_Tails:	index offset(*)

TailsAnimations:	macro		flag1,flag2,sonic,tails

		if stricmp ("\flag2","n")			; Tails does not use this animation
		else
		ifarg \tails
		ptr	Ani_Tails_\tails			; Tails has a different animation from Sonic
		else
		ptr	Ani_Tails_\sonic			; Tails shares an animation with Sonic
		endc
		endc
		endm

		CharacterAnimations		TailsAnimations	; generate pointers and IDs for Tails' animations
; ===========================================================================

Ani_Tails_Walk:	dc.b $FF,$10,$11,$12,$13,$14,$15, $E, $F,$FF	; 0

Ani_Tails_Run:	dc.b $FF,$2E,$2F,$30,$31,$FF,$FF,$FF,$FF,$FF	; 0

Ani_Tails_Roll1:	dc.b   1,$48,$47,$46,$FF		; 0
Ani_Tails_Roll2:	dc.b   1,$48,$47,$46,$FF		; 0
Ani_Tails_Pushing:	dc.b $FD,$63,$64,$65,$66,$FF,$FF,$FF,$FF,$FF ; 0

Ani_Tails_Wait:
		dc.b   7,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  3,  2,  1,  1,  1 ; 0
		dc.b   1,  1,  1,  1,  1,  3,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1 ; 16
		dc.b   5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5 ; 32
		dc.b   6,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  6,$FE,$1C ; 48
Ani_Tails_Balance:
		dc.b   9,$69,$69,$6A,$6A,$69,$69,$6A,$6A,$69,$69,$6A,$6A,$69,$69,$6A ; 0
		dc.b $6A,$69,$69,$6A,$6A,$69,$6A,$FF		; 16
Ani_Tails_LookUp:	dc.b $3F,  4,$FF			; 0
Ani_Tails_Duck:	dc.b $3F,$5B,$FF				; 0
Ani_Tails_Spindash:	dc.b   0,$60,$61,$62,$FF		; 0
Ani_Tails_Dummy1:	dc.b $3F,$82,$FF			; 0
Ani_Tails_Dummy2:	dc.b   7,  8,  8,  9,$FD,  5		; 0
Ani_Tails_Dummy3:	dc.b   7,  9,$FD,  5			; 0
Ani_Tails_Stop:	dc.b   7,$67,$68,$67,$68,$FD,  0		; 0
Ani_Tails_Float1:	dc.b   9,$6E,$73,$FF			; 0
Ani_Tails_Float2:	dc.b   9,$6E,$6F,$70,$71,$72,$FF	; 0
Ani_Tails_Spring:	dc.b   3,$59,$5A,$59,$5A,$59,$5A,$59,$5A,$59,$5A,$59,$5A,$FD,  0 ; 0

Ani_Tails_Hang1:	dc.b   5,$6C,$6D,$FF			; 0
Ani_Tails_Blink:	dc.b  $F,  1,  2,  3,$FE,  1		; 0
Ani_Tails_Blink2:	dc.b  $F,  1,  2,$FE,  1		; 0
Ani_Tails_Hang2:	dc.b $13,$85,$86,$FF			; 0
Ani_Tails_Bubble:	dc.b  $B,$74,$74,$12,$13,$FD,  0	; 0
Ani_Tails_Burnt:	dc.b $20,$5D,$FF			; 0
Ani_Tails_Drown:	dc.b $2F,$5D,$FF			; 0
Ani_Tails_Death:	dc.b   3,$5D,$FF			; 0
Ani_Tails_Hurt:	dc.b   3,$5D,$FF				; 0
Ani_Tails_Hurt2:	dc.b   3,$5C,$FF			; 0
Ani_Tails_OilSlide:	dc.b   9,$6B,$5C,$FF			; 0
Ani_Tails_Blank:	dc.b $77,  0,$FD,  0
Ani_Tails_Dummy4:	dc.b   3,  1,  2,  3,  4,  5,  6,  7,  8,$FF ; 0
Ani_Tails_Dummy5:	dc.b   3,  1,  2,  3,  4,  5,  6,  7,  8,$FF ; 0
Ani_Tails_HaulAss:	dc.b $FF,$32,$33,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; 0

Ani_Tails_Fly:	dc.b   1,$5E,$5F,$FF				; 0

; ===========================================================================

loc_1D184:
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		cmp.b	(v_tailstails_last_frame_id).w,d0
		beq.s	locret_1D1FE
		move.b	d0,(v_tailstails_last_frame_id).w
		lea	(DPLC_Tails).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_1D1FE
		move.w	#-$A00,d4
		bra.s	loc_1D1D2
; ===========================================================================

Tails_LoadGFX:
		moveq	#0,d0
		move.b	ost_frame(a0),d0

	Tails_LoadGFX_2:
		cmp.b	(v_tails_last_frame_id).w,d0
		beq.s	locret_1D1FE
		move.b	d0,(v_tails_last_frame_id).w
		lea	(DPLC_Tails).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_1D1FE
		move.w	#-$C00,d4

	loc_1D1D2:
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		addi.l	#Art_Tails,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(AddDMA).l
		dbf	d5,loc_1D1D2

locret_1D1FE:
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 05 - Tails' tails
; ----------------------------------------------------------------------------

TailsTails:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1D20E(pc,d0.w),d1
		jmp	off_1D20E(pc,d1.w)
; ===========================================================================
off_1D20E:	index offset(*),,2
		ptr loc_1D212					; 0
		ptr loc_1D23A					; 2
; ===========================================================================

loc_1D212:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Tails,ost_mappings(a0)
		move.w	#tile_Tails_Tails,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		move.b	#2,ost_priority(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#render_rel,ost_render(a0)

loc_1D23A:
		movea.w	$3E(a0),a2
		move.b	ost_angle(a2),ost_angle(a0)
		move.b	ost_primary_status(a2),ost_primary_status(a0)
		move.w	ost_x_pos(a2),ost_x_pos(a0)
		move.w	ost_y_pos(a2),ost_y_pos(a0)
		andi.w	#tile_draw,ost_tile(a0)
		tst.w	ost_tile(a2)
		bpl.s	loc_1D268
		ori.w	#tile_hi,ost_tile(a0)

loc_1D268:
		moveq	#0,d0
		move.b	ost_anim(a2),d0
	if FixBugs
		; Tails doesn't actually have to be pushing against something for his
		; tails to animate as if he is. This is because status_pushing_bit is
		; set whenever Tails is stood next to something: he doesn't
		; necessarily have to be pushing against it. To fix this, we have to
		; check if Tails is displaying any of his pushing sprites. This is
		; exactly how this bug is fixed in Sonic 3 & Knuckles.
		cmpi.b	#$63,ost_frame(a2)
		bcs.s	loc_1D278
		cmpi.b	#$66,ost_frame(a2)
		bhi.s	loc_1D278
	else
		btst	#status_pushing_bit,ost_primary_status(a2)
		beq.s	loc_1D278
	endc
		moveq	#4,d0

loc_1D278:
		cmp.b	$30(a0),d0
		beq.s	loc_1D288
		move.b	d0,$30(a0)
		move.b	AniSelect_TailsTails(pc,d0.w),ost_anim(a0)

loc_1D288:
		lea	(Ani_TailsTails).l,a1
		bsr.w	loc_1CDCA
		bsr.w	loc_1D184
		jsr	(DisplaySprite).l			; could be jmp
		rts
; ===========================================================================
AniSelect_TailsTails:
		dc.b   0,  0,  3,  3,  9,  1,  0,  2,  1,  7,  0,  0,  0,  8,  0,  0 ; 0
		dc.b   0,  0,  0,  0, $A,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 16
		dc.b   0,  0					; 32

Ani_TailsTails:	index offset(*)
		ptr byte_1D2D6					; 0
		ptr byte_1D2D9					; 1
		ptr byte_1D2E0					; 2
		ptr byte_1D2E8					; 3
		ptr byte_1D2EE					; 4
		ptr byte_1D2F4					; 5
		ptr byte_1D2FA					; 6
		ptr byte_1D300					; 7
		ptr byte_1D306					; 8
		ptr byte_1D30C					; 9
		ptr byte_1D312					; 10
byte_1D2D6:	dc.b $20,  0,$FF				; 0
byte_1D2D9:	dc.b   7,  9, $A, $B, $C, $D,$FF		; 0
byte_1D2E0:	dc.b   3,  9, $A, $B, $C, $D,$FD,  1		; 0
byte_1D2E8:	dc.b $FC,$49,$4A,$4B,$4C,$FF			; 0
byte_1D2EE:	dc.b   3,$4D,$4E,$4F,$50,$FF			; 0
byte_1D2F4:	dc.b   3,$51,$52,$53,$54,$FF			; 0
byte_1D2FA:	dc.b   3,$55, $56, $57, $58, $FF		; 0
byte_1D300:	dc.b   2,$81,$82,$83,$84,$FF			; 0
byte_1D306:	dc.b   2,$87,$88,$89,$8A,$FF			; 0
byte_1D30C:	dc.b   9,$87,$88,$89,$8A,$FF			; 0
byte_1D312:	dc.b   9,$81,$82,$83,$84,$FF			; 0
; ===========================================================================


JmpTo2_KillCharacter:
		jmp	(KillCharacter).l

		align 4

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0A - drowning countdown numbers, small bubbles that float out of
; Sonic and Tails' mouths, and small bubbles made by Chop Chop
; ----------------------------------------------------------------------------

DrownCount:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Drown_Index(pc,d0.w),d1
		jmp	Drown_Index(pc,d1.w)
; ===========================================================================
Drown_Index:	index offset(*),,2
		ptr Drown_Main					; 0
		ptr Drown_Animate				; 2
		ptr Drown_ChkWater				; 4
		ptr Drown_Display				; 6
		ptr Drown_Delete				; 8
		ptr Drown_Countdown				; $A
		ptr Drown_AirLeft				; $C
		ptr Drown_Display_Num				; $E
		ptr Drown_Delete				; $10

		rsobj DrownCount,$2C
ost_drown_restart_time:	rs.w 1					; $2C ; time to restart after Sonic drowns
ost_drown_current_dplc:	rs.w 1					; $2E ; last countdown number art that was loaded
ost_drown_x_start:	rs.w 1					; $30 ; original x-axis position
ost_drown_disp_time:	rs.b 1					; $32 ; time to display each number
ost_drown_type:		rs.b 1					; $33 ; bubble type and seconds between spawning each number
ost_drown_extra_bub:	rs.b 1					; $34 ; number of extra bubbles to create - 1
ost_drown_extra_flag:	rs.w 1					; $36 ; flags for extra bubbles
	spawn_bubbles:		equ 1				; bit 1, set if bubbles are to be spawned
	number_spawned_bit:	equ 6				; flag to prevent more than one number bubble from spawning at once
	make_num_bit:		equ 7				; next bubble will be turned into a number
ost_drown_num_time:	rs.w 1					; $38 ; time between each number changes
ost_drown_delay_time:	rs.w 1					; $3A ; delay between bubbles
ost_drown_parent:		rs.l 1				; $3C ; OST address of character this object is attached to
ost_drown_parent_lo:	equ __rs-1				; $3F ; tst.b'd to check if manager object is tied to main character or sidekick
		rsobjend
; ===========================================================================

Drown_Main: ; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to Drown_Animate next
		move.l	#Map_Bub_Player1,ost_mappings(a0)
		tst.b	ost_drown_parent_lo(a0)			; did the main character spawn this object?
		beq.s	.notsidekick				; if so, branch
		move.l	#Map_Bub_Player2,ost_mappings(a0)	; use different mappings for Tails

	.notsidekick:
		move.w	#tile_Nem_BubbleGenerator+tile_hi,ost_tile(a0)
		move.b	#render_rel|render_onscreen,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	ost_subtype(a0),d0			; get subtype (drowning manager is $81)
		bpl.s	.bubble_or_num				; if it is a bubble or a number, branch

		addq.b	#id_Drown_Countdown-id_Drown_Animate,ost_primary_routine(a0) ; go to Drown_Countdown next
		andi.w	#$7F,d0					; ignore high bit of type
		move.b	d0,ost_drown_type(a0)			; type should be 1
		bra.w	Drown_Countdown
; ===========================================================================

.bubble_or_num:
		move.b	d0,ost_anim(a0)				; subtypes for bubbles and numbers correspond to animations
		move.w	ost_x_pos(a0),ost_drown_x_start(a0)
		move.w	#-$88,ost_y_vel(a0)

Drown_Animate: ; Routine 2
		lea	(Ani_Drown).l,a1			; could be PC-relative
		jsr	(AnimateSprite).l			; run animation and go to Drown_ChkWater next

Drown_ChkWater: ; Routine 4
		move.w	(v_water_height_actual).w,d0
		cmp.w	ost_y_pos(a0),d0			; has small or medium bubble reached the water surface?
		bcs.s	.wobble					; if not, branch
		move.b	#id_Drown_Display,ost_primary_routine(a0) ; go to Drown_Display next (could be addq #2 instead)
		addq.b	#7,ost_anim(a0)				; make small bubbles disappear and number bubbles start flashing
		cmpi.b	#id_Ani_Drown_Blank,ost_anim(a0)
	if FixBugs=0
		; This block of code sets the medium bubble's animation to a blank frame when it reaches the surface of the
		; water. In Sonic 1, this functionality was completely broken: the move.b  #id_Ani_Drown_Blank,ost_anim(a0)
		; was missing, causing the blank frame to never be set. While Sonic 2 fixed this,
		; the code still has this redundant instruction left in it, which can safely be removed.
		beq.s	Drown_Display
	endc
		bcs.s	Drown_Display				; branch if it is not a medium bubble (animation $E)
		move.b	#id_Ani_Drown_Blank,ost_anim(a0)	; if it's a medium bubble and has reached the surface, set it to the blank animation
		bra.s	Drown_Display
; ===========================================================================

.wobble:
		; If in a wind tunnel, then make the bubbles move with the character.
		; Used in Sonic 1 and 3, but unused here, as there are no underwater
		; wind tunnels in Sonic 2.
		tst.b	(f_wind_tunnel_now).w			; is character in a wind tunnel?
		beq.s	.notunnel				; if not, branch
		addq.w	#4,ost_drown_x_start(a0)		; move bubbles right with the character

	.notunnel:
		move.b	ost_angle(a0),d0
		addq.b	#1,ost_angle(a0)
		andi.w	#$7F,d0
		lea	(Drown_WobbleData).l,a1
		move.b	(a1,d0.w),d0				; get byte from wobble data array based on angle value
		ext.w	d0
		add.w	ost_drown_x_start(a0),d0
		move.w	d0,ost_x_pos(a0)			; update position
	if FixBugs
		; This isn't actually a bugfix: it's just that the next bugfix pushes
		; this call out of range, so it has to be extended to a word.
		bsr.w	Drown_ShowNumber
	else
		bsr.s	Drown_ShowNumber
	endc
		jsr	(SpeedToPos).l
		tst.b	ost_render(a0)				; is object on-screen?
		bpl.s	.delete					; if not, branch
		jmp	(DisplaySprite).l

	;JmpTo4_DeleteObject:
	.delete:
		jmp	(DeleteObject).l
; ===========================================================================

Drown_Display_Num: ; Routine $E
		movea.l	ost_drown_parent(a0),a2			; a2 = character
		cmpi.b	#air_alert,ost_air_left(a2)		; check air remaining
		bhi.s	Drown_Delete				; if higher than $C, branch

Drown_Display: ; Routine 6
		bsr.s	Drown_ShowNumber
		lea	(Ani_Drown).l,a1
		jsr	(AnimateSprite).l
	if FixBugs
		; If either player starts to drown while standing in very shallow water,
		; their countdown numbers will appear corrupted. This is caused by a missing
		; call to Drown_LoadCountdownArt at this location.
		bsr.w	Drown_LoadCountdownArt
	endc
		jmp	(DisplaySprite).l
; ===========================================================================

Drown_Delete: ; Routine 8 & $10
		jmp	(DeleteObject).l
; ===========================================================================

Drown_AirLeft: ; Routine $C
		movea.l	ost_drown_parent(a0),a2			; a2 = character
		cmpi.b	#air_alert,ost_air_left(a2)		; check air remaining
		bhi.s	.delete					; if higher than $C, branch
		subq.w	#1,ost_drown_num_time(a0)		; decrement timer
		bne.s	.display				; branch if time remains
		move.b	#id_Drown_Display_Num,ost_primary_routine(a0) ; go to Drown_Display_Num next
		addq.b	#7,ost_anim(a0)
		bra.s	Drown_Display
; ===========================================================================

	.display:
		lea	(Ani_Drown).l,a1
		jsr	(AnimateSprite).l
		bsr.w	Drown_LoadCountdownArt			; load number art if necessary
		tst.b	ost_render(a0)				; is number on-screen?
		bpl.s	.delete					; if not, branch
		jmp	(DisplaySprite).l

	.delete:
		jmp	(DeleteObject).l
; ===========================================================================

Drown_ShowNumber:
		tst.w	ost_drown_num_time(a0)			; is this a number bubble?
		beq.s	.nonumber				; if not, exit
		subq.w	#1,ost_drown_num_time(a0)		; decrement timer
		bne.s	.nonumber				; branch if time remains
		cmpi.b	#id_Ani_Drown_ZeroFlash,ost_anim(a0)
		bcc.s	.nonumber				; branch if animation is a number flash

		; Turn this bubble into a number
		move.w	#15,ost_drown_num_time(a0)		; show number for 15 frames
		clr.w	ost_y_vel(a0)
		move.b	#render_onscreen,ost_render(a0)
		move.w	ost_x_pos(a0),d0
		sub.w	(v_camera_x_pos).w,d0
		addi.w	#$80,d0
		move.w	d0,ost_x_screen(a0)			; number is fixed at center of screen
		move.w	ost_y_pos(a0),d0
		sub.w	(v_camera_y_pos).w,d0
		addi.w	#$80,d0
		move.w	d0,ost_y_screen(a0)
		move.b	#id_Drown_AirLeft,ost_primary_routine(a0) ; go to Drown_AirLeft next

	.nonumber:
		rts

; ---------------------------------------------------------------------------
; Data for a bubble's side-to-side wobble. Second copy of data is unused
; Sonic 1 leftover: it was used by the background ripple effect in Revision 1.
; ---------------------------------------------------------------------------

Drown_WobbleData:
		rept 2
		dc.b  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2
		dc.b  2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
		dc.b  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2
		dc.b  2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
		dc.b  0,-1,-1,-1,-1,-1,-2,-2,-2,-2,-2,-3,-3,-3,-3,-3
		dc.b -3,-3,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4
		dc.b -4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-3
		dc.b -3,-3,-3,-3,-3,-3,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1
		endr

; ---------------------------------------------------------------------------
; Subroutine to determine if countdown number art needs to be loaded/updated
; and prepare a DMA transfer if so.
; ---------------------------------------------------------------------------

Drown_LoadCountdownArt:
		moveq	#0,d1
		move.b	ost_frame(a0),d1			; get current frame
		cmpi.b	#id_Frame_DrownNum_0,d1
		bcs.s	.nochange				; branch if a small bubble
		cmpi.b	#id_Frame_Bubble_BubMaker1,d1
		bcc.s	.nochange				; branch if a medium bubble
		cmp.b	ost_drown_current_dplc(a0),d1
		beq.s	.nochange				; branch if number has not changed
		move.b	d1,ost_drown_current_dplc(a0)		; set new number

		; Prepare the DMA transfer. Essentially a DPLC, except the tile length is fixed,
		; and we are calculating the offset.
		subq.w	#8,d1					; subtract 8 from frame ID to get number
		move.w	d1,d0					; multiply by $C0 (the size of each set of number graphics) to get start offset within Art_Countdown
		add.w	d1,d1
		add.w	d0,d1
		lsl.w	#6,d1
		addi.l	#Art_Countdown,d1			; add to address of Art_Countdown to get start address of DMA transfer
		move.w	#vram_SonicDrownNum,d2			; countdown number is loaded at same VRAM address as splash and dust art
		tst.b	ost_drown_parent_lo(a0)			; is it the main character?
		beq.s	.notsidekick				; if not, branch
		move.w	#vram_TailsDrownNum,d2			; use the VRAM for the sidekick's splash and dust art

	.notsidekick:
		move.w	#sizeof_CountdownNum/2,d3		; size of DMA transfer
		jsr	(AddDMA).l

	.nochange:
		rts
; ===========================================================================

Drown_Countdown: ; Routine $A
		movea.l	ost_drown_parent(a0),a2			; a2 = character
		tst.w	ost_drown_restart_time(a0)		; has the character drowned?
		bne.w	.kill_character				; if so, branch
		cmpi.b	#id_Death,ost_primary_routine(a2)	; is the character dead?
		bcc.w	.nocountdown				; if so, branch
		btst	#status_underwater_bit,ost_primary_status(a2) ; is character underwater?
		beq.w	.nocountdown				; if not, branch
		subq.w	#1,ost_drown_num_time(a0)		; decrement timer between countdown number changes
		bpl.w	.create_bubble				; branch if time remains
		move.w	#(1*60)-1,ost_drown_num_time(a0)	; set timer to 1 second
		move.w	#spawn_bubbles,ost_drown_extra_flag(a0)	; set flag to make additional bubbles
		jsr	(RandomNumber).l
		andi.w	#1,d0					; random number 0 or 1
		move.b	d0,ost_drown_extra_bub(a0)
		moveq	#0,d0
		move.b	ost_air_left(a2),d0			; check air remaining
		cmpi.w	#air_ding1,d0
		beq.s	.warnsound				; play sound if	air is 25
		cmpi.w	#air_ding2,d0
		beq.s	.warnsound				; play sound if	air is 20
		cmpi.w	#air_ding3,d0
		beq.s	.warnsound				; play sound if	air is 15
		cmpi.w	#air_alert,d0
		bhi.s	.reduceair				; if air is above 12, branch
		bne.s	.skipmusic				; if air is less than 12, branch
		tst.b	ost_drown_parent_lo(a0)			; is it the main character?
		bne.s	.skipmusic				; if not, branch
		move.w	#mus_Drowning,d0			; play countdown music
		jsr	(PlayMusic).l

	.skipmusic:
		subq.b	#1,ost_drown_disp_time(a0)		; decrement number display timer
		bpl.s	.reduceair				; branch if time remains
		move.b	ost_drown_type(a0),ost_drown_disp_time(a0) ; reset display timer
		bset	#make_num_bit,ost_drown_extra_flag(a0)	; set flag to spawn a number bubble
		bra.s	.reduceair
; ===========================================================================

.warnsound:
		tst.b	ost_drown_parent_lo(a0)
		bne.s	.reduceair
		move.w	#sfx_Ding,d0				; play "ding-ding" warning sound
		jsr	(PlaySound).l

.reduceair:
		subq.b	#1,ost_air_left(a2)			; decrement air remaining
		bcc.w	.gotomakenum				; if above 0, branch

		; If we're here, the player has drowned.
		move.b	#$81,ost_obj_control(a2)		; lock player's controls
		move.w	#sfx_Drown,d0				; play drowning sound
		jsr	(PlaySound).l
		move.b	#11-1,ost_drown_extra_bub(a0)		; spawn 11 additional bubbles as the player drowns
		move.w	#spawn_bubbles,ost_drown_extra_flag(a0)
		move.w	#(2*60),ost_drown_restart_time(a0)	; restart after 2 seconds
		movea.l	a2,a1
		bsr.w	ResumeMusic				; reset player's air count to full (could have been 'move.b	#air_full,ost_air_left(a2)' )
		pushr.l	a0					; save OST address to stack
		movea.l	a2,a0					; use player's OST temporarily
		bsr.w	Sonic_ResetOnFloor_2			; clear their status flags
		move.b	#$17,ost_anim(a0)			; use their drowning animation
		bset	#status_air_bit,ost_primary_status(a0)
		bset	#tile_hi_bit,ost_tile(a0)
		move.w	#0,ost_y_vel(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_inertia(a0)

	if FixBugs
		; Drowning fixes. See Sonic_Drown for more information.
		move.b	#id_Drown,routine(a0)			; set character to their drowning routine
	endc
		popr.l	a0					; restore OST
		cmpa.w	#v_ost_player1,a2			; is it the main character?
		bne.s	.noscrolllock				; if not, branch
		move.b	#1,(f_disable_scrolling).w		; disable scrolling

	if FixBugs
		; The game forgets to stop the timer. If the main character drowns at 9:58,
		; they will get a Time Over: their death animation will be applied to their
		; drowning sprite and the Time Over card will appear. Stopping the timer
		; eliminates this edge case.
		clr.b	(f_hud_time_update).w			; stop the timer immediately
	endc

	.noscrolllock:
		rts
; ===========================================================================

.kill_character:
		subq.w	#1,ost_drown_restart_time(a0)		; decrement delay timer after drowning
	if FixBugs
		; Drowning fixes. See Sonic_Drown for more information.
		bne.s 	.create_bubble				; branch if time remains
	else
		bne.s	.delay_death				; branch if time remains
	endc
		move.b	#id_Death,ost_primary_routine(a2)	; character is now dead
		rts
; ===========================================================================

	if FixBugs=0
		; This function is no longer needed with the rewrite of the drowning mechanism.
		; See Sonic_Drown for more information.
	.delay_death:
		pushr.l	a0					; save OST address to stack
		movea.l	a2,a0					; use player's OST temporarily
		jsr	(SpeedToPos).l				; update their position
		addi.w	#$10,ost_y_vel(a0)			; make them fall
		popr.l	a0					; restore OST
		bra.s	.create_bubble
	endc
; ===========================================================================

.gotomakenum:
		bra.s	.makenum				; why not branch directly?
; ===========================================================================

.create_bubble:
		tst.w	ost_drown_extra_flag(a0)		; should bubbles/numbers be spawned?
		beq.w	.nocountdown				; if not, branch
		subq.w	#1,ost_drown_delay_time(a0)		; decrement timer between bubble spawning
		bpl.w	.nocountdown				; branch if time remains

.makenum:
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		addq.w	#8,d0
		move.w	d0,ost_drown_delay_time(a0)		; set timer as random 8-23 frames
		jsr	(FindFreeObj).l				; find free OST slot
		bne.w	.nocountdown				; branch if not found
		_move.b	ost_id(a0),ost_id(a1)			; load DrownCount object (a1 = spawned bubble)
		move.w	ost_x_pos(a2),ost_x_pos(a1)
		moveq	#6,d0					; 6 pixels to right
		btst	#status_xflip_bit,ost_primary_status(a2) ; is character facing right?
		beq.s	.noflip					; if not, branch
		neg.w	d0					; 6 pixels to left
		move.b	#$40,ost_angle(a1)

	.noflip:
		add.w	d0,ost_x_pos(a1)			; bubble starts 6 pixels to right or left of character
		move.w	ost_y_pos(a2),ost_y_pos(a1)
		move.l	ost_drown_parent(a0),ost_drown_parent(a1)
		move.b	#id_Ani_Drown_SmallBubble,ost_subtype(a1) ; spawn a small bubble
		tst.w	ost_drown_restart_time(a0)		; has player drowned?
		beq.w	.not_dead				; if not, branch
		andi.w	#7,ost_drown_delay_time(a0)		; cut time between bubbles to 7 frames or less)
		addi.w	#0,ost_drown_delay_time(a0)		; pointless
		move.w	ost_y_pos(a2),d0
		subi.w	#$C,d0					; bubble spawns 12 pixels higher than character
		move.w	d0,ost_y_pos(a1)
		jsr	(RandomNumber).l
		move.b	d0,ost_angle(a1)			; randomize angle
		move.w	(v_frame_counter).w,d0			; get frame counter
		andi.b	#3,d0
		bne.s	.create_bubble_done			; branch if not a multiple of 4
		move.b	#id_Ani_Drown_MediumBubble,ost_subtype(a1) ; if current frame number is multiple of 4, spawn a medium bubble instead
		bra.s	.create_bubble_done
; ===========================================================================

.not_dead:
		btst	#make_num_bit,ost_drown_extra_flag(a0)	; is this going to be a number bubble?
		beq.s	.create_bubble_done			; if not, branch
		moveq	#0,d2
		move.b	ost_air_left(a2),d2			; get air remaining
		cmpi.b	#air_alert,d2
		bcc.s	.create_bubble_done			; branch if greater than 12
		lsr.w	#1,d2					; divide by 2 to get number to display
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	.random_not_zero			; branch if random number is not a multiple of 4
		bset	#number_spawned_bit,ost_drown_extra_flag(a0) ; set flag to prevent more than one number bubble spawning at once
		bne.s	.create_bubble_done			; branch if it was already set
		move.b	d2,ost_subtype(a1)			; set number to display
		move.w	#28,ost_drown_num_time(a1)		; indicate that this bubble will turn into a number

	.random_not_zero:
		tst.b	ost_drown_extra_bub(a0)			; was this the last bubble to be spawned?
		bne.s	.create_bubble_done			; if not, branch
		bset	#number_spawned_bit,ost_drown_extra_flag(a0) ; set flag to prevent more than one number bubble spawning at once
		bne.s	.create_bubble_done			; branch if it was already set
		move.b	d2,ost_subtype(a1)			; set number to display
		move.w	#28,ost_drown_num_time(a1)		; indicate that this bubble will turn into a number

.create_bubble_done:
		subq.b	#1,ost_drown_extra_bub(a0)		; decrement count of bubbles to spawn
		bpl.s	.nocountdown				; branch if more bubbles are to be spawned
		clr.w	ost_drown_extra_flag(a0)		; clear the bubble flags

.nocountdown:
		rts

; ---------------------------------------------------------------------------
; Subroutine to reset player's air count and restore music after exiting
; water or inhaling a bubble
; ---------------------------------------------------------------------------

ResumeMusic:
		cmpi.b	#air_alert,ost_air_left(a1)		; has player just drowned, or do they have more than 12 seconds of air left?
		bhi.s	.reset_air				; if so, branch
		cmpa.w	#v_ost_player1,a1			; main character?
		bne.s	.reset_air				; if not, branch
		move.w	(v_level_music).w,d0			; get current level's music
		btst	#status_invincible_bit,ost_secondary_status(a1) ; is Sonic invincible?
		beq.s	.notinvinc				; if not, branch
		move.w	#mus_Invincible,d0

.notinvinc:
		tst.b	(f_super).w				; is Sonic super?
		beq.w	.notsuper				; if not, branch
		move.w	#mus_SuperSonic,d0			; play Super theme

.notsuper:
		tst.b	(v_current_boss).w			; are we in a boss fight?
		beq.s	.playselected				; if not, branch
		move.w	#mus_Boss,d0				; play the boss theme

.playselected:
		jsr	(PlayMusic).l				; play the selected music

.reset_air:
		move.b	#air_full,ost_air_left(a1)		; reset the air timer
		rts

; ---------------------------------------------------------------------------
; Animation script - bubbles
; ---------------------------------------------------------------------------

Ani_Drown:	index offset(*)
		ptr Ani_Drown_ZeroAppear			; 0
		ptr Ani_Drown_OneAppear				; 1
		ptr Ani_Drown_TwoAppear				; 2
		ptr Ani_Drown_ThreeAppear			; 3
		ptr Ani_Drown_FourAppear			; 4
		ptr Ani_Drown_FiveAppear			; 5
		ptr Ani_Drown_SmallBubble			; 6
		ptr Ani_Drown_ZeroFlash				; 7
		ptr Ani_Drown_OneFlash				; 8
		ptr Ani_Drown_TwoFlash				; 9
		ptr Ani_Drown_ThreeFlash			; $A
		ptr Ani_Drown_FourFlash				; $B
		ptr Ani_Drown_FiveFlash				; $C
		ptr Ani_Drown_Blank				; $D
		ptr Ani_Drown_MediumBubble			; $E

Ani_Drown_ZeroAppear:
		dc.b 5
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b id_Frame_DrownNum_0
		dc.b id_Frame_DrownNum_0
		dc.b afRoutine
		rev02even

Ani_Drown_OneAppear:
		dc.b 5
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b id_Frame_DrownNum_1
		dc.b id_Frame_DrownNum_1
		dc.b afRoutine
		rev02even

Ani_Drown_TwoAppear:
		dc.b 5
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b id_Frame_DrownNum_2
		dc.b id_Frame_DrownNum_2
		dc.b afRoutine
		rev02even

Ani_Drown_ThreeAppear:
		dc.b 5
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b id_Frame_DrownNum_3
		dc.b id_Frame_DrownNum_3
		dc.b afRoutine
		rev02even

Ani_Drown_FourAppear:
		dc.b 5
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b id_Frame_DrownNum_4
		dc.b id_Frame_DrownNum_4
		dc.b afRoutine
		rev02even

Ani_Drown_FiveAppear:
		dc.b 5
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b id_Frame_DrownNum_5
		dc.b id_Frame_DrownNum_5
		dc.b afRoutine
		rev02even

Ani_Drown_SmallBubble:
		dc.b $E
		dc.b id_Frame_Bubble_0
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b afRoutine
		rev02even

Ani_Drown_ZeroFlash:
		dc.b 7
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_0
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_0
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_0
		dc.b afRoutine
		rev02even

Ani_Drown_OneFlash:
		dc.b 7
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_1
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_1
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_1
		dc.b afRoutine
		rev02even

Ani_Drown_TwoFlash:
		dc.b 7
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_2
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_2
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_2
		dc.b afRoutine
		rev02even

Ani_Drown_ThreeFlash:
		dc.b 7
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_3
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_3
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_3
		dc.b afRoutine
		rev02even

Ani_Drown_FourFlash:
		dc.b 7
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_4
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_4
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_4
		dc.b afRoutine
		rev02even

Ani_Drown_FiveFlash:
		dc.b 7
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_5
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_5
		dc.b id_Frame_Bubble_Blank
		dc.b id_Frame_DrownNum_5
		dc.b afRoutine
		rev02even

Ani_Drown_Blank:
		dc.b $E
		dc.b afRoutine
		rev02even

Ani_Drown_MediumBubble:
		dc.b $E
		dc.b id_Frame_Bubble_1
		dc.b id_Frame_Bubble_1_Dup
		dc.b id_Frame_Bubble_2
		dc.b id_Frame_Bubble_3
		dc.b afRoutine
		even

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 38 - Shield
; ----------------------------------------------------------------------------

ShieldItem:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1D900(pc,d0.w),d1
		jmp	off_1D900(pc,d1.w)
; ===========================================================================
off_1D900:	index offset(*),,2
		ptr loc_1D904					; 0
		ptr loc_1D92C					; 2
; ===========================================================================

loc_1D904:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Shield,ost_mappings(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#1,ost_priority(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.w	#tile_Nem_Shield,ost_tile(a0)
		bsr.w	AdjustVRAM2P

loc_1D92C:
		movea.w	$3E(a0),a2
		btst	#1,$2B(a2)
		bne.s	locret_1D976
		btst	#0,$2B(a2)
		beq.s	JmpTo7_DeleteObject
		move.w	ost_x_pos(a2),ost_x_pos(a0)
		move.w	ost_y_pos(a2),ost_y_pos(a0)
		move.b	ost_primary_status(a2),ost_primary_status(a0)
		andi.w	#tile_draw,ost_tile(a0)
		tst.w	ost_tile(a2)
		bpl.s	loc_1D964
		ori.w	#tile_hi,ost_tile(a0)

loc_1D964:
		lea	(byte_1DBD6).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

locret_1D976:
		rts
; ===========================================================================

JmpTo7_DeleteObject:
		jmp	(DeleteObject).l

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 35 - Invincibility Stars
; ----------------------------------------------------------------------------

InvincibiltyStars:
		moveq	#0,d0
		move.b	ost_invstars_routine(a0),d0
		move.w	off_1D98C(pc,d0.w),d1
		jmp	off_1D98C(pc,d1.w)
; ===========================================================================
off_1D98C:	index offset(*),,2
		ptr loc_1D9A4					; 0
		ptr loc_1DA0C					; 2
		ptr loc_1DA80					; 4

ost_invstars_routine:	equ $A

off_1D992:
		dc.l byte_1DB8F
		dc.w $B
		dc.l byte_1DBA4
		dc.w $160D
		dc.l byte_1DBBD
		dc.w $2C0D
; ===========================================================================

loc_1D9A4:
		moveq	#0,d2
		lea	off_1D992-6(pc),a2
		lea	(a0),a1
		moveq	#3,d1

loc_1D9AE:
		_move.b	ost_id(a0),ost_id(a1)
		move.b	#4,ost_invstars_routine(a1)
		move.l	#Map_Invincibility,ost_mappings(a1)
		move.w	#tile_Nem_Invinciblity_Stars,ost_tile(a1)
		bsr.w	AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#$10,ost_mainspr_width(a1)
		move.b	#2,ost_mainspr_childsprites(a1)
		move.w	$3E(a0),$3E(a1)
		move.b	d2,$36(a1)
		addq.w	#1,d2
		move.l	(a2)+,$30(a1)
		move.w	(a2)+,$34(a1)
		lea	$40(a1),a1
		dbf	d1,loc_1D9AE
		move.b	#2,ost_invstars_routine(a0)
		move.b	#4,$34(a0)

loc_1DA0C:
		movea.w	$3E(a0),a1
		btst	#1,$2B(a1)
		beq.w	DeleteObject
		move.w	ost_x_pos(a1),d0
		move.w	d0,ost_x_pos(a0)
		move.w	ost_y_pos(a1),d1
		move.w	d1,ost_y_pos(a0)
		lea	ost_subspr2_x_pos(a0),a2
		lea	byte_1DB82(pc),a3
		moveq	#0,d5

loc_1DA34:
		move.w	$38(a0),d2
		move.b	(a3,d2.w),d5
		bpl.s	loc_1DA44
		clr.w	$38(a0)
		bra.s	loc_1DA34
; ===========================================================================

loc_1DA44:
		addq.w	#1,$38(a0)
		lea	byte_1DB42(pc),a6
		move.b	$34(a0),d6
		jsr	loc_1DB2C(pc)
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	d5,(a2)+
		addi.w	#$20,d6
		jsr	loc_1DB2C(pc)
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	d5,(a2)+
		moveq	#$12,d0
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_1DA74
		neg.w	d0

loc_1DA74:
		add.b	d0,$34(a0)
		move.w	#$80,d0
		bra.w	DisplaySprite3
; ===========================================================================

loc_1DA80:
	if FixBugs
		; If Sonic turns Super while invincible, the stars don't go away.
		; S3K fixes this by doing the following:
		tst.b	(f_super).w				; has Sonic turned super?
		bne.w	DeleteObject				; if so, delete the stars
	endc
		movea.w	$3E(a0),a1
		btst	#1,$2B(a1)
		beq.w	DeleteObject
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	loc_1DAA4
		lea	(v_sonic_pos_tracker_num).w,a5
		lea	(v_sonic_pos_tracker).w,a6
		tst.b	$3F(a0)
		beq.s	loc_1DAAC

loc_1DAA4:
		lea	(v_tails_pos_tracker_num).w,a5
		lea	(v_tails_pos_tracker).w,a6

loc_1DAAC:
		move.b	$36(a0),d1
		lsl.b	#2,d1
		move.w	d1,d2
		add.w	d1,d1
		add.w	d2,d1
		move.w	(a5),d0
		sub.b	d1,d0
		lea	(a6,d0.w),a2
		move.w	(a2)+,d0
		move.w	(a2)+,d1
		move.w	d0,ost_x_pos(a0)
		move.w	d1,ost_y_pos(a0)
		lea	ost_subspr2_x_pos(a0),a2
		movea.l	$30(a0),a3

loc_1DAD4:
		move.w	$38(a0),d2
		move.b	(a3,d2.w),d5
		bpl.s	loc_1DAE4
		clr.w	$38(a0)
		bra.s	loc_1DAD4
; ===========================================================================

loc_1DAE4:
		swap	d5
		add.b	$35(a0),d2
		move.b	(a3,d2.w),d5
		addq.w	#1,$38(a0)
		lea	byte_1DB42(pc),a6
		move.b	$34(a0),d6
		jsr	loc_1DB2C(pc)
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	d5,(a2)+
		addi.w	#$20,d6
		swap	d5
		jsr	loc_1DB2C(pc)
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	d5,(a2)+
		moveq	#2,d0
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_1DB20
		neg.w	d0

loc_1DB20:
		add.b	d0,$34(a0)
		move.w	#$80,d0
		bra.w	DisplaySprite3
; ===========================================================================

loc_1DB2C:
		andi.w	#$3E,d6
		move.b	(a6,d6.w),d2
		move.b	1(a6,d6.w),d3
		ext.w	d2
		ext.w	d3
		add.w	d0,d2
		add.w	d1,d3
		rts
; ===========================================================================
byte_1DB42:
		dc.b  $F,  0, $F,  3, $E,  6, $D,  8, $B, $B,  8, $D,  6, $E,  3, $F ; 0
		dc.b   0,$10,$FC, $F,$F9, $E,$F7, $D,$F4, $B,$F2,  8,$F1,  6,$F0,  3 ; 16
		dc.b $F0,  0,$F0,$FC,$F1,$F9,$F2,$F7,$F4,$F4,$F7,$F2,$F9,$F1,$FC,$F0 ; 32
		dc.b $FF,$F0,  3,$F0,  6,$F1,  8,$F2, $B,$F4, $D,$F7, $E,$F9, $F,$FC ; 48

byte_1DB82:
		dc.b   8,  5,  7,  6,  6,  7,  5,  8,  6,  7,  7,  6,$FF ; 0

byte_1DB8F:
		dc.b   8,  7,  6,  5,  4,  3,  4,  5,  6,  7,$FF,  3,  4,  5,  6,  7 ; 0
		dc.b   8,  7,  6,  5,  4			; 16
byte_1DBA4:
		dc.b   8,  7,  6,  5,  4,  3,  2,  3,  4,  5,  6,  7,$FF,  2,  3,  4 ; 0
		dc.b   5,  6,  7,  8,  7,  6,  5,  4,  3	; 16

byte_1DBBD:
		dc.b   7,  6,  5,  4,  3,  2,  1,  2,  3,  4,  5,  6,$FF,  1,  2,  3 ; 0
		dc.b   4,  5,  6,  7,  6,  5,  4,  3,  2	; 16

byte_1DBD6:
		dc.b   0,  2,  0,  5,  0,  5,  1,  5,  2,  5,  3,  5,  4,$FF ; 0

; ===========================================================================

		include "mappings/sprite/Shield.asm"
		include "mappings/sprite/Invincibility Stars.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 08 - Water splash and spindash dust
; ----------------------------------------------------------------------------

Splash_SpindashDust:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1DD2E(pc,d0.w),d1
		jmp	off_1DD2E(pc,d1.w)
; ===========================================================================
off_1DD2E: index offset(*),,2
		ptr loc_1DD36					; 0
		ptr loc_1DD90					; 2
		ptr loc_1DE46					; 4
		ptr loc_1DE4A					; 6
; ===========================================================================

loc_1DD36:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SplashDust,ost_mappings(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#1,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.w	#vram_SonicDust/sizeof_cell,ost_tile(a0)
		move.w	#v_ost_player1,$3E(a0)
		move.w	#vram_SonicDust,$3C(a0)
		cmpa.w	#v_ost_lo_sonic_dust,a0
		beq.s	loc_1DD8C
		move.b	#1,$34(a0)
		cmpi.w	#tails_alone,(v_player_mode).w
		beq.s	loc_1DD8C
		move.w	#vram_TailsDust/sizeof_cell,ost_tile(a0)
		move.w	#v_ost_player2,$3E(a0)
		move.w	#vram_TailsDust,$3C(a0)

loc_1DD8C:
		bsr.w	AdjustVRAM2P

loc_1DD90:
		movea.w	$3E(a0),a2
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		add.w	d0,d0
		move.w	off_1DDA4(pc,d0.w),d1
		jmp	off_1DDA4(pc,d1.w)
; ===========================================================================
off_1DDA4:	index offset(*)
		ptr loc_1DE28					; 0
		ptr loc_1DDAC					; 1
		ptr loc_1DDCC					; 2
		ptr loc_1DE20					; 3
; ===========================================================================

loc_1DDAC:
		move.w	(v_water_height_actual).w,ost_y_pos(a0)
		tst.b	ost_anim_restart(a0)
		bne.s	loc_1DE28
		move.w	ost_x_pos(a2),ost_x_pos(a0)
		move.b	#0,ost_primary_status(a0)
		andi.w	#tile_draw,ost_tile(a0)
		bra.s	loc_1DE28
; ===========================================================================

loc_1DDCC:
		cmpi.b	#air_alert,ost_air_left(a2)
		bcs.s	loc_1DE3E
		cmpi.b	#4,ost_primary_routine(a2)
		bcc.s	loc_1DE3E
		tst.b	$39(a2)
		beq.s	loc_1DE3E
		move.w	ost_x_pos(a2),ost_x_pos(a0)
		move.w	ost_y_pos(a2),ost_y_pos(a0)
		move.b	ost_primary_status(a2),ost_primary_status(a0)
		andi.b	#1,ost_primary_status(a0)
		tst.b	$34(a0)
		beq.s	loc_1DE06
		subi_.w	#4,ost_y_pos(a0)

loc_1DE06:
		tst.b	ost_anim_restart(a0)
		bne.s	loc_1DE28
		andi.w	#tile_draw,ost_tile(a0)
		tst.w	ost_tile(a2)
		bpl.s	loc_1DE28
		ori.w	#tile_hi,ost_tile(a0)
		bra.s	loc_1DE28
; ===========================================================================

loc_1DE20:
		cmpi.b	#air_alert,ost_air_left(a2)
		bcs.s	loc_1DE3E

loc_1DE28:
		lea	(Ani_SplashDust).l,a1
		jsr	(AnimateSprite).l
		bsr.w	loc_1DEE4
		jmp	(DisplaySprite).l
; ===========================================================================

loc_1DE3E:
		move.b	#0,ost_anim(a0)
		rts
; ===========================================================================

loc_1DE46:
		bra.w	DeleteObject
; ===========================================================================

loc_1DE4A:
		movea.w	$3E(a0),a2
		cmpi.b	#$D,ost_anim(a2)
		beq.s	loc_1DE64
		move.b	#2,ost_primary_routine(a0)
		move.b	#0,$32(a0)
		rts
; ===========================================================================

loc_1DE64:
		subq.b	#1,$32(a0)
		bpl.s	loc_1DEE0
		move.b	#3,$32(a0)
		bsr.w	FindFreeObj
		bne.s	loc_1DEE0
		_move.b	ost_id(a0),ost_id(a1)
		move.w	ost_x_pos(a2),ost_x_pos(a1)
		move.w	ost_y_pos(a2),ost_y_pos(a1)
		addi.w	#$10,ost_y_pos(a1)
		tst.b	$34(a0)
		beq.s	loc_1DE9A
		subi_.w	#4,ost_y_pos(a1)

loc_1DE9A:
		move.b	#0,ost_primary_status(a1)
		move.b	#3,ost_anim(a1)
		addq.b	#2,ost_primary_routine(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#1,ost_priority(a1)
		move.b	#4,ost_displaywidth(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.w	$3E(a0),$3E(a1)
		andi.w	#tile_draw,ost_tile(a1)
		tst.w	ost_tile(a2)
		bpl.s	loc_1DEE0
		ori.w	#tile_hi,ost_tile(a1)

loc_1DEE0:
		bsr.s	loc_1DEE4
		rts
; ===========================================================================

loc_1DEE4:
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		cmp.b	$30(a0),d0
		beq.s	locret_1DF36
		move.b	d0,$30(a0)
		lea	(DynPLC_SplashDust).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_1DF36

loc_1DF06:
		move.w	$3C(a0),d4

loc_1DF0A:
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		addi.l	#Art_SplashAndDust,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(AddDMA).l
		dbf	d5,loc_1DF0A

locret_1DF36:
		rts
; ===========================================================================
Ani_SplashDust:	index offset(*)
		ptr Ani_SplashDust_Blank			; 0
		ptr Ani_SplashDust_Splash1			; 1
		ptr Ani_SplashDust_Splash2			; 2
		ptr Ani_SplashDust_Dust				; 3

Ani_SplashDust_Blank:	dc.b $1F,  0,$FF			; 0
Ani_SplashDust_Splash1:	dc.b   3,  1,  2,  3,  4,  5,  6,  7,  8,  9,$FD,  0 ; 0
Ani_SplashDust_Splash2:	dc.b   1, $A, $B, $C, $D, $E, $F,$10,$FF ; 0
Ani_SplashDust_Dust:	dc.b   3,$11,$12,$13,$14,$FC		; 0

; ===========================================================================

		include "mappings/sprite/Splash and Spindash Dust.asm"
		include "mappings/spriteDPLC/Splash and Spindash Dust.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 7E - Super Sonic's stars
; ----------------------------------------------------------------------------

SuperSonicStars:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SuperStars_Index(pc,d0.w),d1
		jmp	SuperStars_Index(pc,d1.w)
; ===========================================================================
SuperStars_Index:	index offset(*),,2
		ptr loc_1E102					; 0
		ptr loc_1E138					; 2
; ===========================================================================

loc_1E102:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SuperStars,ost_mappings(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#1,ost_priority(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.w	#tile_Nem_SuperSonic_Stars,ost_tile(a0)
		bsr.w	AdjustVRAM2P
		btst	#tile_hi_bit,(v_ost_player1+ost_tile).w
		beq.s	loc_1E138
		bset	#tile_hi_bit,ost_tile(a0)

loc_1E138:
		tst.b	(f_super).w
		beq.s	loc_1E1B8
		tst.b	$30(a0)
		beq.s	loc_1E188
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_1E170
		move.b	#1,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#6,ost_frame(a0)
		bcs.s	loc_1E170
		move.b	#0,ost_frame(a0)
		move.b	#0,$30(a0)
		move.b	#1,$31(a0)
		rts
; ===========================================================================

loc_1E170:
		tst.b	$31(a0)
		bne.s	loc_1E182

loc_1E176:
		move.w	(v_ost_player1+ost_x_pos).w,ost_x_pos(a0)
		move.w	(v_ost_player1+ost_y_pos).w,ost_y_pos(a0)

loc_1E182:
		jmp	(DisplaySprite).l
; ===========================================================================

loc_1E188:
		tst.b	(v_ost_player1+ost_obj_control).w
		bne.s	loc_1E1AA
		move.w	(v_ost_player1+ost_inertia).w,d0
		bpl.s	loc_1E196
		neg.w	d0

loc_1E196:
		cmpi.w	#$800,d0
		bcs.s	loc_1E1AA
		move.b	#0,ost_frame(a0)
		move.b	#1,$30(a0)
		bra.s	loc_1E176
; ===========================================================================

loc_1E1AA:
		move.b	#0,$30(a0)
		move.b	#0,$31(a0)
		rts
; ===========================================================================

loc_1E1B8:
		jmp	(DeleteObject).l
; ===========================================================================

		include "mappings/sprite/Super Sonic Stars.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

; ---------------------------------------------------------------------------
; Subroutine to change Sonic and Tails' angle & position as they walk
; along the floor
; ---------------------------------------------------------------------------

Player_AnglePos:
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#$C,ost_top_solid_bit(a0)
		beq.s	.use_primary
		move.l	#v_secondary_collision,(v_collision_index_ptr).w

	.use_primary:
		move.b	ost_top_solid_bit(a0),d5		;  bit to test for solidness
		btst	#status_platform_bit,ost_primary_status(a0)
		beq.s	.not_on_platform			; branch if player isn't on a platform
		moveq	#0,d0
		move.b	d0,(v_angle_right).w			; clear angle hotspots
		move.b	d0,(v_angle_left).w
		rts
; ===========================================================================

.not_on_platform:
		moveq	#3,d0
		move.b	d0,(v_angle_right).w
		move.b	d0,(v_angle_left).w
		move.b	ost_angle(a0),d0			; get last angle
		addi.b	#$20,d0
		bpl.s	.floor_or_left				; branch if angle is (generally) flat or left vertical
		move.b	ost_angle(a0),d0
		bpl.s	.angle_pos				; branch if angle is between $60 and $7F
		subq.b	#1,d0					; subtract 1 if $80-$DF

	.angle_pos:
		addi.b	#$20,d0
		bra.s	.chk_surface				; d0 = angle + ($1F or $20)
; ===========================================================================

.floor_or_left:
		move.b	ost_angle(a0),d0
		bpl.s	.angle_pos_				; branch if angle is between 0 and $60
		addq.b	#1,d0					; add 1 if $E0-$FF

	.angle_pos_:
		addi.b	#$1F,d0					; d0 = angle + ($1F or $20)

.chk_surface:
		andi.b	#$C0,d0					; read only bits 6-7 of angle
		cmpi.b	#$40,d0
		beq.w	Player_WalkVertL			; branch if on left vertical
		cmpi.b	#$80,d0
		beq.w	Player_WalkCeiling			; branch if on ceiling
		cmpi.b	#$C0,d0
		beq.w	Player_WalkVertR			; branch if on right vertical

;Player_WalkFloor:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos of bottom edge of player
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d3					; d3 = x pos of right edge of player
		lea	(v_angle_right).w,a4			; write angle here
		movea.w	#$10,a3					; tile height
		move.w	#0,d6
		bsr.w	FindFloor
		pushr.w	d1					; save d1 (distance to floor) to stack

		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos of bottom edge of player
		move.b	ost_width(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3					; d3 = x pos of left edge of player
		lea	(v_angle_left).w,a4			; write angle here
		movea.w	#$10,a3					; tile height
		move.w	#0,d6
		bsr.w	FindFloor				; d1 = distance to floor left side
		popr.w	d0					; d0 = distance to floor right side
		bsr.w	Player_UpdateAngle			; update angle (could be bsr.s)
		tst.w	d1
		beq.s	.on_or_below_floor			; branch if player is 0px from floor
		bpl.s	.above_floor				; branch if player is above floor
		cmpi.w	#-$E,d1
		blt.s	.on_or_below_floor			; branch if player is > 14px below floor
		add.w	d1,ost_y_pos(a0)			; align to floor

.on_or_below_floor:
		rts
; ===========================================================================

.above_floor:
		mvabs.b	ost_x_vel(a0),d0			; d0 = absolute value of x vel
		addq.b	#4,d0
		cmpi.b	#$E,d0
		bcs.s	.slow_x					; branch if player's absolute x vel+4 is less than 14
		move.b	#$E,d0					; 14 pixels above floor

	.slow_x:
		cmp.b	d0,d1
		bgt.s	.in_air					; branch if player is > 14px above floor

.on_disc:
		add.w	d1,ost_y_pos(a0)			; align to floor
		rts
; ===========================================================================

.in_air:
		tst.b	ost_sticktoconvex(a0)
		bne.s	.on_disc				; branch if player is on a convex surface (used in Sonic 1 & 3K; unused here)
		bset	#status_air_bit,ost_primary_status(a0)
		bclr	#status_pushing_bit,ost_primary_status(a0)
		move.b	#id_Ani_Son_Run,ost_anim_restart(a0)	; restart player's animation
		rts

; ---------------------------------------------------------------------------
; Subroutine to	update Sonic or Tails' angle

; input:
;	d0 = distance to floor right side
;	d1 = distance to floor left side

; output:
;	d1 = shortest distance to floor (either side)
;	d2 = angle
; ---------------------------------------------------------------------------

Player_UpdateAngle:
		move.b	(v_angle_left).w,d2			; use left side angle
		cmp.w	d0,d1
		ble.s	.left_nearer				; branch if floor is nearer on left side
		move.b	(v_angle_right).w,d2			; use right side angle
		move.w	d0,d1					; use distance of right side

	.left_nearer:
		btst	#0,d2
		bne.s	.snap_angle				; branch if bit 0 of angle is set
		move.b	d2,d0					; d2 = angle
		sub.b	ost_angle(a0),d0			; get difference between old and new angles
		bpl.s	.alreadypos				; branch if already positive
		neg.b	d0					; make positive

	.alreadypos:
		cmpi.b	#$20,d0					; d0 = absolute value of difference between old and new angles
		bcc.s	.snap_angle				; branch if angle has changed by $20 or more
		move.b	d2,ost_angle(a0)			; update angle
		rts
; ===========================================================================

.snap_angle:
		move.b	ost_angle(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2					; snap to nearest 90 degree angle
		move.b	d2,ost_angle(a0)			; update angle
		rts

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic and Tails to walk up a vertical slope/wall to
; their right
; ---------------------------------------------------------------------------

Player_WalkVertR:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2					; d2 = y pos of upper edge of player (i.e. their front or back)
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d3					; d3 = x pos of bottom edge of player (i.e. their feet)
		lea	(v_angle_right).w,a4			; write angle here
		movea.w	#$10,a3					; tile width
		move.w	#0,d6
		bsr.w	FindWall
		pushr.w	d1					; save d1 (distance to wall) to stack

		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos of lower edge of Sonic (i.e. his front or back)
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d3					; d3 = x pos of bottom edge of Sonic (i.e. his feet)
		lea	(v_angle_left).w,a4			; write angle here
		movea.w	#$10,a3					; tile width
		move.w	#0,d6
		bsr.w	FindWall				; d1 = distance to wall lower side
		popr.w	d0					; d0 = distance to wall upper side
		bsr.w	Player_UpdateAngle			; update angle
		tst.w	d1
		beq.s	.on_or_inside_wall			; branch if player is 0px from wall
		bpl.s	.outside_wall				; branch if player is outside wall
		cmpi.w	#-$E,d1
		blt.s	.on_or_inside_wall			; branch if player is > 14px inside wall
		add.w	d1,ost_x_pos(a0)

	.on_or_inside_wall:
		rts
; ===========================================================================

.outside_wall:
		mvabs.b	ost_y_vel(a0),d0			; d0 = absolute value of y vel
		addq.b	#4,d0
		cmpi.b	#$E,d0
		bcs.s	.slow_y					; branch if player's absolute y vel+4 is less than 14
		move.b	#$E,d0					; 14 pixels outside of wall

	.slow_y:
		cmp.b	d0,d1
		bgt.s	.in_air					; branch if player is > 14px outside wall

.on_disc:
		add.w	d1,ost_x_pos(a0)			; align to wall
		rts
; ===========================================================================

.in_air:
		tst.b	ost_sticktoconvex(a0)
		bne.s	.on_disc				; branch if player is on a convex surface (used in Sonic 1 & 3K; unused here)
		bset	#status_air_bit,ost_primary_status(a0)
		bclr	#status_pushing_bit,ost_primary_status(a0)
		move.b	#id_Ani_Son_Run,ost_anim_restart(a0)	; restart player's animation
		rts

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic and Tails to walk upside down
; ---------------------------------------------------------------------------

Player_WalkCeiling:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d2					; d2 = y pos of top edge of Sonic (i.e. his feet)
		eori.w	#$F,d2					; add some amount
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d3					; d3 = x pos of right edge of Sonic
		lea	(v_angle_right).w,a4			; write angle here
		movea.w	#-$10,a3				; tile height
		move.w	#chunkmap_yflip,d6			; yflip tile
		bsr.w	FindFloor
		pushr.w	d1					; save d1 (distance to ceiling) to stack

		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d2					; d2 = y pos of top edge of Sonic (i.e. his feet)
		eori.w	#$F,d2
		move.b	ost_width(a0),d0
		ext.w	d0
		sub.w	d0,d3					; d3 = x pos of left edge of Sonic
		lea	(v_angle_left).w,a4			; write angle here
		movea.w	#-$10,a3				; tile height
		move.w	#chunkmap_yflip,d6			; yflip tile
		bsr.w	FindFloor				; d1 = distance to ceiling left side
		popr.w	d0					; d0 = distance to ceiling right side
		bsr.w	Player_UpdateAngle			; update angle
		tst.w	d1
		beq.s	.on_or_above_ceiling			; branch if player is 0px from ceiling
		bpl.s	.below_ceiling				; branch if player is below ceiling
		cmpi.w	#-$E,d1
		blt.s	.on_or_above_ceiling			; branch if player is > 14px inside ceiling
		sub.w	d1,ost_y_pos(a0)			; align to ceiling

	.on_or_above_ceiling:
		rts
; ===========================================================================

.below_ceiling:
		mvabs.b	ost_x_vel(a0),d0			; d0 = absolute value of x vel
		addq.b	#4,d0
		cmpi.b	#$E,d0
		bcs.s	.slow_x					; branch if player's absolute x vel+4 is less than 14
		move.b	#$E,d0					; 14 pixels above floor

	.slow_x:
		cmp.b	d0,d1
		bgt.s	.in_air					; branch if player is > 14px below ceiling

.on_disc:
		sub.w	d1,ost_y_pos(a0)			; align to ceiling
		rts
; ===========================================================================

.in_air:
		tst.b	ost_sticktoconvex(a0)
		bne.s	.on_disc				; branch if player is on a convex surface (used in Sonic 1 & 3K; unused here)
		bset	#status_air_bit,ost_primary_status(a0)
		bclr	#status_pushing_bit,ost_primary_status(a0)
		move.b	#id_Ani_Son_Run,ost_anim_restart(a0)	; restart player's animation
		rts
; ===========================================================================

Player_WalkVertL:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		sub.w	d0,d2					; d2 = y pos of upper edge of Sonic (i.e. his front or back)
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d3					; d3 = x pos of bottom edge of Sonic (i.e. his feet)
		eori.w	#$F,d3					; add some amount
		lea	(v_angle_right).w,a4			; write angle here
		movea.w	#-$10,a3				; tile width
		move.w	#chunkmap_xflip,d6
		bsr.w	FindWall
		pushr.w	d1					; save d1 (distance to wall) to stack

		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos of lower edge of Sonic (i.e. his front or back)
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d3					; d3 = x pos of bottom edge of Sonic (i.e. his feet)
		eori.w	#$F,d3
		lea	(v_angle_left).w,a4			; write angle here
		movea.w	#-$10,a3				; tile width
		move.w	#chunkmap_xflip,d6
		bsr.w	FindWall				; d1 = distance to wall lower side
		popr.w	d0					; d0 = distance to wall upper side
		bsr.w	Player_UpdateAngle			; update angle
		tst.w	d1
		beq.s	.on_or_inside_wall			; branch if player is 0px from wall
		bpl.s	.outside_wall				; branch if player is outside wall
		cmpi.w	#-$E,d1
		blt.s	.on_or_inside_wall			; branch if player is > 14px inside wall
		sub.w	d1,ost_x_pos(a0)			; align to wall

	.on_or_inside_wall:
		rts
; ===========================================================================

.outside_wall:
		mvabs.b	ost_y_vel(a0),d0
		addq.b	#4,d0
		cmpi.b	#$E,d0
		bcs.s	.slow_y					; branch if player's absolute y vel+4 is less than 14
		move.b	#$E,d0					; 14 pixels outside of wall

	.slow_y:
		cmp.b	d0,d1
		bgt.s	.in_air					; branch if player is > 14px outside wall


.on_disc:
		sub.w	d1,ost_x_pos(a0)			; align to wall
		rts
; ===========================================================================

.in_air:
		tst.b	ost_sticktoconvex(a0)
		bne.s	.on_disc				; branch if player is on a convex surface (used in Sonic 1 & 3K; unused here)
		bset	#status_air_bit,ost_primary_status(a0)
		bclr	#status_pushing_bit,ost_primary_status(a0)
		move.b	#id_Ani_Son_Run,ost_anim_restart(a0)	; restart player's animation
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find which 16x16 tile the object is standing on

; input:
;	d2.w = y position of object's bottom edge
;	d3.w = x position of object

; output:
;	a1 = address within 128x128 mappings where object is standing
;	(a1).w = 16x16 tile number, x/yflip, solidness

;	uses d0.w, d1.l, d2.w, d4,w
; ---------------------------------------------------------------------------

FindNearestTile:
		move.w	d2,d0					; get y pos of bottom edge of object
		add.w	d0,d0					; multiply y pos by 2 (because layout alternates between level and bg lines)
		andi.w	#$F00,d0				; read only high byte of y pos (as each level tile is 128 px tall)
		move.w	d3,d1					; get x pos of object
		lsr.w	#3,d1					; divide x pos by 8
		move.w	d1,d4					; save for later
		lsr.w	#4,d1					; divide by 16; result is x pos divided by 128
		andi.w	#$7F,d1					; read only high byte of x pos
		add.w	d1,d0					; combine for position in layout
		moveq	#-1,d1
		clr.w	d1					; d1 = $FFFF0000 (used to make a RAM address)
		lea	(v_level_layout).w,a1
		move.b	(a1,d0.w),d1				; get 128x128 tile number
		add.w	d1,d1					; multiply by 2
		move.w	TileOffsetList(pc,d1.w),d1		; get base address of 128x128 tile
		move.w	d2,d0					; d0 = y pos * 2 (because each 16x16 tile is represented by 2 bytes)
		andi.w	#$70,d0					; read only high nybble of low byte (for y pos within 128x128 tile)
		add.w	d0,d1					; add to base address
		andi.w	#$E,d4					; d0 = high nybble of low byte of x pos, minus the highest bit
		add.w	d4,d1					; add to base address
		movea.l	d1,a1
		rts

; ---------------------------------------------------------------------------
; Lookup table of 128x128 tile addresses. These were calculated on the fly
; in Sonic 1.
; ---------------------------------------------------------------------------

TileOffsetList:
		c: = 0						; start at zero
		rept countof_128x128
		dc.w c						; include value
		c: = c+$80					; increment by 128
		endr						; repeat 256 times, generating the table

; ---------------------------------------------------------------------------
; Subroutine to	find the floor or ceiling

; input:
;	d2.w = y position of object's bottom edge
;	d3.w = x position of object
;	d5.l = bit to test for solidness: $D = top solid; $E = left/right/bottom solid
;	d6.w = eor bitmask for 16x16 tile
;	a3.w = height of 16x16 tiles: $10 or -$10 if object is inverted
;	a4 = RAM address to write angle byte

; output:
;	d1.w = distance to the floor
;	a1 = address within 128x128 mappings where object is standing
;	(a1).w = 16x16 tile number, x/yflip, solidness
;	(a4).b = floor angle

;	uses d0.w, d2.w, d4.w
; ---------------------------------------------------------------------------

FindFloor:
		bsr.w	FindNearestTile				; a1 = address within 128x128 mappings of 16x16 tile being stood on
		move.w	(a1),d0					; get value for solidness, orientation and 16x16 tile number
		move.w	d0,d4
		andi.w	#(~chunkmap_settings)&$FFFF,d0		; ignore solid/orientation bits
		beq.s	.isblank				; branch if tile is blank
		btst	d5,d4					; is the tile solid?
		bne.s	.issolid				; if yes, branch

.isblank:
		add.w	a3,d2
		bsr.w	FindFloor2				; try tile below the nearest
		sub.w	a3,d2
		addi.w	#$10,d1					; return distance to floor
		rts
; ===========================================================================

.issolid:
		movea.l	(v_collision_index_ptr).w,a2
		move.b	(a2,d0.w),d0				; get collision heightmap id
		andi.w	#$FF,d0					; heightmap id is 1 byte
		beq.s	.isblank				; branch if 0
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)				; get collision angle value
		lsl.w	#4,d0					; d0 = heightmap id * $10 (the width of a heightmap for 1 tile)
		move.w	d3,d1					; get x pos of object
		btst	#chunkmap_xflip_bit,d4			; is tile flipped horizontally?
		beq.s	.no_xflip				; if not, branch
		not.w	d1
		neg.b	(a4)					; xflip angle

	.no_xflip:
		btst	#chunkmap_yflip_bit,d4			; is tile flipped vertically?
		beq.s	.no_yflip				; if not, branch
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)				; yflip angle

	.no_yflip:
		andi.w	#$F,d1					; read only low nybble of x pos (i.e. x pos within 16x16 tile)
		add.w	d0,d1					; (id * $10) + x pos. = place in heightmap data
		lea	(CollArray1).l,a2
		move.b	(a2,d1.w),d0				; get actual height value from heightmap
		ext.w	d0
		eor.w	d6,d4					; apply x/yflip (allows for double-flip cancellation)
		btst	#chunkmap_yflip_bit,d4			; is block flipped vertically?
		beq.s	.no_yflip2				; if not, branch
		neg.w	d0

	.no_yflip2:
		tst.w	d0
		beq.s	.isblank				; branch if height is 0
		bmi.s	.negfloor				; branch if height is negative
		cmpi.b	#$10,d0
		beq.s	.maxfloor				; branch if height is $10 (max)
		move.w	d2,d1					; get y pos of object
		andi.w	#$F,d1					; read only low nybble for y pos within 16x16 tile
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1					; return distance to floor
		rts
; ===========================================================================

.negfloor:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	.isblank

.maxfloor:
		sub.w	a3,d2
		bsr.w	FindFloor2				; try tile above the nearest
		add.w	a3,d2
		subi.w	#$10,d1					; return distance to floor
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find the floor above/below the current 16x16 tile
; Almost identical to FindFloor, but a few key differences mean it cannot
; be easily combined with it.
; ---------------------------------------------------------------------------

FindFloor2:
		bsr.w	FindNearestTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#(~chunkmap_settings)&$FFFF,d0
		beq.s	.isblank2
		btst	d5,d4
		bne.s	.issolid

.isblank2:
		move.w	#$F,d1
		move.w	d2,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts
; ===========================================================================

.issolid:
		movea.l	(v_collision_index_ptr).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	.isblank2
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#chunkmap_xflip_bit,d4
		beq.s	.no_xflip
		not.w	d1
		neg.b	(a4)

	.no_xflip:
		btst	#chunkmap_yflip_bit,d4
		beq.s	.no_yflip
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

	.no_yflip:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray1).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#chunkmap_yflip_bit,d4
		beq.s	.no_yflip2
		neg.w	d0

	.no_yflip2:
		tst.w	d0
		beq.s	.isblank2
		bmi.s	.negfloor
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts
; ===========================================================================

.negfloor:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	.isblank2
		not.w	d1
		rts

; ===========================================================================

FindFloorRing_Cont:
		bsr.w	FindNearestTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	loc_1E922
		btst	d5,d4
		bne.s	loc_1E928

loc_1E922:
		move.w	#$10,d1
		rts
; ===========================================================================

loc_1E928:
		movea.l	(v_collision_index_ptr).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_1E922
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#$A,d4
		beq.s	loc_1E94E
		not.w	d1
		neg.b	(a4)

loc_1E94E:
		btst	#$B,d4
		beq.s	loc_1E95E
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_1E95E:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray1).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$B,d4
		beq.s	loc_1E97A
		neg.w	d0

loc_1E97A:
		tst.w	d0
		beq.s	loc_1E922
		bmi.s	loc_1E996
		cmpi.b	#$10,d0
		beq.s	loc_1E9A2
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts
; ===========================================================================

loc_1E996:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_1E922

loc_1E9A2:
		sub.w	a3,d2
		bsr.w	FindFloor2
		add.w	a3,d2
		subi.w	#$10,d1
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find a wall

; input:
;	d2.w = y position of object's bottom edge
;	d3.w = x position of object
;	d5.l = bit to test for solidness: $D = top solid; $E = left/right/bottom solid
;	d6.w = eor bitmask for 16x16 tile
;	a3.w = height of 16x16 tiles: $10 or -$10 if object is inverted
;	a4 = RAM address to write angle byte

; output:
;	d1.w = distance to the wall
;	a1 = address within 256x256 mappings where object is standing
;	(a1).w = 16x16 tile number, x/yflip, solidness
;	(a4).b = floor angle

;	uses d0.w, d3.w, d4.w
; ---------------------------------------------------------------------------

FindWall:
		bsr.w	FindNearestTile				; a1 = address within 256x256 mappings of 16x16 tile being stood on
		move.w	(a1),d0					; get value for solidness, orientation and 16x16 tile number
		move.w	d0,d4
		andi.w	#(~chunkmap_settings)&$FFFF,d0		; ignore solid/orientation bits
		beq.s	.isblank				; branch if tile is blank
		btst	d5,d4					; is the tile solid?
		bne.s	.issolid				; if yes, branch

.isblank:
		add.w	a3,d3
		bsr.w	FindWall2				; try tile to the right
		sub.w	a3,d3
		addi.w	#$10,d1					; return distance to wall
		rts
; ===========================================================================

.issolid:
		movea.l	(v_collision_index_ptr).w,a2
		move.b	(a2,d0.w),d0				; get collision heightmap id
		andi.w	#$FF,d0					; heightmap id is 1 byte
		beq.s	.isblank				; branch if 0
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)				; get collision angle value
		lsl.w	#4,d0					; d0 = heightmap id * $10 (the width of a heightmap for 1 tile)
		move.w	d2,d1					; get y pos of object
		btst	#chunkmap_yflip_bit,d4			; is block flipped vertically?
		beq.s	.no_yflip				; if not, branch
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)				; yflip angle

	.no_yflip:
		btst	#chunkmap_xflip_bit,d4			; is block flipped horizontally?
		beq.s	.no_xflip				; if not, branch
		neg.b	(a4)					; xflip angle

	.no_xflip:
		andi.w	#$F,d1					; read only low nybble of x pos (i.e. x pos within 16x16 tile)
		add.w	d0,d1					; (id * $10) + x pos. = place in heightmap data
		lea	(CollArray2).l,a2
		move.b	(a2,d1.w),d0				; get actual height value from heightmap
		ext.w	d0
		eor.w	d6,d4					; apply x/yflip (allows for double-flip cancellation)
		btst	#chunkmap_xflip_bit,d4			; is block flipped horizontally?
		beq.s	.no_xflip2				; if not, branch
		neg.w	d0

	.no_xflip2:
		tst.w	d0
		beq.s	.isblank				; branch if height is 0
		bmi.s	.negfloor				; branch if height is negative
		cmpi.b	#$10,d0
		beq.s	.maxfloor				; branch if height is $10 (max)
		move.w	d3,d1					; get x pos of object
		andi.w	#$F,d1					; read only low nybble for x pos within 16x16 tile
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1					; return distance to wall
		rts
; ===========================================================================

.negfloor:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	.isblank

.maxfloor:
		sub.w	a3,d3
		bsr.w	FindWall2				; try tile to the left
		add.w	a3,d3
		subi.w	#$10,d1					; return distance to wall
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find a wall left/right of the current 16x16 tile.
; Almost identical to FindWall, but a few key differences mean it cannot
; be easily combined with it.
; ---------------------------------------------------------------------------

FindWall2:
		bsr.w	FindNearestTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$3FF,d0
		beq.s	.isblank
		btst	d5,d4
		bne.s	.issolid

.isblank:
		move.w	#$F,d1
		move.w	d3,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts
; ===========================================================================

.issolid:
		movea.l	(v_collision_index_ptr).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	.isblank
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d2,d1
		btst	#chunkmap_yflip_bit,d4
		beq.s	.no_yflip
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

	.no_yflip:
		btst	#chunkmap_xflip_bit,d4
		beq.s	.no_xflip
		neg.b	(a4)

	.no_xflip:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray2).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#chunkmap_xflip_bit,d4
		beq.s	.no_xflip2
		neg.w	d0

	.no_xflip2:
		tst.w	d0
		beq.s	.isblank
		bmi.s	.negfloor
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts
; ===========================================================================

.negfloor:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	.isblank
		not.w	d1
		rts

; ---------------------------------------------------------------------------
; Unused collision array converter

; This subroutine takes 'raw' bitmap-like collision block data as input and
; converts it into the proper collision arrays (ColArray and ColArray2).
; Pointers to said raw data are dummied out.
; Curiously, an example of the original 'raw' data that this was intended
; to process can be found in the J2ME version, in a file called 'blkcol.bct'.

;	uses d0.l, d1.w, d2.w, d3.w, d4.l, d5.l, a1, a2
; ---------------------------------------------------------------------------

RawColBlocks		equ CollArray1
ConvRowColBlocks	equ CollArray1

ConvertCollisionArray:
		rts						; dummied out
; ===========================================================================

		; The raw format stores the collision data column by column for the normal collision array.
		; This makes a copy of the data, but stored row by row, for the rotated collision array.
		lea	(RawColBlocks).l,a1			; source location of raw collision block data
		lea	(ConvRowColBlocks).l,a2			; destinatation location for row-converted collision block data
		move.w	#$100-1,d3				; Nnmber of blocks in collision data

	.blockloop:
		moveq	#16,d5					; start on the 16th bit (the leftmost pixel)
		move.w	#16-1,d2				; width of a block in pixels

	.columnloop:
		moveq	#0,d4
		move.w	#16-1,d1				; height of a block in pixels

	.rowloop:
		move.w	(a1)+,d0				; get row of collision bits
		lsr.l	d5,d0					; push the selected bit of this row into the 'eXtend' flag
		addx.w	d4,d4					; shift d4 to the left, and insert the selected bit into bit 0
		dbf	d1,.rowloop				; loop for each row of pixels in a block

		move.w	d4,(a2)+				; store column of collision bits
		suba.w	#2*16,a1				; back to the start of the block
		subq.w	#1,d5					; get next bit in the row
		dbf	d2,.columnloop				; loop for each column of pixels in a block

		adda.w	#2*16,a1				; next block
		dbf	d3,.blockloop				; loop for each block in the raw collision block data

		; This then converts the collision data into the final collision arrays.
		lea	(ConvRowColBlocks).l,a1
		lea	(CollArray2).l,a2
		bsr.s	.convertarray				; convert the row-converted collision block data into final rotated collision array
		lea	(RawColBlocks).l,a1
		lea	(CollArray1).l,a2			; convert the raw collision block data into final normal collision array

	.convertarray:
		move.w	#$1000-1,d3				; Size of the collision array

	.processloop:
		moveq	#0,d2
		move.w	#$F,d1
		move.w	(a1)+,d0				; get current column of collision pixels
		beq.s	.nocollision				; branch if there's no collision in this column
		bmi.s	.toppixelsolid				; branch if top pixel of collision is solid

	; Here we count, starting from the bottom, how many pixels tall
	; the collision in this column is.
	.processcolumnloop1:
		lsr.w	#1,d0
		bcc.s	.pixelnotsolid1
		addq.b	#1,d2

	.pixelnotsolid1:
		dbf	d1,.processcolumnloop1

		bra.s	.columnprocessed
; ===========================================================================

	.toppixelsolid:
		cmpi.w	#$FFFF,d0				; is entire column solid?
		beq.s	.entirecolumnsolid			; branch if so

	; Here we count, starting from the top, how many pixels tall
	; the collision in this column is (the resulting number is negative).
	.processcolumnloop2:
		lsl.w	#1,d0
		bcc.s	.pixelnotsolid2
		subq.b	#1,d2

	.pixelnotsolid2:
		dbf	d1,.processcolumnloop2

		bra.s	.columnprocessed
; ===========================================================================

	.entirecolumnsolid:
		move.w	#$10,d0

	.nocollision:
		move.w	d0,d2

	.columnprocessed:
		move.b	d2,(a2)+				; store column collision height
		dbf	d3,.processloop

		rts

; ===========================================================================

	if Revision<2
		nop
	endc

; ---------------------------------------------------------------------------
; Subroutine to	calculate distance from Sonic/Tails to the wall in front of
; them

; input:
;	d0 = player's floor angle rotated 90 degrees (i.e. angle of wall ahead)

; output:
;	d1 = distance to wall
; ---------------------------------------------------------------------------

Player_CalcRoomAhead:
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a0) ; is player on plane 0?
		beq.s	.useprimary				; if so, branch
		move.l	#v_secondary_collision,(v_collision_index_ptr).w ; use secondary collision

	.useprimary:
		move.b	ost_lrb_solid_bit(a0),d5		; bit to test for solidness
		move.l	ost_x_pos(a0),d3
		move.l	ost_y_pos(a0),d2
		move.w	ost_x_vel(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3					; d3 = predicted x pos. at next frame
		move.w	ost_y_vel(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2					; d2 = predicted y pos. at next frame
		swap	d2
		swap	d3
		move.b	d0,(v_angle_right).w
		move.b	d0,(v_angle_left).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	.floor_or_left				; branch if angle is floor or left vertical
		move.b	d1,d0
		bpl.s	.angle_pos
		subq.b	#1,d0

	.angle_pos:
		addi.b	#$20,d0
		bra.s	.find_wall
; ===========================================================================

.floor_or_left:
		move.b	d1,d0
		bpl.s	.angle_pos_
		addq.b	#1,d0

	.angle_pos_:
		addi.b	#$1F,d0

.find_wall:
		andi.b	#$C0,d0
		beq.w	Player_FindFloor_Quick
		cmpi.b	#$80,d0
		beq.w	Player_FindCeiling_Quick
		andi.b	#$38,d1
		bne.s	.find_wall_lr
		addq.w	#8,d2

	.find_wall_lr:
		cmpi.b	#$40,d0
		beq.w	Player_FindWallLeft_Quick
		bra.w	Player_FindWallRight_Quick

; ---------------------------------------------------------------------------
; Subroutine to	calculate distance from Sonic/Tails' head to the ceiling

; input:
;	d0 = player's floor angle inverted

; output:
;	d1 = distance to ceiling

;	uses d5.b
; ---------------------------------------------------------------------------

Player_CalcHeadroom:
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a0) ; is player on plane 0?
		beq.s	.useprimary				; if so, branch
		move.l	#v_secondary_collision,(v_collision_index_ptr).w ; use secondary collision

	.useprimary:
		move.b	ost_lrb_solid_bit(a0),d5
		move.b	d0,(v_angle_right).w
		move.b	d0,(v_angle_left).w
		addi.b	#$20,d0
		andi.b	#$C0,d0					; read only bits 6 and 7 of angle
		cmpi.b	#$40,d0					; is Sonic on a left-facing wall?
		beq.w	Player_FindWallLeft			; ceiling is to the left
		cmpi.b	#$80,d0					; is Sonic on the ground?
		beq.w	Player_FindCeiling			; ceiling is directly above
		cmpi.b	#$C0,d0					; is Sonic on a right-facing wall?
		beq.w	Player_FindWallRight			; ceiling is to the right
		; else, fall through to Player_FindFloor (could skip the collision layer check with a bra.s)

; ---------------------------------------------------------------------------
; Subroutine to	find Sonic/Tails' distance to the floor

; output:
;	d0 = distance to floor (larger if on a slope)
;	d1 = distance to floor (smaller if on a slope)
;	d3 = floor angle
;	a1 = address within 256x256 mappings where Sonic is standing
;	(a1) = 16x16 tile number
;	(a4) = floor angle
; ---------------------------------------------------------------------------

Player_FindFloor:
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a0) ; is player on plane 0?
		beq.s	.useprimary				; if so, branch
		move.l	#v_secondary_collision,(v_collision_index_ptr).w ; use secondary collision

	.useprimary:
		move.b	ost_top_solid_bit(a0),d5		; bit to check for solidness
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos. of player's bottom edge
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d3					; d3 = x pos. of player's right edge
		lea	(v_angle_right).w,a4			; write angle here
		movea.w	#$10,a3					; tile height
		move.w	#0,d6
		bsr.w	FindFloor
		pushr.w	d1					; save d1 (distance to floor) to stack

		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos. of player's bottom edge
		move.b	ost_width(a0),d0
		ext.w	d0
		sub.w	d0,d3					; d3 = x pos. of player's left edge
		lea	(v_angle_left).w,a4			; write angle here
		movea.w	#$10,a3					; tile height
		move.w	#0,d6					; EOR bitmask
		bsr.w	FindFloor				; d1 = distance to floor left side
		popr.w	d0					; d0 = distance to floor right side
		move.b	#0,d2

Player_FindSmaller:
		move.b	(v_angle_left).w,d3
		cmp.w	d0,d1					; compare the output distances
		ble.s	.no_swap				; branch if d0 > d1
		move.b	(v_angle_right).w,d3
		exg	d0,d1					; d1 is always the smaller distance

	.no_swap:
		btst	#0,d3					; is bit 0 of angle set?
		beq.s	.no_angle_snap				; if not, branch
		move.b	d2,d3					; clear d3 (this is copied to ost_angle)

	.no_angle_snap:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	find distance to floor, no width/height or collision layer
; checks

; input:
;	d2 = y position of Sonic
;	d3 = x position of Sonic

; output:
;	d1 = distance to floor
;	d3 = floor angle
;	a1 = address within 256x256 mappings where player is standing
;	(a1).w = 16x16 tile number
;	(a4).b = floor angle
; ---------------------------------------------------------------------------

;Player_FindFloor_Quick_UsePos:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3

Player_FindFloor_Quick:
		addi.w	#sonic_average_radius,d2
		lea	(v_angle_right).w,a4			; write angle here
		movea.w	#$10,a3					; tile height
		move.w	#0,d6
		bsr.w	FindFloor
		move.b	#0,d2

Player_SnapAngle:
		move.b	(v_angle_right).w,d3
		btst	#0,d3
		beq.s	.no_angle_snap				; branch if bit 0 of angle is clear
		move.b	d2,d3					; snap angle to 0, $40, $80 or $C0

	.no_angle_snap:
		rts

; ---------------------------------------------------------------------------
; Unused collision checking subroutine
; ---------------------------------------------------------------------------

		move.w	ost_x_pos(a0),d3
		move.w	ost_y_pos(a0),d2
		subq.w	#4,d2
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a0)
		beq.s	.useprimary
		move.l	#v_secondary_collision,(v_collision_index_ptr).w

	.useprimary:
		lea	(v_angle_right).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		move.b	ost_lrb_solid_bit(a0),d5
		bsr.w	FindFloor
		move.b	(v_angle_right).w,d3
		btst	#0,d3
		beq.s	.nosnap
		move.b	#0,d3

	.nosnap:
		rts

; ---------------------------------------------------------------------------
; Subroutine to find the the distance of an object to the floor, taking both
; collision layers into account. Identical to FindFloorObj, expect it checks
; which collision layer the object is on and sets the appropriate collision
; pointer for FindFloor.

; input:
;	d3.w =  x position of object (FindFloorObj_ChkCol_NoX only)

; output:
;	d1 = distance to floor
;	d3 = floor angle
;	a1 = address within 256x256 mappings where player is standing
;	(a1).w = 16x16 tile number
;	(a4).b = floor angle

;	uses d0.w, d5.b, d6.w, a3
; ---------------------------------------------------------------------------

FindFloorObj_ChkCol:
		move.w	ost_x_pos(a0),d3

FindFloorObj_ChkCol_NoX:
		move.w	ost_y_pos(a0),d2
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos of bottom edge of object
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a0) ; is object on plane 0?
		beq.s	.useprimary				; if so, branch
		move.l	#v_secondary_collision,(v_collision_index_ptr).w ; use secondary collision

	.useprimary:
		lea	(v_angle_right).w,a4			; write angle here
		move.b	#0,(a4)
		movea.w	#$10,a3					; height of a 16x16 tile
		move.w	#0,d6					; EOR bitmask
		move.b	ost_top_solid_bit(a0),d5		; bit to test for solidness
		bsr.w	FindFloor
		move.b	(v_angle_right).w,d3
		btst	#0,d3					; is angle snap bit set?
		beq.s	.exit
		move.b	#0,d3					; snap to flat floor

	.exit:
		rts

; ---------------------------------------------------------------------------
; Identical to FindFloorObj_ChkCol, expect object = a1
; ---------------------------------------------------------------------------

FindFloorObj_ChkCol2:
		move.w	ost_x_pos(a1),d3
		move.w	ost_y_pos(a1),d2
		moveq	#0,d0
		move.b	ost_height(a1),d0
		ext.w	d0
		add.w	d0,d2					; d2 = y pos of bottom edge of object
		move.l	#v_primary_collision,(v_collision_index_ptr).w
		cmpi.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; is object on plane 0?
		beq.s	.useprimary				; if so, branch
		move.l	#v_secondary_collision,(v_collision_index_ptr).w ; use secondary collision

	.useprimary:
		lea	(v_angle_right).w,a4			; write angle here
		move.b	#0,(a4)
		movea.w	#$10,a3					; height of a 16x16 tile
		move.w	#0,d6					; EOR bitmask
		move.b	ost_top_solid_bit(a1),d5		; bit to test for solidness
		bsr.w	FindFloor
		move.b	(v_angle_right).w,d3
		btst	#0,d3					; is angle snap bit set?
		beq.s	.exit
		move.b	#0,d3					; snap to flat floor

	.exit:
		rts
; ===========================================================================
;ObjCheckFloorDist:
FindFloorObj:
		move.w	ost_x_pos(a0),d3
		move.w	ost_y_pos(a0),d2
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2
		lea	(v_angle_right).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5
		bsr.w	FindFloor
		move.b	(v_angle_right).w,d3
		btst	#0,d3
		beq.s	locret_1EE2E
		move.b	#0,d3

locret_1EE2E:
		rts
; ===========================================================================

FindFloorFire:
		move.w	ost_x_pos(a1),d3
		move.w	ost_y_pos(a1),d2
		move.b	ost_height(a1),d0
		ext.w	d0
		add.w	d0,d2
		lea	(v_angle_right).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5
		bra.w	FindFloor
; ===========================================================================

FindFloorRing:
		move.w	ost_x_pos(a0),d3
		move.w	ost_y_pos(a0),d2
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d2
		lea	(v_angle_right).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$C,d5
		bra.w	FindFloorRing_Cont
; ===========================================================================

Player_FindWallRight:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	(v_angle_right).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall
		move.w	d1,-(sp)
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	ost_height(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	(v_angle_left).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall
		move.w	(sp)+,d0
		move.b	#-$40,d2
		bra.w	Player_FindSmaller
; ===========================================================================

Player_FindWallRight_Quick_UsePos:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3

Player_FindWallRight_Quick:
		addi.w	#$A,d3
		lea	(v_angle_right).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		bsr.w	FindWall
		move.b	#-$40,d2
		bra.w	Player_SnapAngle
; ===========================================================================
;ObjCheckRightWallDist:
FindWallRightObj:
		add.w	ost_x_pos(a0),d3
		move.w	ost_y_pos(a0),d2
		lea	(v_angle_right).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr.w	FindWall
		move.b	(v_angle_right).w,d3
		btst	#0,d3
		beq.s	locret_1EF2C
		move.b	#-$40,d3

locret_1EF2C:
		rts
; ===========================================================================

Player_FindCeiling:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	(v_angle_right).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		bsr.w	FindFloor
		move.w	d1,-(sp)
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	ost_width(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	(v_angle_left).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		bsr.w	FindFloor
		move.w	(sp)+,d0
		move.b	#-$80,d2
		bra.w	Player_FindSmaller
; ===========================================================================
		; unused/dead.
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3

Player_FindCeiling_Quick:
		subi.w	#$A,d2
		eori.w	#$F,d2
		lea	(v_angle_right).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		bsr.w	FindFloor
		move.b	#-$80,d2
		bra.w	Player_SnapAngle
; ===========================================================================

FindCeilingObj:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		lea	(v_angle_right).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$D,d5
		bsr.w	FindFloor
		move.b	(v_angle_right).w,d3
		btst	#0,d3
		beq.s	locret_1EFF4
		move.b	#-$80,d3

locret_1EFF4:
		rts
; ===========================================================================

Player_FindWallLeft:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	(v_angle_right).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall
		pushr.w	d1
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3
		moveq	#0,d0
		move.b	ost_width(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	ost_height(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	(v_angle_left).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall
		popr.w	d0
		move.b	#$40,d2
		bra.w	Player_FindSmaller
; ===========================================================================

Player_FindWallLeft_Quick_UsePos:
		move.w	ost_y_pos(a0),d2
		move.w	ost_x_pos(a0),d3

Player_FindWallLeft_Quick:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	(v_angle_right).w,a4
		movea.w	#-$10,a3
		move.w	#$400,d6
		bsr.w	FindWall
		move.b	#$40,d2
		bra.w	Player_SnapAngle
; ===========================================================================

FindWallLeftObj:
		add.w	ost_x_pos(a0),d3
		move.w	ost_y_pos(a0),d2
	if FixBugs
		; Colliding with left walls is erratic with this function.
		; This is caused by a missing instruction to flip collision on the 16x16 block.
		eori.w	#$F,d3
	endc
		lea	(v_angle_right).w,a4
		move.b	#0,(a4)
		movea.w	#-$10,a3
		move.w	#$400,d6
		moveq	#$D,d5
		bsr.w	FindWall
		move.b	(v_angle_right).w,d3
		btst	#0,d3
		beq.s	locret_1F0B2
		move.b	#$40,d3

locret_1F0B2:
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 79 - lamppost / starpost / checkpoint
; ----------------------------------------------------------------------------

Starpost:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Starpost_Index(pc,d0.w),d1
		jmp	Starpost_Index(pc,d1.w)
; ===========================================================================
Starpost_Index:	index offset(*),,2
		ptr loc_1F0CC					; 0
		ptr loc_1F12C					; 1
		ptr loc_1F230					; 2
		ptr loc_1F240					; 3
		ptr loc_1F536					; 4
; ===========================================================================

loc_1F0CC:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Starpost,ost_mappings(a0)
		move.w	#tile_Nem_Checkpoint,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo3_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#5,ost_priority(a0)
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
    if FixBugs
		; If you spawn a checkpoint in Debug Mode and activate it, then
		; every checkpoint that is spawned with Debug Mode afterwards will be
		; activated too. The cause of the bug is that the spawned checkpoint
		; does not have a respawn entry, but this object fails to check for
		; that before accessing the respawn table.
		beq.s	loc_1F12C
    endc
		bclr	#7,2(a2,d0.w)
		btst	#0,2(a2,d0.w)
		bne.s	loc_1F120
		move.b	(v_last_lamppost).w,d1
		andi.b	#$7F,d1
		move.b	ost_subtype(a0),d2
		andi.b	#$7F,d2
		cmp.b	d2,d1
		bcs.s	loc_1F12C

loc_1F120:
		bset	#0,2(a2,d0.w)
		move.b	#2,ost_anim(a0)

loc_1F12C:
		tst.w	(v_debug_active).w
		bne.w	loc_1F230
		lea	($FFFFB000).w,a3
		move.b	(v_last_lamppost).w,d1
		bsr.s	loc_1F154
		tst.w	(f_two_player).w
		beq.w	loc_1F230
		lea	($FFFFB040).w,a3
		move.b	(v_last_lamppost_p2).w,d1
		bsr.s	loc_1F154
		bra.w	loc_1F230
; ===========================================================================

loc_1F154:
		andi.b	#$7F,d1
		move.b	ost_subtype(a0),d2
		andi.b	#$7F,d2
		cmp.b	d2,d1
		bcc.w	loc_1F222
		move.w	ost_x_pos(a3),d0
		sub.w	ost_x_pos(a0),d0
		addi_.w	#8,d0
		cmpi.w	#$10,d0
		bcc.w	locret_1F220
		move.w	ost_y_pos(a3),d0
		sub.w	ost_y_pos(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$68,d0
		bcc.w	locret_1F220
		move.w	#$A1,d0
		jsr	(PlaySound).l
		jsr	(FindFreeObj).l
		bne.s	loc_1F206
		_move.b	#id_Starpost,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),$30(a1)
		move.w	ost_y_pos(a0),$32(a1)
		subi.w	#$14,$32(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.b	#2,ost_frame(a1)
		move.w	#$20,$36(a1)
		move.w	a0,$3E(a1)
		tst.w	(f_two_player).w
		bne.s	loc_1F206
		cmpi.b	#7,(v_emeralds).w
		beq.s	loc_1F206
		cmpi.w	#$32,(v_rings).w
		bcs.s	loc_1F206
		bsr.w	loc_1F4C4

loc_1F206:
		move.b	#1,ost_anim(a0)

loc_1F20C:
		bsr.w	loc_1F298
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
	if FixBugs
		; If you spawn a checkpoint in Debug Mode and activate it, then
		; every checkpoint that is spawned with Debug Mode afterwards will be
		; activated too. The cause of the bug is that the spawned checkpoint
		; does not have a respawn entry, but this object fails to check for
		; that before accessing the respawn table.
		beq.s	locret_1F220
	endc
		bset	#0,2(a2,d0.w)

locret_1F220:
		rts
; ===========================================================================

loc_1F222:
		tst.b	ost_anim(a0)
		bne.s	locret_1F22E
		move.b	#2,ost_anim(a0)

locret_1F22E:
		rts
; ===========================================================================

loc_1F230:
		lea	(byte_1F414).l,a1
		jsrto	AnimateSprite,JmpTo2_AnimateSprite
		jmp	(DespawnObject).l
; ===========================================================================

loc_1F240:
		subq.w	#1,$36(a0)
		bpl.s	loc_1F262
		movea.w	$3E(a0),a1
		cmpi.b	#id_Starpost,ost_id(a1)
		bne.s	loc_1F25C
		move.b	#2,ost_anim(a1)
		move.b	#0,ost_frame(a1)

loc_1F25C:
		jmp	(DeleteObject).l
; ===========================================================================

loc_1F262:
		move.b	ost_angle(a0),d0
		subi.b	#$10,ost_angle(a0)
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$C00,d1
		swap	d1
		add.w	$30(a0),d1
		move.w	d1,ost_x_pos(a0)
		muls.w	#$C00,d0
		swap	d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		jmp	(DespawnObject).l
; ===========================================================================

loc_1F298:
		cmpa.w	#v_ost_player1,a3
		bne.w	loc_1F326
		move.b	ost_subtype(a0),(v_last_lamppost).w
		move.b	(v_last_lamppost).w,(v_last_lamppost_lampcopy).w
		move.w	ost_x_pos(a0),(v_x_pos_lampcopy).w
		move.w	ost_y_pos(a0),(v_y_pos_lampcopy).w
		move.w	(v_ost_player1+ost_tile).w,(v_ost_tile_lampcopy).w
		move.w	(v_ost_player1+ost_top_solid_bit).w,(v_ost_top_solid_bit_lampcopy).w
		move.w	(v_rings).w,(v_rings_lampcopy).w
		move.b	(v_ring_reward).w,(v_ring_reward_lampcopy).w
		move.l	(v_time).w,(v_time_lampcopy).w
		move.b	(v_dle_routine).w,(v_dle_routine_lampcopy).w
		move.w	(v_boundary_bottom).w,(v_boundary_bottom_next_lampcopy).w
		move.w	(v_camera_x_pos).w,(v_camera_x_pos_lampcopy).w
		move.w	(v_camera_y_pos).w,(v_camera_y_pos_lampcopy).w
		move.w	(v_bg1_x_pos).w,(v_bg1_x_pos_lampcopy).w
		move.w	(v_bg1_y_pos).w,(v_bg1_y_pos_lampcopy).w
		move.w	(v_bg2_x_pos).w,(v_bg2_x_pos_lampcopy).w
		move.w	(v_bg2_y_pos).w,(v_bg2_y_pos_lampcopy).w

loc_1F306:
		move.w	(v_bg3_x_pos).w,(v_bg3_x_pos_lampcopy).w
		move.w	(v_bg3_y_pos).w,(v_bg3_y_pos_lampcopy).w
		move.w	(v_water_height_normal).w,(v_water_height_normal_lampcopy).w
		move.b	(v_water_routine).w,(v_water_routine_lampcopy).w
		move.b	(f_water_pal_full).w,(f_water_pal_full_lampcopy).w
		rts
; ===========================================================================

loc_1F326:
		move.b	ost_subtype(a0),(v_last_lamppost_p2).w
		move.b	(v_last_lamppost_p2).w,(v_last_lamppost_p2_lampcopy).w
		move.w	ost_x_pos(a0),(v_x_pos_p2_lampcopy).w
		move.w	ost_y_pos(a0),(v_y_pos_p2_lampcopy).w
		move.w	(v_ost_player2+ost_tile).w,(v_ost_tile_p2_lampcopy).w
		move.w	(v_ost_player2+ost_top_solid_bit).w,(v_ost_top_solid_bit_p2_lampcopy).w
		move.w	(v_rings_p2).w,(v_rings_p2_lampcopy).w
		move.b	(v_ring_reward_p2).w,(v_ring_reward_lampcopy_2p).w

loc_1F356:
		move.l	(v_time_p2).w,(v_time_p2_lampcopy).w
		rts
; ===========================================================================

Starpost_LoadInfo:
		move.b	(v_last_lamppost_lampcopy).w,(v_last_lamppost).w
		move.w	(v_x_pos_lampcopy).w,($FFFFB008).w
		move.w	(v_y_pos_lampcopy).w,($FFFFB00C).w
		move.w	(v_rings_lampcopy).w,(v_rings).w
		move.b	(v_ring_reward_lampcopy).w,(v_ring_reward).w
		clr.w	(v_rings).w
		clr.b	(v_ring_reward).w
		move.l	(v_time_lampcopy).w,(v_time).w
		move.b	#$3B,(v_time_frames).w
		subq.b	#1,(v_time_sec).w
		move.w	(v_ost_tile_lampcopy).w,(v_ost_player1+ost_tile).w
		move.w	(v_ost_top_solid_bit_lampcopy).w,(v_ost_player1+ost_top_solid_bit).w
		move.b	(v_dle_routine_lampcopy).w,(v_dle_routine).w
		move.b	(v_water_routine_lampcopy).w,(v_water_routine).w
		move.w	(v_boundary_bottom_next_lampcopy).w,(v_boundary_bottom).w
		move.w	(v_boundary_bottom_next_lampcopy).w,(v_boundary_bottom_next).w
		move.w	(v_camera_x_pos_lampcopy).w,(v_camera_x_pos).w
		move.w	(v_camera_y_pos_lampcopy).w,(v_camera_y_pos).w
		move.w	(v_bg1_x_pos_lampcopy).w,(v_bg1_x_pos).w
		move.w	(v_bg1_y_pos_lampcopy).w,(v_bg1_y_pos).w
		move.w	(v_bg2_x_pos_lampcopy).w,(v_bg2_x_pos).w

loc_1F3D6:
		move.w	(v_bg2_y_pos_lampcopy).w,(v_bg2_y_pos).w
		move.w	(v_bg3_x_pos_lampcopy).w,(v_bg3_x_pos).w
		move.w	(v_bg3_y_pos_lampcopy).w,(v_bg3_y_pos).w

loc_1F3E8:
		tst.b	(f_water).w
		beq.s	loc_1F400
		move.w	(v_water_height_normal_lampcopy).w,(v_water_height_normal).w
		move.b	(v_water_routine_lampcopy).w,(v_water_routine).w
		move.b	(f_water_pal_full_lampcopy).w,(f_water_pal_full).w

loc_1F400:
		tst.b	(v_last_lamppost).w

loc_1F404:
		bpl.s	locret_1F412
		move.w	(v_x_pos_lampcopy).w,d0
		subi.w	#$A0,d0
		move.w	d0,(v_boundary_left).w

locret_1F412:
		rts
; ===========================================================================
byte_1F414:
		dc.b   0					; 0
		dc.b   6					; 1
		dc.b   0					; 2
		dc.b   9					; 3
		dc.b   0					; 4
		dc.b  $C					; 5
		dc.b  $F					; 6
		dc.b   0					; 7
		dc.b $FF					; 8
		dc.b  $F					; 9
		dc.b   1					; 10
		dc.b $FF					; 11
		dc.b   3					; 12
		dc.b   0					; 13
		dc.b   4					; 14
		dc.b $FF					; 15

; ===========================================================================

		include "mappings/sprite/Starpost.asm"
		include "mappings/sprite/Starpost Star Halo.asm"

; ===========================================================================

loc_1F4C4:
		moveq	#4-1,d1
		moveq	#0,d2

loc_1F4C8:
		bsr.w	FindNextFreeObj
		bne.s	locret_1F534
		_move.b	ost_id(a0),ost_id(a1)
		move.l	#Map_SpecialEntryStars,ost_mappings(a1)
		move.w	#tile_Nem_Checkpoint,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#8,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),d0
		move.w	d0,ost_x_pos(a1)
		move.w	d0,$30(a1)
		move.w	ost_y_pos(a0),d0
		subi.w	#$30,d0

loc_1F502:
		move.w	d0,ost_y_pos(a1)
		move.w	d0,$32(a1)

loc_1F50A:
		move.b	ost_priority(a0),ost_priority(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	#1,ost_frame(a1)
		move.w	#-$400,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		move.w	d2,$34(a1)
		addi.w	#$40,d2
		dbf	d1,loc_1F4C8

locret_1F534:
		rts
; ===========================================================================

loc_1F536:
		move.b	ost_col_property(a0),d0
		beq.w	loc_1F554
		andi.b	#1,d0
		beq.s	loc_1F550
		move.b	#1,(f_unused_ss_flag).w
		move.b	#$10,(v_gamemode).w

loc_1F550:
		clr.b	ost_col_property(a0)

loc_1F554:
		addi.w	#$A,$34(a0)
		move.w	$34(a0),d0
		andi.w	#$FF,d0
		jsr	(CalcSine).l
		asr.w	#5,d0
		asr.w	#3,d1
		move.w	d1,d3
		move.w	$34(a0),d2
		andi.w	#$3E0,d2
		lsr.w	#5,d2
		moveq	#2,d5
		moveq	#0,d4
		cmpi.w	#$10,d2
		ble.s	loc_1F584
		neg.w	d1

loc_1F584:
		andi.w	#$F,d2
		cmpi.w	#8,d2
		ble.s	loc_1F594
		neg.w	d2
		andi.w	#7,d2

loc_1F594:
		lsr.w	#1,d2
		beq.s	loc_1F59A
		add.w	d1,d4

loc_1F59A:
		asl.w	#1,d1
		dbf	d5,loc_1F594
		asr.w	#4,d4
		add.w	d4,d0
		addq.w	#1,$36(a0)
		move.w	$36(a0),d1
		cmpi.w	#$80,d1
		beq.s	loc_1F5BE
		bgt.s	loc_1F5C4

loc_1F5B4:
		muls.w	d1,d0
		muls.w	d1,d3
		asr.w	#7,d0
		asr.w	#7,d3
		bra.s	loc_1F5D6
; ===========================================================================

loc_1F5BE:
		move.b	#id_col_4x4+id_col_custom,ost_col_type(a0)

loc_1F5C4:
		cmpi.w	#$180,d1
		ble.s	loc_1F5D6
		neg.w	d1
		addi.w	#$200,d1
		bmi.w	JmpTo10_DeleteObject
		bra.s	loc_1F5B4
; ===========================================================================

loc_1F5D6:
		move.w	$30(a0),d2
		add.w	d3,d2
		move.w	d2,ost_x_pos(a0)
		move.w	$32(a0),d2
		add.w	d0,d2
		move.w	d2,ost_y_pos(a0)
		addq.b	#1,ost_anim_frame(a0)
		move.b	ost_anim_frame(a0),d0
		andi.w	#6,d0
		lsr.w	#1,d0
		cmpi.b	#3,d0
		bne.s	loc_1F600
		moveq	#1,d0

loc_1F600:
		move.b	d0,ost_frame(a0)
		jmpto	DespawnObject,JmpTo_DespawnObject
; ===========================================================================

JmpTo10_DeleteObject:
		jmp	(DeleteObject).l


	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_DespawnObject:
		jmp	(DespawnObject).l
JmpTo2_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo3_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 7D - Hidden bonus points (unused Sonic 1 leftover)
; ----------------------------------------------------------------------------

HiddenBonus:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1F632(pc,d0.w),d1
		jmp	off_1F632(pc,d1.w)
; ===========================================================================
off_1F632:	index offset(*),,2
		ptr loc_1F636					; 0
		ptr loc_1F6DA					; 2
; ===========================================================================

loc_1F636:
		moveq	#$10,d2
		move.w	d2,d3
		add.w	d3,d3
		lea	(v_ost_player1).w,a1
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.s	loc_1F6B8
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bcc.s	loc_1F6B8
		tst.w	(v_debug_active).w
		bne.s	loc_1F6B8
		tst.b	(f_unused_ss_flag).w
		bne.s	loc_1F6B8
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Bonus,ost_mappings(a0)
		move.w	#(vram_Bonus/sizeof_cell)+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo4_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#0,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	ost_subtype(a0),ost_frame(a0)
		move.w	#$77,$30(a0)
		move.w	#$C9,d0
		jsr	(PlaySound).l
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		move.w	word_1F6D2(pc,d0.w),d0
		jsr	(AddPoints).l

loc_1F6B8:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	JmpTo11_DeleteObject
		rts
; ===========================================================================

JmpTo11_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================
word_1F6D2:
		dc.w	 0					; 0
		dc.w  1000					; 1
		dc.w   100					; 2
		dc.w	 1					; bug: should be 10
; ===========================================================================

loc_1F6DA:
		subq.w	#1,$30(a0)
		bmi.s	JmpTo12_DeleteObject
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	JmpTo12_DeleteObject
		jmp	(DisplaySprite).l
; ===========================================================================

JmpTo12_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================

		include "mappings/sprite/Hidden Bonus Points (unused).asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo4_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 44 - Round bumpers
; ----------------------------------------------------------------------------

Bumper:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_1F73E(pc,d0.w),d1
		jmp	off_1F73E(pc,d1.w)
; ===========================================================================
off_1F73E:	index offset(*),,2
		ptr loc_1F742					; 0
		ptr loc_1F770					; 2
; ===========================================================================

loc_1F742:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_RoundBump,ost_mappings(a0)
		move.w	#tile_Nem_RoundBumper+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo5_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	#id_col_8x8_2+id_col_custom,ost_col_type(a0)

loc_1F770:
		move.b	ost_col_property(a0),d0
		beq.w	loc_1F83E
		lea	(v_ost_player1).w,a1
		bclr	#0,ost_col_property(a0)
		beq.s	loc_1F786
		bsr.s	loc_1F79C

loc_1F786:
		lea	(v_ost_player2).w,a1
		bclr	#1,ost_col_property(a0)
		beq.s	loc_1F794
		bsr.s	loc_1F79C

loc_1F794:
		clr.b	ost_col_property(a0)
		bra.w	loc_1F83E
; ===========================================================================

loc_1F79C:
		move.w	ost_x_pos(a0),d1
		move.w	ost_y_pos(a0),d2
		sub.w	ost_x_pos(a1),d1
		sub.w	ost_y_pos(a1),d2
		jsr	(CalcAngle).l
		move.b	(v_frame_counter).w,d1
		andi.w	#3,d1
		add.w	d1,d0
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a1)
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#4,ost_primary_status(a1)
		bclr	#5,ost_primary_status(a1)
		clr.b	$3C(a1)
		move.b	#1,ost_anim(a0)
		move.w	#$B4,d0
		jsr	(PlaySound).l
		lea	(v_respawn_list).w,a2

loc_1F800:
		moveq	#0,d0

loc_1F802:
		move.b	ost_respawn(a0),d0
		beq.s	loc_1F814

loc_1F808:
		cmpi.b	#-$76,2(a2,d0.w)

loc_1F80E:
		bcc.s	locret_1F83C
		addq.b	#1,2(a2,d0.w)

loc_1F814:
		moveq	#1,d0
		movea.w	a1,a3
		jsr	(AddPoints2).l
		bsr.w	FindFreeObj
		bne.s	locret_1F83C
		_move.b	#id_Points,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#4,ost_frame(a1)

locret_1F83C:
		rts
; ===========================================================================

loc_1F83E:
		lea	(off_1F84C).l,a1			; could be PC-relative
		jsrto	AnimateSprite,JmpTo3_AnimateSprite
		jmpto	DespawnObject,JmpTo2_DespawnObject
; ===========================================================================
off_1F84C:		index offset(*)
		ptr byte_1F850					; 0
		ptr byte_1F853					; 1

byte_1F850:	dc.b  $F,  0,$FF				; 0
byte_1F853:	dc.b   3,  1,  0,  1,$FD,  0,  0		; 0

; ===========================================================================

		include "mappings/sprite/Round Bumper.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo2_DespawnObject:
		jmp	(DespawnObject).l
JmpTo3_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo5_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 24 - ARZ air bubbles
; ----------------------------------------------------------------------------

Bubble:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Bub_Index(pc,d0.w),d1
		jmp	Bub_Index(pc,d1.w)
; ===========================================================================
Bub_Index:	index offset(*),,2
		ptr loc_1F8C2					; 0
		ptr loc_1F924					; 2
		ptr loc_1F93E					; 4
		ptr loc_1F99E					; 6
		ptr BranchTo_JmpTo15_DeleteObject		; 8
		ptr loc_1F9C0					; $A
; ===========================================================================

loc_1F8C2:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Bub_Player1,ost_mappings(a0)
		move.w	#tile_Nem_BubbleGenerator+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo6_AdjustVRAM2P
		move.b	#render_rel|render_onscreen,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_1F90A
		addq.b	#8,ost_primary_routine(a0)
		andi.w	#$7F,d0
		move.b	d0,$32(a0)
		move.b	d0,$33(a0)

loc_1F900:
		move.b	#6,ost_anim(a0)
		bra.w	loc_1F9C0
; ===========================================================================

loc_1F90A:
		move.b	d0,ost_anim(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	#-$88,ost_y_vel(a0)
		jsr	(RandomNumber).l
		move.b	d0,ost_angle(a0)

loc_1F924:
		lea	(off_1FBCC).l,a1
		jsr	(AnimateSprite).l
		cmpi.b	#6,ost_frame(a0)
		bne.s	loc_1F93E
		move.b	#1,$2E(a0)

loc_1F93E:
		move.w	(v_water_height_actual).w,d0
		cmp.w	ost_y_pos(a0),d0
		bcs.s	loc_1F956
		move.b	#6,ost_primary_routine(a0)
		addq.b	#3,ost_anim(a0)
		bra.w	loc_1F99E
; ===========================================================================

loc_1F956:
		move.b	ost_angle(a0),d0
		addq.b	#1,ost_angle(a0)
		andi.w	#$7F,d0
		lea	(Drown_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,ost_x_pos(a0)
		tst.b	$2E(a0)
		beq.s	loc_1F988
		bsr.w	loc_1FB02
		cmpi.b	#6,ost_primary_routine(a0)
		beq.s	loc_1F99E

loc_1F988:
		jsrto	SpeedToPos,JmpTo3_SpeedToPos
		tst.b	ost_render(a0)
		bpl.s	JmpTo13_DeleteObject
		jmp	(DisplaySprite).l
; ===========================================================================

JmpTo13_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================

loc_1F99E:
		lea	(off_1FBCC).l,a1
		jsr	(AnimateSprite).l
		tst.b	ost_render(a0)
		bpl.s	JmpTo14_DeleteObject
		jmp	(DisplaySprite).l
; ===========================================================================

JmpTo14_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================

    if RemoveJmpTos
JmpTo15_DeleteObject:
    endc

BranchTo_JmpTo15_DeleteObject:
		jmpto	DeleteObject,JmpTo15_DeleteObject
; ===========================================================================

loc_1F9C0:
		tst.w	$36(a0)
		bne.s	loc_1FA22
		move.w	(v_water_height_actual).w,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.w	loc_1FACE
		tst.b	ost_render(a0)
		bpl.w	loc_1FACE
		subq.w	#1,$38(a0)
		bpl.w	loc_1FAC2
		move.w	#1,$36(a0)

loc_1F9E8:
		jsr	(RandomNumber).l
		move.w	d0,d1
		andi.w	#7,d0
		cmpi.w	#6,d0
		bcc.s	loc_1F9E8
		move.b	d0,$34(a0)
		andi.w	#$C,d1

loc_1FA02:
		lea	(Bub_BblTypes).l,a1			; could be PC relative

loc_1FA08:
		adda.w	d1,a1

loc_1FA0A:
		move.l	a1,$3C(a0)
		subq.b	#1,$32(a0)
		bpl.s	loc_1FA20
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)

loc_1FA20:
		bra.s	loc_1FA2A
; ===========================================================================

loc_1FA22:
		subq.w	#1,$38(a0)
		bpl.w	loc_1FAC2

loc_1FA2A:
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		move.w	d0,$38(a0)
		bsr.w	FindFreeObj
		bne.s	loc_1FAA6
		_move.b	ost_id(a0),ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		moveq	#0,d0
		move.b	$34(a0),d0
		movea.l	$3C(a0),a2
		move.b	(a2,d0.w),ost_subtype(a1)
		btst	#7,$36(a0)
		beq.s	loc_1FAA6
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_1FA92
		bset	#6,$36(a0)
		bne.s	loc_1FAA6
		move.b	#2,ost_subtype(a1)

loc_1FA92:
		tst.b	$34(a0)
		bne.s	loc_1FAA6
		bset	#6,$36(a0)
		bne.s	loc_1FAA6
		move.b	#2,ost_subtype(a1)

loc_1FAA6:
		subq.b	#1,$34(a0)
		bpl.s	loc_1FAC2
		jsr	(RandomNumber).l
		andi.w	#$7F,d0
		addi.w	#$80,d0
		add.w	d0,$38(a0)
		clr.w	$36(a0)

loc_1FAC2:
		lea	(off_1FBCC).l,a1			; could be PC relative
		jsr	(AnimateSprite).l

loc_1FACE:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo15_DeleteObject
		move.w	(v_water_height_actual).w,d0
		cmp.w	ost_y_pos(a0),d0
		bcs.w	JmpTo7_DisplaySprite
		rts

    if RemoveJmpTos
JmpTo7_DisplaySprite:
		jmp	(DisplaySprite).l
    endc
; ===========================================================================
Bub_BblTypes:
		dc.b   0					; 0
		dc.b   1					; 1
		dc.b   0					; 2
		dc.b   0					; 3
		dc.b   0					; 4
		dc.b   0					; 5
		dc.b   1					; 6
		dc.b   0					; 7
		dc.b   0					; 8
		dc.b   0					; 9
		dc.b   0					; 10
		dc.b   1					; 11
		dc.b   0					; 12
		dc.b   1					; 13
		dc.b   0					; 14
		dc.b   0					; 15
		dc.b   1					; 16
		dc.b   0					; 17
; ===========================================================================

loc_1FB02:
		lea	(v_ost_player1).w,a1
		bsr.s	loc_1FB0C
		lea	(v_ost_player2).w,a1

loc_1FB0C:
		tst.b	$2A(a1)
		bmi.w	locret_1FBCA
		move.w	ost_x_pos(a1),d0
		move.w	ost_x_pos(a0),d1
		subi.w	#$10,d1
		cmp.w	d0,d1
		bcc.w	locret_1FBCA
		addi.w	#$20,d1
		cmp.w	d0,d1
		bcs.w	locret_1FBCA
		move.w	ost_y_pos(a1),d0
		move.w	ost_y_pos(a0),d1
		cmp.w	d0,d1
		bcc.w	locret_1FBCA
		addi.w	#$10,d1
		cmp.w	d0,d1
		bcs.w	locret_1FBCA
		bsr.w	ResumeMusic
		move.w	#$AD,d0
		jsr	(PlaySound).l
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		clr.w	ost_inertia(a1)
		move.b	#$15,ost_anim(a1)
		move.w	#$23,$2E(a1)
		move.b	#0,$3C(a1)
		bclr	#5,ost_primary_status(a1)
		bclr	#4,ost_primary_status(a1)
		btst	#status_jump_bit,ost_primary_status(a1)
		beq.w	loc_1FBB8
		cmpi.b	#1,(a1)
		bne.s	loc_1FBA8
		bclr	#status_jump_bit,ost_primary_status(a1)
		move.b	#$13,ost_height(a1)
		move.b	#9,ost_width(a1)
		subq.w	#5,ost_y_pos(a1)
		bra.s	loc_1FBB8
; ===========================================================================

loc_1FBA8:
		move.b	#$F,ost_height(a1)
		move.b	#9,ost_width(a1)
		subq.w	#1,ost_y_pos(a1)

loc_1FBB8:
		cmpi.b	#6,ost_primary_routine(a0)
		beq.s	locret_1FBCA
		move.b	#6,ost_primary_routine(a0)
		addq.b	#3,ost_anim(a0)

locret_1FBCA:
		rts
; ===========================================================================
off_1FBCC:	index offset(*)
		ptr byte_1FBDA					; 0
		ptr byte_1FBDF					; 1
		ptr byte_1FBE5					; 2
		ptr byte_1FBEC					; 3
		ptr byte_1FBEC					; 4
		ptr byte_1FBEE					; 5
		ptr byte_1FBF2					; 6
byte_1FBDA:	dc.b  $E,  0,  1,  2,$FC			; 0
byte_1FBDF:	dc.b  $E,  1,  2,  3,  4,$FC			; 0
byte_1FBE5:	dc.b  $E,  2,  3,  4,  5,  6,$FC		; 0
byte_1FBEC:	dc.b   4,$FC					; 0
byte_1FBEE:	dc.b   4,  6,  7,$FC				; 0
byte_1FBF2:	dc.b  $F, $E, $F,$FF				; 0

; ===========================================================================

		include	"mappings/sprite/Bubbles.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo7_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo15_DeleteObject:
		jmp	(DeleteObject).l
JmpTo6_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo3_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ----------------------------------------------------------------------------
; Object 03 - Collision plane/layer switcher
; ----------------------------------------------------------------------------

PlaneSwitcher:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	PSwtch_Index(pc,d0.w),d1
		jsr	PSwtch_Index(pc,d1.w)

	if DebugImprovements
		; Allow this object to be visible in debug mode.
		tst.w	(v_debug_active).w			; is debug mode in use?
		bne.s	.display				; branch if not
		jmp	(DespawnObject3).l			; don't display sprite

	.display:
		jmp	(DespawnObject).l			; display sprite if in debug mode
	else
		jmp	(DespawnObject3).l			; don't display sprite
	endc
; ===========================================================================

PSwtch_Index:	index offset(*),,2
		ptr PSwtch_Init					; 0
		ptr PSwtch_MainX				; 2
		ptr PSwtch_MainY				; 4

		rsobj	PlaneSwitcher,$32
ost_pswtch_radius:		rs.w 1				; $32 ; height of x-switcher or width of y-switcher divided by 2
ost_pswtch_p1_side:		rs.b 1				; $34 ; 0 if player 1 is above or to left of switcher, 1 if below or to right
ost_pswtch_p2_side:		rs.b 1				; $35 ; same as above, but for player 2
		rsobjend
; ===========================================================================

PSwtch_Init: ; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to PSwtch_MainX net
		move.l	#Map_PSwitch,ost_mappings(a0)
		move.w	#tile_Nem_Ring+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo7_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$20/2,ost_displaywidth(a0)
		move.b	#5,ost_priority(a0)
		move.b	ost_subtype(a0),d0			; d0 = subtype
		btst	#pswtch_xy_bit,d0
		beq.s	PSwtch_Init_CheckX			; branch if this is an x-switcher

;PSwtch_Init_CheckY:
		addq.b	#2,ost_primary_routine(a0)		; go to PSwtch_MainY next
		andi.w	#pswtch_size|pswtch_xy,d0		; only need size and xy bits
		move.b	d0,ost_frame(a0)			; index to mapping frame
		andi.w	#pswtch_size,d0				; only need size
		add.w	d0,d0
		move.w	PSwtch_Radii(pc,d0.w),ost_pswtch_radius(a0) ; set radius
		move.w	ost_y_pos(a0),d1			; d1 = y pos of switcher
		lea	(v_ost_player1).w,a1
		cmp.w	ost_y_pos(a1),d1
		bcc.s	.player1_above				; branch if player 1 is at or above switcher
		move.b	#1,ost_pswtch_p1_side(a0)		; mark player as below switcher

	.player1_above:
		lea	(v_ost_player2).w,a1
		cmp.w	ost_y_pos(a1),d1
		bcc.s	.player2_above				; branch if player 2 is at or above switcher
		move.b	#1,ost_pswtch_p2_side(a0)		; mark player as below switcher

	.player2_above:
		bra.w	PSwtch_MainY
; ===========================================================================

PSwtch_Radii:
		dc.w   64/2					; 0
		dc.w  128/2					; 1
		dc.w  256/2					; 2
		dc.w  512/2					; 3
; ===========================================================================

PSwtch_Init_CheckX:
		andi.w	#pswtch_size,d0				; only need size and xy bits
		move.b	d0,ost_frame(a0)			; index to mapping frame
		add.w	d0,d0
		move.w	PSwtch_Radii(pc,d0.w),ost_pswtch_radius(a0) ; set radius
		move.w	ost_x_pos(a0),d1			; d1 = x pos of switcher
		lea	(v_ost_player1).w,a1
		cmp.w	ost_x_pos(a1),d1
		bcc.s	.player1_right				; branch if player 1 is at or to left left of switcher
		move.b	#1,ost_pswtch_p1_side(a0)		; mark player as right of switcher

	.player1_right:
		lea	(v_ost_player2).w,a1
		cmp.w	ost_x_pos(a1),d1
		bcc.s	PSwtch_MainX				; branch if player 2 is at or to left of switcher
		move.b	#1,ost_pswtch_p2_side(a0)		; mark player as right of switcher

PSwtch_MainX: ; Routine 2
		tst.w	(v_debug_active).w			; is debug placement mode active?
		bne.w	.done					; if so, exit
		move.w	ost_x_pos(a0),d1			; d1 = switcher x pos
		lea	ost_pswtch_p1_side(a0),a2		; a2 = flag indicating which side of switcher player is on
		lea	(v_ost_player1).w,a1			; a1 = player
		bsr.s	.x_do					; run for player 1
		lea	(v_ost_player2).w,a1			; run for player 2

	.x_do:
		tst.b	(a2)+
		bne.s	.right					; branch if player is at or right of switcher

	;.left:
		cmp.w	ost_x_pos(a1),d1			; has player reached the x pos of the switcher?
		bhi.w	.done					; branch if not
		move.b	#1,ost_pswtch_p1_side-ost_pswtch_p2_side(a2) ; mark player as right of switcher
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		move.w	ost_pswtch_radius(a0),d4
		sub.w	d4,d2					; d2 = y pos of top of switcher
		add.w	d4,d3					; d3 = y pos of bottom of switcher
		move.w	ost_y_pos(a1),d4			; d4 = player y pos
		cmp.w	d2,d4
		blt.w	.done					; branch if player is above switcher
		cmp.w	d3,d4
		bge.w	.done					; branch if player is below switcher
		move.b	ost_subtype(a0),d0			; is this switcher set to ignore the player if they're airborne?
		bpl.s	.set_plane1				; branch if not
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.w	.done					; if so, do nothing

	.set_plane1:
		btst	#pswtch_priority_only,ost_render(a0)	; are we only changing the player's sprite priority?
		bne.s	.set_priority1				; branch if so
		move.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 0
		move.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a1)
		btst	#pswtch_downright_bit,d0
		beq.s	.set_priority1				; branch if player is being switched to plane 0
		move.b	#chunkmap_secondary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 1
		move.b	#chunkmap_secondary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.set_priority1:
		andi.w	#tile_draw,ost_tile(a1)			; set player's priority to low
		btst	#pswtch_downright_hi_bit,d0
		beq.s	.done					; branch if we're setting priority to low
		ori.w	#tile_hi,ost_tile(a1)			; set player's priority to high
		bra.s	.done
; ===========================================================================

	.right:
		cmp.w	ost_x_pos(a1),d1			; has player reached the x pos of the switcher?
		bls.w	.done					; branch if not
		move.b	#0,ost_pswtch_p1_side-ost_pswtch_p2_side(a2) ; mark player as left of switcher
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		move.w	ost_pswtch_radius(a0),d4
		sub.w	d4,d2					; d2 = y pos of top of switcher
		add.w	d4,d3					; d3 = y pos of bottom of switcher
		move.w	ost_y_pos(a1),d4			; d4 = player y pos
		cmp.w	d2,d4
		blt.w	.done					; branch if player is above switcher
		cmp.w	d3,d4
		bge.w	.done					; branch if player is below switcher
		move.b	ost_subtype(a0),d0			; is this switcher set to ignore the player if they're airborne?
		bpl.s	.set_plane2				; branch if not
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.w	.done					; if so, do nothing

	.set_plane2:
		btst	#pswtch_priority_only,ost_render(a0)	; are we only changing the player's sprite priority?
		bne.s	.set_priority2				; branch if so
		move.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 0
		move.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a1)
		btst	#pswtch_upleft_bit,d0
		beq.s	.set_priority2				; branch if player is being switched to plane 0
		move.b	#chunkmap_secondary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 1
		move.b	#chunkmap_secondary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.set_priority2:
		andi.w	#tile_draw,ost_tile(a1)			; set player's priority to low
		btst	#pswtch_upleft_hi_bit,d0
		beq.s	.done					; branch if we're setting priority to low
		ori.w	#tile_hi,ost_tile(a1)			; set player's priority to high

	.done:
		rts
; ===========================================================================

PSwtch_MainY: ; Routine 4
		tst.w	(v_debug_active).w			; is debug placement mode active?
		bne.w	.done					; if so, exit
		move.w	ost_y_pos(a0),d1			; d1 = switcher y pos
		lea	ost_pswtch_p1_side(a0),a2		; a2 = flag indicating which side of switcher player is on
		lea	(v_ost_player1).w,a1			; a1 = player
		bsr.s	.y_do					; run for player 1
		lea	(v_ost_player2).w,a1			; run for player 2

	.y_do:
		tst.b	(a2)+
		bne.s	.below					; branch if player is at or below switcher

	;.above:
		cmp.w	ost_y_pos(a1),d1			; has player reached the y pos of the switcher?
		bhi.w	.done					; branch if not
		move.b	#1,ost_pswtch_p1_side-ost_pswtch_p2_side(a2) ; mark player as below switcher
		move.w	ost_x_pos(a0),d2
		move.w	d2,d3
		move.w	ost_pswtch_radius(a0),d4
		sub.w	d4,d2					; d2 = y pos of top of switcher
		add.w	d4,d3					; d3 = y pos of bottom of switcher
		move.w	ost_x_pos(a1),d4			; d4 = player y pos
		cmp.w	d2,d4
		blt.w	.done					; branch if player is left of switcher
		cmp.w	d3,d4
		bge.w	.done					; branch if player is right of switcher
		move.b	ost_subtype(a0),d0			; is this switcher set to ignore the player if they're airborne?
		bpl.s	.set_plane1				; branch if not
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.w	.done					; if so, do nothing

	.set_plane1:
		btst	#pswtch_priority_only,ost_render(a0)	; are we only changing the player's sprite priority?
		bne.s	.set_priority1				; branch if so
		move.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 0
		move.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a1)
		btst	#pswtch_downright_bit,d0
		beq.s	.set_priority1				; branch if player is being switched to plane 0
		move.b	#chunkmap_secondary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 1
		move.b	#chunkmap_secondary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.set_priority1:
		andi.w	#tile_draw,ost_tile(a1)			; set player's priority to low
		btst	#pswtch_downright_hi_bit,d0
		beq.s	.done					; branch if we're setting priority to low
		ori.w	#tile_hi,ost_tile(a1)			; set player's priority to high
		bra.s	.done
; ===========================================================================

	.below:
		cmp.w	ost_y_pos(a1),d1			; has player reached the y pos of the switcher?
		bls.w	.done					; branch if not
		move.b	#0,ost_pswtch_p1_side-ost_pswtch_p2_side(a2) ; mark player as above switcher
		move.w	ost_x_pos(a0),d2
		move.w	d2,d3
		move.w	ost_pswtch_radius(a0),d4
		sub.w	d4,d2					; d2 = y pos of top of switcher
		add.w	d4,d3					; d3 = y pos of bottom of switcher
		move.w	ost_x_pos(a1),d4			; d4 = player y pos
		cmp.w	d2,d4
		blt.w	.done					; branch if player is left of switcher
		cmp.w	d3,d4
		bge.w	.done					; branch if player is right of switcher
		move.b	ost_subtype(a0),d0			; is this switcher set to ignore the player if they're airborne?
		bpl.s	.set_plane2				; branch if not
		btst	#status_air_bit,ost_primary_status(a1)	; is player in the air?
		bne.w	.done					; if so, do nothing

	.set_plane2:
		btst	#pswtch_priority_only,ost_render(a0)	; are we only changing the player's sprite priority?
		bne.s	.set_priority2				; branch if so
		move.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 0
		move.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a1)
		btst	#pswtch_upleft_bit,d0
		beq.s	.set_priority2				; branch if player is being switched to plane 0
		move.b	#chunkmap_secondary_solid_top_bit,ost_top_solid_bit(a1) ; set player collision to plane 1
		move.b	#chunkmap_secondary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.set_priority2:
		andi.w	#tile_draw,ost_tile(a1)			; set player's priority to low
		btst	#pswtch_upleft_hi_bit,d0
		beq.s	.done					; branch if we're setting priority to low
		ori.w	#tile_hi,ost_tile(a1)			; set player's priority to high

	.done:
		rts
; ===========================================================================

		include "mappings/sprite/Plane Switcher.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo7_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ----------------------------------------------------------------------------
; Object 0B - CPZ tipping pipe section
; ----------------------------------------------------------------------------

TippingPipe:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_200AA(pc,d0.w),d1
		jmp	off_200AA(pc,d1.w)
; ===========================================================================
off_200AA:	index offset(*),,2
		ptr loc_200B0					; 0
		ptr loc_20104					; 2
		ptr loc_20112					; 4
; ===========================================================================

loc_200B0:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_obj0B,ost_mappings(a0)
		move.w	#tile_Nem_CPZDumpingPipePlat+tile_pal4+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo8_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F0,d0
		addi.w	#$10,d0
		move.w	d0,d1
		subq.w	#1,d0
		move.w	d0,$30(a0)
		move.w	d0,$32(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		addq.w	#1,d0
		lsl.w	#4,d0
		move.b	d0,$36(a0)

loc_20104:
		move.b	(v_vblank_counter_byte).w,d0
		add.b	$36(a0),d0
		bne.s	loc_2013C
		addq.b	#2,ost_primary_routine(a0)

loc_20112:
		subq.w	#1,$30(a0)
		bpl.s	loc_20130
		move.w	#$7F,$30(a0)
		tst.b	ost_anim(a0)
		beq.s	loc_2012A
		move.w	$32(a0),$30(a0)

loc_2012A:
		bchg	#0,ost_anim(a0)

loc_20130:
		lea	(Ani_obj0B).l,a1
		jsr	(AnimateSprite).l

loc_2013C:
		tst.b	ost_frame(a0)
		bne.s	loc_20156
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#$11,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	DetectPlatform
		jmpto	DespawnObject,JmpTo3_DespawnObject
; ===========================================================================

loc_20156:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	BranchTo_JmpTo3_DespawnObject
		bclr	#3,ost_primary_status(a0)
		beq.s	loc_20174
		bclr	#3,($FFFFB022).w
		bset	#1,($FFFFB022).w

loc_20174:
		bclr	#4,ost_primary_status(a0)
		beq.s	BranchTo_JmpTo3_DespawnObject
		bclr	#3,($FFFFB062).w
		bset	#1,($FFFFB062).w

BranchTo_JmpTo3_DespawnObject:
		jmpto	DespawnObject, JmpTo3_DespawnObject
; ===========================================================================
Ani_obj0B:	index offset(*)
		ptr byte_20190					; 0
		ptr byte_20198					; 1

byte_20190:	dc.b   7,  0,  1,  2,  3,  4,$FE,  1		; 0
byte_20198:	dc.b   7,  4,  3,  2,  1,  0,$FE,  1		; 0

	include "mappings/sprite/CPZ Dumping Pipe Platform.asm"

; ===========================================================================

    if RemoveJmpTos=0
JmpTo3_DespawnObject:
		jmp	(DespawnObject).l
JmpTo8_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
    endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 0C - Small floating platform (unused)
; (used in CPZ in the Nick Arcade prototype)
; ----------------------------------------------------------------------------

CPZBetaPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2021E(pc,d0.w),d1
		jmp	off_2021E(pc,d1.w)
; ===========================================================================
off_2021E:		index offset(*),,2
		ptr loc_20222					; 0
		ptr loc_20282					; 2
; ===========================================================================

loc_20222:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_CPZBetaPlat,ost_mappings(a0)
		move.w	#(vram_FloatPlatform/sizeof_cell)+tile_pal4+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo9_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_y_pos(a0),d0
		subi.w	#$10,d0
		move.w	d0,$3A(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F0,d0
		addi.w	#$10,d0
		move.w	d0,d1
		subq.w	#1,d0
		move.w	d0,$30(a0)
		move.w	d0,$32(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		move.b	d0,$3E(a0)
		move.b	d0,$3F(a0)

loc_20282:
		move.b	$3C(a0),d0
		beq.s	loc_202C0
		cmpi.b	#-$80,d0
		bne.s	loc_202D0
		move.b	$3D(a0),d1
		bne.s	loc_202A2
		subq.b	#1,$3E(a0)
		bpl.s	loc_202A2
		move.b	$3F(a0),$3E(a0)
		bra.s	loc_202D0
; ===========================================================================

loc_202A2:
		addq.b	#1,$3D(a0)
		move.b	d1,d0
		jsrto	CalcSine,JmpTo5_CalcSine
		addi_.w	#8,d0
		asr.w	#6,d0
		subi.w	#$10,d0
		add.w	$3A(a0),d0
		move.w	d0,ost_y_pos(a0)
		bra.s	loc_202E6
; ===========================================================================

loc_202C0:
		move.w	(v_vblank_counter_word).w,d1
		andi.w	#$3FF,d1
		bne.s	loc_202D4
		move.b	#1,$3D(a0)

loc_202D0:
		addq.b	#1,$3C(a0)

loc_202D4:
		jsrto	CalcSine,JmpTo5_CalcSine
		addi_.w	#8,d1
		asr.w	#4,d1
		add.w	$3A(a0),d1
		move.w	d1,ost_y_pos(a0)

loc_202E6:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#9,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	DetectPlatform
		jmpto	DespawnObject,JmpTo4_DespawnObject

; ===========================================================================
		include "mappings/sprite/CPZ Beta Platform (unused).asm"
; ===========================================================================

    if Revision<2
		nop
    endc

    if RemoveJmpTos=0
JmpTo4_DespawnObject
		jmp	(DespawnObject).l
JmpTo9_AdjustVRAM2P
		jmp	(AdjustVRAM2P).l
JmpTo5_CalcSine
		jmp	(CalcSine).l

		align 4
    endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 12 - Emerald from Hidden Palace Zone (unused)
; ----------------------------------------------------------------------------

GiantEmerald:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	GiantEmerld_Index(pc,d0.w),d1
		jmp	GiantEmerld_Index(pc,d1.w)
; ===========================================================================
GiantEmerld_Index:	index offset(*),,2
		ptr GiantEmerld_Init				; 0
		ptr GiantEmerld_Solid				; 2
; ===========================================================================

GiantEmerld_Init:						; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to GiantEmerld_Solid next
		move.l	#Map_GiantEmerld,ost_mappings(a0)
		move.w	#(vram_HPZEmerald/sizeof_cell)+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo10_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$40/2,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)

GiantEmerld_Solid:						; Routine 2
		move.w	#$40/2,d1				; width / 2
		move.w	#$20/2,d2				; height when jumping / 2
		move.w	#$20/2,d3				; height when walking / 2
		move.w	ost_x_pos(a0),d4			; object x-pos
		bsr.w	SolidObject				; perform collision checks with players

		out_of_range	JmpTo16_DeleteObject,ost_x_pos(a0)
		jmpto	DisplaySprite,JmpTo8_DisplaySprite
; ===========================================================================
		include "mappings/sprite/HPZ Giant Emerald (unused).asm"
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos
JmpTo16_DeleteObject:
		jmp	(DeleteObject).l
	else
JmpTo8_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo16_DeleteObject:
		jmp	(DeleteObject).l
JmpTo10_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 13 - HPZ Waterfall (unused)
; ----------------------------------------------------------------------------

WaterfallHiddenPalace:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	HPZWFall_Index(pc,d0.w),d1
		jmp	HPZWFall_Index(pc,d1.w)
; ===========================================================================
HPZWFall_Index:	index offset(*),,2
		ptr loc_203C0					; 0
		ptr loc_20486					; 2
		ptr loc_20510					; 4
; ===========================================================================

loc_203C0:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_HPZWFall,ost_mappings(a0)
		move.w	#(vram_HPZWaterfall/sizeof_cell)+tile_pal4+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo11_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	#$12,ost_frame(a0)
		bsr.s	loc_20428
		move.b	#-$60,ost_height(a1)
		bset	#render_useheight_bit,ost_render(a1)
		move.l	a1,$38(a0)

loc_20400:
		move.w	ost_y_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$36(a0)
		cmpi.b	#$10,ost_subtype(a0)
		bcs.s	loc_2046C
		bsr.s	loc_20428
		move.l	a1,$3C(a0)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$98,ost_y_pos(a1)
		bra.s	loc_2046C
; ===========================================================================

loc_20428:
		jsr	(FindNextFreeObj).l
		bne.s	locret_2046A
		_move.b	#id_WaterfallHiddenPalace,ost_id(a1)
		addq.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	#Map_HPZWFall,ost_mappings(a1)
		move.w	#(vram_HPZWaterfall/sizeof_cell)+tile_pal4+tile_hi,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo2_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#1,ost_priority(a1)

locret_2046A:
		rts
; ===========================================================================

loc_2046C:
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		move.w	$34(a0),d0
		subi.w	#$78,d0
		lsl.w	#4,d1
		add.w	d1,d0
		move.w	d0,ost_y_pos(a0)
		move.w	d0,$34(a0)

loc_20486:
		movea.l	$38(a0),a1
		move.b	#$12,ost_frame(a0)
		move.w	$34(a0),d0
		move.w	(v_water_height_actual).w,d1
		cmp.w	d0,d1
		bcc.s	loc_2049E
		move.w	d1,d0

loc_2049E:
		move.w	d0,ost_y_pos(a0)
		sub.w	$36(a0),d0
		addi.w	#$80,d0
		bmi.s	loc_204F0
		lsr.w	#4,d0
		move.w	d0,d1
		cmpi.w	#$F,d0
		bcs.s	loc_204B8
		moveq	#$F,d0

loc_204B8:
		move.b	d0,ost_frame(a1)
		cmpi.b	#$10,ost_subtype(a0)
		bcs.s	loc_204D8
		movea.l	$3C(a0),a1
		subi.w	#$F,d1
		bcc.s	loc_204D0
		moveq	#0,d1

loc_204D0:
		addi.w	#$13,d1
		move.b	d1,ost_frame(a1)

loc_204D8:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo17_DeleteObject
		jmpto	DisplaySprite,JmpTo9_DisplaySprite
; ===========================================================================

loc_204F0:
		moveq	#$13,d0
		move.b	d0,ost_frame(a0)
		move.b	d0,ost_frame(a1)
		move.w	ost_x_pos(a0),d0

loc_204FE:
		andi.w	#-$80,d0

loc_20502:
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo17_DeleteObject
		rts
; ===========================================================================

loc_20510:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo17_DeleteObject
		jmpto	DisplaySprite,JmpTo9_DisplaySprite
; ===========================================================================
		include "mappings/sprite/Hidden Palace Waterfall (unused).asm"
; ===========================================================================

	if RemoveJmpTos
JmpTo17_DeleteObject ; JmpTo
		jmp	(DeleteObject).l
	else
JmpTo9_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo17_DeleteObject:
		jmp	(DeleteObject).l
JmpTo2_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo11_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 04 - Water surface
; ----------------------------------------------------------------------------

WaterSurface:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_208EA(pc,d0.w),d1
		jmp	off_208EA(pc,d1.w)
; ===========================================================================
off_208EA:	index offset(*),,2
		ptr loc_208F0					; 0
		ptr loc_20930					; 2
		ptr loc_209C2					; 4
; ===========================================================================

loc_208F0:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Surf1,ost_mappings(a0)
		move.w	#tile_Nem_WaterSurface1+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#-$80,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$30(a0)
		cmpi.b	#id_ARZ,(v_zone).w			; is it ARZ?
		bne.s	loc_20930				; if not, branch
		addq.b	#2,ost_primary_routine(a0)		; use ARZ-specific code and mappings
		move.l	#Map_Surf2,ost_mappings(a0)
		bra.w	loc_209C2
; ===========================================================================

loc_20930:
		move.w	(v_water_height_actual).w,d1
		move.w	d1,ost_y_pos(a0)
		tst.b	$32(a0)
		bne.s	loc_20952
		btst	#7,(v_joypad_press_actual).w
		beq.s	loc_20962
		addq.b	#3,ost_frame(a0)
		move.b	#1,$32(a0)
		bra.s	loc_20962
; ===========================================================================

loc_20952:
		tst.w	(f_pause).w
		bne.s	loc_20962
		move.b	#0,$32(a0)
		subq.b	#3,ost_frame(a0)

;   if FixBugs=0
;Obj04_Display:
;   endif
loc_20962:
		; This code should be skipped when the game is paused, but is isn't.
		; This causes the wrong sprite to display when the game is paused.
		lea	(byte_20982).l,a1			; could be PC relative
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	(a1,d1.w),ost_frame(a0)
		addq.b	#1,ost_anim_frame(a0)
		andi.b	#$3F,ost_anim_frame(a0)

;	if FixBugs
;Obj04_Display:
;	endc
		jmpto	DisplaySprite,JmpTo10_DisplaySprite
; ===========================================================================
byte_20982:
		dc.b   0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1 ; 0
		dc.b   1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2 ; 16
		dc.b   2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1 ; 32
		dc.b   1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0 ; 48
; ===========================================================================

loc_209C2:
		move.w	(v_water_height_actual).w,d1
		move.w	d1,ost_y_pos(a0)
		tst.b	$32(a0)
		bne.s	loc_209E4
		btst	#7,(v_joypad_press_actual).w
		beq.s	loc_209F4
		addq.b	#2,ost_frame(a0)
		move.b	#1,$32(a0)
		bra.s	BranchTo_JmpTo10_DisplaySprite
; ===========================================================================

loc_209E4:
		tst.w	(f_pause).w
		bne.s	BranchTo_JmpTo10_DisplaySprite
		move.b	#0,$32(a0)
		subq.b	#2,ost_frame(a0)

loc_209F4:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	BranchTo_JmpTo10_DisplaySprite
		move.b	#5,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		andi.b	#1,ost_frame(a0)

BranchTo_JmpTo10_DisplaySprite:
		jmpto	DisplaySprite,JmpTo10_DisplaySprite
; ===========================================================================
		include "mappings/sprite/CPZ & HPZ Water Surface.asm"
		include "mappings/sprite/ARZ Water Surface.asm"
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 49 - EHZ Waterfall
; ----------------------------------------------------------------------------

WaterfallEmeraldHill:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_20BAC(pc,d0.w),d1
		jmp	off_20BAC(pc,d1.w)
; ===========================================================================
off_20BAC:	index offset(*),,2
		ptr loc_20BB0					; 0
		ptr loc_20BEA					; 2
; ===========================================================================

loc_20BB0:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_EHZWFall,ost_mappings(a0)
		move.w	#tile_Nem_Waterfall+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.b	#0,ost_priority(a0)
		move.b	#-$80,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)

loc_20BEA:
		tst.w	(f_two_player).w
		bne.s	loc_20C04
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo18_DeleteObject

loc_20C04:
		move.w	ost_x_pos(a0),d1
		move.w	d1,d2
		subi.w	#$40,d1
		addi.w	#$40,d2
		move.b	ost_subtype(a0),d3
		move.b	#0,ost_frame(a0)
		move.w	($FFFFB008).w,d0
		cmp.w	d1,d0
		bcs.s	loc_20C36
		cmp.w	d2,d0
		bcc.s	loc_20C36
		move.b	#1,ost_frame(a0)
		add.b	d3,ost_frame(a0)
		jmpto	DisplaySprite,JmpTo10_DisplaySprite
; ===========================================================================

loc_20C36:
		move.w	($FFFFB048).w,d0
		cmp.w	d1,d0
		bcs.s	loc_20C48
		cmp.w	d2,d0
		bcc.s	loc_20C48
		move.b	#1,ost_frame(a0)

loc_20C48:
		add.b	d3,ost_frame(a0)
		jmpto	DisplaySprite,JmpTo10_DisplaySprite
; ===========================================================================
		include "mappings/sprite/EHZ Waterfall.asm"
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 31 - invisible	lava marker
; ----------------------------------------------------------------------------

LavaTag:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	LTag_Index(pc,d0.w),d1
		jmp	LTag_Index(pc,d1.w)
; ===========================================================================
LTag_Index:	index offset(*),,2
		ptr loc_20E02					; 0
		ptr loc_20E46					; 2

LTag_ColTypes:
		dc.b id_col_32x32+id_col_hurt			; 0
		dc.b id_col_64x32+id_col_hurt			; 1
		dc.b id_col_128x32+id_col_hurt			; 2
		even
; ===========================================================================

loc_20E02:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.b	LTag_ColTypes(pc,d0.w),ost_col_type(a0)

	if FixBugs
		move.l	#Map_LTag,ost_mappings(a0)
	else
		; Load blank mappings! This is a dumb workaround for the bug below.
		move.l	#NonMap_LTag,ost_mappings(a0)
		tst.w	(v_debug_active).w
		beq.s	loc_20E28
		move.l	#Map_LTag,ost_mappings(a0)
	loc_20E28:
	endc
		move.w	#tile_Nem_Monitors+tile_hi,ost_tile(a0)	; uses the question mark monitor icon
	if FixBugs
		move.b	#render_rel,ost_render(a0)
	else
		; 'render_onscreen' should not be set here: this causes
		; this object to become visible when the player dies, because of how
		; 'ExecuteObjects.dead' works. Amazingly, someone tried to work around
		; this by loading blank mappings if not in debug mode.
		move.b	#render_rel|render_onscreen,ost_render(a0)
	endc
		move.b	#-$80,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),ost_frame(a0)

loc_20E46:
		tst.w	(f_two_player).w
		bne.s	loc_20E60
		move.w	ost_x_pos(a0),d0

loc_20E50:
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo18_DeleteObject

loc_20E60:
		tst.w	(v_debug_active).w
		beq.s	locret_20E6A
		jsrto	DisplaySprite,JmpTo10_DisplaySprite	; could be a jmpto

locret_20E6A:
		rts
; ===========================================================================
	if FixBugs=0
		include "mappings/sprite/Invisible Lava Tag (non-mappings).asm"
	endc
		include "mappings/sprite/Invisible Lava Tag.asm"
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 74 - invisible	solid block
; ----------------------------------------------------------------------------
Invisibarrier:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_20EEE(pc,d0.w),d1
		jmp	off_20EEE(pc,d1.w)
; ===========================================================================
off_20EEE:	index offset(*),,2
		ptr loc_20EF2					; 0
		ptr loc_20F2E					; 2
; ===========================================================================

loc_20EF2:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Invis,ost_mappings(a0)
		move.w	#tile_Nem_Monitors+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	ost_subtype(a0),d0
		move.b	d0,d1
		andi.w	#$F0,d0
		addi.w	#$10,d0
		lsr.w	#1,d0
		move.b	d0,ost_displaywidth(a0)
		andi.w	#$F,d1
		addq.w	#1,d1
		lsl.w	#3,d1
		move.b	d1,ost_height(a0)

loc_20F2E:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		bsr.w	SolidObject_NoRenderChk
		tst.w	(f_two_player).w
	if (Revision=0)|FixBugs
		bne.s	.chkdebug
	else
		bne.s	.locret_20F64
	endc
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo18_DeleteObject
	if (Revision=0)|DebugImprovements
	.chkdebug:
		; This object was visible with debug mode in Revision 0.
		tst.w	(v_debug_active).w
		beq.s	.locret_20F64
		jmp	(DisplaySprite).l
	endc

	.locret_20F64:
		rts
; ===========================================================================
		include "mappings/sprite/Invisible Solid Blocks.asm"
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 7C - CPZ foreground pylons
; ----------------------------------------------------------------------------

Pylon:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_20FE0(pc,d0.w),d1
		jmp	off_20FE0(pc,d1.w)
; ===========================================================================
off_20FE0:	index offset(*),,2
		ptr loc_20FE4					; 0
		ptr loc_21006					; 2
; ===========================================================================

loc_20FE4:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Pylon,ost_mappings(a0)
		move.w	#tile_Nem_Pylon+tile_pal3+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		move.b	#$10,ost_displaywidth(a0)
		move.b	#7,ost_priority(a0)

loc_21006:
		move.w	(v_camera_x_pos).w,d1
		andi.w	#$3FF,d1
		cmpi.w	#$2E0,d1
		bcc.s	locret_2103A
		asr.w	#1,d1
		move.w	d1,d0
		asr.w	#1,d1
		add.w	d1,d0
		neg.w	d0
		move.w	d0,ost_x_screen(a0)
		move.w	(v_camera_y_pos).w,d1
		asr.w	#1,d1
		andi.w	#$3F,d1
		neg.w	d1
		addi.w	#$100,d1
		move.w	d1,ost_y_screen(a0)
		jmpto	DisplaySprite,JmpTo10_DisplaySprite
; ===========================================================================

locret_2103A:
		rts
; ===========================================================================
		include "mappings/sprite/CPZ Pylon.asm"
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 27 - explosion	from a destroyed enemy or monitor
; ----------------------------------------------------------------------------

ExplosionItem:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_21096(pc,d0.w),d1
		jmp	off_21096(pc,d1.w)
; ===========================================================================
off_21096:	index offset(*),,2
		ptr loc_2109C					; 0
		ptr Explosion_Main				; 2
		ptr loc_21102					; 4
; ===========================================================================

loc_2109C:
		addq.b	#2,ost_primary_routine(a0)
		jsrto	FindFreeObj,JmpTo2_FindFreeObj
		bne.s	Explosion_Main
		_move.b	#id_Animals,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	$3E(a0),$3E(a1)

Explosion_Main:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_ExplodeItem,ost_mappings(a0)
		move.w	#tile_Nem_Explosion,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#1,ost_priority(a0)
		move.b	#0,ost_col_type(a0)
		move.b	#$C,ost_displaywidth(a0)
		move.b	#3,ost_anim_time(a0)
		move.b	#0,ost_frame(a0)
		move.w	#$C1,d0
		jsr	(PlaySound).l

loc_21102:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2111C
		move.b	#7,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#5,ost_frame(a0)
		beq.w	JmpTo18_DeleteObject

loc_2111C:
		jmpto	DisplaySprite,JmpTo10_DisplaySprite
; ===========================================================================
		include "mappings/sprite/Explosions.asm"
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 84 - Pinball mode enable/disable
; (used in CNZ and HTZ to determine when Sonic/Tails should stay in a ball)
; ----------------------------------------------------------------------------

PinballMode:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_21170(pc,d0.w),d1
		jsr	off_21170(pc,d1.w)
		jmp	(DespawnObject3).l
; ===========================================================================
off_21170:	index offset(*),,2
		ptr loc_21176					; 0
		ptr loc_21224					; 2
		ptr loc_212F6					; 4
; ===========================================================================

loc_21176:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_PSwitch,ost_mappings(a0)
		move.w	#tile_Nem_Ring,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#5,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		btst	#2,d0
		beq.s	loc_211F0
		addq.b	#2,ost_primary_routine(a0)
		andi.w	#7,d0
		move.b	d0,ost_frame(a0)
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_211E8(pc,d0.w),$32(a0)
		move.w	ost_y_pos(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	ost_y_pos(a1),d1
		bcc.s	loc_211D4
		move.b	#1,$34(a0)

loc_211D4:
		lea	($FFFFB040).w,a1
		cmp.w	ost_y_pos(a1),d1
		bcc.s	loc_211E4
		move.b	#1,$35(a0)

loc_211E4:
		bra.w	loc_212F6
; ===========================================================================
word_211E8:
		dc.w   $20					; 0
		dc.w   $40					; 1
		dc.w   $80					; 2
		dc.w  $100					; 3
; ===========================================================================

loc_211F0:
		andi.w	#3,d0
		move.b	d0,ost_frame(a0)
		add.w	d0,d0
		move.w	word_211E8(pc,d0.w),$32(a0)
		move.w	ost_x_pos(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	ost_x_pos(a1),d1
		bcc.s	loc_21214
		move.b	#1,$34(a0)

loc_21214:
		lea	($FFFFB040).w,a1
		cmp.w	ost_x_pos(a1),d1
		bcc.s	loc_21224
		move.b	#1,$35(a0)

loc_21224:
		tst.w	(v_debug_active).w
		bne.s	locret_21284
		move.w	ost_x_pos(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_21244
		lea	($FFFFB040).w,a1
		cmpi.w	#4,(v_tails_cpu_routine).w
		beq.s	locret_21284

loc_21244:
		tst.b	(a2)+
		bne.s	loc_21286
		cmp.w	ost_x_pos(a1),d1
		bhi.s	locret_21284
		move.b	#1,-1(a2)
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21284
		cmp.w	d3,d4
		bcc.s	locret_21284
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_2127E
		move.b	#1,$39(a1)
		bra.s	loc_212C4
; ===========================================================================

loc_2127E:
		move.b	#0,$39(a1)

locret_21284:
		rts
; ===========================================================================

loc_21286:
		cmp.w	ost_x_pos(a1),d1
		bls.s	locret_21284
		move.b	#0,-1(a2)
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21284
		cmp.w	d3,d4
		bcc.s	locret_21284
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_212BC
		move.b	#1,$39(a1)
		bra.s	loc_212C4
; ===========================================================================

loc_212BC:
		move.b	#0,$39(a1)
		rts
; ===========================================================================

loc_212C4:
		btst	#status_jump_bit,ost_primary_status(a1)
		beq.s	loc_212CE
		rts
; ===========================================================================

loc_212CE:
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		addq.w	#5,ost_y_pos(a1)
		move.w	#$BE,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================

loc_212F6:
		tst.w	(v_debug_active).w
		bne.s	locret_21350
		move.w	ost_y_pos(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_2130E
		lea	($FFFFB040).w,a1

loc_2130E:
		tst.b	(a2)+
		bne.s	loc_21352
		cmp.w	ost_y_pos(a1),d1
		bhi.s	locret_21350
		move.b	#1,-1(a2)
		move.w	ost_x_pos(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	ost_x_pos(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21350
		cmp.w	d3,d4
		bcc.s	locret_21350
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_2134A
		move.b	#1,$39(a1)
		bra.w	loc_212C4
; ===========================================================================

loc_2134A:
		move.b	#0,$39(a1)

locret_21350:
		rts
; ===========================================================================

loc_21352:
		cmp.w	ost_y_pos(a1),d1
		bls.s	locret_21350
		move.b	#0,-1(a2)
		move.w	ost_x_pos(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	ost_x_pos(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_21350
		cmp.w	d3,d4
		bcc.s	locret_21350
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2138A
		move.b	#1,$39(a1)
		bra.w	loc_212C4
; ===========================================================================

loc_2138A:
		move.b	#0,$39(a1)
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 8B - WFZ Cycling palette switcher
; ----------------------------------------------------------------------------

PalSwitcherWingFortress:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_213A6(pc,d0.w),d1
		jsr	off_213A6(pc,d1.w)
		jmp	(DespawnObject3).l
; ===========================================================================
off_213A6:	index offset(*),,2
		ptr loc_213B2					; 0
		ptr loc_21412					; 2

; ===========================================================================
word_213AA:
		dc.w   $20					; 0
		dc.w   $40					; 1
		dc.w   $80					; 2
		dc.w  $100					; 3
; ===========================================================================

loc_213B2:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_PSwitch,ost_mappings(a0)
		move.w	#tile_Nem_Ring,ost_tile(a0)

loc_213C4:
		jsrto	AdjustVRAM2P,JmpTo12_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#5,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#3,d0
		move.b	d0,ost_frame(a0)
		add.w	d0,d0
		move.w	word_213AA(pc,d0.w),$32(a0)
		move.w	ost_x_pos(a0),d1
		lea	($FFFFB000).w,a1
		cmp.w	ost_x_pos(a1),d1
		bcc.s	loc_21402
		move.b	#1,$34(a0)

loc_21402:
		lea	($FFFFB040).w,a1
		cmp.w	ost_x_pos(a1),d1
		bcc.s	loc_21412
		move.b	#1,$35(a0)

loc_21412:
		tst.w	(v_debug_active).w
		bne.s	locret_2146A
		move.w	ost_x_pos(a0),d1
		lea	$34(a0),a2
		lea	($FFFFB000).w,a1
		bsr.s	loc_2142A
		lea	($FFFFB040).w,a1

loc_2142A:
		tst.b	(a2)+
		bne.s	loc_2146C
		cmp.w	ost_x_pos(a1),d1
		bhi.s	locret_2146A
		move.b	#1,-1(a2)
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_2146A
		cmp.w	d3,d4
		bcc.s	locret_2146A
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_21464
		move.b	#1,(f_wfz_scz_fire_toggle).w
		rts
; ===========================================================================

loc_21464:
		move.b	#0,(f_wfz_scz_fire_toggle).w

locret_2146A:
		rts
; ===========================================================================

loc_2146C:
		cmp.w	ost_x_pos(a1),d1
		bls.s	locret_2146A
		move.b	#0,-1(a2)
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		move.w	$32(a0),d4
		sub.w	d4,d2
		add.w	d4,d3
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.s	locret_2146A
		cmp.w	d3,d4
		bcc.s	locret_2146A
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_214A2
		move.b	#1,(f_wfz_scz_fire_toggle).w
		rts
; ===========================================================================

loc_214A2:
		move.b	#0,(f_wfz_scz_fire_toggle).w
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos
JmpTo18_DeleteObject:
		jmp	(DeleteObject).l
	else
JmpTo10_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo18_DeleteObject:
		jmp	(DeleteObject).l
JmpTo2_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo12_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 06 - Rotating cylinder in MTZ and twisting spiral pathway in EHZ
; ----------------------------------------------------------------------------

Spiral:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_214F4(pc,d0.w),d1
		jsr	off_214F4(pc,d1.w)
		tst.w	(f_two_player).w
		beq.s	loc_214DA
		rts
; ===========================================================================

loc_214DA:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_214EE
		rts
; ===========================================================================

loc_214EE:
		jmp	(DeleteObject).l
; ===========================================================================
off_214F4:	index offset(*),,2
		ptr loc_214FA					; 0
		ptr loc_21512					; 2
		ptr loc_21808					; 4
; ===========================================================================

loc_214FA:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#-$30,ost_displaywidth(a0)
		tst.b	ost_subtype(a0)
		bpl.s	loc_21512
		addq.b	#2,ost_primary_routine(a0)
		bra.w	loc_21808
; ===========================================================================

loc_21512:
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		bsr.s	loc_21520
		lea	($FFFFB040).w,a1
		addq.b	#1,d6

loc_21520:
		btst	d6,ost_primary_status(a0)
		bne.w	loc_215C0
		btst	#1,ost_primary_status(a1)
		bne.w	locret_215BE
		btst	#3,ost_primary_status(a1)
		bne.s	loc_21580
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		tst.w	ost_x_vel(a1)
		bmi.s	loc_21556
		cmpi.w	#-$C0,d0
		bgt.s	locret_215BE
		cmpi.w	#-$D0,d0
		blt.s	locret_215BE
		bra.s	loc_21562
; ===========================================================================

loc_21556:
		cmpi.w	#$C0,d0
		blt.s	locret_215BE
		cmpi.w	#$D0,d0
		bgt.s	locret_215BE

loc_21562:
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		subi.w	#$10,d1
		cmpi.w	#$30,d1
		bcc.s	locret_215BE
		tst.b	$2A(a1)
		bne.s	locret_215BE
		bsr.w	Plat_NoCheck
		rts
; ===========================================================================

loc_21580:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		tst.w	ost_x_vel(a1)
		bmi.s	loc_2159C
		cmpi.w	#-$B0,d0
		bgt.s	locret_215BE
		cmpi.w	#-$C0,d0
		blt.s	locret_215BE
		bra.s	loc_215A8
; ===========================================================================

loc_2159C:
		cmpi.w	#$B0,d0
		blt.s	locret_215BE
		cmpi.w	#$C0,d0
		bgt.s	locret_215BE

loc_215A8:
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		subi.w	#$10,d1
		cmpi.w	#$30,d1
		bcc.s	locret_215BE
		bsr.w	Plat_NoCheck

locret_215BE:
		rts
; ===========================================================================

loc_215C0:
		move.w	ost_inertia(a1),d0
		bpl.s	loc_215C8
		neg.w	d0

loc_215C8:
		cmpi.w	#$600,d0
		bcs.s	loc_215EA
		btst	#1,ost_primary_status(a1)
		bne.s	loc_215EA
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$D0,d0
		bmi.s	loc_215EA
		cmpi.w	#$1A0,d0
		bcs.s	loc_21602

loc_215EA:
		bclr	#3,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)
		move.b	#0,$2C(a1)
		move.b	#4,$2D(a1)
		rts
; ===========================================================================

loc_21602:
		btst	#3,ost_primary_status(a1)
		beq.s	locret_215BE
		move.b	byte_21668(pc,d0.w),d1
		ext.w	d1
		move.w	ost_y_pos(a0),d2
		add.w	d1,d2
		moveq	#0,d1
		move.b	ost_height(a1),d1
		subi.w	#$13,d1
		sub.w	d1,d2
		move.w	d2,ost_y_pos(a1)
		lsr.w	#3,d0
		andi.w	#$3F,d0
		move.b	byte_21634(pc,d0.w),ost_flip_angle(a1)
		rts
; ===========================================================================
byte_21634:
		dc.b	 0,    0,    1,	   1			; 0
		dc.b   $16,  $16,  $16,	 $16			; 4
		dc.b   $2C,  $2C,  $2C,	 $2C			; 8
		dc.b   $42,  $42,  $42,	 $42			; 12
		dc.b   $58,  $58,  $58,	 $58			; 16
		dc.b   $6E,  $6E,  $6E,	 $6E			; 20
		dc.b   $84,  $84,  $84,	 $84			; 24
		dc.b   $9A,  $9A,  $9A,	 $9A			; 28
		dc.b   $B0,  $B0,  $B0,	 $B0			; 32
		dc.b   $C6,  $C6,  $C6,	 $C6			; 36
		dc.b   $DC,  $DC,  $DC,	 $DC			; 40
		dc.b   $F2,  $F2,  $F2,	 $F2			; 44
		dc.b	 1,    1,    0,	   0			; 48

byte_21668:
		dc.b $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20 ; 0
		dc.b $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$1F,$1F ; 16
		dc.b $1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1E,$1E,$1E ; 32
		dc.b $1E,$1E,$1E,$1E,$1E,$1E,$1D,$1D,$1D,$1D,$1D,$1C,$1C,$1C,$1C,$1B ; 48
		dc.b $1B,$1B,$1B,$1A,$1A,$1A,$19,$19,$19,$18,$18,$18,$17,$17,$16,$16 ; 64
		dc.b $15,$15,$14,$14,$13,$12,$12,$11,$10,$10, $F, $E, $E, $D, $C, $C ; 80
		dc.b  $B, $A, $A,  9,  8,  8,  7,  6,  6,  5,  4,  4,  3,  2,  2,  1 ; 96
		dc.b   0,$FF,$FE,$FE,$FD,$FC,$FC,$FB,$FA,$F9,$F9,$F8,$F7,$F7,$F6,$F6 ; 112
		dc.b $F5,$F5,$F4,$F4,$F3,$F2,$F2,$F1,$F1,$F0,$F0,$EF,$EF,$EE,$EE,$ED ; 128
		dc.b $ED,$ED,$EC,$EB,$EB,$EA,$EA,$E9,$E9,$E8,$E8,$E7,$E7,$E6,$E6,$E5 ; 144
		dc.b $E5,$E4,$E4,$E4,$E3,$E3,$E2,$E2,$E2,$E1,$E1,$E1,$E0,$E0,$E0,$DF ; 160
		dc.b $DF,$DF,$DF,$DE,$DE,$DE,$DD,$DD,$DD,$DD,$DD,$DD,$DD,$DD,$DC,$DC ; 176
		dc.b $DC,$DC,$DC,$DC,$DC,$DC,$DC,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB ; 192
		dc.b $DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB,$DB ; 208
		dc.b $DB,$DB,$DB,$DB,$DC,$DC,$DC,$DC,$DC,$DC,$DC,$DD,$DD,$DD,$DD,$DD ; 224
		dc.b $DD,$DD,$DD,$DE,$DE,$DE,$DF,$DF,$DF,$DF,$E0,$E0,$E0,$E1,$E1,$E1 ; 240
		dc.b $E2,$E2,$E2,$E3,$E3,$E4,$E4,$E4,$E5,$E5,$E6,$E6,$E7,$E7,$E8,$E8 ; 256
		dc.b $E9,$E9,$EA,$EA,$EB,$EB,$EC,$ED,$ED,$EE,$EE,$EF,$F0,$F0,$F1,$F2 ; 272
		dc.b $F2,$F3,$F4,$F5,$F5,$F6,$F7,$F8,$F9,$F9,$FA,$FB,$FC,$FD,$FE,$FF ; 288
		dc.b   0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9, $A, $A, $B, $C, $D ; 304
		dc.b  $D, $E, $E, $F, $F,$10,$10,$11,$11,$12,$12,$13,$13,$14,$14,$15 ; 320
		dc.b $15,$16,$16,$17,$17,$18,$18,$18,$19,$19,$19,$19,$1A,$1A,$1A,$1A ; 336
		dc.b $1B,$1B,$1B,$1B,$1C,$1C,$1C,$1C,$1C,$1C,$1D,$1D,$1D,$1D,$1D,$1D ; 352
		dc.b $1D,$1E,$1E,$1E,$1E,$1E,$1E,$1E,$1F,$1F,$1F,$1F,$1F,$1F,$1F,$1F ; 368
		dc.b $1F,$1F,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20 ; 384
		dc.b $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20 ; 400
; ===========================================================================

loc_21808:
		lea	($FFFFB000).w,a1
		lea	(v_mtz_cylinder_angle_sonic).w,a2
		moveq	#3,d6
		bsr.s	loc_2181E
		lea	($FFFFB040).w,a1
		lea	(v_mtz_cylinder_angle_tails).w,a2
		addq.b	#1,d6

loc_2181E:
		btst	d6,ost_primary_status(a0)
		bne.w	loc_2188C
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmpi.w	#-$C0,d0
		blt.s	locret_2188A
		cmpi.w	#$C0,d0
		bge.s	locret_2188A
		move.w	ost_y_pos(a0),d0
		addi.w	#$3C,d0
		move.w	ost_y_pos(a1),d2
		move.b	ost_height(a1),d1
		ext.w	d1
		add.w	d2,d1
		addq.w	#4,d1
		sub.w	d1,d0
		bhi.s	locret_2188A
		cmpi.w	#-$10,d0
		bcs.s	locret_2188A
		cmpi.b	#6,ost_primary_routine(a1)
		bcc.s	locret_2188A
		add.w	d0,d2
		addq.w	#3,d2
		move.w	d2,ost_y_pos(a1)
		move.b	#1,ost_flip_turned(a1)
		bsr.w	Plat_NoCheck
		move.w	#1,ost_anim(a1)
		move.b	#0,(a2)
		tst.w	ost_inertia(a1)
		bne.s	locret_2188A
		move.w	#1,ost_inertia(a1)

locret_2188A:
		rts
; ===========================================================================

loc_2188C:
		btst	#1,ost_primary_status(a1)
		bne.s	loc_218C6
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$C0,d0
		bmi.s	loc_218A8
		cmpi.w	#$180,d0
		bcs.s	loc_218E0

loc_218A8:
		bclr	#3,ost_primary_status(a1)
		bclr	d6,ost_primary_status(a0)
		move.b	#0,$2C(a1)
		move.b	#4,$2D(a1)
		bset	#1,ost_primary_status(a1)
		rts
; ===========================================================================

loc_218C6:
		move.b	(a2),d0
		addi.b	#$20,d0
		cmpi.b	#$40,d0
		bcc.s	loc_218D8
		asr	ost_y_vel(a1)
		bra.s	loc_218A8
; ===========================================================================

loc_218D8:
		move.w	#0,ost_y_vel(a1)
		bra.s	loc_218A8
; ===========================================================================

loc_218E0:
		btst	#3,ost_primary_status(a1)
		beq.s	locret_2188A
		move.b	(a2),d0
		jsrto	CalcSine,JmpTo6_CalcSine
		muls.w	#$2800,d1
		swap	d1
		move.w	ost_y_pos(a0),d2
		add.w	d1,d2
		moveq	#0,d1
		move.b	ost_height(a1),d1
		subi.w	#$13,d1
		sub.w	d1,d2
		move.w	d2,ost_y_pos(a1)
		move.b	(a2),d0
		move.b	d0,ost_flip_angle(a1)
		addq.b	#4,(a2)
		tst.w	ost_inertia(a1)
		bne.s	locret_2191E
		move.w	#1,ost_inertia(a1)

locret_2191E:
		rts
; ===========================================================================


	if RemoveJmpTos=0
JmpTo6_CalcSine:
		jmp	(CalcSine).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 14 - HTZ See-saw
; ----------------------------------------------------------------------------

Seesaw:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2193E(pc,d0.w),d1
		jsr	off_2193E(pc,d1.w)
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo_DespawnObject2
; ===========================================================================
off_2193E:	index offset(*),,2
		ptr loc_2194A					; 0
		ptr loc_219B8					; 2
		ptr locret_21A74				; 4
		ptr loc_21AA2					; 6
		ptr loc_21AFC					; 8
		ptr loc_21B94					; $A
; ===========================================================================

loc_2194A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Seesaw,ost_mappings(a0)
		move.w	#tile_Nem_SeeSaw,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo13_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$30,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$30(a0)
		tst.b	ost_subtype(a0)
		bne.s	loc_219A4
		jsrto	FindNextFreeObj,JmpTo3_FindNextFreeObj
		bne.s	loc_219A4
		_move.b	#id_Seesaw,ost_id(a1)
		addq.b	#6,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.l	a0,$3C(a1)

loc_219A4:
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_219B2
		move.b	#2,ost_frame(a0)

loc_219B2:
		move.b	ost_frame(a0),$3A(a0)

loc_219B8:
		move.b	$3A(a0),d1
		btst	#3,ost_primary_status(a0)
		beq.s	loc_21A12
		moveq	#2,d1
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_219D8
		neg.w	d0
		moveq	#0,d1

loc_219D8:
		cmpi.w	#8,d0
		bcc.s	loc_219E0
		moveq	#1,d1

loc_219E0:
		btst	#4,ost_primary_status(a0)
		beq.s	loc_21A4A
		moveq	#2,d2
		lea	($FFFFB040).w,a1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_219FC
		neg.w	d0
		moveq	#0,d2

loc_219FC:
		cmpi.w	#8,d0
		bcc.s	loc_21A04
		moveq	#1,d2

loc_21A04:
		add.w	d2,d1
		cmpi.w	#3,d1
		bne.s	loc_21A0E
		addq.w	#1,d1

loc_21A0E:
		lsr.w	#1,d1
		bra.s	loc_21A4A
; ===========================================================================

loc_21A12:
		btst	#4,ost_primary_status(a0)
		beq.s	loc_21A38
		moveq	#2,d1
		lea	($FFFFB040).w,a1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_21A2E
		neg.w	d0
		moveq	#0,d1

loc_21A2E:
		cmpi.w	#8,d0
		bcc.s	loc_21A4A
		moveq	#1,d1
		bra.s	loc_21A4A
; ===========================================================================

loc_21A38:
		move.w	($FFFFB012).w,d0
		move.w	($FFFFB052).w,d2
		cmp.w	d0,d2
		blt.s	loc_21A46
		move.w	d2,d0

loc_21A46:
		move.w	d0,$38(a0)

loc_21A4A:
		bsr.w	loc_21A76
		lea	(byte_21C8E).l,a2
		btst	#0,ost_frame(a0)
		beq.s	loc_21A62
		lea	(byte_21CBF).l,a2

loc_21A62:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#8,d3
		move.w	(sp)+,d4
		bra.w	SlopeObject
; ===========================================================================

locret_21A74:
		rts
; ===========================================================================

loc_21A76:
		move.b	ost_frame(a0),d0
		cmp.b	d1,d0
		beq.s	locret_21AA0
		bcc.s	loc_21A82
		addq.b	#2,d0

loc_21A82:
		subq.b	#1,d0
		move.b	d0,ost_frame(a0)
		move.b	d1,$3A(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		btst	#1,ost_frame(a0)
		beq.s	locret_21AA0
		bset	#render_xflip_bit,ost_render(a0)

locret_21AA0:
		rts
; ===========================================================================

loc_21AA2:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SSawBall,ost_mappings(a0)
		move.w	#tile_Nem_Sol,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo13_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a0)
		move.b	#$C,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$30(a0)
		addi.w	#$28,ost_x_pos(a0)
		addi.w	#$10,ost_y_pos(a0)
		move.w	ost_y_pos(a0),$34(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_21AFC
		subi.w	#$50,ost_x_pos(a0)
		move.b	#2,$3A(a0)

loc_21AFC:
		bsr.w	loc_21C66
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$3A(a0),d0
		sub.b	$3A(a1),d0
		beq.s	loc_21B56
		bcc.s	loc_21B14
		neg.b	d0

loc_21B14:
		move.w	#-$818,d1
		move.w	#-$114,d2
		cmpi.b	#1,d0
		beq.s	loc_21B3A
		move.w	#-$AF0,d1
		move.w	#-$CC,d2
		cmpi.w	#$A00,$38(a1)
		blt.s	loc_21B3A
		move.w	#-$E00,d1
		move.w	#-$A0,d2

loc_21B3A:
		move.w	d1,ost_y_vel(a0)
		move.w	d2,ost_x_vel(a0)
		move.w	ost_x_pos(a0),d0
		sub.w	$30(a0),d0
		bcc.s	loc_21B50
		neg.w	ost_x_vel(a0)

loc_21B50:
		addq.b	#2,ost_primary_routine(a0)
		bra.s	loc_21B94
; ===========================================================================

loc_21B56:
		lea	(word_21C5C).l,a2
		moveq	#0,d0
		move.b	ost_frame(a1),d0
		move.w	#$28,d2
		move.w	ost_x_pos(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_21B74
		neg.w	d2
		addq.w	#2,d0

loc_21B74:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		move.w	d1,ost_y_pos(a0)
		add.w	$30(a0),d2
		move.w	d2,ost_x_pos(a0)
		clr.w	ost_y_sub(a0)
		clr.w	ost_x_sub(a0)
		rts
; ===========================================================================

loc_21B94:
		bsr.w	loc_21C66
		tst.w	ost_y_vel(a0)
		bpl.s	loc_21BB6
		jsrto	ObjectFall,JmpTo_ObjectFall
		move.w	$34(a0),d0
		subi.w	#$2F,d0
		cmp.w	ost_y_pos(a0),d0
		bgt.s	locret_21BB4
		jsrto	ObjectFall,JmpTo_ObjectFall

locret_21BB4:
		rts
; ===========================================================================

loc_21BB6:
		jsrto	ObjectFall,JmpTo_ObjectFall
		movea.l	$3C(a0),a1
		lea	(word_21C5C).l,a2
		moveq	#0,d0
		move.b	ost_frame(a1),d0
		move.w	ost_x_pos(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_21BD6
		addq.w	#2,d0

loc_21BD6:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	ost_y_pos(a0),d1
		bgt.s	locret_21C2A
		movea.l	$3C(a0),a1
		moveq	#2,d1
		tst.w	ost_x_vel(a0)
		bmi.s	loc_21BF4
		moveq	#0,d1

loc_21BF4:
		move.b	d1,$3A(a1)
		move.b	d1,$3A(a0)
		cmp.b	ost_frame(a1),d1
		beq.s	loc_21C1E
		lea	($FFFFB000).w,a2
		bclr	#3,ost_primary_status(a1)
		beq.s	loc_21C10
		bsr.s	loc_21C2C

loc_21C10:
		lea	($FFFFB040).w,a2
		bclr	#4,ost_primary_status(a1)
		beq.s	loc_21C1E
		bsr.s	loc_21C2C

loc_21C1E:
		clr.w	ost_x_vel(a0)
		clr.w	ost_y_vel(a0)
		subq.b	#2,ost_primary_routine(a0)

locret_21C2A:
		rts
; ===========================================================================

loc_21C2C:
		move.w	ost_y_vel(a0),ost_y_vel(a2)
		neg.w	ost_y_vel(a2)
		bset	#1,ost_primary_status(a2)
		bclr	#3,ost_primary_status(a2)
		clr.b	$3C(a2)
		move.b	#$10,ost_anim(a2)
		move.b	#2,ost_primary_routine(a2)
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================
word_21C5C:
		dc.w -8, -28, -47, -28, -8			; low, balanced, high, balanced, low
; ===========================================================================

loc_21C66:
		move.b	(v_frame_counter_low).w,d0
		andi.b	#3,d0
		bne.s	loc_21C76
		bchg	#tile_pal12_bit,ost_tile(a0)

loc_21C76:
		andi.b	#~render_xflip,ost_render(a0)
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		bcs.s	locret_21C8C
		ori.b	#render_xflip,ost_render(a0)

locret_21C8C:
		rts
; ===========================================================================
byte_21C8E:
		dc.b $14,$14,$16,$18,$1A,$1C,$1A,$18,$16,$14,$13,$12,$11,$10, $F, $E ; 0
		dc.b  $D, $C, $B, $A,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0,$FF,$FE ; 16
		dc.b $FD,$FC,$FB,$FA,$F9,$F8,$F7,$F6,$F5,$F4,$F3,$F2,$F2,$F2,$F2,$F2 ; 32
		dc.b $F2					; 48

byte_21CBF:
		dc.b   5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5 ; 0
		dc.b   5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5 ; 16
		dc.b   5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5 ; 32
		dc.b   0					; 48

; ===========================================================================

		include "mappings/sprite/HTZ Seesaws.asm"
		include "mappings/sprite/HTZ Seesaw Ball.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo3_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo13_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_ObjectFall:
		jmp	(ObjectFall).l
JmpTo_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 16 - HTZ tram/zipline
; ----------------------------------------------------------------------------

Tram:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_21DBA(pc,d0.w),d1
		jmp	off_21DBA(pc,d1.w)
; ===========================================================================
off_21DBA:	index offset(*),,2
		ptr loc_21DBE					; 0
		ptr loc_21E10					; 2
; ===========================================================================

loc_21DBE:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Tram,ost_mappings(a0)
		move.w	#tile_Nem_Tram+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo14_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#0,ost_frame(a0)
		move.b	#1,ost_priority(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.b	#$40,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#3,d0
		move.w	d0,$34(a0)

loc_21E10:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	loc_21E2C
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		move.w	#-$28,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform,JmpTo3_DetectPlatform
		jmpto	DespawnObject,JmpTo5_DespawnObject
; ===========================================================================

loc_21E2C:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_21E3A(pc,d0.w),d1
		jmp	off_21E3A(pc,d1.w)
; ===========================================================================
off_21E3A:	index offset(*),,2
		ptr loc_21E40					; 0
		ptr loc_21E68					; 2
		ptr loc_21EC2					; 4
; ===========================================================================

loc_21E40:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_21E66
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$200,ost_x_vel(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_21E60
		neg.w	ost_x_vel(a0)

loc_21E60:
		move.w	#$100,ost_y_vel(a0)

locret_21E66:
		rts
; ===========================================================================

loc_21E68:
		move.w	(v_frame_counter).w,d0
		andi.w	#$F,d0
		bne.s	loc_21E7C
		move.w	#$E4,d0
		jsr	(PlaySound).l

loc_21E7C:
		jsrto	SpeedToPos,JmpTo4_SpeedToPos
		subq.w	#1,$34(a0)
		bne.s	locret_21EC0
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#2,ost_frame(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		jsrto	FindNextFreeObj,JmpTo4_FindNextFreeObj
		bne.s	locret_21EC0
		_move.b	#id_Scenery1,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#6,ost_subtype(a1)

locret_21EC0:
		rts
; ===========================================================================

loc_21EC2:
		jsrto	SpeedToPos,JmpTo4_SpeedToPos
		addi.w	#$38,ost_y_vel(a0)
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	locret_21F12
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	loc_21F0C
		bclr	#3,ost_primary_status(a0)
		beq.s	loc_21EF8
		bclr	#3,($FFFFB022).w
		bset	#1,($FFFFB022).w

loc_21EF8:
		bclr	#4,ost_primary_status(a0)
		beq.s	loc_21F0C
		bclr	#3,($FFFFB062).w
		bset	#1,($FFFFB062).w

loc_21F0C:
		move.w	#$4000,ost_x_pos(a0)

locret_21F12:
		rts
; ===========================================================================

		include "mappings/sprite/HTZ Tram.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo5_DespawnObject:
		jmp	(DespawnObject).l
JmpTo4_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo14_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo3_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo4_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 19 - Platforms in CPZ, OOZ and WFZ
; ----------------------------------------------------------------------------

Platform2:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_22026(pc,d0.w),d1
		jmp	off_22026(pc,d1.w)
; ===========================================================================
off_22026:	index offset(*),,2
		ptr loc_22032					; 0
		ptr loc_220B8					; 2

Plat2_SubtypeProperties:
		; ost_displaywidth. ost_frame
		dc.b $20, 0
		dc.b $18, 1
		dc.b $40, 2
		dc.b $20, 3
; ===========================================================================

loc_22032:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Plat2,ost_mappings(a0)
		move.w	#tile_Nem_CPZElevator+tile_pal4,ost_tile(a0)
		cmpi.b	#id_OOZ,(v_zone).w
		bne.s	loc_22052
		move.w	#tile_Nem_OOZElevator+tile_pal4,ost_tile(a0)

loc_22052:
		cmpi.b	#id_WFZ,(v_zone).w
		bne.s	loc_22060
		move.w	#tile_Nem_WFZFloatingPlatform+tile_pal2+tile_hi,ost_tile(a0)

loc_22060:
		jsrto	AdjustVRAM2P,JmpTo15_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Plat2_SubtypeProperties(pc,d0.w),a2
		move.b	(a2)+,ost_displaywidth(a0)
		move.b	(a2)+,ost_frame(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		andi.b	#$F,ost_subtype(a0)
		cmpi.b	#3,ost_subtype(a0)
		bne.s	loc_220AA
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_220B2

loc_220AA:
		cmpi.b	#7,ost_subtype(a0)
		bne.s	loc_220B8

loc_220B2:
		subi.w	#$C0,ost_y_pos(a0)

loc_220B8:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	loc_220E8
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		move.w	#$11,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform,JmpTo4_DetectPlatform
		move.w	$30(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo20_DeleteObject
		jmpto	DisplaySprite,JmpTo11_DisplaySprite
; ===========================================================================

loc_220E8:
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	off_220FC(pc,d0.w),d1
		jmp	off_220FC(pc,d1.w)
; ===========================================================================
off_220FC:	index offset(*)
		ptr loc_2211C					; 0
		ptr loc_22126					; 1
		ptr loc_22146					; 2
		ptr loc_22166					; 3
		ptr loc_22176					; 4
		ptr locret_22196				; 5
		ptr loc_22198					; 6
		ptr loc_22198					; 7
		ptr loc_221B4					; 8
		ptr loc_221B4					; 9
		ptr loc_221B4					; 10
		ptr loc_221B4					; 11
		ptr loc_221EE					; 12
		ptr loc_221EE					; 13
		ptr loc_221EE					; 14
		ptr loc_221EE					; 15
; ===========================================================================

loc_2211C:
		move.b	($FFFFFE68).w,d0
		move.w	#$40,d1
		bra.s	loc_2212E
; ===========================================================================

loc_22126:
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1

loc_2212E:
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2213A
		neg.w	d0
		add.w	d1,d0

loc_2213A:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_x_pos(a0)
		rts
; ===========================================================================

loc_22146:
		move.b	($FFFFFE7C).w,d0
		move.w	#$80,d1
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2215A
		neg.w	d0
		add.w	d1,d0

loc_2215A:
		move.w	$32(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_y_pos(a0)
		rts
; ===========================================================================

loc_22166:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_22174
		addq.b	#1,ost_subtype(a0)

locret_22174:
		rts
; ===========================================================================

loc_22176:
		jsrto	SpeedToPos,JmpTo5_SpeedToPos
		moveq	#8,d1
		move.w	$32(a0),d0
		subi.w	#$60,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	loc_2218C
		neg.w	d1

loc_2218C:
		add.w	d1,ost_y_vel(a0)
		bne.s	locret_22196
		addq.b	#1,ost_subtype(a0)

locret_22196:
		rts
; ===========================================================================

loc_22198:
		jsrto	SpeedToPos,JmpTo5_SpeedToPos
		moveq	#8,d1
		move.w	$32(a0),d0
		subi.w	#$60,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	loc_221AE
		neg.w	d1

loc_221AE:
		add.w	d1,ost_y_vel(a0)
		rts
; ===========================================================================

loc_221B4:
		move.b	($FFFFFE98).w,d1
		subi.b	#$40,d1
		ext.w	d1
		move.b	($FFFFFE9C).w,d2
		subi.b	#$40,d2
		ext.w	d2
		btst	#2,d0
		beq.s	loc_221D2
		neg.w	d1
		neg.w	d2

loc_221D2:
		btst	#1,d0
		beq.s	loc_221DC
		neg.w	d1
		exg	d1,d2

loc_221DC:
		add.w	$30(a0),d1
		move.w	d1,ost_x_pos(a0)
		add.w	$32(a0),d2
		move.w	d2,ost_y_pos(a0)
		rts
; ===========================================================================

loc_221EE:
		move.b	($FFFFFE98).w,d1
		subi.b	#$40,d1
		ext.w	d1
		move.b	($FFFFFE9C).w,d2
		subi.b	#$40,d2
		ext.w	d2
		btst	#2,d0
		beq.s	loc_2220C
		neg.w	d1
		neg.w	d2

loc_2220C:
		btst	#1,d0
		beq.s	loc_22216
		neg.w	d1
		exg	d1,d2

loc_22216:
		neg.w	d1
		add.w	$30(a0),d1
		move.w	d1,ost_x_pos(a0)
		add.w	$32(a0),d2
		move.w	d2,ost_y_pos(a0)
		rts
; ===========================================================================

		include "mappings/sprite/CPZ, OOZ, & WFZ Platforms.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos
JmpTo20_DeleteObject:
		jmp	(DeleteObject).l
	else
JmpTo11_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo20_DeleteObject:
		jmp	(DeleteObject).l
JmpTo15_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo4_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo5_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 1B - CPZ Speed Booster
; ----------------------------------------------------------------------------

SpeedBooster:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Bstr_Index(pc,d0.w),d1
		jmp	Bstr_Index(pc,d1.w)
; ===========================================================================
Bstr_Index:	index offset(*),,2
		ptr loc_222C2					; 0
		ptr loc_222F8					; 2

Bstr_Speeds:
		dc.w $1000					; 0
		dc.w  $A00					; 1
; ===========================================================================

loc_222C2:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Bstr,ost_mappings(a0)
		move.w	#tile_Nem_Booster+tile_pal4+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo16_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#2,d0
		move.w	Bstr_Speeds(pc,d0.w),$30(a0)

loc_222F8:
		move.b	(v_frame_counter_low).w,d0
		andi.b	#2,d0
		move.b	d0,ost_frame(a0)
		move.w	ost_x_pos(a0),d0
		move.w	d0,d1
		subi.w	#$10,d0
		addi.w	#$10,d1
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		subi.w	#$10,d2
		addi.w	#$10,d3
		; if debug mode is active, then skip
		lea	(v_ost_player1).w,a1
		btst	#1,ost_primary_status(a1)
		bne.s	loc_22354
		move.w	ost_x_pos(a1),d4
		cmp.w	d0,d4
		bcs.w	loc_22354
		cmp.w	d1,d4
		bcc.w	loc_22354
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.w	loc_22354
		cmp.w	d3,d4
		bcc.w	loc_22354
		move.w	d0,-(sp)
		bsr.w	loc_22388
		move.w	(sp)+,d0

loc_22354:
		lea	(v_ost_player2).w,a1
		btst	#1,ost_primary_status(a1)
		bne.s	loc_22384
		move.w	ost_x_pos(a1),d4
		cmp.w	d0,d4
		bcs.w	loc_22384
		cmp.w	d1,d4
		bcc.w	loc_22384
		move.w	ost_y_pos(a1),d4
		cmp.w	d2,d4
		bcs.w	loc_22384
		cmp.w	d3,d4
		bcc.w	loc_22384
		bsr.w	loc_22388

loc_22384:
		jmpto	DespawnObject,JmpTo6_DespawnObject
; ===========================================================================

loc_22388:
		move.w	ost_x_vel(a1),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_22396
		neg.w	d0

loc_22396:
		cmpi.w	#$1000,d0
		bge.s	loc_223D8
		move.w	$30(a0),ost_x_vel(a1)
		bclr	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_223BA
		bset	#status_xflip_bit,ost_primary_status(a1)
		neg.w	ost_x_vel(a1)

loc_223BA:
		move.w	#$F,$2E(a1)
		move.w	ost_x_vel(a1),ost_inertia(a1)
		bclr	#5,ost_primary_status(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)

loc_223D8:
		move.w	#sfx_Spring,d0
		jmp	(PlaySound).l
; ===========================================================================

		include "mappings/sprite/CPZ Speed Booster.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo6_DespawnObject:
		jmp	(DespawnObject).l
JmpTo16_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 1D - CPZ blue balls
; ----------------------------------------------------------------------------

BlueBalls:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	BBalls_Index(pc,d0.w),d1
		jmp	BBalls_Index(pc,d1.w)
; ===========================================================================
BBalls_Index:	index offset(*),,2
		ptr loc_22428					; 0
		ptr loc_224D6					; 2
		ptr loc_224F4					; 4
		ptr loc_224D6					; 6
		ptr loc_22528					; 8

; unused table of speed values
		dc.w $FB80					; 0
		dc.w $FB00					; 1
		dc.w $FA00					; 2
		dc.w $F900					; 3
; ===========================================================================

loc_22428:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#-$480,ost_y_vel(a0)
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		move.b	d1,d0
		andi.b	#$F,d1
		moveq	#2,d5
		andi.b	#-$10,d0
		beq.s	loc_22448
		moveq	#6,d5

loc_22448:
		move.b	ost_primary_status(a0),d4
		moveq	#0,d2
		movea.l	a0,a1
		bra.s	loc_22458
; ===========================================================================

loc_22452:
		jsrto	FindNextFreeObj,JmpTo5_FindNextFreeObj
		bne.s	loc_224D0

loc_22458:
		_move.b	ost_id(a0),ost_id(a1)
		move.b	d5,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	#Map_BBalls,ost_mappings(a1)
		move.w	#tile_Nem_Droplet+tile_pal4,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo3_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a1)
		move.w	ost_x_pos(a1),$38(a1)
		move.w	ost_y_pos(a1),$30(a1)
		move.w	ost_y_vel(a0),ost_y_vel(a1)
		move.w	ost_y_vel(a1),$34(a1)
		move.b	#8,ost_displaywidth(a1)
		move.w	#$60,$3A(a1)
		move.w	#$B,$36(a1)
		andi.b	#1,d4
		beq.s	loc_224CA
		neg.w	$36(a1)
		neg.w	$3A(a1)

loc_224CA:
		move.w	d2,$32(a1)
		addq.w	#3,d2

loc_224D0:
		dbf	d1,loc_22452
		rts
; ===========================================================================

loc_224D6:
		subq.w	#1,$32(a0)
		bpl.s	loc_224F0
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$3B,$32(a0)
		move.w	#sfx_Gloop,d0
		jsr	(PlaySoundLocal).l

loc_224F0:
		jmpto	DespawnObject,JmpTo7_DespawnObject
; ===========================================================================

loc_224F4:
		jsrto	SpeedToPos,JmpTo6_SpeedToPos
		move.w	$36(a0),d0
		add.w	d0,ost_x_vel(a0)

loc_22500:
		addi.w	#$18,ost_y_vel(a0)
		bne.s	loc_2250C
		neg.w	$36(a0)

loc_2250C:
		move.w	$30(a0),d0
		cmp.w	ost_y_pos(a0),d0
		bhi.s	loc_22524
		move.w	$34(a0),ost_y_vel(a0)
		clr.w	ost_x_vel(a0)
		subq.b	#2,ost_primary_routine(a0)

loc_22524:
		jmpto	DespawnObject,JmpTo7_DespawnObject
; ===========================================================================

loc_22528:
		jsrto	SpeedToPos,JmpTo6_SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		bne.s	loc_22540
		move.w	$3A(a0),d0
		add.w	$38(a0),d0
		move.w	d0,ost_x_pos(a0)

loc_22540:
		cmpi.w	#$180,ost_y_vel(a0)
		bne.s	loc_22552
		move.w	#$DA,d0
		jsr	(PlaySoundLocal).l

loc_22552:
		move.w	$30(a0),d0
		cmp.w	ost_y_pos(a0),d0
		bhi.s	loc_22572
		move.w	$34(a0),ost_y_vel(a0)
		move.w	$38(a0),ost_x_pos(a0)
		move.w	#sfx_Gloop,d0
		jsr	(PlaySoundLocal).l

loc_22572:
		jmpto	DespawnObject,JmpTo7_DespawnObject
; ===========================================================================

		include "mappings/sprite/CPZ Blue Balls.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo7_DespawnObject:
		jmp	(DespawnObject).l
JmpTo5_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo3_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo6_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 1E - CPZ spin tube
; ----------------------------------------------------------------------------

SpinTube:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_225B8(pc,d0.w),d1
		jsr	off_225B8(pc,d1.w)
		move.b	$2C(a0),d0
		add.b	$36(a0),d0
		beq.w	JmpTo_DespawnObject3
		rts

    if RemoveJmpTos
JmpTo_DespawnObject3:
		jmp	(DespawnObject3).l
    endC
; ===========================================================================
off_225B8	index offset(*),,2
		ptr loc_225C2					; 0
		ptr loc_225D6					; 2

word_225BC:
		dc.w   $A0					; 0
		dc.w  $100					; 1
		dc.w  $120					; 2
; ===========================================================================

loc_225C2:
		addq.b	#2,ost_primary_routine(a0)
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		andi.w	#6,d0
		move.w	word_225BC(pc,d0.w),$2A(a0)

loc_225D6:
		lea	(v_ost_player1).w,a1
		lea	$2C(a0),a4
		bsr.s	loc_225E8
		lea	(v_ost_player2).w,a1
		lea	$36(a0),a4

loc_225E8:
		moveq	#0,d0
		move.b	(a4),d0
		move.w	off_225F4(pc,d0.w),d0
		jmp	off_225F4(pc,d0.w)
; ===========================================================================
off_225F4:	index offset(*),,2
		ptr loc_225FC					; 0
		ptr loc_2271A					; 2
		ptr loc_227FE					; 4
		ptr loc_2286A					; 6
; ===========================================================================

loc_225FC:
		tst.w	(v_debug_active).w
		bne.w	locret_22718
		move.w	$2A(a0),d2
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmp.w	d2,d0
		bcc.w	locret_22718
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		cmpi.w	#$80,d1
		bcc.w	locret_22718
		cmpi.b	#$20,ost_anim(a1)
		beq.w	locret_22718
		moveq	#0,d3
		cmpi.w	#$A0,d2
		beq.s	loc_22648
		moveq	#8,d3
		cmpi.w	#$120,d2
		beq.s	loc_22648
		moveq	#4,d3
		neg.w	d0
		addi.w	#$100,d0

loc_22648:
		cmpi.w	#$80,d0
		bcs.s	loc_2267E
		moveq	#0,d2
		move.b	ost_subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$F,d0
		move.b	byte_2266E(pc,d0.w),d2
		cmpi.b	#2,d2
		bne.s	loc_22688
		move.b	(v_time_sec).w,d2
		andi.b	#1,d2
		bra.s	loc_22688
; ===========================================================================
byte_2266E:
		dc.b   2					; 0
		dc.b   2					; 1
		dc.b   2					; 2
		dc.b   2					; 3
		dc.b   2					; 4
		dc.b   2					; 5
		dc.b   2					; 6
		dc.b   2					; 7
		dc.b   2					; 8
		dc.b   2					; 9
		dc.b   0					; 10
		dc.b   2					; 11
		dc.b   0					; 12
		dc.b   1					; 13
		dc.b   2					; 14
		dc.b   1					; 15
; ===========================================================================

loc_2267E:
		moveq	#2,d2
		cmpi.w	#$40,d1
		bcc.s	loc_22688
		moveq	#3,d2

loc_22688:
		move.b	d2,1(a4)
		add.w	d3,d2
		add.w	d2,d2
		andi.w	#$1E,d2
		lea	SpinTube_Termini(pc),a2
		adda.w	(a2,d2.w),a2
		move.w	(a2)+,4(a4)
		subq.w	#4,4(a4)
		move.w	(a2)+,d4
		add.w	ost_x_pos(a0),d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		add.w	ost_y_pos(a0),d5
		move.w	d5,ost_y_pos(a1)
		move.l	a2,6(a4)
		move.w	(a2)+,d4
		add.w	ost_x_pos(a0),d4
		move.w	(a2)+,d5
		add.w	ost_y_pos(a0),d5
		addq.b	#2,(a4)
		move.b	#-$7F,$2A(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$800,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		bclr	#5,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)
		move.b	#0,$3C(a1)
		bclr	#tile_hi_bit,ost_tile(a1)
		move.w	#$800,d2
		bsr.w	loc_22902
		move.w	#$BE,d0
		jsr	(PlaySound).l

locret_22718:
		rts
; ===========================================================================

loc_2271A:
		subq.b	#1,2(a4)
		bpl.s	loc_2275E
		movea.l	6(a4),a2
		move.w	(a2)+,d4
		add.w	ost_x_pos(a0),d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		add.w	ost_y_pos(a0),d5
		move.w	d5,ost_y_pos(a1)
		tst.b	1(a4)
		bpl.s	loc_22740
		subq.w	#8,a2

loc_22740:
		move.l	a2,6(a4)
		subq.w	#4,4(a4)
		beq.s	loc_22784
		move.w	(a2)+,d4
		add.w	ost_x_pos(a0),d4
		move.w	(a2)+,d5
		add.w	ost_y_pos(a0),d5
		move.w	#$800,d2
		bra.w	loc_22902
; ===========================================================================

loc_2275E:
		move.l	ost_x_pos(a1),d2
		move.l	ost_y_pos(a1),d3
		move.w	ost_x_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,ost_x_pos(a1)
		move.l	d3,ost_y_pos(a1)
		rts
; ===========================================================================

loc_22784:
		cmpi.b	#4,1(a4)
		bcc.s	loc_227A6
		move.b	ost_subtype(a0),d0
		andi.w	#$FC,d0
		add.b	1(a4),d0
		move.b	#4,1(a4)
		move.b	byte_227BE(pc,d0.w),d0
		bne.w	loc_22892

loc_227A6:
		andi.w	#$7FF,ost_y_pos(a1)
		move.b	#6,(a4)
		clr.b	$2A(a1)
		move.w	#$BC,d0
		jmp	(PlaySound).l
; ===========================================================================
byte_227BE:
		dc.b   2,  1,  0,  0
		dc.b  -1,  3,  0,  0
		dc.b   4, -2,  0,  0
		dc.b  -3, -4,  0,  0
		dc.b  -5, -5,  0,  0
		dc.b   7,  6,  0,  0
		dc.b  -7, -6,  0,  0
		dc.b   8,  9,  0,  0
		dc.b  -8, -9,  0,  0
		dc.b  11, 10,  0,  0
		dc.b  12,  0,  0,  0
		dc.b -11,-10,  0,  0
		dc.b -12,  0,  0,  0
		dc.b   0, 13,  0,  0
		dc.b -13, 14,  0,  0
		dc.b   0,-14,  0,  0
; ===========================================================================

loc_227FE:
		subq.b	#1,2(a4)
		bpl.s	loc_22832
		movea.l	6(a4),a2
		move.w	(a2)+,d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		move.w	d5,ost_y_pos(a1)
		tst.b	1(a4)
		bpl.s	loc_2281C
		subq.w	#8,a2

loc_2281C:
		move.l	a2,6(a4)
		subq.w	#4,4(a4)
		beq.s	loc_22858
		move.w	(a2)+,d4
		move.w	(a2)+,d5
		move.w	#$800,d2
		bra.w	loc_22902
; ===========================================================================

loc_22832:
		move.l	ost_x_pos(a1),d2
		move.l	ost_y_pos(a1),d3
		move.w	ost_x_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,ost_x_pos(a1)
		move.l	d3,ost_y_pos(a1)
		rts
; ===========================================================================

loc_22858:
		andi.w	#$7FF,ost_y_pos(a1)
		clr.b	(a4)
		move.w	#$BC,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_2286A:
		move.w	$2A(a0),d2
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		cmp.w	d2,d0
		bcc.w	loc_2288E
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		cmpi.w	#$80,d1
		bcc.w	loc_2288E
		rts
; ===========================================================================

loc_2288E:
		clr.b	(a4)
		rts
; ===========================================================================

loc_22892:
		bpl.s	loc_228C4
		neg.b	d0
		move.b	#-4,1(a4)
		add.w	d0,d0
		lea	(SpinTube_TubeData).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d0
		subq.w	#4,d0
		move.w	d0,4(a4)
		lea	(a2,d0.w),a2
		move.w	(a2)+,d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		move.w	d5,ost_y_pos(a1)
		subq.w	#8,a2
		bra.s	loc_228E4
; ===========================================================================

loc_228C4:
		add.w	d0,d0
		lea	(SpinTube_TubeData).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,4(a4)
		subq.w	#4,4(a4)
		move.w	(a2)+,d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		move.w	d5,ost_y_pos(a1)

loc_228E4:
		move.l	a2,6(a4)
		move.w	(a2)+,d4
		move.w	(a2)+,d5
		move.w	#$800,d2
		bsr.w	loc_22902

loc_228F4:
		move.w	#$BE,d0
		jsr	(PlaySound).l
		addq.b	#2,(a4)
		rts
; ===========================================================================

loc_22902:
		moveq	#0,d0
		move.w	d2,d3
		move.w	d4,d0
		sub.w	ost_x_pos(a1),d0
		bge.s	loc_22912
		neg.w	d0
		neg.w	d2

loc_22912:
		moveq	#0,d1
		move.w	d5,d1
		sub.w	ost_y_pos(a1),d1
		bge.s	loc_22920
		neg.w	d1
		neg.w	d3

loc_22920:
		cmp.w	d0,d1
		bcs.s	loc_22952
		moveq	#0,d1
		move.w	d5,d1
		sub.w	ost_y_pos(a1),d1
		swap	d1
		divs.w	d3,d1
		moveq	#0,d0
		move.w	d4,d0
		sub.w	ost_x_pos(a1),d0
		beq.s	loc_2293E
		swap	d0
		divs.w	d1,d0

loc_2293E:
		move.w	d0,ost_x_vel(a1)
		move.w	d3,ost_y_vel(a1)
		tst.w	d1
		bpl.s	loc_2294C
		neg.w	d1

loc_2294C:
		move.w	d1,2(a4)
		rts
; ===========================================================================

loc_22952:
		moveq	#0,d0
		move.w	d4,d0
		sub.w	ost_x_pos(a1),d0
		swap	d0
		divs.w	d2,d0
		moveq	#0,d1
		move.w	d5,d1
		sub.w	ost_y_pos(a1),d1
		beq.s	loc_2296C
		swap	d1
		divs.w	d0,d1

loc_2296C:
		move.w	d1,ost_y_vel(a1)
		move.w	d2,ost_x_vel(a1)
		tst.w	d0
		bpl.s	loc_2297A
		neg.w	d0

loc_2297A:
		move.w	d0,2(a4)
		rts
; ===========================================================================

		include "misc/CPZ Spin Tube Termini.asm"
		include "misc/CPZ Spin Tube Locations.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_DespawnObject3:
		jmp	(DespawnObject3).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 20 - HTZ boss lava bubble
; ----------------------------------------------------------------------------

LavaBubble:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_23006(pc,d0.w),d1
		jmp	off_23006(pc,d1.w)
; ===========================================================================
off_23006:	index offset(*),,2
		ptr loc_23014					; 0
		ptr loc_23076					; 2
		ptr loc_23084					; 4
		ptr loc_2311E					; 6
		ptr loc_23144					; 8
		ptr loc_231D2					; $A
		ptr loc_23232					; $C
; ===========================================================================

loc_23014:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#8,ost_height(a0)
		move.b	#8,ost_width(a0)
		move.l	#Map_Fireball2,ost_mappings(a0)
		move.w	#tile_Nem_HTZFireball2+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo17_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.w	ost_y_pos(a0),$30(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#3,d0
		andi.w	#$780,d0
		neg.w	d0
		move.w	d0,ost_x_vel(a0)
		move.w	d0,ost_y_vel(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lsl.w	#4,d0
		move.w	d0,$32(a0)
		move.w	d0,$34(a0)

loc_23076:
		lea	(Ani_LavaBub).l,a1
		jsrto	AnimateSprite,JmpTo4_AnimateSprite
		jmpto	DespawnObject,JmpTo8_DespawnObject
; ===========================================================================

loc_23084:
		cmpi.b	#5,ost_anim_time(a0)
		bne.s	loc_230B4
		jsrto	FindNextFreeObj,JmpTo6_FindNextFreeObj
		bne.s	loc_230A6
		bsr.s	loc_230C2
		jsrto	FindNextFreeObj,JmpTo6_FindNextFreeObj
		bne.s	loc_230A6
		bsr.s	loc_230C2
		neg.w	ost_x_vel(a1)
		bset	#render_xflip_bit,ost_render(a1)

loc_230A6:
		move.w	#$AE,d0
		jsr	(PlaySound).l
		addq.b	#2,ost_primary_routine(a0)

loc_230B4:
		lea	(Ani_LavaBub).l,a1
		jsrto	AnimateSprite,JmpTo4_AnimateSprite
		jmpto	DespawnObject,JmpTo8_DespawnObject
; ===========================================================================

loc_230C2:
		_move.b	#id_LavaBubble,ost_id(a1)
		move.b	#8,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_x_vel(a0),ost_x_vel(a1)
		move.w	ost_y_vel(a0),ost_y_vel(a1)
		move.b	#8,ost_height(a1)
		move.b	#8,ost_width(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a1)
		move.w	ost_y_pos(a1),$30(a1)
		rts
; ===========================================================================

loc_2311E:
		subq.w	#1,$32(a0)
		bpl.s	loc_23136
		move.w	$34(a0),$32(a0)
		move.b	#2,ost_primary_routine(a0)
		move.w	#1,ost_anim(a0)

loc_23136:
		lea	(Ani_LavaBub).l,a1
		jsrto	AnimateSprite,JmpTo4_AnimateSprite
		jmpto	DespawnObject,JmpTo8_DespawnObject
; ===========================================================================

loc_23144:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2315A
		move.b	#7,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		andi.b	#1,ost_frame(a0)

loc_2315A:
		jsrto	SpeedToPos,JmpTo7_SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	loc_23176
		jmpto	DeleteObject,JmpTo21_DeleteObject
; ===========================================================================

loc_23176:
		bclr	#render_yflip_bit,ost_render(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_231CE
		bset	#render_yflip_bit,ost_render(a0)
		bsr.w	FindFloorObj
		tst.w	d1
		bpl.s	loc_231CE
		add.w	d1,ost_y_pos(a0)
		addq.b	#2,ost_primary_routine(a0)
		move.b	#2,ost_anim(a0)
		move.b	#4,ost_frame(a0)
		move.w	#0,ost_y_vel(a0)
		move.l	#Map_Fireball1,ost_mappings(a0)
		move.w	#(vram_HTZFireball1/sizeof_cell)+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo17_AdjustVRAM2P
		move.b	#0,ost_frame(a0)
		move.w	#9,$32(a0)
		move.b	#3,$36(a0)

loc_231CE:
		jmpto	DespawnObject,JmpTo8_DespawnObject
; ===========================================================================

loc_231D2:
		subq.w	#1,$32(a0)
		bpl.s	loc_23224
		move.w	#$7F,$32(a0)
		subq.b	#1,$36(a0)
		bmi.s	loc_23224
		jsrto	FindNextFreeObj,JmpTo6_FindNextFreeObj
		bne.s	loc_23224
		moveq	#0,d0
		move.w	#$F,d1

loc_231F0:
		move.l	(a0,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_231F0
		move.w	#9,$32(a1)
		move.w	#$200,ost_anim(a1)
		move.w	#$E,d0
		tst.w	ost_x_vel(a1)
		bpl.s	loc_23214
		neg.w	d0

loc_23214:
		add.w	d0,ost_x_pos(a1)
		move.l	a1,-(sp)
		bsr.w	FindFloorFire
		movea.l	(sp)+,a1
		add.w	d1,ost_y_pos(a1)

loc_23224:
		lea	(Ani_LavaBub).l,a1
		jsrto	AnimateSprite,JmpTo4_AnimateSprite
		jmpto	DespawnObject,JmpTo8_DespawnObject
; ===========================================================================

loc_23232:
		jmpto	DeleteObject,JmpTo21_DeleteObject
; ===========================================================================
Ani_LavaBub:	index offset(*)
		ptr byte_2323C					; 0
		ptr byte_23243					; 1
		ptr byte_23246					; 2
byte_2323C:	dc.b  $B,  2,  3,$FC,  4,$FD,  1		; 0
byte_23243:	dc.b $7F,  5,$FF				; 0
byte_23246:	dc.b   5,  4,  5,  2,  3,  0,  1,  0,  1,  2,  3,  4,  5,$FC ; 0


		include "mappings/sprite/Fireball 2.asm"
		include "mappings/sprite/Fireball 1.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo21_DeleteObject:
		jmp	(DeleteObject).l
JmpTo8_DespawnObject:
		jmp	(DespawnObject).l
JmpTo6_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo4_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo17_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo7_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 2F - HTZ smashable ground
; ----------------------------------------------------------------------------

SmashGround:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2330E(pc,d0.w),d1
		jmp	off_2330E(pc,d1.w)
; ===========================================================================
off_2330E:	index offset(*),,2
		ptr loc_2331E					; 0
		ptr loc_23368					; 2
		ptr loc_234DC					; 4

byte_23314:
		;    ost_height
		;	 ost_frame
		dc.b $24, 0					; 0
		dc.b $20, 2					; 2
		dc.b $18, 4					; 4
		dc.b $10, 6					; 6
		dc.b   8, 8					; 8
; ===========================================================================

loc_2331E:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SmashGround,ost_mappings(a0)
		move.w	#0+tile_pal3+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo18_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$1E,d0
		lea	byte_23314(pc,d0.w),a2
		move.b	(a2)+,ost_height(a0)
		move.b	(a2)+,ost_frame(a0)
		move.b	#$20,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)

loc_23368:
		move.w	(v_enemy_combo).w,$38(a0)
		move.b	($FFFFB01C).w,$32(a0)
		move.b	($FFFFB05C).w,$33(a0)
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo3_SolidObject
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_233A4

BranchTo_JmpTo9_DespawnObject:
		jmpto	DespawnObject,JmpTo9_DespawnObject
; ===========================================================================

loc_233A4:
		cmpi.b	#$18,d0
		bne.s	loc_23408
		cmpi.b	#2,$32(a0)
		bne.s	loc_233C0
		tst.b	ost_subtype(a0)
		bmi.s	loc_233F0
		cmpi.b	#$E,(v_ost_player1+ost_top_solid_bit).w
		beq.s	loc_233F0

loc_233C0:
		move.b	#$C,(v_ost_player1+ost_top_solid_bit).w
		move.b	#$D,($FFFFB03F).w
		cmpi.b	#2,$33(a0)
		bne.s	loc_233E2
		tst.b	ost_subtype(a0)
		bmi.s	loc_233F0
		cmpi.b	#$E,(v_ost_player2+ost_top_solid_bit).w
		beq.s	loc_233F0

loc_233E2:
		move.b	#$C,(v_ost_player2+ost_top_solid_bit).w
		move.b	#$D,($FFFFB07F).w
		bra.s	BranchTo_JmpTo9_DespawnObject
; ===========================================================================

loc_233F0:
		lea	($FFFFB000).w,a1
		move.b	$32(a0),d0
		bsr.s	loc_2343E
		lea	($FFFFB040).w,a1
		move.b	$33(a0),d0
		bsr.s	loc_2343E
		bra.w	loc_234A4
; ===========================================================================

loc_23408:
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_23470
		cmpi.b	#2,$32(a0)
		bne.s	loc_23426
		tst.b	ost_subtype(a0)
		bmi.s	loc_23436
		cmpi.b	#$E,(v_ost_player1+ost_top_solid_bit).w
		beq.s	loc_23436

loc_23426:
		move.b	#$C,(v_ost_player1+ost_top_solid_bit).w
		move.b	#$D,($FFFFB03F).w
		bra.w	BranchTo_JmpTo9_DespawnObject
; ===========================================================================

loc_23436:
		lea	($FFFFB000).w,a1
		bsr.s	loc_23444
		bra.s	loc_234A4
; ===========================================================================

loc_2343E:
		cmpi.b	#2,d0
		bne.s	loc_2345C

loc_23444:
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)

loc_2345C:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		rts
; ===========================================================================

loc_23470:
		andi.b	#$10,d0
		beq.w	BranchTo_JmpTo9_DespawnObject
		cmpi.b	#2,$33(a0)
		bne.s	loc_2348E
		tst.b	ost_subtype(a0)
		bmi.s	loc_2349E
		cmpi.b	#$E,(v_ost_player2+ost_top_solid_bit).w
		beq.s	loc_2349E

loc_2348E:
		move.b	#$C,(v_ost_player2+ost_top_solid_bit).w
		move.b	#$D,($FFFFB07F).w
		bra.w	BranchTo_JmpTo9_DespawnObject
; ===========================================================================

loc_2349E:
		lea	($FFFFB040).w,a1
		bsr.s	loc_23444

loc_234A4:
		move.w	$38(a0),(v_enemy_combo).w
		andi.b	#-$19,ost_primary_status(a0)
		lea	(byte_234F2).l,a4
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		addq.b	#1,ost_frame(a0)
		move.l	d0,d1
		add.w	d0,d0
		add.w	d0,d0
		lea	(a4,d0.w),a4
		neg.w	d1
		addi.w	#9,d1

loc_234D0:
		move.w	#$18,d2
		jsrto	SmashObject,JmpTo_SmashObject
		bsr.w	loc_236A8

loc_234DC:
		jsrto	SpeedToPos,JmpTo8_SpeedToPos

loc_234E0:
		addi.w	#$18,ost_y_vel(a0)
		tst.b	ost_render(a0)
		bpl.w	JmpTo22_DeleteObject
		jmpto	DisplaySprite,JmpTo12_DisplaySprite
; ===========================================================================
byte_234F2:
		dc.b $FF					; 0
		dc.b   0					; 1
		dc.b $F8					; 2
		dc.b   0					; 3
		dc.b   1					; 4
		dc.b   0					; 5
		dc.b $F8					; 6
		dc.b   0					; 7
		dc.b $FF					; 8
		dc.b $20					; 9
		dc.b $F9					; 10
		dc.b   0					; 11
		dc.b   0					; 12
		dc.b $E0					; 13
		dc.b $F9					; 14
		dc.b   0					; 15
		dc.b $FF					; 16
		dc.b $40					; 17
		dc.b $FA					; 18
		dc.b   0					; 19
		dc.b   0					; 20
		dc.b $C0					; 21
		dc.b $FA					; 22
		dc.b   0					; 23
		dc.b $FF					; 24
		dc.b $60					; 25
		dc.b $FB					; 26
		dc.b   0					; 27
		dc.b   0					; 28
		dc.b $A0					; 29
		dc.b $FB					; 30
		dc.b   0					; 31
		dc.b $FF					; 32
		dc.b $80					; 33
		dc.b $FC					; 34
		dc.b   0					; 35
		dc.b   0					; 36
		dc.b $80					; 37
		dc.b $FC					; 38
		dc.b   0					; 39
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 32 - CPZ spin tube block and HTZ breakable rock
; ----------------------------------------------------------------------------

SmashBlock:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_23528(pc,d0.w),d1
		jmp	off_23528(pc,d1.w)
; ===========================================================================
off_23528:	index offset(*),,2
		ptr loc_2352E					; 0
		ptr loc_23582					; 2
		ptr loc_2366A					; 4
; ===========================================================================

loc_2352E:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_BreakRock,ost_mappings(a0)
		move.w	#tile_Nem_HTZRock+tile_pal3,ost_tile(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.l	#byte_23680,$3C(a0)
		cmpi.b	#id_CPZ,(v_zone).w
		bne.s	loc_23572
		move.l	#Map_SpinTubeBlock,ost_mappings(a0)
		move.w	#tile_Nem_CPZMetalBlock+tile_pal4,ost_tile(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.l	#byte_23698,$3C(a0)

loc_23572:
		jsrto	AdjustVRAM2P,JmpTo18_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)

loc_23582:
		move.w	(v_enemy_combo).w,$38(a0)
		move.b	($FFFFB01C).w,$32(a0)
		move.b	($FFFFB05C).w,$33(a0)
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo3_SolidObject
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_235BC

BranchTo2_JmpTo9_DespawnObject:
		jmpto	DespawnObject,JmpTo9_DespawnObject
; ===========================================================================

loc_235BC:
		cmpi.b	#$18,d0
		bne.s	loc_235EA
		cmpi.b	#2,$32(a0)
		beq.s	loc_235D2
		cmpi.b	#2,$33(a0)
		bne.s	BranchTo2_JmpTo9_DespawnObject

loc_235D2:
		lea	(v_ost_player1).w,a1
		move.b	$32(a0),d0
		bsr.s	loc_23602
		lea	(v_ost_player2).w,a1
		move.b	$33(a0),d0
		bsr.s	loc_23602
		bra.w	loc_23652
; ===========================================================================

loc_235EA:
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_2363A
		cmpi.b	#2,$32(a0)
		bne.s	BranchTo2_JmpTo9_DespawnObject
		lea	($FFFFB000).w,a1
		bsr.s	loc_23608
		bra.s	loc_23652
; ===========================================================================

loc_23602:
		cmpi.b	#2,d0
		bne.s	loc_23626

loc_23608:
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		move.w	#-$300,ost_y_vel(a1)

loc_23626:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		rts
; ===========================================================================

loc_2363A:
		; Possibly copied and pasted? These first two lines are completely pointless;
		; there is no way this will return zero and trigger a branch.
		andi.b	#$10,d0
		beq.w	BranchTo2_JmpTo9_DespawnObject
		cmpi.b	#2,$33(a0)
		bne.w	BranchTo2_JmpTo9_DespawnObject
		lea	($FFFFB040).w,a1
		bsr.s	loc_23608

loc_23652:
		move.w	$38(a0),(v_enemy_combo).w
		andi.b	#-$19,ost_primary_status(a0)
		movea.l	$3C(a0),a4
		jsrto	SmashObject,JmpTo_SmashObject
		bsr.w	loc_236A8

loc_2366A:
		jsrto	SpeedToPos,JmpTo8_SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		tst.b	ost_render(a0)
		bpl.w	JmpTo22_DeleteObject
		jmpto	DisplaySprite,JmpTo12_DisplaySprite
; ===========================================================================
byte_23680:
		;    x_vel y_vel
		dc.w -$200,-$200
		dc.w     0,-$280
		dc.w  $200,-$200
		dc.w -$1C0,-$1C0
		dc.w     0,-$200
		dc.w  $1C0,-$1C0

byte_23698:
		;    x_vel y_vel
		dc.w -$100,-$200
		dc.w  $100,-$200
		dc.w  -$C0,-$1C0
		dc.w   $C0,-$1C0
; ===========================================================================

loc_236A8:
		jsrto	FindFreeObj,JmpTo3_FindFreeObj
		bne.s	locret_236F0
		_move.b	#id_Points,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	(v_enemy_combo).w,d2
		addq.w	#2,(v_enemy_combo).w
		cmpi.w	#6,d2
		bcs.s	loc_236D0
		moveq	#6,d2

loc_236D0:
		moveq	#0,d0
		move.w	word_236F2(pc,d2.w),d0
		cmpi.w	#$20,(v_enemy_combo).w
		bcs.s	loc_236E4
		move.w	#$3E8,d0
		moveq	#$A,d2

loc_236E4:
		jsr	(AddPoints).l
		lsr.w	#1,d2
		move.b	d2,ost_frame(a1)

locret_236F0:
		rts
; ===========================================================================
word_236F2:
		dc.w	10
		dc.w	20					; 1
		dc.w	50					; 2
		dc.w   100					; 3
; ===========================================================================

		include "mappings/sprite/HTZ Smashable Ground.asm"
		include "mappings/sprite/HTZ Breakable Rock.asm"
		include "mappings/sprite/CPZ Spin Tube Block.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos
JmpTo22_DeleteObject:
		jmp	(DeleteObject).l
	else
JmpTo12_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo22_DeleteObject:
		jmp	(DeleteObject).l
JmpTo3_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo9_DespawnObject:
		jmp	(DespawnObject).l
JmpTo18_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_SmashObject:
		jmp	(SmashObject).l
JmpTo3_SolidObject:
		jmp	(SolidObject).l
JmpTo8_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 30 - HTZ rising lava
; ----------------------------------------------------------------------------

RisingLava:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_238EA(pc,d0.w),d1
		jmp	off_238EA(pc,d1.w)
; ===========================================================================
off_238EA:	index offset(*),,2
		ptr loc_238F8					; 0
		ptr loc_23944					; 2

byte_238EE:
		dc.b $C0					; 0
		dc.b   0					; 1
		dc.b $C0					; 2
		dc.b   0					; 3
		dc.b $C0					; 4
		dc.b   0					; 5
		dc.b $E0					; 6
		dc.b   0					; 7
		dc.b $C0					; 8
		dc.b   0					; 9
		even
; ===========================================================================

loc_238F8:
		addq.b	#2,ost_primary_routine(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.w	ost_x_pos(a0),$30(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.b	byte_238EE(pc,d0.w),ost_displaywidth(a0)
		cmpi.b	#6,d0
		bcs.s	loc_23944
		bne.s	loc_23926
		cmpi.w	#$380,(v_camera_y_pos).w
		bcc.s	loc_23944
		bra.s	loc_2392E
; ===========================================================================

loc_23926:
		cmpi.w	#$380,(v_camera_y_pos).w
		bcs.s	loc_23944

loc_2392E:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_23940
		bclr	#7,2(a2,d0.w)

loc_23940:
		jmpto	DeleteObject,JmpTo23_DeleteObject
; ===========================================================================

loc_23944:
		move.w	$32(a0),d0
		add.w	(v_camera_y_pos_offset).w,d0
		move.w	d0,ost_y_pos(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.w	off_23968(pc,d0.w),d1
		jsr	off_23968(pc,d1.w)
		tst.b	(f_screen_shake_htz).w
		beq.w	JmpTo2_DespawnObject3
		rts
; ===========================================================================
off_23968:	index offset(*),,2
		ptr loc_23972					; 0
		ptr loc_23972					; 2
		ptr loc_2398A					; 4
		ptr loc_239D0					; 6
		ptr loc_239EA					; 8
; ===========================================================================

loc_23972:
		move.w	#$CB,d1
		move.w	#$80,d2
		move.w	#$81,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject_NoRenderChk,JmpTo_SolidObject_NoRenderChk
		jmpto	DropOnFloor,JmpTo_DropOnFloor
; ===========================================================================

loc_2398A:
		move.w	#$CB,d1
		move.w	#$78,d2
		move.w	#$79,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject_NoRenderChk,JmpTo_SolidObject_NoRenderChk
		jsrto	DropOnFloor,JmpTo_DropOnFloor

loc_239A2:
		btst	#3,ost_primary_status(a0)
		beq.s	loc_239B8
		move.l	a0,-(sp)
		movea.l	a0,a1
		lea	($FFFFB000).w,a0
		jsrto	React_ChkHurt,JmpTo_React_ChkHurt
		movea.l	(sp)+,a0

loc_239B8:
		btst	#4,ost_primary_status(a0)
		beq.s	locret_239CE
		move.l	a0,-(sp)
		movea.l	a0,a1
		lea	($FFFFB040).w,a0
		jsrto	React_ChkHurt,JmpTo_React_ChkHurt
		movea.l	(sp)+,a0

locret_239CE:
		rts
; ===========================================================================

loc_239D0:
		move.w	#$EB,d1
		move.w	#$78,d2
		move.w	#$79,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject_NoRenderChk,JmpTo_SolidObject_NoRenderChk
		jsrto	DropOnFloor,JmpTo_DropOnFloor
		bra.s	loc_239A2
; ===========================================================================

loc_239EA:
		move.w	#$CB,d1
		move.w	#$2E,d2
		move.w	ost_x_pos(a0),d4
		lea	(byte_23A04).l,a2
		jsrto	SolidObject_Heightmap,JmpTo_SolidObject_Heightmap
		jmpto	DropOnFloor,JmpTo_DropOnFloor
; ===========================================================================
byte_23A04:
		dc.b $30,$30,$30,$30,$30,$30,$30,$30,$2F,$2F,$2E,$2E,$2D,$2D,$2C,$2C ; 0
		dc.b $2B,$2B,$2A,$2A,$29,$29,$28,$28,$27,$27,$26,$26,$25,$25,$24,$24 ; 16
		dc.b $23,$23,$22,$22,$21,$21,$20,$20,$1F,$1F,$1E,$1E,$1D,$1D,$1C,$1C ; 32
		dc.b $1B,$1B,$1A,$1A,$19,$19,$18,$18,$17,$17,$16,$16,$15,$15,$14,$14 ; 48
		dc.b $13,$13,$12,$12,$11,$11,$10,$10, $F, $F, $E, $E, $D, $D, $C, $C ; 64
		dc.b  $B, $B, $A, $A,  9,  9,  8,  8,  7,  7,  6,  6,  5,  5,  4,  4 ; 80
		dc.b   3,  3,  2,  2,  1,  1,  0,  0,$FF,$FF,$FE,$FE,$FD,$FD,$FC,$FC ; 96
		dc.b $FB,$FB,$FA,$FA,$F9,$F9,$F8,$F8,$F7,$F7,$F6,$F6,$F5,$F5,$F4,$F4 ; 112
		dc.b $F3,$F3,$F2,$F2,$F1,$F1,$F0,$F0,$EF,$EF,$EE,$EE,$ED,$ED,$EC,$EC ; 128
		dc.b $EB,$EB,$EA,$EA,$E9,$E9,$E8,$E8,$E7,$E7,$E6,$E6,$E5,$E5,$E4,$E4 ; 144
		dc.b $E3,$E3,$E2,$E2,$E1,$E1,$E0,$E0,$DF,$DF,$DE,$DE,$DD,$DD,$DC,$DC ; 160
		dc.b $DB,$DB,$DA,$DA,$D9,$D9,$D8,$D8,$D7,$D7,$D6,$D6,$D5,$D5,$D4,$D4 ; 176
		dc.b $D3,$D3,$D2,$D2,$D1,$D1,$D0,$D0,$D0,$D0,$D0,$D0 ; 192
; ===========================================================================

	if RemoveJmpTos
JmpTo2_DespawnObject3:
		jmp	(DespawnObject3).l
	else
JmpTo23_DeleteObject:
		jmp	(DeleteObject).l
JmpTo_React_ChkHurt:
		jmp	(React_ChkHurt).l
JmpTo2_DespawnObject3:
		jmp	(DespawnObject3).l
JmpTo_DropOnFloor:
		jmp	(DropOnFloor).l
JmpTo_SolidObject_NoRenderChk:
		jmp	(SolidObject_NoRenderChk).l
JmpTo_SolidObject_Heightmap:
		jmp	(SolidObject_Heightmap).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 33 - OOZ burner platform
; ----------------------------------------------------------------------------

BurnerPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_23B02(pc,d0.w),d1
		jmp	off_23B02(pc,d1.w)
; ===========================================================================
off_23B02:	index offset(*),,2
		ptr loc_23B08					; 0
		ptr loc_23B90					; 2
		ptr loc_23D9A					; 4
; ===========================================================================

loc_23B08:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_BurnPlat,ost_mappings(a0)
		move.w	#tile_Nem_BurnerLid+tile_pal4,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.w	ost_y_pos(a0),$30(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$78,$36(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_23B48
		move.b	#4,ost_secondary_routine(a0)

loc_23B48:
		jsrto	FindNextFreeObj,JmpTo7_FindNextFreeObj
		bne.s	loc_23B90
		_move.b	ost_id(a0),ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		subi.w	#$10,ost_y_pos(a1)
		move.l	#Map_Burner,ost_mappings(a1)
		move.w	#tile_Nem_Burner+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.l	a0,$3C(a1)

loc_23B90:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_23BBC(pc,d0.w),d1
		jsr	off_23BBC(pc,d1.w)
		move.w	(sp)+,d4
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#8,d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo4_SolidObject
		jmpto	DespawnObject,JmpTo10_DespawnObject
; ===========================================================================
off_23BBC:	index offset(*),,2
		ptr loc_23BC6					; 0
		ptr loc_23BEA					; 2
		ptr loc_23C26					; 4
		ptr loc_23D20					; 6
		ptr locret_23D98				; 8
; ===========================================================================

loc_23BC6:
		subq.w	#1,$36(a0)
		bpl.s	locret_23BE8
		move.w	#$78,$36(a0)
		move.l	#-$96800,$32(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#sfx_LidPop,d0
		jsr	(PlaySoundLocal).l

locret_23BE8:
		rts
; ===========================================================================

loc_23BEA:
		move.l	ost_y_pos(a0),d1
		add.l	$32(a0),d1
		move.l	d1,ost_y_pos(a0)
		addi.l	#$3800,$32(a0)
		swap	d1
		cmp.w	$30(a0),d1
		bcs.s	locret_23C24
		move.l	$32(a0),d0
		cmpi.l	#loc_10000,d0
		bcc.s	loc_23C16
		subq.b	#2,ost_secondary_routine(a0)

loc_23C16:
		lsr.l	#2,d0
		neg.l	d0
		move.l	d0,$32(a0)
		move.w	$30(a0),ost_y_pos(a0)

locret_23C24:
		rts
; ===========================================================================

loc_23C26:
		move.w	ost_x_pos(a0),d2
		move.w	d2,d3
		subi.w	#$10,d2
		addi.w	#$10,d3
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_23C9E
		cmpi.b	#$18,d0
		beq.s	loc_23CA0
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		bsr.s	loc_23C52
		lea	($FFFFB040).w,a1
		addq.b	#1,d6

loc_23C52:
		btst	d6,ost_primary_status(a0)
		beq.s	locret_23C9E
		move.w	ost_x_pos(a1),d0
		cmp.w	d2,d0
		bcs.s	locret_23C9E
		cmp.w	d3,d0
		bcc.s	locret_23C9E
		move.b	#1,$2A(a1)
		move.w	#0,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		bclr	#5,ost_primary_status(a1)
		bclr	#tile_hi_bit,ost_tile(a1)
		move.l	#-$96800,$32(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#sfx_LidPop,d0
		jsr	(PlaySoundLocal).l

locret_23C9E:
		rts
; ===========================================================================

loc_23CA0:
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a1),d0
		cmp.w	d2,d0
		bcs.s	locret_23D1E
		cmp.w	d3,d0
		bcc.s	locret_23D1E
		lea	($FFFFB040).w,a2
		move.w	ost_x_pos(a2),d0
		cmp.w	d2,d0
		bcs.s	locret_23D1E
		cmp.w	d3,d0
		bcc.s	locret_23D1E
		move.b	#1,$2A(a1)
		move.w	#0,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		bclr	#5,ost_primary_status(a1)
		bclr	#tile_hi_bit,ost_tile(a1)
		move.b	#1,$2A(a2)
		move.w	#0,ost_inertia(a2)
		move.w	#0,ost_x_vel(a2)
		move.w	#0,ost_y_vel(a2)
		bclr	#5,ost_primary_status(a2)
		bclr	#tile_hi_bit,ost_tile(a2)
		move.l	#-$96800,$32(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#sfx_LidPop,d0
		jsr	(PlaySoundLocal).l

locret_23D1E:
		rts
; ===========================================================================

loc_23D20:
		move.l	ost_y_pos(a0),d1
		add.l	$32(a0),d1
		move.l	d1,ost_y_pos(a0)
		addi.l	#$3800,$32(a0)
		swap	d1
		move.w	$30(a0),d0
		subi.w	#$7D,d0
		cmp.w	d0,d1
		bne.s	locret_23D96
		addq.b	#2,ost_secondary_routine(a0)
		lea	($FFFFB000).w,a1
		move.b	ost_primary_status(a0),d0
		andi.b	#8,d0
		bsr.s	loc_23D60
		lea	($FFFFB040).w,a1
		move.b	ost_primary_status(a0),d0
		andi.b	#$10,d0

loc_23D60:
		beq.s	locret_23D96
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$800,ost_inertia(a1)
		bset	#1,ost_primary_status(a1)
		move.w	#-$1000,ost_y_vel(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#0,$2A(a1)
		move.w	#sfx_Spring,d0
		jsr	(PlaySoundLocal).l

locret_23D96:
		rts
; ===========================================================================

locret_23D98:
		rts
; ===========================================================================

loc_23D9A:
		movea.l	$3C(a0),a1
		move.w	ost_y_pos(a0),d0
		sub.w	ost_y_pos(a1),d0
		cmpi.w	#$14,d0
		blt.s	loc_23DC2
		move.b	#id_col_8x4+id_col_hurt,ost_col_type(a0)
		lea	(Ani_BurnerFlame).l,a1
		jsr	(AnimateSprite).l
		jmpto	DespawnObject,JmpTo10_DespawnObject
; ===========================================================================

loc_23DC2:
		move.b	#0,ost_col_type(a0)
		move.b	#0,ost_anim_frame(a0)
		rts
; ===========================================================================

Ani_BurnerFlame:	index offset(*)
	ptr byte_23DD2

byte_23DD2:
		dc.b   2,  2,  0,  2,  0,  2,  0,  1,$FF
		even
; ===========================================================================

		include "mappings/sprite/OOZ Burner Platform.asm"
		include "mappings/sprite/OOZ Burner Flame.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo10_DespawnObject:
		jmp	(DespawnObject).l
JmpTo7_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo4_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 43 - OOZ sliding spike obstacle
; ----------------------------------------------------------------------------

RailSpikes:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_23E4E(pc,d0.w),d1
		jmp	off_23E4E(pc,d1.w)
; ===========================================================================
off_23E4E:	index offset(*),,2
		ptr loc_23E66					; 0
		ptr loc_23F0A					; 2
		ptr loc_23F5C					; 4

byte_23E54:
		dc.b   0					; 0
		dc.b $68					; 1
		dc.b   0					; 2
		dc.b   0					; 3
		dc.b   0					; 4
		dc.b   0					; 5
		dc.b   1					; 6
		dc.b $E8					; 7
		dc.b $FF					; 8
		dc.b $E8					; 9
		dc.b   0					; 10
		dc.b $18					; 11
		dc.b   1					; 12
		dc.b $A8					; 13
		dc.b $FF					; 14
		dc.b $A8					; 15
		dc.b $FF					; 16
		dc.b $D8					; 17
; ===========================================================================

loc_23E66:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#tile_Nem_SlidingSpikes+tile_pal3+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo19_AdjustVRAM2P
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		lea	byte_23E54(pc,d1.w),a2
		move.b	(a2)+,d1
		movea.l	a0,a1
		bra.s	loc_23EA8
; ===========================================================================

loc_23E84:
		jsrto	FindNextFreeObj,JmpTo8_FindNextFreeObj
		bne.s	loc_23ED4
		_move.b	ost_id(a0),ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#1,$36(a1)

loc_23EA8:
		move.l	#Map_RailSpikes,ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$18,ost_displaywidth(a1)
		move.b	#id_col_24x40+id_col_hurt,ost_col_type(a1)
		move.w	ost_x_pos(a1),$30(a1)

loc_23ED4:
		dbf	d1,loc_23E84
		move.l	a0,$3C(a1)
		move.l	a1,$3C(a0)
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	$30(a0),d0
		sub.w	d1,d0
		move.w	d0,$32(a0)
		move.w	d0,$32(a1)
		add.w	d1,d0
		add.w	d1,d0
		move.w	d0,$34(a0)
		move.w	d0,$34(a1)
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a0)
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a1)

loc_23F0A:
		bsr.s	loc_23F66
		move.w	$32(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bls.s	loc_23F30
		move.w	$34(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_23F36

loc_23F30:
		jmp	(DisplaySprite).l
; ===========================================================================

loc_23F36:
		movea.l	$3C(a0),a1
		cmpa.l	a0,a1
		beq.s	loc_23F44
		jsr	(DeleteChild).l

loc_23F44:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_23F56
		bclr	#7,2(a2,d0.w)

loc_23F56:
		jmp	(DeleteObject).l
; ===========================================================================

loc_23F5C:
		bsr.s	loc_23F66
		bsr.s	loc_23FB0
		jmp	(DisplaySprite).l
; ===========================================================================

loc_23F66:
		tst.b	$36(a0)
		bne.s	loc_23F8E
		move.w	ost_x_pos(a0),d1
		subq.w	#1,d1
		cmp.w	$32(a0),d1
		bne.s	loc_23F88
		move.b	#1,$36(a0)
		move.w	#sfx_SlidingSpike,d0
		jsr	(PlaySoundLocal).l

loc_23F88:
		move.w	d1,ost_x_pos(a0)
		rts
; ===========================================================================

loc_23F8E:
		move.w	ost_x_pos(a0),d1
		addq.w	#1,d1
		cmp.w	$34(a0),d1
		bne.s	loc_23FAA
		move.b	#0,$36(a0)
		move.w	#sfx_SlidingSpike,d0
		jsr	(PlaySoundLocal).l

loc_23FAA:
		move.w	d1,ost_x_pos(a0)
		rts
; ===========================================================================

loc_23FB0:
		movea.l	$3C(a0),a1
		move.w	ost_x_pos(a0),d0
		subi.w	#$18,d0
		move.w	ost_x_pos(a1),d2
		addi.w	#$18,d2
		cmp.w	d0,d2
		bne.s	locret_23FDE
		eori.b	#1,$36(a0)
		eori.b	#1,$36(a1)
		move.w	#sfx_SlidingSpike,d0
		jsr	(PlaySoundLocal).l

locret_23FDE:
		rts
; ===========================================================================

		include "mappings/sprite/OOZ Sliding Spikes.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo8_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo19_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 07 - OOZ Oil Ocean
; Actually runs an invisible platform locked to the player's x-position
; ----------------------------------------------------------------------------
Oil:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2402E(pc,d0.w),d1
		jmp	off_2402E(pc,d1.w)
; ===========================================================================
off_2402E:	index offset(*),,2
		ptr loc_24032					; 0
		ptr loc_24054					; 2
; ===========================================================================

loc_24032:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$758,ost_y_pos(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.w	ost_y_pos(a0),$30(a0)
		move.b	#$30,$38(a0)
		bset	#status_broken_bit,ost_primary_status(a0)

loc_24054:
		tst.w	(v_debug_active).w
		bne.w	locret_240E8
		lea	(v_ost_player1).w,a1
		moveq	#8,d1
		move.b	ost_primary_status(a0),d0
		and.b	d1,d0
		bne.s	loc_24078
		cmpi.b	#$30,$38(a0)
		beq.s	loc_24082
		addq.b	#1,$38(a0)
		bra.s	loc_24082
; ===========================================================================

loc_24078:
		tst.b	$38(a0)
		beq.s	loc_240D6
		subq.b	#1,$38(a0)

loc_24082:
		moveq	#$20,d1
		moveq	#0,d3
		move.b	$38(a0),d3
		moveq	#3,d6
		move.w	ost_x_pos(a1),d4
		move.w	d4,ost_x_pos(a0)
		jsrto	DetectPlatform_SingleCharacter,JmpTo_DetectPlatform_SingleCharacter
		lea	(v_ost_player2).w,a1
		moveq	#$10,d1
		move.b	ost_primary_status(a0),d0
		and.b	d1,d0
		bne.s	loc_240B4
		cmpi.b	#$30,$3A(a0)
		beq.s	loc_240BE
		addq.b	#1,$3A(a0)
		bra.s	loc_240BE
; ===========================================================================

loc_240B4:
		tst.b	$3A(a0)
		beq.s	loc_240D6
		subq.b	#1,$3A(a0)

loc_240BE:
		moveq	#$20,d1
		moveq	#0,d3
		move.b	$3A(a0),d3
		moveq	#4,d6
		move.w	ost_x_pos(a1),d4
		move.w	d4,ost_x_pos(a0)
		jsrto	DetectPlatform_SingleCharacter,JmpTo_DetectPlatform_SingleCharacter
		rts
; ===========================================================================

loc_240D6:
		not.b	d1
		and.b	d1,ost_primary_status(a0)
		pushr.l	a0
		movea.l	a0,a2
		movea.l	a1,a0
		jsrto	KillCharacter,JmpTo3_KillCharacter
		popr.l	a0

locret_240E8:
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo3_KillCharacter:
		jmp	(KillCharacter).l
JmpTo_DetectPlatform_SingleCharacter:
		jmp	(DetectPlatform_SingleCharacter).l

		align 4
	endc

; ----------------------------------------------------------------------------
; Object 45 - OOZ pressure spring
; ----------------------------------------------------------------------------

PressureSpring:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	PSpring_Index(pc,d0.w),d1
		jsr	PSpring_Index(pc,d1.w)
		jmpto	DespawnObject,JmpTo11_DespawnObject
; ===========================================================================
PSpring_Index:	index offset(*),,2
		ptr PSpring_Init				; 0
		ptr PSpring_Vertical				; 2
		ptr PSpring_Horizontal				; 4

		rsobj	PressureSpring,$30
ost_pspring_strength:	rs.w 1					; $30; strength of spring
ost_pspring_frame:		rs.b 1				; $32; frame counter used to track how compressed the spring is
						rs.b 1		; unused
ost_pspring_og_xpos: 	rs.w 1					; $34; backup of horizontal spring's initial x pos
ost_pspring_compress:	rs.b 1					; $36; flag indicating horizontal spring is compressing
		rsobjend
; ===========================================================================

PSpring_Init:	; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to PSpring_Vertical next
		move.l	#Map_PSpring,ost_mappings(a0)
		move.w	#tile_Nem_PushSpring+tile_pal3,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#32/2,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),d0			; high nybble of subtype = orientation, low nybble = strength
		lsr.w	#3,d0					; only need high nybble
    if FixBugs
		; This bugfix is a bit of a hack: ideally, the Oil Ocean Zone Act 2
		; object layout should be corrected to not contain instances of this
		; object with an invalid subtype, but this will have to do.
		andi.w	#pspring_direction>>3,d0
  	 else
		; Some instances of this object use an invalid subtype of $30,
		; which results in d0 being 6 here. Due to sheer luck,
		; this ends up branching to 'PSpring_InitHorizontal' instead of crashing the game.
		andi.w	#(pspring_direction|$60)>>3,d0		; $E
    endc
		move.w	PSpring_Init_Index(pc,d0.w),d0
		jmp	PSpring_Init_Index(pc,d0.w)
; ===========================================================================
PSpring_Init_Index:	index offset(*)
		ptr PSpring_InitVertical			; 0
		ptr PSpring_InitHorizontal			; 2
; ===========================================================================

PSpring_InitHorizontal:
		move.b	#id_PSpring_Horizontal,ost_primary_routine(a0)
		move.b	#1,ost_anim(a0)				; unused
		move.b	#id_Frame_PSpring_Horiz1,ost_frame(a0)
		move.w	#tile_Nem_PushSpring+tile_pal3,ost_tile(a0) ; unnecessary
		move.b	#40/2,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),ost_pspring_og_xpos(a0)

PSpring_InitVertical:
		move.b	ost_subtype(a0),d0
		andi.w	#2,d0					; only need low nybble
		move.w	PSpring_Strengths(pc,d0.w),ost_pspring_strength(a0) ; get spring strength
		jsrto	AdjustVRAM2P,JmpTo20_AdjustVRAM2P
		rts
; ===========================================================================

PSpring_Strengths:
		dc.w $F000					; 0
		dc.w $F600					; 2
; ===========================================================================

PSpring_Vertical:						; Routine 2; unused
		move.b	ost_primary_status(a0),d0
		andi.b	#status_platform_both,d0		; is a player standing on the spring?
		bne.s	.compress				; if so, branch
		tst.b	ost_pspring_frame(a0)			; is spring at rest (id_Frame_PSpring_Vert1)?
		beq.s	.solid					; if so, branch
		subq.b	#1,ost_pspring_frame(a0)		; decrement frame, decompressing the spring
		bra.s	.solid
; ===========================================================================

	.compress:
		cmpi.b	#id_Frame_PSpring_Vert10,ost_pspring_frame(a0) ; is spring fully compressed?
		beq.s	PSpring_Vertical_LaunchPlayer		; if so, branch
		addq.b	#1,ost_pspring_frame(a0)		; increment frame, compressing the spring

	.solid:
		moveq	#0,d3
		move.b	ost_pspring_frame(a0),d3		; current frame of spring
		move.b	d3,ost_frame(a0)			; set frame for display
		add.w	d3,d3					; d3 = frame ID * 2 (each successive frame lowers player by 2px)
		move.w	#54/2,d1				; d1 = half width
		move.w	#40/2,d2				; d2 = half height
		move.w	ost_x_pos(a0),d4			; d4 = x pos
		jsrto	SolidObject_OOZSpring,JmpTo_SolidObject_OOZSpring
		rts
; ===========================================================================

PSpring_Vertical_LaunchPlayer:
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		bsr.s	.launchplayerdo				; run for player 1
		lea	(v_ost_player2).w,a1
		moveq	#status_p2_platform_bit,d6		; run for player 2

.launchplayerdo:
		bclr	d6,ost_primary_status(a0)		; is player standing on spring?
		beq.w	.nolaunch				; branch if not
		move.w	ost_pspring_strength(a0),ost_y_vel(a1)	; launch player vertically
		bset	#status_air_bit,ost_primary_status(a1)
		bclr	#status_platform_bit,ost_primary_status(a1)
		move.b	#id_Ani_Spring,ost_anim(a1)		; use spring animation
		move.b	#id_Control,ost_primary_routine(a1)
		move.b	ost_subtype(a0),d0			; does this spring stop player's transverse movement?
		bpl.s	.retain_transverse			; branch if not
		move.w	#0,ost_x_vel(a1)			; stop player's horizontal movement

	.retain_transverse:
		btst	#pspring_tumbleplayer_bit,d0
		beq.s	.no_tumble				; branch if this spring isn't set to tumble the player
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#id_Ani_Walk,ost_anim(a1)
		move.b	#1-1,ost_flips_remaining(a1)		; make player flip once
		move.b	#4,ost_flip_speed(a1)
		btst	#pspring_strength_bit,d0
		bne.s	.weak					; branch if this is a weak spring
		move.b	#2-1,ost_flips_remaining(a1)		; make player flip twice

	.weak:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	.no_tumble				; branch if spring isn't x-flipped
		neg.b	ost_flip_angle(a1)			; invert flip angle and inertia
		neg.w	ost_inertia(a1)

	.no_tumble:
		andi.b	#pspring_plane0|pspring_plane1,d0	; only need plane switch bits
		cmpi.b	#pspring_plane0,d0			; are we moving player to plane 0?
		bne.s	.not_plane0				; branch if not
		move.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; move player to plane 0
		move.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.not_plane0:
		cmpi.b	#pspring_plane1,d0			; are we moving player to plane 1?
		bne.s	.playsound				; branch if not
		move.b	#chunkmap_secondary_solid_top_bit,ost_top_solid_bit(a1) ; move player to plane 1
		move.b	#chunkmap_secondary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.playsound:
		move.w	#sfx_Spring,d0				; play spring SFX
		jmp	(PlaySound).l
; ===========================================================================

.nolaunch:
		rts
; ===========================================================================

PSpring_Horizontal:						; Routine 4
		move.b	#0,ost_pspring_compress(a0)
		move.w	#$3E/2,d1				; half width
		move.w	#$18/2,d2				; half height
		move.w	#$1A/2,d3				; half height standing
		move.w	ost_x_pos(a0),d4			; object x pos
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up input registers so we can run this routine again for player 2
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo_SolidObject_NoRenderChk_SingleCharacter ; run solidity checks for player 1
		cmpi.w	#1,d4					; did player 1 touch the side of the spring?
		bne.s	.player2				; branch if not
		move.b	ost_primary_status(a0),d1
		move.w	ost_x_pos(a0),d2
		sub.w	ost_x_pos(a1),d2
		bcs.s	.player1_right				; branch if player 1 is right of spring
		eori.b	#status_xflip,d1			; invert x flip flag

	.player1_right:
		andi.b	#status_xflip,d1			; is x flip bit still set?
		bne.s	.player2				; if so, branch
		bsr.w	PSpring_HorizCompress			; compress spring

	.player2:
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#status_p2_platform_bit,d6
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo_SolidObject_NoRenderChk_SingleCharacter ; run solidity checks for player 2
		cmpi.w	#1,d4					; did player 2 touch the side of the spring?
		bne.s	.chk_decompress				; branch if not
		move.b	ost_primary_status(a0),d1
		move.w	ost_x_pos(a0),d2
		sub.w	ost_x_pos(a1),d2
		bcs.s	.player2_right				; branch if player 2 is right of spring
		eori.b	#status_xflip,d1			; invert x flip flag

	.player2_right:
		andi.b	#status_xflip,d1			; is x flip bit still set?
		bne.s	.chk_decompress				; if so branch
		bsr.s	PSpring_HorizCompress

	.chk_decompress:
		tst.b	ost_pspring_compress(a0)		; is spring compressing?
		bne.s	.exit					; if so, exit
		move.w	ost_pspring_og_xpos(a0),d0
		cmp.w	ost_x_pos(a0),d0
		beq.s	.exit					; branch if spring is idle
		bcc.s	.right					; branch if spring faces right (decompress to right)
		subq.b	#4,ost_frame(a0)			; decrement frame by 4, decompressing the spring
		subq.w	#4,ost_x_pos(a0)			; move spring left 4 px
		cmp.w	ost_x_pos(a0),d0			; has spring fully decompressed?
		bcs.s	.launchplayer				; branch if not
		move.b	#id_Frame_PSpring_Horiz1,ost_frame(a0)	; set idle frame
		move.w	ost_pspring_og_xpos(a0),ost_x_pos(a0)	; force original x pos
		bra.s	.launchplayer
; ===========================================================================

	.right:
		subq.b	#4,ost_frame(a0)			; decrement frame by 4, decompressing the spring
		addq.w	#4,ost_x_pos(a0)			; move spring right 4 px
		cmp.w	ost_x_pos(a0),d0			; has spring fully decompressed?
		bcc.s	.launchplayer				; branch if not
		move.b	#id_Frame_PSpring_Horiz1,ost_frame(a0)	; set idle frame
		move.w	ost_pspring_og_xpos(a0),ost_x_pos(a0)	; force original x pos

	.launchplayer:
		bsr.w	PSpring_Horiz_LaunchPlayer

	.exit:
		rts
; ===========================================================================

PSpring_HorizCompress:
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	.spring_right				; branch if spring faces right
		btst	#status_xflip_bit,ost_primary_status(a1)
		bne.w	.exit					; branch if player is not facing spring

;spring_left:
		tst.w	d0					; d0 = 0 if earlier SolidObject call branched to Solid_AlignToSide from Solid_LeftRight (occurs if player is on edge of object)
		bne.w	.on_edge				; branch if player is on edge
		tst.w	ost_inertia(a1)
		beq.s	.exit					; branch if player is not moving
		bpl.s	.max_compression			; branch if player is moving right
		bra.s	.exit					; exit if moving left
; ===========================================================================

	.on_edge:
		move.w	ost_pspring_og_xpos(a0),d0
		addi.w	#18,d0
		cmp.w	ost_x_pos(a0),d0			; has spring moved 18px right?
		beq.s	.max_compression			; if so, branch
		addq.w	#1,ost_x_pos(a0)			; move 1px right
		moveq	#1,d0					; same with player
		move.w	#$40,d1					; new player inertia
		bra.s	.set_player_pos
; ===========================================================================

.spring_right:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	.exit					; branch if player is not facing spring
		tst.w	d0					; d0 = 0 if earlier SolidObject call branched to Solid_AlignToSide from Solid_LeftRight (occurs if player is on edge of object)
		bne.w	.on_edge2				; branch if player is on edge
		tst.w	ost_inertia(a1)
		bmi.s	.max_compression			; branch if player is moving left
		bra.s	.exit					; exit if player is not moving or moving right
; ===========================================================================

	.on_edge2:
		move.w	ost_pspring_og_xpos(a0),d0
		subi.w	#18,d0
		cmp.w	ost_x_pos(a0),d0			; has spring moved 18px left?
		beq.s	.max_compression			; if so, branch
		subq.w	#1,ost_x_pos(a0)			; move 1 px left
		moveq	#-1,d0					; same with player
		move.w	#-$40,d1				; new player inertia

	.set_player_pos:
		add.w	d0,ost_x_pos(a1)
		move.w	d1,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)			; stop player's x movement
		move.w	ost_pspring_og_xpos(a0),d0
		sub.w	ost_x_pos(a0),d0			; diference of og and current x pos + $A is current sprite frame
		bcc.s	.setframe				; branch if spring faces right (i.e., compressing to the left)
		neg.w	d0

	.setframe:
		addi.w	#id_Frame_PSpring_Horiz1,d0
		move.b	d0,ost_frame(a0)			; set sprite frame

	.max_compression:
		move.b	#1,ost_pspring_compress(a0)		; mark spring as compressing

	.exit:
		rts
; ===========================================================================

PSpring_Horiz_LaunchPlayer:
		move.b	ost_primary_status(a0),d0
		andi.b	#status_pushing_both,d0			; is at least one player touching spring?
		beq.w	.nolaunch				; exit if not
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_pushing_bit,d6
		bsr.s	.launchplayerdo				; run for player 1
		lea	(v_ost_player2).w,a1
		moveq	#status_p2_pushing_bit,d6		; run for player 2

.launchplayerdo:
		bclr	d6,ost_primary_status(a0)		; clear spring's pushing bit for this player
		beq.w	.nolaunch				; branch if this player was not touching spring
		move.w	ost_pspring_og_xpos(a0),d0
		sub.w	ost_x_pos(a0),d0
		bcc.s	.springright				; branch if spring faces right
		neg.w	d0

	.springright:
		addi.w	#$A,d0					; add 12
		lsl.w	#7,d0					; multiply by 128
		neg.w	d0					; negate
		move.w	d0,ost_x_vel(a1)			; d0 = new x vel of player
		subq.w	#4,ost_x_pos(a1)			; move player 4px left
		bset	#status_xflip_bit,ost_primary_status(a1) ; player faces left
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	.springleft				; branch if spring faces left
		bclr	#status_xflip_bit,ost_primary_status(a1) ; player faces right
		addi_.w	#8,ost_x_pos(a1)			; move player 8px right
		neg.w	ost_x_vel(a1)

	.springleft:
		move.w	#$F,ost_lock_time(a1)			; lock player's controls for 15 frames
		move.w	ost_x_vel(a1),ost_inertia(a1)
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	.jump					; branch if player jumped into the spring
		move.b	#id_Ani_Walk,ost_anim(a1)		; use walking animation

	.jump:
		move.b	ost_subtype(a0),d0			; does this spring stop player's transverse movement?
		bpl.s	.retain_transverse			; branch if not
		move.w	#0,ost_y_vel(a1)			; stop player's horizontal movement

	.retain_transverse:
		btst	#pspring_tumbleplayer_bit,d0
		beq.s	.no_tumble				; branch if this spring isn't set to tumble the player
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#id_Ani_Walk,ost_anim(a1)
		move.b	#2-1,ost_flips_remaining(a1)		; make player flip twice
		move.b	#8,ost_flip_speed(a1)
		btst	#pspring_strength_bit,d0
		bne.s	.weak
		move.b	#4-1,ost_flips_remaining(a1)		; make player flip 4 times

	.weak:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	.no_tumble				; branch if spring isn't x-flipped
		neg.b	ost_flip_angle(a1)			; invert flip angle and inertia
		neg.w	ost_inertia(a1)

	.no_tumble:
		andi.b	#pspring_plane0|pspring_plane1,d0	; only need plane switch bits
		cmpi.b	#pspring_plane0,d0			; are we moving player to plane 0?
		bne.s	.not_plane0				; branch if not
		move.b	#chunkmap_primary_solid_top_bit,ost_top_solid_bit(a1) ; move player to plane 0
		move.b	#chunkmap_primary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.not_plane0:
		cmpi.b	#pspring_plane1,d0			; are we moving player to plane 1?
		bne.s	.playsound				; branch if not
		move.b	#chunkmap_secondary_solid_top_bit,ost_top_solid_bit(a1) ; move player to plane 1
		move.b	#chunkmap_secondary_solid_lrb_bit,ost_lrb_solid_bit(a1)

	.playsound:
		bclr	#status_pushing_bit,ost_primary_status(a1) ; clear player's pushing flag
		move.b	#id_Ani_Run,ost_anim_restart(a1)	; force player's animation to restart

		move.w	#sfx_Spring,d0
		jmp	(PlaySound).l				; play spring SFX
; ===========================================================================

.nolaunch:
		rts

; -------------------------------------------------------------------------------
; Unused animation script
; -------------------------------------------------------------------------------

Ani_PSpring:	index offset(*)
		ptr Ani_PSpring_Vert				; 0
		ptr Ani_PSpring_Horiz				; 1

Ani_PSpring_Vert:
		dc.b 0
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert2
		dc.b id_Frame_PSpring_Vert3
		dc.b id_Frame_PSpring_Vert4
		dc.b id_Frame_PSpring_Vert5
		dc.b id_Frame_PSpring_Vert6
		dc.b id_Frame_PSpring_Vert7
		dc.b id_Frame_PSpring_Vert8
		dc.b id_Frame_PSpring_Vert9
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert10
		dc.b id_Frame_PSpring_Vert9
		dc.b id_Frame_PSpring_Vert8
		dc.b id_Frame_PSpring_Vert7
		dc.b id_Frame_PSpring_Vert6
		dc.b id_Frame_PSpring_Vert5
		dc.b id_Frame_PSpring_Vert4
		dc.b id_Frame_PSpring_Vert3
		dc.b id_Frame_PSpring_Vert2
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert1
		dc.b id_Frame_PSpring_Vert1
		dc.b afEnd

Ani_PSpring_Horiz:
		dc.b 0
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz2
		dc.b id_Frame_PSpring_Horiz3
		dc.b id_Frame_PSpring_Horiz4
		dc.b id_Frame_PSpring_Horiz5
		dc.b id_Frame_PSpring_Horiz6
		dc.b id_Frame_PSpring_Horiz7
		dc.b id_Frame_PSpring_Horiz8
		dc.b id_Frame_PSpring_Horiz9
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz10
		dc.b id_Frame_PSpring_Horiz9
		dc.b id_Frame_PSpring_Horiz8
		dc.b id_Frame_PSpring_Horiz7
		dc.b id_Frame_PSpring_Horiz6
		dc.b id_Frame_PSpring_Horiz5
		dc.b id_Frame_PSpring_Horiz4
		dc.b id_Frame_PSpring_Horiz3
		dc.b id_Frame_PSpring_Horiz2
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz1
		dc.b id_Frame_PSpring_Horiz1
		dc.b afEnd

; ===========================================================================

		include "mappings/sprite/OOZ Pressure Spring.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 46 - OOZ ball on spring (unused beta leftover)
; ----------------------------------------------------------------------------

GiantBall:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_24A24(pc,d0.w),d1
		jmp	off_24A24(pc,d1.w)
; ===========================================================================
off_24A24:	index offset(*),,2
		ptr loc_24A2C					; 0
		ptr loc_24AEA					; 2
		ptr loc_24B38					; 4
		ptr loc_24BDC					; 6
; ===========================================================================

loc_24A2C:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_24A48
		bclr	#7,2(a2,d0.w)
		bset	#0,2(a2,d0.w)
		bne.w	JmpTo25_DeleteObject

loc_24A48:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$F,ost_height(a0)
		move.b	#$F,ost_width(a0)
		move.l	#Map_OOZBetaBall,ost_mappings(a0)
		move.w	#tile_Nem_SpringBall+tile_pal4,ost_tile(a0)
		bsr.w	JmpTo20_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$36(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#0,ost_frame(a0)
		move.w	#0,$14(a0)
		move.b	#1,$1F(a0)

		jsrto	FindFreeObj,JmpTo4_FindFreeObj
		bne.s	loc_24AE6
		_move.b	#id_GiantBall,ost_id(a1)
		addq.b	#6,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$12,ost_y_pos(a1)
		move.l	#Map_PSpring,ost_mappings(a1)
		move.w	#tile_Nem_PushSpring+tile_pal3,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.b	#9,ost_frame(a1)
		move.l	a0,$3C(a1)

loc_24AE6:
		move.l	a1,$3C(a0)

loc_24AEA:
		btst	#6,(v_joypad2_press_actual).w
		bne.s	loc_24B04
		lea	(v_button_state).w,a2
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#4,d0
		tst.b	(a2,d0.w)
		beq.s	loc_24B30

loc_24B04:
		addq.b	#2,ost_primary_routine(a0)
		bset	#1,ost_primary_status(a0)
		move.w	#-$300,ost_y_vel(a0)
		move.w	#$100,$14(a0)
		movea.l	$3C(a0),a1
		move.b	#1,$30(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_24B30
		neg.w	$14(a0)

loc_24B30:
		bsr.w	loc_24BF0
		jmpto	DespawnObject,JmpTo11_DespawnObject
; ===========================================================================

loc_24B38:
		move.w	ost_x_pos(a0),-(sp)
		jsrto	SpeedToPos,JmpTo9_SpeedToPos
		btst	#1,ost_primary_status(a0)
		beq.s	loc_24B8C
		addi.w	#$18,ost_y_vel(a0)
		bmi.s	loc_24B8A
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		bcs.s	loc_24BC4
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.w	loc_24B8A
		add.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		bclr	#1,ost_primary_status(a0)
		move.w	#$100,ost_x_vel(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_24B8A
		neg.w	ost_x_vel(a0)

loc_24B8A:
		bra.s	loc_24BA4
; ===========================================================================

loc_24B8C:
		jsr	(FindFloorObj).l
		cmpi.w	#8,d1
		blt.s	loc_24BA0
		bset	#1,ost_primary_status(a0)
		bra.s	loc_24BA4
; ===========================================================================

loc_24BA0:
		add.w	d1,ost_y_pos(a0)

loc_24BA4:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo5_SolidObject
		bsr.w	loc_24BF0
		jmpto	DespawnObject,JmpTo11_DespawnObject
; ===========================================================================

loc_24BC4:
		move.w	(sp)+,d4
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	BranchTo_JmpTo25_DeleteObject
		bclr	#7,2(a2,d0.w)

    if RemoveJmpTos
JmpTo25_DeleteObject:
    endc

BranchTo_JmpTo25_DeleteObject:
		bra.w	JmpTo25_DeleteObject
; ===========================================================================

loc_24BDC:
		tst.b	$30(a0)
		beq.s	loc_24BEC
		subq.b	#1,ost_frame(a0)
		bne.s	loc_24BEC
		clr.b	$30(a0)

loc_24BEC:
		jmpto	DespawnObject,JmpTo11_DespawnObject
; ===========================================================================

loc_24BF0:
		tst.b	ost_frame(a0)
		beq.s	loc_24BFE
		move.b	#0,ost_frame(a0)
		rts
; ===========================================================================

loc_24BFE:
		move.b	$14(a0),d0
		beq.s	loc_24C2A
		bmi.s	loc_24C32
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_24C2A
		neg.b	d0
		addq.b	#8,d0
		bcs.s	loc_24C14
		moveq	#0,d0

loc_24C14:
		move.b	d0,ost_anim_time(a0)
		move.b	$1F(a0),d0
		addq.b	#1,d0
		cmpi.b	#4,d0
		bne.s	loc_24C26
		moveq	#1,d0

loc_24C26:
		move.b	d0,$1F(a0)

loc_24C2A:
		move.b	$1F(a0),ost_frame(a0)
		rts
; ===========================================================================

loc_24C32:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_24C2A
		addq.b	#8,d0
		bcs.s	loc_24C3E
		moveq	#0,d0

loc_24C3E:
		move.b	d0,ost_anim_time(a0)
		move.b	$1F(a0),d0
		subq.b	#1,d0
		bne.s	loc_24C4C
		moveq	#3,d0

loc_24C4C:
		move.b	d0,$1F(a0)
		bra.s	loc_24C2A
; ===========================================================================

		include "mappings/sprite/OOZ Beta Ball (unused).asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo25_DeleteObject:
		jmp	(DeleteObject).l
JmpTo4_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo11_DespawnObject:
		jmp	(DespawnObject).l
JmpTo20_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo5_SolidObject:
		jmp	(SolidObject).l
JmpTo_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l
JmpTo_SolidObject_OOZSpring:
		jmp	(SolidObject_OOZSpring).l
JmpTo9_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 47 - Button
; ----------------------------------------------------------------------------

Button:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_24D02(pc,d0.w),d1
		jmp	off_24D02(pc,d1.w)
; ===========================================================================
off_24D02:	index offset(*),,2
		ptr loc_24D06					; 0
		ptr loc_24D32					; 2
; ===========================================================================

loc_24D06:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_But,ost_mappings(a0)
		move.w	#tile_Nem_Button,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo21_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		addq.w	#4,ost_y_pos(a0)

loc_24D32:
		tst.b	ost_render(a0)
		bpl.s	BranchTo_JmpTo12_DespawnObject
		move.w	#$1B,d1
		move.w	#4,d2
		move.w	#5,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo6_SolidObject
		move.b	#0,ost_frame(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lea	(v_button_state).w,a3
		lea	(a3,d0.w),a3
		moveq	#0,d3
		btst	#6,ost_subtype(a0)
		beq.s	loc_24D6E
		moveq	#7,d3

loc_24D6E:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_24D7C
		bclr	d3,(a3)
		bra.s	BranchTo_JmpTo12_DespawnObject
; ===========================================================================

loc_24D7C:
		tst.b	(a3)
		bne.s	loc_24D8A
		move.w	#$CD,d0
		jsr	(PlaySound).l

loc_24D8A:
		bset	d3,(a3)
		move.b	#1,ost_frame(a0)

BranchTo_JmpTo12_DespawnObject:
		jmpto	DespawnObject,JmpTo12_DespawnObject
; ===========================================================================

		include "mappings/sprite/Button.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo12_DespawnObject:
		jmp	(DespawnObject).l
JmpTo21_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo6_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 3D - OOZ launcher block
; ----------------------------------------------------------------------------

LauncherBlock:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_24DDE(pc,d0.w),d1
		jmp	off_24DDE(pc,d1.w)
; ===========================================================================
off_24DDE:	index offset(*),,2
		ptr loc_24DE6					; 0
		ptr loc_24E26					; 2
		ptr loc_24F3C					; 4
		ptr loc_24F52					; 6
; ===========================================================================

loc_24DE6:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_LaunchBlock,ost_mappings(a0)
		move.w	#tile_Nem_StripedBlocksVert+tile_pal4,ost_tile(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_24E0A
		move.w	#tile_Nem_StripedBlocksHoriz+tile_pal4,ost_tile(a0)
		move.b	#2,ost_frame(a0)

loc_24E0A:
		jsrto	AdjustVRAM2P,JmpTo22_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		bset	#status_broken_bit,ost_primary_status(a0)
		move.b	#4,ost_priority(a0)

loc_24E26:
		move.b	($FFFFB01C).w,$32(a0)
		move.b	($FFFFB05C).w,$33(a0)
		move.w	($FFFFB012).w,$34(a0)
		move.w	($FFFFB052).w,$36(a0)
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo7_SolidObject
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_24E60

loc_24E5C:
		bra.w	JmpTo13_DespawnObject
; ===========================================================================

loc_24E60:
		cmpi.b	#$18,d0
		bne.s	loc_24E96
		cmpi.b	#2,$32(a0)
		beq.s	loc_24E76
		cmpi.b	#2,$33(a0)
		bne.s	loc_24E5C

loc_24E76:
		lea	($FFFFB000).w,a1
		move.b	$32(a0),d0
		move.w	$34(a0),d1
		bsr.s	loc_24EB2
		lea	($FFFFB040).w,a1
		move.b	$33(a0),d0
		move.w	$36(a0),d1
		bsr.s	loc_24EB2
		bra.w	loc_24F04
; ===========================================================================

loc_24E96:
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_24EE8
		cmpi.b	#2,$32(a0)
		bne.s	loc_24E5C
		lea	($FFFFB000).w,a1
		move.w	$34(a0),d1
		bsr.s	loc_24EB8
		bra.s	loc_24F04
; ===========================================================================

loc_24EB2:
		cmpi.b	#2,d0
		bne.s	loc_24ED4

loc_24EB8:
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		move.w	d1,ost_y_vel(a1)

loc_24ED4:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		rts
; ===========================================================================

loc_24EE8:
		andi.b	#$10,d0
		beq.w	loc_24E5C
		cmpi.b	#2,$33(a0)
		bne.w	loc_24E5C
		lea	(v_ost_player2).w,a1
		move.w	$36(a0),d1
		bsr.s	loc_24EB8

loc_24F04:
		andi.b	#-$19,ost_primary_status(a0)
		jsrto	FindNextFreeObj,JmpTo9_FindNextFreeObj
		bne.s	loc_24F28
		moveq	#0,d0
		move.w	#$A,d1

loc_24F16:
		move.l	(a0,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_24F16
		move.b	#6,ost_primary_routine(a1)

loc_24F28:
		lea	(word_2507A).l,a4
		addq.b	#1,ost_frame(a0)
		moveq	#$F,d1
		move.w	#$18,d2
		jsrto	SmashObject,JmpTo2_SmashObject

loc_24F3C:
		jsrto	SpeedToPos,JmpTo10_SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		tst.b	ost_render(a0)
		bpl.w	JmpTo26_DeleteObject
		jmpto	DisplaySprite,JmpTo14_DisplaySprite
; ===========================================================================

loc_24F52:
		lea	(v_ost_player1).w,a1
		lea	$2C(a0),a4
		bsr.s	loc_24F74
		lea	(v_ost_player2).w,a1
		lea	$36(a0),a4
		bsr.s	loc_24F74
		move.b	$2C(a0),d0
		add.b	$36(a0),d0
		beq.w	JmpTo3_DespawnObject3
		rts
; ===========================================================================

loc_24F74:
		moveq	#0,d0
		move.b	(a4),d0
		move.w	off_24F80(pc,d0.w),d0
		jmp	off_24F80(pc,d0.w)
; ===========================================================================
off_24F80:	index offset(*),,2
		ptr loc_24F84					; 0
		ptr loc_25036					; 2
; ===========================================================================

loc_24F84:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$10,d0
		cmpi.w	#$20,d0
		bcc.w	locret_25034
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		tst.b	ost_subtype(a0)
		beq.s	loc_24FAA
		addi.w	#$10,d1

loc_24FAA:
		cmpi.w	#$10,d1
		bcc.w	locret_25034
		cmpa.w	#-$4FC0,a1
		bne.s	loc_24FC2
		cmpi.w	#4,(v_tails_cpu_routine).w
		beq.w	locret_25034

loc_24FC2:
		addq.b	#2,(a4)
		move.b	#-$7F,$2A(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$800,ost_inertia(a1)
		tst.b	ost_subtype(a0)
		beq.s	loc_24FF0
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#-$800,ost_y_vel(a1)
		bra.s	loc_25002
; ===========================================================================

loc_24FF0:
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#$800,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)

loc_25002:
		bclr	#5,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)
		bset	#3,ost_primary_status(a1)
		move.w	a0,d0
		subi.w	#-$5000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.w	#$BE,d0
		jsr	(PlaySound).l

locret_25034:
		rts
; ===========================================================================

loc_25036:
		tst.b	ost_render(a1)
		bmi.s	loc_25054
		move.b	#0,$2A(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#0,(a4)
		rts
; ===========================================================================

loc_25054:
		move.l	ost_x_pos(a1),d2
		move.l	ost_y_pos(a1),d3
		move.w	ost_x_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,ost_x_pos(a1)
		move.l	d3,ost_y_pos(a1)
		rts
; ===========================================================================
; spritePiece x and y vels
word_2507A:
		dc.w -$400,-$400				; 0
		dc.w -$200,-$400				; 2
		dc.w  $200,-$400				; 4
		dc.w  $400,-$400				; 6
		dc.w -$3C0,-$200				; 8
		dc.w -$1C0,-$200				; 10
		dc.w  $1C0,-$200				; 12
		dc.w  $3C0,-$200				; 14
		dc.w -$380, $200				; 16
		dc.w -$180, $200				; 18
		dc.w  $180, $200				; 20
		dc.w  $380, $200				; 22
		dc.w -$340, $400				; 24
		dc.w -$140, $400				; 26
		dc.w  $140, $400				; 28
		dc.w  $340, $400				; 30
; ===========================================================================

		include "mappings/sprite/OOZ Launcher Block.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos
JmpTo3_DespawnObject3:
		jmp	(DespawnObject3).l
JmpTo26_DeleteObject:
		jmp	(DeleteObject).l

	else

JmpTo14_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo26_DeleteObject:
		jmp	(DeleteObject).l
JmpTo13_DespawnObject:
		jmp	(DespawnObject).l
JmpTo9_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo3_DespawnObject3:
		jmp	(DespawnObject3).l
JmpTo22_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo2_SmashObject:
		jmp	(SmashObject).l
JmpTo7_SolidObject:
		jmp	(SolidObject).l
JmpTo10_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 48 - OOZ transporter balls
; ----------------------------------------------------------------------------

LauncherBall:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_25262(pc,d0.w),d1
		jsr	off_25262(pc,d1.w)
		move.b	$2C(a0),d0
		add.b	$36(a0),d0
		beq.w	JmpTo14_DespawnObject
		jmpto	DisplaySprite,JmpTo15_DisplaySprite

    if RemoveJmpTos
JmpTo14_DespawnObject:
		jmp	(DespawnObject).l
    endc

; ===========================================================================
off_25262:	index offset(*),,2
		ptr loc_25276					; 0
		ptr loc_252C6					; 2

byte_25266:	; ost_render, ost_3F
		dc.b   render_rel,  							0 ; 0
		dc.b   render_rel|render_yflip,					7 ; 2
		dc.b   render_rel|render_xflip|render_yflip,	0 ; 4
		dc.b   render_rel|render_xflip,					7 ; 6
		dc.b   render_rel|render_xflip,					0 ; 8
		dc.b   render_rel,								7 ; 10
		dc.b   render_rel|render_yflip,					0 ; 12
		dc.b   render_rel|render_xflip|render_yflip,	7 ; 14
; ===========================================================================

loc_25276:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_TransBall,ost_mappings(a0)
		move.w	#tile_Nem_LaunchBall+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo23_AdjustVRAM2P
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2529E
		addq.w	#4,d0

loc_2529E:
		add.w	d0,d0
		move.b	byte_25266(pc,d0.w),ost_render(a0)
		move.b	byte_25266+1(pc,d0.w),$3F(a0)
		beq.s	loc_252B4
		move.b	#1,$3E(a0)

loc_252B4:
		move.b	$3F(a0),ost_frame(a0)
		move.b	#$28,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)

loc_252C6:
		lea	($FFFFB000).w,a1
		lea	$2C(a0),a4
		moveq	#$2C,d2
		bsr.s	loc_252DC
		lea	($FFFFB040).w,a1
		lea	$36(a0),a4
		moveq	#$36,d2

loc_252DC:
		moveq	#0,d0
		move.b	(a4),d0
		move.w	off_252E8(pc,d0.w),d0
		jmp	off_252E8(pc,d0.w)
; ===========================================================================
off_252E8:	index offset(*),,2
		ptr loc_252F0					; 0
		ptr loc_253C6					; 2
		ptr loc_25474					; 4
		ptr loc_254F2					; 6
; ===========================================================================

loc_252F0:
		tst.w	(v_debug_active).w
		bne.w	locret_253C4
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$10,d0
		cmpi.w	#$20,d0
		bcc.w	locret_253C4
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		addi.w	#$10,d1
		cmpi.w	#$20,d1
		bcc.w	locret_253C4
		cmpa.w	#-$4FC0,a1
		bne.s	loc_25330
		cmpi.w	#4,(v_tails_cpu_routine).w
		beq.w	locret_253C4

loc_25330:
		cmpi.b	#6,ost_primary_routine(a1)
		bcc.w	locret_253C4
		tst.w	(v_debug_active).w
		bne.w	locret_253C4
		btst	#3,ost_primary_status(a1)
		beq.s	loc_25360
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a3
		move.b	#0,(a3,d2.w)

loc_25360:
		move.w	a0,d0
		subi.w	#-$5000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		addq.b	#2,(a4)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#-$7F,$2A(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$1000,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		bclr	#5,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)
		bset	#3,ost_primary_status(a1)
		move.b	$3F(a0),ost_frame(a0)
		move.w	#$BE,d0
		jsr	(PlaySound).l

locret_253C4:
		rts
; ===========================================================================

loc_253C6:
		tst.b	$3E(a0)
		bne.s	loc_253EE
		cmpi.b	#7,ost_frame(a0)
		beq.s	loc_25408
		subq.w	#1,ost_anim_time(a0)
		bpl.s	locret_253EC
		move.w	#7,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#7,ost_frame(a0)
		beq.s	loc_25408

locret_253EC:
		rts
; ===========================================================================

loc_253EE:
		tst.b	ost_frame(a0)
		beq.s	loc_25408
		subq.w	#1,ost_anim_time(a0)
		bpl.s	locret_253EC
		move.w	#7,ost_anim_time(a0)
		subq.b	#1,ost_frame(a0)
		beq.s	loc_25408
		rts
; ===========================================================================

loc_25408:
		addq.b	#2,(a4)
		move.b	ost_subtype(a0),d0
		addq.b	#1,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2541A
		subq.b	#2,d0

loc_2541A:
		andi.w	#3,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	word_25464(pc,d0.w),ost_x_vel(a1)
		move.w	word_25464+2(pc,d0.w),ost_y_vel(a1)
		move.w	#3,ost_anim_time(a0)
		tst.b	ost_subtype(a0)
		bpl.s	locret_25462
		move.b	#0,$2A(a1)

loc_25440:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#0,$3C(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#6,(a4)
		move.w	#7,$3C(a0)

locret_25462:
		rts
; ===========================================================================
word_25464:
		dc.w	 0,$F000				; 0
		dc.w $1000,    0				; 2
		dc.w	 0,$1000				; 4
		dc.w $F000,    0				; 6
; ===========================================================================

loc_25474:
		tst.b	ost_render(a1)
		bmi.s	loc_25492
		move.b	#0,$2A(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#0,(a4)
		rts
; ===========================================================================

loc_25492:
		cmpi.b	#2,$2C(a0)
		beq.s	loc_254CC
		cmpi.b	#2,$36(a0)
		beq.s	loc_254CC
		subq.w	#1,ost_anim_time(a0)
		bpl.s	loc_254CC
		move.w	#1,ost_anim_time(a0)
		tst.b	$3E(a0)
		beq.s	loc_254C2
		cmpi.b	#7,ost_frame(a0)
		beq.s	loc_254CC
		addq.b	#1,ost_frame(a0)
		bra.s	loc_254CC
; ===========================================================================

loc_254C2:
		tst.b	ost_frame(a0)
		beq.s	loc_254CC
		subq.b	#1,ost_frame(a0)

loc_254CC:
		move.l	ost_x_pos(a1),d2
		move.l	ost_y_pos(a1),d3
		move.w	ost_x_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,ost_x_pos(a1)
		move.l	d3,ost_y_pos(a1)
		rts
; ===========================================================================

loc_254F2:
		subq.w	#1,$3C(a0)
		bpl.s	locret_254FC
		move.b	#0,(a4)

locret_254FC:
		rts
; ===========================================================================

		include "mappings/sprite/OOZ Transporter Ball.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo15_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo14_DespawnObject:
		jmp	(DespawnObject).l
JmpTo23_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 22 - ARZ arrow shooter
; ----------------------------------------------------------------------------

ArrowShooter:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_256A2(pc,d0.w),d1
		jmp	off_256A2(pc,d1.w)
; ===========================================================================
off_256A2:	index offset(*),,2
		ptr loc_256AC					; 0
		ptr loc_256E0					; 2
		ptr loc_2572A					; 4
		ptr loc_2577A					; 6
		ptr loc_257BE					; 8
; ===========================================================================

loc_256AC:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_ArrowShoot,ost_mappings(a0)
		move.w	#tile_Nem_ArrowAndShooter,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo24_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_frame(a0)
		andi.b	#$F,ost_subtype(a0)

loc_256E0:
		cmpi.b	#2,ost_anim(a0)
		beq.s	loc_25706
		moveq	#0,d2
		lea	(v_ost_player1).w,a1
		bsr.s	loc_25714
		lea	(v_ost_player2).w,a1
		bsr.s	loc_25714
		tst.b	d2
		bne.s	loc_25702
		tst.b	ost_anim(a0)
		beq.s	loc_25702
		moveq	#2,d2

loc_25702:
		move.b	d2,ost_anim(a0)

loc_25706:
		lea	(Ani_ArrowShoot).l,a1
		jsrto	AnimateSprite,JmpTo5_AnimateSprite
		jmpto	DespawnObject,JmpTo15_DespawnObject
; ===========================================================================

loc_25714:
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_25720
		neg.w	d0

loc_25720:
		cmpi.w	#$40,d0
		bcc.s	locret_25728
		moveq	#1,d2

locret_25728:
		rts
; ===========================================================================

loc_2572A:
		jsrto	FindFreeObj,JmpTo5_FindFreeObj
		bne.s	loc_25768
		_move.b	ost_id(a0),ost_id(a1)
		addq.b	#6,ost_primary_routine(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.w	#$DB,d0
		jsr	(PlaySound).l

loc_25768:
		subq.b	#2,ost_primary_routine(a0)
		lea	(Ani_ArrowShoot).l,a1
		jsrto	AnimateSprite,JmpTo5_AnimateSprite
		jmpto	DespawnObject,JmpTo15_DespawnObject
; ===========================================================================

loc_2577A:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#8,ost_height(a0)
		move.b	#$10,ost_width(a0)
		move.b	#4,ost_priority(a0)
		move.b	#id_col_8x4+id_col_hurt,ost_col_type(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#0,ost_frame(a0)
		move.w	#$400,ost_x_vel(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_257B4
		neg.w	ost_x_vel(a0)

loc_257B4:
		move.w	#$AE,d0
		jsr	(PlaySound).l

loc_257BE:
		bsr.w	JmpTo11_SpeedToPos
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_257DE
		moveq	#-8,d3
		bsr.w	FindWallLeftObj
		tst.w	d1
		bmi.w	BranchTo_JmpTo27_DeleteObject
		jmpto	DespawnObject,JmpTo15_DespawnObject
; ===========================================================================

BranchTo_JmpTo27_DeleteObject:
		jmpto	DeleteObject,JmpTo27_DeleteObject
; ===========================================================================

loc_257DE:
		moveq	#8,d3
		bsr.w	FindWallRightObj
		tst.w	d1
		bmi.w	BranchTo_JmpTo27_DeleteObject
		jmpto	DespawnObject,JmpTo15_DespawnObject
; ===========================================================================
Ani_ArrowShoot:	index offset(*)
		ptr byte_257F4					; 0
		ptr byte_257F7					; 1
		ptr byte_257FB					; 2

byte_257F4:	dc.b $1F,  1,$FF

byte_257F7:	dc.b   3,  1,  2,$FF

byte_257FB:	dc.b   7,  3,  4,$FC,  4,  3,  1,$FD,  0
; ===========================================================================

		include "mappings/sprite/ARZ Arrow Shooter.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo27_DeleteObject:
		jmp	(DeleteObject).l
JmpTo5_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo15_DespawnObject:
		jmp	(DespawnObject).l
JmpTo5_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo24_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo11_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 23 - ARZ falling pillar
; ----------------------------------------------------------------------------

FallingPillar:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2589A(pc,d0.w),d1
		jmp	off_2589A(pc,d1.w)
; ===========================================================================
off_2589A:	index offset(*),,2
		ptr loc_2589E					; 0
		ptr loc_25922					; 2
; ===========================================================================

loc_2589E:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_FallPillar,ost_mappings(a0)
		move.w	#0+tile_pal2,ost_tile(a0)		; level art
		jsrto	AdjustVRAM2P,JmpTo25_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#$20,ost_height(a0)
		move.b	#4,ost_priority(a0)
		jsrto	FindNextFreeObj,JmpTo10_FindNextFreeObj
		bne.s	loc_25922
		_move.b	ost_id(a0),ost_id(a1)
		addq.b	#2,ost_primary_routine(a1)
		addq.b	#2,ost_secondary_routine(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_x_pos(a0),$30(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$30,ost_y_pos(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#$10,ost_height(a1)
		move.b	#4,ost_priority(a1)
		move.b	#1,ost_frame(a1)

loc_25922:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	loc_25948
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo8_SolidObject
		jmpto	DespawnObject,JmpTo16_DespawnObject
; ===========================================================================

loc_25948:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_25956(pc,d0.w),d1
		jmp	off_25956(pc,d1.w)
; ===========================================================================
off_25956:	index offset(*),,2
		ptr locret_2598C				; 0
		ptr loc_2595E					; 2
		ptr loc_2598E					; 4
		ptr loc_259B8					; 6
; ===========================================================================

loc_2595E:
		tst.w	(v_debug_active).w
		bne.s	locret_2598C
		lea	($FFFFB000).w,a1
		bsr.s	loc_2596E
		lea	($FFFFB040).w,a1

loc_2596E:
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_2597A
		neg.w	d0

loc_2597A:
		cmpi.w	#$80,d0
		bcc.s	locret_2598C
		move.b	#4,ost_secondary_routine(a0)
		move.w	#8,$34(a0)

locret_2598C:

		rts
; ===========================================================================

loc_2598E:
		move.w	$34(a0),d0
		subq.w	#1,d0
		bcc.s	loc_2599C
		addq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_2599C:
		move.w	d0,$34(a0)
		move.b	byte_259B0(pc,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,ost_x_pos(a0)
		rts
; ===========================================================================
byte_259B0:
		dc.b   0					; 0
		dc.b   1					; 1
		dc.b  -1					; 2
		dc.b   1					; 3
		dc.b   0					; 4
		dc.b  -1					; 5
		dc.b   0					; 6
		dc.b   1					; 7
; ===========================================================================

loc_259B8:
		jsrto	SpeedToPos,JmpTo12_SpeedToPos
		addi.w	#$38,ost_y_vel(a0)
		bsr.w	FindFloorObj
		tst.w	d1
		bpl.w	locret_259E4
		add.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.b	#2,ost_frame(a0)
		clr.b	ost_secondary_routine(a0)

locret_259E4:
		rts
; ===========================================================================

		include "mappings/sprite/ARZ Falling Pillar.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 2B - ARZ rising pillar
; ----------------------------------------------------------------------------

RisingPillar:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_25A68(pc,d0.w),d1
		jmp	off_25A68(pc,d1.w)
; ===========================================================================
off_25A68:	index offset(*),,2
		ptr loc_25A6E					; 0
		ptr loc_25A9C					; 2
		ptr loc_25B8E					; 4
; ===========================================================================

loc_25A6E:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_RisePillar,ost_mappings(a0)
		move.w	#0+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo25_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#$18,ost_height(a0)
		move.b	#4,ost_priority(a0)

loc_25A9C:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	loc_25B28
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo8_SolidObject
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.w	loc_25ACE
		jmpto	DespawnObject,JmpTo16_DespawnObject
; ===========================================================================

loc_25ACE:
		lea	(word_25BBE).l,a4
		lea	(byte_25BB0).l,a2
		addq.b	#7,ost_frame(a0)
		bsr.w	loc_25BF6
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		bsr.s	loc_25AF6
		lea	($FFFFB040).w,a1
		addq.b	#1,d6
		bsr.s	loc_25AF6
		bra.w	loc_25B8E
; ===========================================================================

loc_25AF6:
		bclr	d6,ost_primary_status(a0)
		beq.s	locret_25B26
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)

locret_25B26:
		rts
; ===========================================================================

loc_25B28:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_25B36(pc,d0.w),d1
		jmp	off_25B36(pc,d1.w)
; ===========================================================================
off_25B36:	index offset(*),,2
		ptr loc_25B3C					; 0
		ptr loc_25B66					; 2
		ptr locret_25B64				; 4
; ===========================================================================

loc_25B3C:
		tst.w	(v_debug_active).w
		bne.s	locret_25B64
		lea	($FFFFB000).w,a1
		bsr.s	loc_25B4C
		lea	($FFFFB040).w,a1

loc_25B4C:
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_25B58
		neg.w	d0

loc_25B58:
		cmpi.w	#$40,d0
		bcc.s	locret_25B64
		move.b	#2,ost_secondary_routine(a0)

locret_25B64:
		rts
; ===========================================================================

loc_25B66:
		subq.w	#1,$34(a0)
		bcc.s	locret_25B8C
		move.w	#3,$34(a0)
		subq.w	#4,ost_y_pos(a0)
		addq.b	#4,ost_height(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#6,ost_frame(a0)
		bne.s	locret_25B8C
		move.b	#4,ost_secondary_routine(a0)

locret_25B8C:
		rts
; ===========================================================================

loc_25B8E:
		tst.b	$3F(a0)
		beq.s	loc_25B9A
		subq.b	#1,$3F(a0)
		bra.s	loc_25BA4
; ===========================================================================

loc_25B9A:
		jsrto	SpeedToPos,JmpTo12_SpeedToPos
		addi.w	#$18,ost_y_vel(a0)

loc_25BA4:
		tst.b	ost_render(a0)
		bpl.w	JmpTo28_DeleteObject
		jmpto	DisplaySprite,JmpTo16_DisplaySprite
; ===========================================================================
byte_25BB0:
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b   0					; 2
		dc.b   0					; 3
		dc.b   4					; 4
		dc.b   4					; 5
		dc.b   8					; 6
		dc.b   8					; 7
		dc.b  $C					; 8
		dc.b  $C					; 9
		dc.b $10					; 10
		dc.b $10					; 11
		dc.b $14					; 12
		dc.b $14					; 13

word_25BBE:
		dc.w $FE00,$FE00,$200,$FE00			; 0
		dc.w $FE40,$FE40,$1C0,$FE40			; 4
		dc.w $FE80,$FE80,$180,$FE80			; 8
		dc.w $FEC0,$FEC0,$140,$FEC0			; 12
		dc.w $FF00,$FF00,$100,$FF00			; 16
		dc.w $FF40,$FF40,$C0,$FF40			; 20
		dc.w $FF80,$FF80,$80,$FF80			; 24
; ===========================================================================

loc_25BF6:
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		add.w	d0,d0
		movea.l	ost_mappings(a0),a3
		adda.w	(a3,d0.w),a3
		move.w	(a3)+,d1
		subq.w	#1,d1
		bset	#render_rawmap_bit,ost_render(a0)
		_move.b	ost_id(a0),d4
		move.b	ost_render(a0),d5
		movea.l	a0,a1
		bra.s	loc_25C24
; ===========================================================================

loc_25C1C:
		jsrto	FindNextFreeObj,JmpTo10_FindNextFreeObj
		bne.s	loc_25C64
		addq.w	#8,a3

loc_25C24:
		move.b	#4,ost_primary_routine(a1)
		_move.b	d4,ost_id(a1)
		move.l	a3,ost_mappings(a1)
		move.b	d5,ost_render(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	ost_priority(a0),ost_priority(a1)
		move.b	ost_displaywidth(a0),ost_displaywidth(a1)
		move.w	(a4)+,ost_x_vel(a1)
		move.w	(a4)+,ost_y_vel(a1)
		move.b	(a2)+,$3F(a1)
		dbf	d1,loc_25C1C

loc_25C64:
		move.w	#sfx_Smash,d0
		jmp	(PlaySound).l

; ===========================================================================

		include "mappings/sprite/ARZ Rising Pillar.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos
JmpTo28_DeleteObject:
		jmp	(DeleteObject).l

	else

JmpTo16_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo28_DeleteObject:
		jmp	(DeleteObject).l
JmpTo16_DespawnObject:
		jmp	(DespawnObject).l
JmpTo10_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo25_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo8_SolidObject:
		jmp	(SolidObject).l
JmpTo12_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 2C - ARZ leaf generator
; ----------------------------------------------------------------------------

LeafGenerator:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	LeafGen_Index(pc,d0.w),d1
		jmp	LeafGen_Index(pc,d1.w)
; ===========================================================================
LeafGen_Index:	index offset(*),,2
		ptr loc_2611C					; 0
		ptr loc_26152					; 2
		ptr loc_26296					; 4

LeafGen_ColTypes:
		dc.b id_col_32x32+id_col_custom			; 0
		dc.b id_col_64x32+id_col_custom			; 1
		dc.b id_col_128x32+id_col_custom		; 2
		even
; ===========================================================================

loc_2611C:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.b	LeafGen_ColTypes(pc,d0.w),ost_col_type(a0)
		move.l	#Map_LTag,ost_mappings(a0)
		move.w	#tile_Nem_Monitors+tile_hi,ost_tile(a0)
	if FixBugs
		move.b	#render_rel,ost_render(a0)
	else
		; 'render_onscreen' should not be set here: this causes
		; this object to become visible when the player dies, because of how
		; 'ExecuteObjects.dead' works.
		move.b	#render_rel|render_onscreen,ost_render(a0)
	endc
		move.b	#-$80,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	ost_subtype(a0),ost_frame(a0)

loc_26152:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo29_DeleteObject
		move.b	ost_col_property(a0),d0
		beq.s	loc_261C2
		move.w	$2E(a0),d0
		beq.s	loc_2617C
		add.b	(v_frame_counter_low).w,d0
		andi.w	#$F,d0
		bne.s	loc_26198

loc_2617C:
		lea	($FFFFB000).w,a2
		bclr	#0,ost_col_property(a0)
		beq.s	loc_261BC
		bsr.s	loc_261C8
		tst.w	$2E(a0)
		bne.s	loc_261BC
		move.w	(v_frame_counter).w,$2E(a0)
		bra.s	loc_261BC
; ===========================================================================

loc_26198:
		addi_.w	#8,d0
		andi.w	#$F,d0
		bne.s	loc_261BC
		lea	($FFFFB040).w,a2
		bclr	#1,ost_col_property(a0)
		beq.s	loc_261BC
		bsr.s	loc_261C8
		tst.w	$2E(a0)
		bne.s	loc_261BC
		move.w	(v_frame_counter).w,$2E(a0)

loc_261BC:
		clr.b	ost_col_property(a0)
		rts
; ===========================================================================

loc_261C2:
		clr.w	$2E(a0)
		rts
; ===========================================================================

loc_261C8:
		move.w	ost_x_vel(a2),d0
		bpl.s	loc_261D0
		neg.w	d0

loc_261D0:
		cmpi.w	#$200,d0
		bcc.s	loc_261E4
		move.w	ost_y_vel(a2),d0
		bpl.s	loc_261DE
		neg.w	d0

loc_261DE:
		cmpi.w	#$200,d0
		bcs.s	loc_261C2

loc_261E4:
		lea	(byte_26286).l,a3
		moveq	#3,d6

loc_261EC:
		jsrto	FindFreeObj,JmpTo6_FindFreeObj
		bne.w	loc_26278
		_move.b	#id_LeafGenerator,ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a2),ost_x_pos(a1)
		move.w	ost_y_pos(a2),ost_y_pos(a1)
		jsrto	RandomNumber,JmpTo2_RandomNumber
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,ost_x_pos(a1)
		swap	d0
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,ost_y_pos(a1)
		move.w	(a3)+,ost_x_vel(a1)
		move.w	(a3)+,ost_y_vel(a1)
		btst	#status_xflip_bit,ost_primary_status(a2)
		beq.s	loc_2623A
		neg.w	ost_x_vel(a1)

loc_2623A:
		move.w	ost_x_pos(a1),$30(a1)
		move.w	ost_y_pos(a1),$34(a1)
		andi.b	#1,d0
		move.b	d0,ost_frame(a1)
		move.l	#Map_Leaves,ost_mappings(a1)
		move.w	#tile_Nem_Leaves+tile_pal4+tile_hi,ost_tile(a1)
		move.b	#render_rel|render_onscreen,ost_render(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	#1,ost_priority(a1)
		move.b	#4,$38(a1)

	if FixBugs
		move.b	d1,ost_angle(a1)			; d1 = random number by the above call to RandomNumber
	else
		; This line makes no sense: the object being written to is the parent,
		; not the child, and angle isn't used by the parent at all. The child,
		; however, does use angle, so it would appear that this is a typo.
		move.b	d1,ost_angle(a0)
	endc

loc_26278:
		dbf	d6,loc_261EC
		move.w	#sfx_Leaves,d0
		jmp	(PlaySound).l
; ===========================================================================
byte_26286:
		dc.b $FF					; 0
		dc.b $80					; 1
		dc.b $FF					; 2
		dc.b $80					; 3
		dc.b   0					; 4
		dc.b $C0					; 5
		dc.b $FF					; 6
		dc.b $C0					; 7
		dc.b $FF					; 8
		dc.b $40					; 9
		dc.b   0					; 10
		dc.b $40					; 11
		dc.b   0					; 12
		dc.b $80					; 13
		dc.b   0					; 14
		dc.b $80					; 15
; ===========================================================================

loc_26296:
		move.b	$38(a0),d0
		add.b	d0,ost_angle(a0)
		add.b	(v_vblank_counter_byte).w,d0
		andi.w	#$1F,d0
		bne.s	loc_262B4
		add.b	d7,d0
		andi.b	#1,d0
		beq.s	loc_262B4
		neg.b	$38(a0)

loc_262B4:
		move.l	$30(a0),d2
		move.l	$34(a0),d3
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,$30(a0)
		move.l	d3,$34(a0)
		swap	d2
		andi.w	#3,d3
		addq.w	#4,d3
		add.w	d3,ost_y_vel(a0)
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo7_CalcSine
		asr.w	#6,d0
		add.w	$30(a0),d0
		move.w	d0,ost_x_pos(a0)
		asr.w	#6,d1
		add.w	$34(a0),d1
		move.w	d1,ost_y_pos(a0)
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_26312
		move.b	#$B,ost_anim_time(a0)
		bchg	#1,ost_frame(a0)

loc_26312:
		tst.b	ost_render(a0)
		bpl.w	JmpTo29_DeleteObject
		jmpto	DisplaySprite,JmpTo17_DisplaySprite

    if RemoveJmpTos
JmpTo29_DeleteObject:
		jmp	(DeleteObject).l
    endc

; ===========================================================================

		include "mappings/sprite/ARZ Leaves.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo17_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo29_DeleteObject:
		jmp	(DeleteObject).l
JmpTo6_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo2_RandomNumber:
		jmp	(RandomNumber).l
JmpTo7_CalcSine:
		jmp	(CalcSine).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 40 - CPZ, ARZ, and MCZ "diving board" springboard
; ----------------------------------------------------------------------------

Springboard:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SprngBrd_Index(pc,d0.w),d1
		jsr	SprngBrd_Index(pc,d1.w)
		jmpto	DespawnObject,JmpTo17_DespawnObject
; ===========================================================================
SprngBrd_Index:	index offset(*),,2
		ptr loc_2638C					; 0
		ptr loc_263C8					; 2

SprngBrd_Powers:
		; This object supports different strengths based on subtype,
		; but only types 1 and 3 are set, and the 'andi.w #2,d0' below
		; means that only the second of these values is ever used.

		dc.w -$400					; 0, unused
		dc.w -$A00					; 1
		dc.w -$800					; 2, unused
; ===========================================================================

loc_2638C:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SprngBrd,ost_mappings(a0)
		move.w	#tile_Nem_LeverSpring,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo26_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$1C,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		bset	#status_broken_bit,ost_primary_status(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#2,d0
		move.w	SprngBrd_Powers(pc,d0.w),$30(a0)

loc_263C8:
		lea	(Ani_SprngBrd).l,a1			; could be PC-relative
		jsrto	AnimateSprite,JmpTo6_AnimateSprite
		move.w	#$27,d1
		move.w	#8,d2
		move.w	ost_x_pos(a0),d4
		lea	SprngBrd_SlopeData_DiagUp(pc),a2
		tst.b	ost_frame(a0)
		beq.s	loc_263EC
		lea	SprngBrd_SlopeData_Straight(pc),a2

loc_263EC:
		lea	(v_ost_player1).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		jsrto	SolidObject_Heightmap_SingleCharacter,JmpTo_SolidObject_Heightmap_SingleCharacter
		btst	#3,ost_primary_status(a0)
		beq.s	loc_26404
		bsr.s	loc_2641E

loc_26404:
		movem.l	(sp)+,d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#4,d6
		jsrto	SolidObject_Heightmap_SingleCharacter,JmpTo_SolidObject_Heightmap_SingleCharacter
		btst	#4,ost_primary_status(a0)
		beq.s	locret_2641C
		bsr.s	loc_2641E

locret_2641C:
		rts
; ===========================================================================

loc_2641E:
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_26436
		move.w	ost_x_pos(a0),d0
		subi.w	#$10,d0
		cmp.w	ost_x_pos(a1),d0
		bcs.s	loc_26446
		rts
; ===========================================================================

loc_26436:
		move.w	ost_x_pos(a0),d0
		addi.w	#$10,d0
		cmp.w	ost_x_pos(a1),d0
		bcc.s	loc_26446
		rts
; ===========================================================================

loc_26446:
		cmpi.b	#1,ost_anim(a0)
		beq.s	loc_26456
		move.w	#$100,ost_anim(a0)
		rts
; ===========================================================================

loc_26456:
		tst.b	ost_frame(a0)
		beq.s	loc_2645E
		rts
; ===========================================================================

loc_2645E:
		move.w	ost_x_pos(a0),d0
		subi.w	#$1C,d0
		sub.w	ost_x_pos(a1),d0
		neg.w	d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2647A
		not.w	d0
    if FixBugs
		addi.w	#2*$1C,d0
    else
		; This should be (2*$1C) instead of $27. As is, this makes it
		; impossible to get as high of a launch from flipped springs
		; as you can for unflipped ones.
		addi.w	#$27,d0
	endc

loc_2647A:
		tst.w	d0
		bpl.s	loc_26480
		moveq	#0,d0

loc_26480:
		lea	(byte_26550).l,a3
		move.b	(a3,d0.w),d0
		move.w	#-$400,ost_y_vel(a1)
		sub.b	d0,ost_y_vel(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_264AA
		bclr	#status_xflip_bit,ost_primary_status(a1)
		neg.b	d0

loc_264AA:
		move.w	ost_x_vel(a1),d1
		bpl.s	loc_264B2
		neg.w	d1

loc_264B2:
		cmpi.w	#$400,d1
		bcs.s	loc_264BC
		sub.b	d0,ost_x_vel(a1)

loc_264BC:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#$10,ost_anim(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$39(a1)
		move.b	ost_subtype(a0),d0
		btst	#0,d0
		beq.s	loc_2651E
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#1,$2C(a1)
		move.b	#8,$2D(a1)
		btst	#1,d0
		bne.s	loc_2650E
		move.b	#3,$2C(a1)

loc_2650E:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_2651E
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_2651E:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_26534
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_26534:
		cmpi.b	#8,d0
		bne.s	loc_26546
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_26546:
		move.w	#sfx_Spring,d0
		jmp	(PlaySound).l
; ===========================================================================
byte_26550:
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 ; 0
		dc.b   0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1 ; 16
		dc.b   1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2 ; 32
		dc.b   3,  3,  3,  3,  3,  3,  4,  4,  0,  0,  0,  0,  0,  0,  0,  0 ; 48
		dc.b   0,  0,  0,  0,  0,  0,  0,  0		; 64

SprngBrd_SlopeData_DiagUp:
		dc.b   8,  8,  8,  8,  8,  8,  8,  9, $A, $B, $C, $D, $E, $F,$10,$10 ; 0
		dc.b $11,$12,$13,$14,$14,$15,$15,$16,$17,$18,$18,$18,$18,$18,$18,$18 ; 16
		dc.b $18,$18,$18,$18,$18,$18,$18,$18		; 32

SprngBrd_SlopeData_Straight:
		dc.b   8,  8,  8,  8,  8,  8,  8,  9, $A, $B, $C, $C, $C, $C, $D, $D ; 0
		dc.b  $D, $D, $D, $D, $E, $E, $F, $F,$10,$10,$10,$10, $F, $F, $E, $E ; 16
		dc.b  $D, $D, $D, $D, $D, $D, $D, $D		; 32

Ani_SprngBrd:	index offset(*)
		ptr byte_265EC					; 0
		ptr byte_265EF					; 1

byte_265EC:	dc.b  $F,  0,$FF				; 0
byte_265EF:	dc.b   3,  1,  0,$FD,  0			; 0

; ===========================================================================

		include "mappings/sprite/Springboard.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo17_DespawnObject:
		jmp	(DespawnObject).l
JmpTo6_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo26_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_SolidObject_Heightmap_SingleCharacter:
		jmp	(SolidObject_Heightmap_SingleCharacter).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 42 - MTZ steam spring
; ----------------------------------------------------------------------------

SteamSpring:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_26642(pc,d0.w),d1
		jmp	off_26642(pc,d1.w)
; ===========================================================================
off_26642:	index offset(*),,2
		ptr loc_26648					; 0
		ptr loc_26688					; 2
		ptr loc_2683A					; 4
; ===========================================================================

loc_26648:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SteamSpring,ost_mappings(a0)
		move.w	#0+tile_pal4,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		jsrto	AdjustVRAM2P,JmpTo27_AdjustVRAM2P
		move.b	#7,ost_frame(a0)
		move.w	ost_y_pos(a0),$34(a0)
		move.w	#$10,$36(a0)
		addi.w	#$10,ost_y_pos(a0)

loc_26688:
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$10,d3
		move.w	ost_x_pos(a0),d4
		lea	(v_ost_player1).w,a1
		moveq	#3,d6
		pushr.l	d1-d4
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo2_SolidObject_NoRenderChk_SingleCharacter
		btst	#3,ost_primary_status(a0)
		beq.s	loc_266B2
		bsr.w	loc_2678E

loc_266B2:
		popr.l	d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#4,d6
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo2_SolidObject_NoRenderChk_SingleCharacter
		btst	#4,ost_primary_status(a0)
		beq.s	loc_266CC
		bsr.w	loc_2678E

loc_266CC:
		move.b	ost_secondary_routine(a0),d0
		bne.s	loc_266E4
		subq.w	#1,$32(a0)
		bpl.s	loc_26748
		move.w	#$3B,$32(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.s	loc_26748
; ===========================================================================

loc_266E4:
		subq.b	#2,d0
		bne.s	loc_26716
		subq.w	#8,$36(a0)
		bne.s	loc_26708
		addq.b	#2,ost_secondary_routine(a0)
		bsr.s	loc_2674C
		addi.w	#$28,ost_x_pos(a1)
		bsr.s	loc_2674C
		subi.w	#$28,ost_x_pos(a1)
		bset	#render_xflip_bit,ost_render(a1)

loc_26708:
		move.w	$36(a0),d0
		add.w	$34(a0),d0
		move.w	d0,ost_y_pos(a0)
		bra.s	loc_26748
; ===========================================================================

loc_26716:
		subq.b	#2,d0
		bne.s	loc_2672C
		subq.w	#1,$32(a0)
		bpl.s	loc_26748
		move.w	#$3B,$32(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.s	loc_26748
; ===========================================================================

loc_2672C:
		addq.w	#8,$36(a0)
		cmpi.w	#$10,$36(a0)
		bne.s	loc_2673C
		clr.b	ost_secondary_routine(a0)

loc_2673C:
		move.w	$36(a0),d0
		add.w	$34(a0),d0
		move.w	d0,ost_y_pos(a0)

loc_26748:
		jmpto	DespawnObject,JmpTo18_DespawnObject
; ===========================================================================

loc_2674C:
		jsrto	FindFreeObj,JmpTo7_FindFreeObj
		bne.s	locret_2678C
		_move.b	ost_id(a0),ost_id(a1)
		addq.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	$34(a0),ost_y_pos(a1)
		move.b	#7,ost_anim_time(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	#tile_Nem_SteamSpring+tile_pal2,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#$18,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)

	locret_2678C:
		rts
; ===========================================================================

loc_2678E:
		cmpi.b	#2,ost_secondary_routine(a0)
		beq.s	loc_26798
		rts
; ===========================================================================

loc_26798:
		move.w	#-$A00,ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#$10,ost_anim(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$39(a1)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_267C8
		move.w	#0,ost_x_vel(a1)

loc_267C8:
		btst	#0,d0
		beq.s	loc_26808
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#0,$2C(a1)
		move.b	#4,$2D(a1)
		btst	#1,d0
		bne.s	loc_267F8
		move.b	#1,$2C(a1)

loc_267F8:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_26808
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_26808:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_2681E
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_2681E:
		cmpi.b	#8,d0
		bne.s	loc_26830
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_26830:
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_2683A:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_26868
		move.b	#7,ost_anim_time(a0)
		move.b	#0,ost_col_type(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#3,ost_frame(a0)
		bne.s	loc_2685E
		move.b	#id_col_16x4+id_col_hurt,ost_col_type(a0)

loc_2685E:
		cmpi.b	#7,ost_frame(a0)
		beq.w	JmpTo30_DeleteObject

loc_26868:
		jmpto	DisplaySprite,JmpTo18_DisplaySprite

	if RemoveJmpTos
JmpTo30_DeleteObject:
		jmp	(DeleteObject).l
    endc

; ===========================================================================

		include "mappings/sprite/MTZ Steam Spring.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo18_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo30_DeleteObject:
		jmp	(DeleteObject).l
JmpTo7_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo18_DespawnObject:
		jmp	(DespawnObject).l
JmpTo27_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo2_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 64 - MTZ stomping pistons
; ----------------------------------------------------------------------------

TwinStompers:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2692E(pc,d0.w),d1
		jmp	off_2692E(pc,d1.w)
; ===========================================================================
off_2692E:	index offset(*),,2
		ptr loc_2693A					; 0
		ptr loc_269A2					; 2

byte_26932:
		dc.b $40, $C					; 0
		dc.b $40,  1					; 2
		dc.b $10,$20					; 4
		dc.b $40,  1					; 6
; ===========================================================================

loc_2693A:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	byte_26932(pc,d0.w),a3
		move.b	(a3)+,ost_displaywidth(a0)
		move.b	(a3)+,$2E(a0)
		lsr.w	#2,d0
		move.b	d0,ost_frame(a0)
		bne.s	loc_2696A
		move.b	#$6C,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)

loc_2696A:
		move.l	#Map_Stomp,ost_mappings(a0)
		move.w	#0+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo28_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$30(a0)
		moveq	#0,d0
		move.b	(a3)+,d0
		move.w	d0,$3C(a0)
		andi.b	#$F,ost_subtype(a0)

loc_269A2:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		move.w	off_269F4(pc,d0.w),d1
		jsr	off_269F4(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	ost_render(a0)
		bpl.s	loc_269D6
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	$2E(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo9_SolidObject

loc_269D6:
		move.w	$34(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	JmpTo31_DeleteObject
		jmp	(DisplaySprite).l
; ===========================================================================

JmpTo31_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================
off_269F4:	index offset(*),,2
		ptr locret_269F8				; 0
		ptr loc_269FA					; 2
; ===========================================================================

locret_269F8:
		rts
; ===========================================================================

loc_269FA:
		tst.b	$38(a0)
		bne.s	loc_26A1E
		tst.w	$3A(a0)
		beq.s	loc_26A0C
		subq.w	#8,$3A(a0)
		bra.s	loc_26A3E
; ===========================================================================

loc_26A0C:
		subq.w	#1,$36(a0)
		bpl.s	loc_26A3E
		move.w	#$5A,$36(a0)
		move.b	#1,$38(a0)

loc_26A1E:
		move.w	$3A(a0),d0
		cmp.w	$3C(a0),d0
		beq.s	loc_26A2E
		addq.w	#8,$3A(a0)
		bra.s	loc_26A3E
; ===========================================================================

loc_26A2E:
		subq.w	#1,$36(a0)
		bpl.s	loc_26A3E
		move.w	#$5A,$36(a0)
		clr.b	$38(a0)

loc_26A3E:
		move.w	$3A(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_26A50
		neg.w	d0
		addi.w	#$40,d0

loc_26A50:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,ost_y_pos(a0)
		rts
; ===========================================================================

		include "mappings/sprite/MTZ Stomping Pistons.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo28_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo9_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 65 - MTZ retractable platforms, long moving platforms, and small
; cog rollers
; ----------------------------------------------------------------------------

Platform5:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_26AEE(pc,d0.w),d1
		jmp	off_26AEE(pc,d1.w)
; ===========================================================================
off_26AEE:	index offset(*),,2
		ptr loc_26B06					; 0
		ptr loc_26C1C					; 2
		ptr loc_26EA4					; 4
		ptr loc_26EC2					; 6 (cog subtype)

byte_26AF6:
		dc.b $40, $C					; 0
		dc.b $80,  1					; 2
		dc.b $20, $C					; 4
		dc.b $40,  3					; 6
		dc.b $10,$10					; 8
		dc.b $20,  0					; 10
		dc.b $40, $C					; 12
		dc.b $80,  7					; 14
; ===========================================================================

loc_26B06:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_MTZPlats,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo29_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	byte_26AF6(pc,d0.w),a3
		move.b	(a3)+,ost_displaywidth(a0)
		move.b	(a3)+,ost_height(a0)
		lsr.w	#2,d0
		move.b	d0,ost_frame(a0)
		cmpi.b	#1,d0
		bne.s	loc_26B52
		bset	#status_broken_bit,ost_primary_status(a0)

loc_26B52:
		cmpi.b	#2,d0
		bne.s	loc_26B6E
		addq.b	#4,ost_primary_routine(a0)
		move.l	#Map_SmallCog,ost_mappings(a0)
		move.w	#tile_Nem_Cog+tile_pal4,ost_tile(a0)
		bra.w	loc_26EC2
; ===========================================================================

loc_26B6E:
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$30(a0)
		moveq	#0,d0
		move.b	(a3)+,d0
		move.w	d0,$3C(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		bpl.w	loc_26C16
		andi.b	#$F,d0
		move.b	d0,$3E(a0)
		move.b	(a3),ost_subtype(a0)
		cmpi.b	#7,(a3)
		bne.s	loc_26BA4
		move.w	$3C(a0),$3A(a0)

loc_26BA4:
		jsrto	FindNextFreeObj,JmpTo11_FindNextFreeObj
		bne.s	loc_26C04
		_move.b	ost_id(a0),ost_id(a1)
		addq.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#-$4C,ost_x_pos(a1)
		addi.w	#$14,ost_y_pos(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_26BE0
		subi.w	#-$18,ost_x_pos(a1)
		bset	#render_xflip_bit,ost_render(a1)

loc_26BE0:
		move.l	#Map_SmallCog,ost_mappings(a1)
		move.w	#tile_Nem_Cog+tile_pal4,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	a0,$3C(a1)

loc_26C04:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_26C16
		bclr	#7,2(a2,d0.w)

loc_26C16:
		andi.b	#$F,ost_subtype(a0)

loc_26C1C:
		move.w	ost_x_pos(a0),$2E(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		move.w	off_26C7E(pc,d0.w),d1
		jsr	off_26C7E(pc,d1.w)
		move.w	$2E(a0),d4
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi_.w	#5,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo10_SolidObject
		move.w	$34(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_26C66
		jmp	(DisplaySprite).l
; ===========================================================================

loc_26C66:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_26C78
		bclr	#7,2(a2,d0.w)

loc_26C78:
		jmp	(DeleteObject).l
; ===========================================================================
off_26C7E:	index offset(*)
		ptr locret_26C8E				; 0
		ptr loc_26CA4					; 1
		ptr loc_26D34					; 2
		ptr loc_26D94					; 3
		ptr loc_26E3C					; 4
		ptr loc_26E4A					; 5
		ptr loc_26C90					; 6
		ptr loc_26D14					; 7
; ===========================================================================

locret_26C8E:
		rts
; ===========================================================================

loc_26C90:
		tst.b	$38(a0)
		bne.s	loc_26CA2
		subq.w	#1,$36(a0)
		bne.s	loc_26CD0
		move.b	#1,$38(a0)

loc_26CA2:
		bra.s	loc_26CC2
; ===========================================================================

loc_26CA4:
		tst.b	$38(a0)
		bne.s	loc_26CC2
		lea	(v_button_state).w,a2
		moveq	#0,d0
		move.b	$3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_26CD0
		move.b	#1,$38(a0)

loc_26CC2:
		move.w	$3C(a0),d0
		cmp.w	$3A(a0),d0
		beq.s	loc_26CF2
		addq.w	#2,$3A(a0)

loc_26CD0:
		move.w	$3A(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_26CE2
		neg.w	d0
		addi.w	#$80,d0

loc_26CE2:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_x_pos(a0)
		move.w	d1,$2E(a0)
		rts
; ===========================================================================

loc_26CF2:
		addq.b	#1,ost_subtype(a0)
		move.w	#$B4,$36(a0)
		clr.b	$38(a0)
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_26CD0
		bset	#0,2(a2,d0.w)
		bra.s	loc_26CD0
; ===========================================================================

loc_26D14:
		tst.b	$38(a0)
		bne.s	loc_26D32
		lea	(v_button_state).w,a2
		moveq	#0,d0
		move.b	$3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_26D50
		move.b	#1,$38(a0)

loc_26D32:
		bra.s	loc_26D46
; ===========================================================================

loc_26D34:
		tst.b	$38(a0)
		bne.s	loc_26D46
		subq.w	#1,$36(a0)
		bne.s	loc_26D50
		move.b	#1,$38(a0)

loc_26D46:
		tst.w	$3A(a0)
		beq.s	loc_26D72
		subq.w	#2,$3A(a0)

loc_26D50:
		move.w	$3A(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_26D62
		neg.w	d0
		addi.w	#$80,d0

loc_26D62:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_x_pos(a0)
		move.w	d1,$2E(a0)
		rts
; ===========================================================================

loc_26D72:
		subq.b	#1,ost_subtype(a0)
		move.w	#$B4,$36(a0)
		clr.b	$38(a0)
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_26D50
		bclr	#0,2(a2,d0.w)
		bra.s	loc_26D50
; ===========================================================================

loc_26D94:
		move.w	$34(a0),d4
		move.w	d4,d5
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_26DAC
		subi.w	#$20,d4
		addi.w	#$60,d5
		bra.s	loc_26DB4
; ===========================================================================

loc_26DAC:
		subi.w	#$A0,d4
		subi.w	#$20,d5

loc_26DB4:
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		subi.w	#$10,d2
		addi.w	#$40,d3
		moveq	#0,d1
		move.w	($FFFFB008).w,d0
		cmp.w	d4,d0
		bcs.s	loc_26DDE
		cmp.w	d5,d0
		bcc.s	loc_26DDE
		move.w	($FFFFB00C).w,d0
		cmp.w	d2,d0
		bcs.s	loc_26DDE
		cmp.w	d3,d0
		bcc.s	loc_26DDE
		moveq	#1,d1

loc_26DDE:
		move.w	($FFFFB048).w,d0
		cmp.w	d4,d0
		bcs.s	loc_26DF8
		cmp.w	d5,d0
		bcc.s	loc_26DF8
		move.w	($FFFFB04C).w,d0
		cmp.w	d2,d0
		bcs.s	loc_26DF8
		cmp.w	d3,d0
		bcc.s	loc_26DF8
		moveq	#1,d1

loc_26DF8:
		tst.b	d1
		beq.s	loc_26E0E
		move.w	$3C(a0),d0
		cmp.w	$3A(a0),d0
		beq.s	locret_26E3A
		addi.w	#$10,$3A(a0)
		bra.s	loc_26E1A
; ===========================================================================

loc_26E0E:
		tst.w	$3A(a0)
		beq.s	loc_26E1A
		subi.w	#$10,$3A(a0)

loc_26E1A:
		move.w	$3A(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_26E2C
		neg.w	d0
		addi.w	#$40,d0

loc_26E2C:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_x_pos(a0)
		move.w	d1,$2E(a0)

locret_26E3A:
		rts
; ===========================================================================

loc_26E3C:
		btst	#3,ost_primary_status(a0)
		beq.s	locret_26E48
		addq.b	#1,ost_subtype(a0)

locret_26E48:
		rts
; ===========================================================================

loc_26E4A:
		tst.b	$38(a0)
		bne.s	loc_26E84
		addq.w	#2,ost_x_pos(a0)
		cmpi.b	#id_MTZ_2,(v_zone).w
		bne.s	loc_26E74
		cmpi.w	#$1CC0,ost_x_pos(a0)
		beq.s	loc_26E6C
		cmpi.w	#$2940,ost_x_pos(a0)
		bne.s	loc_26E96

loc_26E6C:
		move.b	#0,ost_subtype(a0)
		bra.s	loc_26E96
; ===========================================================================

loc_26E74:
		cmpi.w	#$1BC0,ost_x_pos(a0)
		bne.s	loc_26E96
		move.b	#1,$38(a0)
		bra.s	loc_26E96
; ===========================================================================

loc_26E84:
		subq.w	#2,ost_x_pos(a0)
		cmpi.w	#$1880,ost_x_pos(a0)
		bne.s	loc_26E96
		move.b	#0,$38(a0)

loc_26E96:
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_x_pos(a0),(v_mtz_platform_cog_x_pos).w
		rts
; ===========================================================================

loc_26EA4:
		movea.l	$3C(a0),a1
		move.w	$3A(a1),d0

loc_26EAC:
		andi.w	#7,d0
		move.b	byte_26EBA(pc,d0.w),ost_frame(a0)
		jmpto	DespawnObject,JmpTo19_DespawnObject
; ===========================================================================
byte_26EBA:
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b   2					; 2
		dc.b   2					; 3
		dc.b   2					; 4
		dc.b   1					; 5
		dc.b   1					; 6
		dc.b   1					; 7
; ===========================================================================

loc_26EC2:
		move.w	(v_mtz_platform_cog_x_pos).w,d0
		bra.s	loc_26EAC
; ===========================================================================

		include "mappings/sprite/MTZ Long Moving Platforms.asm"
		include "mappings/sprite/MTZ Small Cog.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo19_DespawnObject:
		jmp	(DespawnObject).l
JmpTo11_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo29_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo10_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 66 - MTZ spring walls
; Invisible object; the yellow triangles are part of the level layout
; ----------------------------------------------------------------------------

SpringWall:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_26F66(pc,d0.w),d1
		jmp	off_26F66(pc,d1.w)
; ===========================================================================
off_26F66:	index offset(*),,2
		ptr loc_26F6A					; 0
		ptr loc_26FAE					; 2
; ===========================================================================

loc_26F6A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SpringWall,ost_mappings(a0)
		move.w	#tile_Nem_Monitors+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo30_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$40,ost_height(a0)
		move.b	ost_subtype(a0),d0
		lsr.b	#4,d0
		andi.b	#7,d0
		move.b	d0,ost_frame(a0)
		beq.s	loc_26FAE
		move.b	#-$80,ost_height(a0)

loc_26FAE:
		move.w	#$13,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo3_SolidObject_NoRenderChk_SingleCharacter
		cmpi.b	#1,d4
		bne.s	loc_26FF6
		btst	#1,ost_primary_status(a1)
		beq.s	loc_26FF6
		move.b	ost_primary_status(a0),d1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcs.s	loc_26FEE
		eori.b	#1,d1

loc_26FEE:
		andi.b	#1,d1
		bne.s	loc_26FF6
		bsr.s	loc_27042

loc_26FF6:
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		moveq	#4,d6
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo3_SolidObject_NoRenderChk_SingleCharacter
		cmpi.b	#1,d4
		bne.s	loc_2702C
		btst	#1,ost_primary_status(a1)
		beq.s	loc_2702C
		move.b	ost_primary_status(a0),d1
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcs.s	loc_27024
		eori.b	#1,d1

loc_27024:
		andi.b	#1,d1
		bne.s	loc_2702C
		bsr.s	loc_27042

loc_2702C:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo33_DeleteObject
	if (Revision=0)|DebugImprovements
		; This object was visible with debug mode in Revision 0.
		tst.w	(v_debug_active).w
		beq.s	.nodisplay
		jsrto	DisplaySprite,JmpTo47_DisplaySprite
	.nodisplay:
	endc
		rts

    if RemoveJmpTos
JmpTo33_DeleteObject:
		jmp	(DeleteObject).l
    endif
; ===========================================================================

loc_27042:
	if (Revision>0)|FixBugs
		; Revision 0 didn't check if the player was hurt or dead.
		cmpi.b	#id_Hurt,ost_primary_routine(a1)
		bcs.s	loc_2704C
		rts
	endc
; ===========================================================================

loc_2704C:
		move.w	$30(a0),ost_x_vel(a1)
		move.w	#-$800,ost_x_vel(a1)
		move.w	#-$800,ost_y_vel(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_27076
		bclr	#status_xflip_bit,ost_primary_status(a1)
		neg.w	ost_x_vel(a1)

loc_27076:
		move.w	#$F,$2E(a1)
		move.w	ost_x_vel(a1),ost_inertia(a1)
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_27090
		move.b	#0,ost_anim(a1)

loc_27090:
		move.b	ost_subtype(a0),d0
		bpl.s	loc_2709C

loc_27096:
		move.w	#0,ost_y_vel(a1)

loc_2709C:
		btst	#0,d0
		beq.s	loc_270DC
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#1,$2C(a1)
		move.b	#8,$2D(a1)
		btst	#1,d0
		bne.s	loc_270CC
		move.b	#3,$2C(a1)

loc_270CC:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_270DC
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_270DC:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_270F2
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_270F2:
		cmpi.b	#8,d0
		bne.s	loc_27104
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_27104:
		bclr	#5,ost_primary_status(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		move.w	#$CC,d0
		jmp	(PlaySound).l
; ===========================================================================

		include "mappings/sprite/MTZ Spring Walls.asm"

; ===========================================================================

	if RemoveJmpTos=0

	if Revision=0
JmpTo47_DisplaySprite:
		jmp	(DisplaySprite).l
	endc

JmpTo33_DeleteObject:
		jmp	(DeleteObject).l
JmpTo30_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo3_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 67 - MTZ teleporter
; ----------------------------------------------------------------------------

Teleporter:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_27184(pc,d0.w),d1
		jsr	off_27184(pc,d1.w)
		move.b	$2C(a0),d0
		add.b	$36(a0),d0
		beq.w	JmpTo4_DespawnObject3
		lea	(Ani_TelPrtFlash).l,a1
		jsrto	AnimateSprite,JmpTo7_AnimateSprite
		jmpto	DisplaySprite,JmpTo19_DisplaySprite
; ===========================================================================
off_27184:	index offset(*),,2
		ptr loc_27188					; 0
		ptr loc_271AC					; 2
; ===========================================================================

loc_27188:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_TelptrFlash,ost_mappings(a0)
		move.w	#tile_Nem_TeleportFlash+tile_pal4,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#5,ost_priority(a0)

loc_271AC:
		lea	(v_ost_player1).w,a1
		lea	$2C(a0),a4
		bsr.s	loc_271BE
		lea	(v_ost_player2).w,a1
		lea	$36(a0),a4

loc_271BE:
		moveq	#0,d0
		move.b	(a4),d0
		move.w	off_271CA(pc,d0.w),d0
		jmp	off_271CA(pc,d0.w)
; ===========================================================================
off_271CA:	index offset(*),,2
		ptr loc_271D0					; 0
		ptr loc_27260					; 2
		ptr loc_27294					; 4
; ===========================================================================

loc_271D0:
		tst.w	(v_debug_active).w
		bne.w	locret_2725E
		move.w	ost_x_pos(a1),d0

loc_271DC:
		sub.w	ost_x_pos(a0),d0
		addq.w	#3,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_271EE
		addi.w	#$A,d0

loc_271EE:
		cmpi.w	#$10,d0
		bcc.s	locret_2725E
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		addi.w	#$20,d1
		cmpi.w	#$40,d1
		bcc.s	locret_2725E
		tst.b	$2A(a1)
		bne.s	locret_2725E
		addq.b	#2,(a4)
		move.b	#-$7F,$2A(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$800,ost_inertia(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		bclr	#5,ost_primary_status(a0)
		bclr	#5,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		clr.b	1(a4)
		move.w	#$BE,d0
		jsr	(PlaySound).l
		move.w	#$100,ost_anim(a0)

locret_2725E:
		rts
; ===========================================================================

loc_27260:
		move.b	1(a4),d0
		addq.b	#2,1(a4)
		jsr	(CalcSine).l
		asr.w	#5,d0
		move.w	ost_y_pos(a0),d2
		sub.w	d0,d2
		move.w	d2,ost_y_pos(a1)
		cmpi.b	#-$80,1(a4)
		bne.s	locret_27292
		bsr.w	loc_27310
		addq.b	#2,(a4)
		move.w	#$BC,d0
		jsr	(PlaySound).l

locret_27292:
		rts
; ===========================================================================

loc_27294:
		subq.b	#1,2(a4)
		bpl.s	loc_272C8
		movea.l	6(a4),a2
		move.w	(a2)+,d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		move.w	d5,ost_y_pos(a1)
		tst.b	ost_subtype(a0)
		bpl.s	loc_272B2
		subq.w	#8,a2

loc_272B2:
		move.l	a2,6(a4)
		subq.w	#4,4(a4)
		beq.s	loc_272EE
		move.w	(a2)+,d4
		move.w	(a2)+,d5
		move.w	#$1000,d2
		bra.w	loc_27374
; ===========================================================================

loc_272C8:
		move.l	ost_x_pos(a1),d2
		move.l	ost_y_pos(a1),d3
		move.w	ost_x_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,ost_x_pos(a1)
		move.l	d3,ost_y_pos(a1)
		rts
; ===========================================================================

loc_272EE:
		andi.w	#$7FF,ost_y_pos(a1)
		clr.b	(a4)
		clr.b	$2A(a1)
		btst	#4,ost_subtype(a0)
		bne.s	locret_2730E
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)

locret_2730E:
		rts
; ===========================================================================

loc_27310:
		move.b	ost_subtype(a0),d0
		bpl.s	loc_27344
		neg.b	d0
		andi.w	#$F,d0
		add.w	d0,d0
		lea	(Telport_TubeData).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d0
		subq.w	#4,d0
		move.w	d0,4(a4)
		lea	(a2,d0.w),a2
		move.w	(a2)+,d4
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		move.w	d5,ost_y_pos(a1)
		subq.w	#8,a2
		bra.s	loc_27368
; ===========================================================================

loc_27344:
		andi.w	#$F,d0
		add.w	d0,d0

loc_2734A:
		lea	(Telport_TubeData).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,4(a4)
		subq.w	#4,4(a4)
		move.w	(a2)+,d4

loc_2735E:
		move.w	d4,ost_x_pos(a1)
		move.w	(a2)+,d5
		move.w	d5,ost_y_pos(a1)

loc_27368:
		move.l	a2,6(a4)
		move.w	(a2)+,d4
		move.w	(a2)+,d5
		move.w	#$1000,d2

loc_27374:
		moveq	#0,d0
		move.w	d2,d3
		move.w	d4,d0
		sub.w	ost_x_pos(a1),d0
		bge.s	loc_27384
		neg.w	d0
		neg.w	d2

loc_27384:
		moveq	#0,d1
		move.w	d5,d1
		sub.w	ost_y_pos(a1),d1
		bge.s	loc_27392
		neg.w	d1
		neg.w	d3

loc_27392:
		cmp.w	d0,d1
		bcs.s	loc_273C4
		moveq	#0,d1
		move.w	d5,d1
		sub.w	ost_y_pos(a1),d1
		swap	d1
		divs.w	d3,d1
		moveq	#0,d0
		move.w	d4,d0
		sub.w	ost_x_pos(a1),d0
		beq.s	loc_273B0
		swap	d0
		divs.w	d1,d0

loc_273B0:
		move.w	d0,ost_x_vel(a1)
		move.w	d3,ost_y_vel(a1)
		tst.w	d1
		bpl.s	loc_273BE
		neg.w	d1

loc_273BE:
		move.w	d1,2(a4)
		rts
; ===========================================================================

loc_273C4:
		moveq	#0,d0
		move.w	d4,d0
		sub.w	ost_x_pos(a1),d0
		swap	d0
		divs.w	d2,d0
		moveq	#0,d1
		move.w	d5,d1
		sub.w	ost_y_pos(a1),d1
		beq.s	loc_273DE
		swap	d1
		divs.w	d0,d1

loc_273DE:
		move.w	d1,ost_y_vel(a1)
		move.w	d2,ost_x_vel(a1)
		tst.w	d0
		bpl.s	loc_273EC
		neg.w	d0

loc_273EC:
		move.w	d0,2(a4)
		rts
; ===========================================================================

		include "misc/MTZ Tube Locations.asm"

Ani_TelprtFlash:	index offset(*)
		ptr byte_27532					; 0
		ptr byte_27535					; 1

byte_27532:
		dc.b $1F,  0,$FF
		rev02even

byte_27535:
		dc.b   1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,$FE,  2
		even

; ===========================================================================

		include "mappings/sprite/MTZ Teleporter Flash.asm"

; ===========================================================================

	if RemoveJmpTos
JmpTo4_DespawnObject3:
		jmp	(DespawnObject3).l

	else

JmpTo19_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo7_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo4_DespawnObject3:
		jmp	(DespawnObject3).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 68 - MTZ spike block (spikes emerging from each side sequentially)
; ----------------------------------------------------------------------------

SpikeBlock:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SpkBlk_Index(pc,d0.w),d1
		jmp	SpkBlk_Index(pc,d1.w)
; ===========================================================================
SpkBlk_Index:	index offset(*),,2
		ptr loc_275A8					; 0
		ptr loc_2764A					; 2
		ptr loc_27662					; 4

		;rsobj
;spikearoundblock_initial_x_pos =	objoff_30
;spikearoundblock_initial_y_pos =	objoff_32
;spikearoundblock_offset =		objoff_34 ; offset from the center
;spikearoundblock_position =		objoff_36 ; 0 = retracted or expanding, 1 = expanded or retracting
;spikearoundblock_waiting =		objoff_38 ; 0 = moving, 1 = waiting
; ===========================================================================

loc_275A8:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SpkBlk,ost_mappings(a0)
		move.w	#tile_Nem_SpikeBlock+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo31_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		jsrto	FindNextFreeObj,JmpTo12_FindNextFreeObj
		bne.s	loc_27644
		_move.b	ost_id(a0),ost_id(a1)
		addq.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_x_pos(a1),$30(a1)
		move.w	ost_y_pos(a1),$32(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	#tile_Nem_MTZSpike+tile_pal2,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.w	(v_frame_counter).w,d0
		lsr.w	#6,d0
		move.w	d0,d1
		andi.w	#1,d0
		move.w	d0,$36(a1)
		lsr.w	#1,d1
		add.b	ost_subtype(a0),d1
		andi.w	#3,d1
		move.b	d1,ost_secondary_routine(a1)
		move.b	d1,ost_frame(a1)
		lea	(SpkBlk_ColTypes).l,a2
		move.b	(a2,d1.w),ost_col_type(a1)

loc_27644:
		move.b	#4,ost_frame(a0)

loc_2764A:
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo11_SolidObject
		jmpto	DespawnObject,JmpTo20_DespawnObject
; ===========================================================================

loc_27662:
		bsr.w	loc_276CA
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		add.w	d0,d0
		move.w	off_2767E(pc,d0.w),d1
		jsr	off_2767E(pc,d1.w)
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo2_DespawnObject2
; ===========================================================================
off_2767E:	index offset(*)
		ptr loc_27686					; 0
		ptr loc_27698					; 1
		ptr loc_276A8					; 2
		ptr loc_276B8					; 3
; ===========================================================================

loc_27686:
		moveq	#0,d0
		move.b	$34(a0),d0
		neg.w	d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================

loc_27698:
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$30(a0),d0
		move.w	d0,ost_x_pos(a0)
		rts
; ===========================================================================

loc_276A8:
		moveq	#0,d0
		move.b	$34(a0),d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================

loc_276B8:
		moveq	#0,d0
		move.b	$34(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,ost_x_pos(a0)
		rts
; ===========================================================================

loc_276CA:
		tst.w	$38(a0)
		beq.s	loc_276EE
		move.b	(v_frame_counter_low).w,d0
		andi.b	#$3F,d0
		bne.s	locret_2774A
		clr.w	$38(a0)
		tst.b	ost_render(a0)
		bpl.s	loc_276EE
		move.w	#$B6,d0
		jsr	(PlaySound).l

loc_276EE:
		tst.w	$36(a0)
		beq.s	loc_2772A
		subi.w	#$800,$34(a0)
		bcc.s	locret_2774A
		move.w	#0,$34(a0)
		move.w	#0,$36(a0)
		move.w	#1,$38(a0)
		addq.b	#1,ost_secondary_routine(a0)
		andi.b	#3,ost_secondary_routine(a0)
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.b	d0,ost_frame(a0)
		move.b	SpkBlk_ColTypes(pc,d0.w),ost_col_type(a0)
		rts
; ===========================================================================

loc_2772A:
		addi.w	#$800,$34(a0)
		cmpi.w	#$2000,$34(a0)
		bcs.s	locret_2774A
		move.w	#$2000,$34(a0)
		move.w	#1,$36(a0)
		move.w	#1,$38(a0)

locret_2774A:
		rts
; ===========================================================================
SpkBlk_ColTypes:
		rept 2
		dc.b id_col_4x16+id_col_hurt			; 0 & 2, vertical spikes
		dc.b id_col_16x4+id_col_hurt			; 1 & 3, horizontal spikes
		endr
; ===========================================================================

		include "mappings/sprite/MTZ Spike Block and Floor Spike.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 6D - MTZ floor spike
; ----------------------------------------------------------------------------

FloorSpike:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_277A2(pc,d0.w),d1
		jmp	off_277A2(pc,d1.w)
; ===========================================================================
off_277A2:	index offset(*),,2
		ptr loc_277A6					; 0
		ptr loc_277E0					; 2
; ===========================================================================

loc_277A6:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SpkBlk,ost_mappings(a0)
		move.w	#tile_Nem_MTZSpike+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo31_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.b	#id_col_4x16+id_col_hurt,ost_col_type(a0)

loc_277E0:
		bsr.w	loc_277FC
		moveq	#0,d0
		move.b	$34(a0),d0
		neg.w	d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo2_DespawnObject2
; ===========================================================================

loc_277FC:
		tst.w	$3A(a0)
		beq.s	loc_27808
		subq.w	#1,$3A(a0)
		rts
; ===========================================================================

loc_27808:
		tst.w	$38(a0)
		beq.s	loc_27820
		move.b	(v_frame_counter_low).w,d0
		sub.b	ost_subtype(a0),d0
		andi.b	#$7F,d0
		bne.s	locret_27862
		clr.w	$38(a0)

loc_27820:
		tst.w	$36(a0)
		beq.s	loc_27842
		subi.w	#$400,$34(a0)
		bcc.s	locret_27862
		move.w	#0,$34(a0)
		move.w	#0,$36(a0)
		move.w	#1,$38(a0)
		rts
; ===========================================================================

loc_27842:
		addi.w	#$400,$34(a0)
		cmpi.w	#$2000,$34(a0)
		bcs.s	locret_27862
		move.w	#$2000,$34(a0)
		move.w	#1,$36(a0)
		move.w	#3,$3A(a0)

locret_27862:
		rts
; ===========================================================================

	if RemoveJmpTos=0
JmpTo20_DespawnObject:
		jmp	(DespawnObject).l
JmpTo12_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo31_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo11_SolidObject:
		jmp	(SolidObject).l
JmpTo2_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 69 - MTZ giant nut
; ----------------------------------------------------------------------------

Nut:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_27892(pc,d0.w),d1
		jmp	off_27892(pc,d1.w)
; ===========================================================================
off_27892:	index offset(*),,2
		ptr loc_2789A					; 0
		ptr loc_278DC					; 2
		ptr loc_279FC					; 4
		ptr loc_278F4					; 6

		rsobj	Nut,$32
ost_nut_32:			rs.w 1
ost_nut_34:			rs.w 1
ost_nut_36:			rs.w 1
ost_nut_p1_mode:	rs.b 1					; $38
ost_nut_39:			rs.b 1
		rsset $3C
ost_nut_p2_mode:	rs.b 1					; $3C
ost_nut_3D:			rs.b 1
		rsobjend
; ===========================================================================

loc_2789A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Nut,ost_mappings(a0)
		move.w	#tile_Nem_Nut+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo32_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#$B,ost_height(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_y_pos(a0),ost_nut_32(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#$7F,d0
		lsl.w	#3,d0
		move.w	d0,ost_nut_36(a0)

loc_278DC:
		lea	(v_ost_player1).w,a1
		lea	ost_nut_p1_mode(a0),a4
		moveq	#3,d6
		bsr.s	loc_27912
		lea	(v_ost_player2).w,a1
		lea	ost_nut_p2_mode(a0),a4
		moveq	#4,d6
		bsr.s	loc_27912

loc_278F4:
		andi.w	#$7FF,ost_y_pos(a0)
		move.w	#$2B,d1
		move.w	#$C,d2
		move.w	#$D,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo12_SolidObject
		jmpto	DespawnObject,JmpTo21_DespawnObject
; ===========================================================================

loc_27912:
		btst	d6,ost_primary_status(a0)
		bne.s	loc_2791A
		clr.b	(a4)

loc_2791A:
		moveq	#0,d0
		move.b	(a4),d0
		move.w	off_27926(pc,d0.w),d0
		jmp	off_27926(pc,d0.w)
; ===========================================================================
off_27926:	index offset(*),,2
		ptr loc_2792C					; 0
		ptr loc_2794C					; 2
		ptr loc_2796E					; 4
; ===========================================================================

loc_2792C:
		btst	d6,ost_primary_status(a0)
		bne.s	loc_27934
		rts
; ===========================================================================

loc_27934:
		addq.b	#2,(a4)
		move.b	#0,1(a4)				; ost_nut_39 or 3D
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_2794C
		move.b	#1,1(a4)

loc_2794C:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		tst.b	1(a4)					; ost_nut_39 or 3D
		beq.s	loc_2795E
		addi.w	#$F,d0

loc_2795E:
		cmpi.w	#$10,d0
		bcc.s	locret_2796C
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		addq.b	#2,(a4)

locret_2796C:
		rts
; ===========================================================================

loc_2796E:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		bcc.s	loc_279D4
		add.w	d0,ost_nut_34(a0)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_nut_34(a0),d0
		asr.w	#3,d0
		move.w	d0,d1
		asr.w	#1,d0
		andi.w	#3,d0
		move.b	d0,ost_frame(a0)
		neg.w	d1
		add.w	ost_nut_32(a0),d1
		move.w	d1,ost_y_pos(a0)
		sub.w	ost_nut_32(a0),d1
		move.w	ost_nut_36(a0),d0
		cmp.w	d0,d1
		blt.s	locret_279D2
		move.w	d0,d1
		add.w	ost_nut_32(a0),d1
		move.w	d1,ost_y_pos(a0)
		lsl.w	#3,d0
		neg.w	d0
		move.w	d0,ost_nut_34(a0)
		move.b	#0,ost_frame(a0)
		tst.b	ost_subtype(a0)
		bmi.s	loc_279CC
		clr.b	(a4)
		rts
; ===========================================================================

loc_279CC:
		move.b	#4,ost_primary_routine(a0)

locret_279D2:
		rts
; ===========================================================================

loc_279D4:
		add.w	d0,ost_nut_34(a0)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_nut_34(a0),d0
		asr.w	#3,d0
		move.w	d0,d1
		asr.w	#1,d0
		andi.w	#3,d0
		move.b	d0,ost_frame(a0)
		neg.w	d1
		add.w	ost_nut_32(a0),d1
		move.w	d1,ost_y_pos(a0)
		rts
; ===========================================================================

loc_279FC:
		jsrto	SpeedToPos,JmpTo13_SpeedToPos
		addi.w	#$38,ost_y_vel(a0)
		jsrto	FindFloorObj,JmpTo_FindFloorObj
		tst.w	d1
		bpl.w	loc_27A22
		add.w	d1,ost_y_pos(a0)
		andi.w	#$7FF,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		addq.b	#2,ost_primary_routine(a0)

loc_27A22:
		bra.w	loc_278F4
; ===========================================================================

		include "mappings/sprite/MTZ Nut.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo21_DespawnObject:
		jmp	(DespawnObject).l
JmpTo_FindFloorObj:
		jmp	(FindFloorObj).l
JmpTo32_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo12_SolidObject:
		jmp	(SolidObject).l
JmpTo13_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 6A - MCZ crates and MTZ platform that moves when player leaves it
; ----------------------------------------------------------------------------

Platform3:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_27ABE(pc,d0.w),d1
		jmp	off_27ABE(pc,d1.w)
; ===========================================================================
off_27ABE:	index offset(*),,2
		ptr loc_27AC4					; 0
		ptr loc_27BDE					; 2
		ptr loc_27C66					; 4
; ===========================================================================

loc_27AC4:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_MTZPlats,ost_mappings(a0)
		move.w	#0+tile_pal4,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#$C,ost_height(a0)
		move.l	#byte_27CDC,$2C(a0)
		move.b	#1,ost_frame(a0)
		cmpi.b	#id_MCZ,(v_zone).w
		bne.w	loc_27BC4
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Crate,ost_mappings(a0)
		move.w	#tile_Nem_Crate+tile_pal4,ost_tile(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#$20,ost_height(a0)
		move.l	#byte_27CF4,$2C(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_27B3C
		move.l	#byte_27D12,$2C(a0)

loc_27B3C:
		move.b	#0,ost_frame(a0)
		cmpi.b	#$18,ost_subtype(a0)
		bne.w	loc_27BD0
		jsrto	FindNextFreeObj,JmpTo13_FindNextFreeObj
		bne.s	loc_27B9C
		bsr.s	loc_27B9E
		addi.w	#$40,ost_x_pos(a1)
		addi.w	#$40,ost_y_pos(a1)
		move.b	#6,ost_subtype(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_27B74
		move.b	#$C,ost_subtype(a1)

loc_27B74:
		jsrto	FindNextFreeObj,JmpTo13_FindNextFreeObj
		bne.s	loc_27B9C
		bsr.s	loc_27B9E
		subi.w	#$40,ost_x_pos(a1)
		addi.w	#$40,ost_y_pos(a1)
		move.b	#$C,ost_subtype(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_27B9C
		move.b	#6,ost_subtype(a1)

loc_27B9C:
		bra.s	loc_27BC4
; ===========================================================================

loc_27B9E:
		_move.b	ost_id(a0),ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_x_pos(a0),$32(a1)
		move.w	ost_y_pos(a0),$30(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		rts
; ===========================================================================

loc_27BC4:
		move.w	ost_x_pos(a0),$32(a0)
		move.w	ost_y_pos(a0),$30(a0)

loc_27BD0:
		jsrto	AdjustVRAM2P,JmpTo33_AdjustVRAM2P
		move.b	ost_subtype(a0),$38(a0)
		bra.w	loc_27CA2
; ===========================================================================

loc_27BDE:
		move.w	ost_x_pos(a0),-(sp)
		tst.w	$36(a0)
		bne.s	loc_27C2E
		move.b	$3C(a0),d1
		move.b	ost_primary_status(a0),d0
		btst	#3,d0
		bne.s	loc_27C0A
		btst	#3,d1
		beq.s	loc_27C0E
		move.b	#1,$36(a0)
		move.b	#0,$3C(a0)
		bra.s	loc_27C3E
; ===========================================================================

loc_27C0A:
		move.b	d0,$3C(a0)

loc_27C0E:
		btst	#4,d0
		bne.s	loc_27C28
		btst	#4,d1
		beq.s	loc_27C3E
		move.b	#1,$36(a0)
		move.b	#0,$3C(a0)
		bra.s	loc_27C3E
; ===========================================================================

loc_27C28:
		move.b	d0,$3C(a0)
		bra.s	loc_27C3E
; ===========================================================================

loc_27C2E:
		jsr	(SpeedToPos).l
		subq.w	#1,$34(a0)
		bne.s	loc_27C3E
		bsr.w	loc_27CA2

loc_27C3E:
		move.w	(sp)+,d4
		tst.b	ost_render(a0)
		bpl.s	loc_27C5E
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo13_SolidObject

loc_27C5E:
		move.w	$32(a0),d0
		jmpto	DespawnObject2,JmpTo3_DespawnObject2
; ===========================================================================

loc_27C66:
		move.w	ost_x_pos(a0),-(sp)
		jsr	(SpeedToPos).l
		subq.w	#1,$34(a0)
		bne.s	loc_27C7A
		bsr.w	loc_27CA2

loc_27C7A:
		move.w	(sp)+,d4
		tst.b	ost_render(a0)
		bpl.s	loc_27C9A
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo13_SolidObject

loc_27C9A:
		move.w	$32(a0),d0
		jmpto	DespawnObject2,JmpTo3_DespawnObject2
; ===========================================================================

loc_27CA2:
		moveq	#0,d0
		move.b	$38(a0),d0
		movea.l	$2C(a0),a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,ost_x_vel(a0)
		move.w	(a1)+,ost_y_vel(a0)
		move.w	(a1)+,$34(a0)
		move.w	#7,$3A(a0)
		move.b	#0,$36(a0)
		addq.b	#6,$38(a0)
		cmpi.b	#$18,$38(a0)
		bcs.s	locret_27CDA
		move.b	#0,$38(a0)

locret_27CDA:
		rts
; ===========================================================================
; Data describing the movement of the platforms/crates, I believe.


byte_27CDC:	; MTZ falling platform
		dc.b   0,  0,  4,  0,  0,$10,  4,  0,$FE,  0,  0,$20,  0,  0,  4,  0
		dc.b   0,$10,$FC,  0,$FE,  0,  0,$20

byte_27CF4:	; MCZ crate
		dc.b   0,  0,  1,  0,  0,$40,$FF,  0,  0,  0,  0,$80,  0,  0,$FF,  0
		dc.b   0,$40,  1,  0,  0,  0,  0,$80,  1,  0,  0,  0,  0,$40

byte_27D12:	; MCZ crate (x-flipped)
		dc.b   0,  0,  1,  0,  0,$40,  1,  0,  0,  0,  0,$80,  0,  0,$FF,  0
		dc.b   0,$40,$FF,  0,  0,  0,  0,$80,$FF,  0,  0,  0,  0,$40
		even
; ===========================================================================

		include "mappings/sprite/MCZ Crate.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo13_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo33_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo13_SolidObject:
		jmp	(SolidObject).l
JmpTo3_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 6B - CPZ continuously moving stair platforms and MTZ fixed platform
; ----------------------------------------------------------------------------

Platform4:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_27D7A(pc,d0.w),d1
		jmp	off_27D7A(pc,d1.w)
; ===========================================================================
off_27D7A:	index offset(*),,2
		ptr loc_27D86					; 0
		ptr loc_27E0E					; 2

byte_27D7E:
		dc.b $20					; 0
		dc.b  $C					; 1
		dc.b   1					; 2
		dc.b   0					; 3
		dc.b $10					; 4
		dc.b $10					; 5
		dc.b   0					; 6
		dc.b   0					; 7
; ===========================================================================

loc_27D86:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_MTZPlats,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_pal4,ost_tile(a0)
		cmpi.b	#id_CPZ,(v_zone).w
		bne.s	loc_27DAE
		move.l	#Map_StairBlock,ost_mappings(a0)
		move.w	#tile_Nem_StairBlock+tile_pal4,ost_tile(a0)

loc_27DAE:
		jsrto	AdjustVRAM2P,JmpTo34_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	byte_27D7E(pc,d0.w),a2
		move.b	(a2)+,ost_displaywidth(a0)
		move.b	(a2)+,ost_height(a0)
		move.b	(a2)+,ost_frame(a0)
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$30(a0)
		move.b	ost_primary_status(a0),$2E(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		subq.w	#8,d0
		bcs.s	loc_27E0E
		lsl.w	#2,d0
		lea	($FFFFFE8A).w,a2
		lea	(a2,d0.w),a2
		tst.w	(a2)
		bpl.s	loc_27E0E
		bchg	#0,$2E(a0)

loc_27E0E:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	off_27E4E(pc,d0.w),d1
		jsr	off_27E4E(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	ost_render(a0)
		bpl.s	loc_27E46
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo14_SolidObject

loc_27E46:
		move.w	$34(a0),d0
		jmpto	DespawnObject2,JmpTo4_DespawnObject2
; ===========================================================================
off_27E4E:	index offset(*)
		ptr locret_27E66				; 0
		ptr loc_27E68					; 1
		ptr loc_27E74					; 2
		ptr loc_27E96					; 3
		ptr loc_27EA2					; 4
		ptr loc_27EC4					; 5
		ptr loc_27EE2					; 6
		ptr loc_27F10					; 7
		ptr loc_27F4E					; 8
		ptr loc_27F60					; 9
		ptr loc_27F70					; 10
		ptr loc_27F80					; 11
; ===========================================================================

locret_27E66:
		rts
; ===========================================================================

loc_27E68:
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	loc_27E7E
; ===========================================================================

loc_27E74:
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

loc_27E7E:
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_27E8A
		neg.w	d0
		add.w	d1,d0

loc_27E8A:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_x_pos(a0)
		rts
; ===========================================================================

loc_27E96:
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	loc_27EAC
; ===========================================================================

loc_27EA2:
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

loc_27EAC:
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_27EB8
		neg.w	d0
		add.w	d1,d0

loc_27EB8:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,ost_y_pos(a0)
		rts
; ===========================================================================

loc_27EC4:
		move.b	($FFFFFE60).w,d0
		lsr.w	#1,d0
		add.w	$30(a0),d0
		move.w	d0,ost_y_pos(a0)
		move.b	ost_primary_status(a0),d1
		andi.b	#$18,d1
		beq.s	locret_27EE0
		addq.b	#1,ost_subtype(a0)

locret_27EE0:
		rts
; ===========================================================================

loc_27EE2:
		move.l	ost_y_pos(a0),d3
		move.w	ost_y_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,ost_y_pos(a0)
		addi_.w	#8,ost_y_vel(a0)
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	locret_27F0E
		move.b	#0,ost_subtype(a0)

locret_27F0E:
		rts
; ===========================================================================

loc_27F10:
		tst.b	$38(a0)
		bne.s	loc_27F26
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_27F4C
		move.b	#8,$38(a0)

loc_27F26:
		jsrto	SpeedToPos,JmpTo14_SpeedToPos
		andi.w	#$7FF,ost_y_pos(a0)
		cmpi.w	#$2A8,ost_y_vel(a0)
		bne.s	loc_27F3C
		neg.b	$38(a0)

loc_27F3C:
		move.b	$38(a0),d1
		ext.w	d1
		add.w	d1,ost_y_vel(a0)
		bne.s	locret_27F4C
		clr.b	ost_subtype(a0)

locret_27F4C:
		rts
; ===========================================================================

loc_27F4E:
		move.w	#$10,d1
		moveq	#0,d0
		move.b	($FFFFFE88).w,d0
		lsr.w	#1,d0
		move.w	($FFFFFE8A).w,d3
		bra.s	loc_27F8E
; ===========================================================================

loc_27F60:
		move.w	#$30,d1
		moveq	#0,d0
		move.b	($FFFFFE8C).w,d0
		move.w	($FFFFFE8E).w,d3
		bra.s	loc_27F8E
; ===========================================================================

loc_27F70:
		move.w	#$50,d1
		moveq	#0,d0
		move.b	($FFFFFE90).w,d0
		move.w	($FFFFFE92).w,d3
		bra.s	loc_27F8E
; ===========================================================================

loc_27F80:
		move.w	#$70,d1
		moveq	#0,d0
		move.b	($FFFFFE94).w,d0
		move.w	($FFFFFE96).w,d3

loc_27F8E:
		tst.w	d3
		bne.s	loc_27F9C
		addq.b	#1,$2E(a0)
		andi.b	#3,$2E(a0)

loc_27F9C:
		move.b	$2E(a0),d2
		andi.b	#3,d2
		bne.s	loc_27FBC
		sub.w	d1,d0
		add.w	$34(a0),d0
		move.w	d0,ost_x_pos(a0)
		neg.w	d1
		add.w	$30(a0),d1
		move.w	d1,ost_y_pos(a0)
		rts
; ===========================================================================

loc_27FBC:
		subq.b	#1,d2
		bne.s	loc_27FDA
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,ost_y_pos(a0)
		addq.w	#1,d1
		add.w	$34(a0),d1
		move.w	d1,ost_x_pos(a0)
		rts
; ===========================================================================

loc_27FDA:
		subq.b	#1,d2
		bne.s	loc_27FF8
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	$34(a0),d0
		move.w	d0,ost_x_pos(a0)
		addq.w	#1,d1
		add.w	$30(a0),d1
		move.w	d1,ost_y_pos(a0)
		rts
; ===========================================================================

loc_27FF8:
		sub.w	d1,d0
		add.w	$30(a0),d0

loc_27FFE:
		move.w	d0,ost_y_pos(a0)
		neg.w	d1

loc_28004:
		add.w	$34(a0),d1
		move.w	d1,ost_x_pos(a0)

locret_2800C:
		rts
; ===========================================================================

		include "mappings/sprite/CPZ Stair Block.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo34_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo14_SolidObject:
		jmp	(SolidObject).l
JmpTo4_DespawnObject2:
		jmp	(DespawnObject2).l
JmpTo14_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 6C - MTZ rope platforms (reworked from Sonic 1's SBZ spinning
; conveyer platforms)
; ----------------------------------------------------------------------------

Conveyer:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2805C(pc,d0.w),d1
		jsr	off_2805C(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_28058
		jmpto	DisplaySprite,JmpTo20_DisplaySprite
; ===========================================================================

loc_28058:
		jmpto	Deleteobject,JmpTo34_DeleteObject
; ===========================================================================
off_2805C:	index offset(*),,2
		ptr loc_28060					; 0
		ptr loc_28168					; 2
; ===========================================================================

loc_28060:
		move.b	ost_subtype(a0),d0
		bmi.w	loc_28112
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_ConveyerPlat,ost_mappings(a0)
		move.w	#tile_Nem_RopePlat+tile_pal4,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		jsrto	AdjustVRAM2P,JmpTo35_AdjustVRAM2P
		move.b	#0,ost_frame(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	off_28252(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$38(a0)
		move.l	a2,$3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,$38(a0)
		move.b	#4,$3A(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_280F2
		neg.b	$3A(a0)
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_280EE
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_280EE
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_280EE:
		move.b	d1,$38(a0)

loc_280F2:
		move.w	(a2,d1.w),d0
		add.w	$30(a0),d0
		move.w	d0,$34(a0)
		move.w	2(a2,d1.w),d0
		add.w	$32(a0),d0
		move.w	d0,$36(a0)
		bsr.w	loc_281DA
		bra.w	loc_28168
; ===========================================================================

loc_28112:
		andi.w	#$7F,d0
		add.w	d0,d0
		lea	(off_282D6).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		bra.s	loc_28136
; ===========================================================================

loc_28130:
		jsrto	FindFreeObj,JmpTo8_FindFreeObj
		bne.s	loc_28160

loc_28136:
		_move.b	#id_Conveyer,ost_id(a1)
		move.w	(a2)+,d0
		add.w	d2,d0
		move.w	d0,ost_x_pos(a1)
		move.w	(a2)+,d0
		add.w	d3,d0
		move.w	d0,ost_y_pos(a1)
		move.w	d2,$30(a1)
		move.w	d3,$32(a1)
		move.w	(a2)+,d0
		move.b	d0,ost_subtype(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)

loc_28160:
		dbf	d1,loc_28130
		addq.l	#4,sp
		rts
; ===========================================================================

loc_28168:
		pushr.w	ost_x_pos(a0)
		bsr.w	loc_2817E
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		moveq	#8,d3
		popr.w	d4
		jmpto	DetectPlatform,JmpTo5_DetectPlatform
; ===========================================================================

loc_2817E:
		move.w	ost_x_pos(a0),d0
		cmp.w	$34(a0),d0
		bne.s	loc_281D4
		move.w	ost_y_pos(a0),d0
		cmp.w	$36(a0),d0
		bne.s	loc_281D4
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_281B0
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_281B0
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_281B0:
		move.b	d1,$38(a0)
		movea.l	$3C(a0),a1
		move.w	(a1,d1.w),d0
		add.w	$30(a0),d0
		move.w	d0,$34(a0)
		move.w	2(a1,d1.w),d0
		add.w	$32(a0),d0
		move.w	d0,$36(a0)
		bsr.w	loc_281DA

loc_281D4:
		bsr.w	JmpTo15_SpeedToPos
		rts
; ===========================================================================

loc_281DA:
		moveq	#0,d0
		move.w	#-$100,d2
		move.w	ost_x_pos(a0),d0
		sub.w	$34(a0),d0
		bcc.s	loc_281EE
		neg.w	d0
		neg.w	d2

loc_281EE:
		moveq	#0,d1
		move.w	#-$100,d3
		move.w	ost_y_pos(a0),d1
		sub.w	$36(a0),d1
		bcc.s	loc_28202
		neg.w	d1
		neg.w	d3

loc_28202:
		cmp.w	d0,d1
		bcs.s	loc_2822C
		move.w	ost_x_pos(a0),d0
		sub.w	$34(a0),d0
		beq.s	loc_28218
		ext.l	d0
		asl.l	#8,d0
		divs.w	d1,d0
		neg.w	d0

loc_28218:
		move.w	d0,ost_x_vel(a0)
		move.w	d3,ost_y_vel(a0)
		swap	d0
		move.w	d0,ost_x_sub(a0)
		clr.w	ost_y_sub(a0)
		rts
; ===========================================================================

loc_2822C:
		move.w	ost_y_pos(a0),d1
		sub.w	$36(a0),d1
		beq.s	loc_2823E
		ext.l	d1
		asl.l	#8,d1
		divs.w	d0,d1
		neg.w	d1

loc_2823E:
		move.w	d1,ost_y_vel(a0)
		move.w	d2,ost_x_vel(a0)
		swap	d1
		move.w	d1,ost_y_sub(a0)
		clr.w	ost_x_sub(a0)
		rts
; ===========================================================================
off_28252:	index offset(*)
		ptr byte_28258					; 0
		ptr byte_28282					; 1
		ptr byte_282AC					; 2

byte_28258:
		dc.b   0,$28,  0,  0,  0,  0,$FF,$EA,  0, $A,$FF,$E0,  0,$20,$FF,$E0 ; 0
		dc.b   0,$E0,$FF,$EA,  0,$F6,  0,  0,  1,  0,  0,$16,  0,$F6,  0,$20 ; 16
		dc.b   0,$E0,  0,$20,  0,$20,  0,$16,  0, $A	; 32

byte_28282:
		dc.b   0,$28,  0,  0,  0,  0,$FF,$EA,  0, $A,$FF,$E0,  0,$20,$FF,$E0 ; 0
		dc.b   1,$60,$FF,$EA,  1,$76,  0,  0,  1,$80,  0,$16,  1,$76,  0,$20 ; 16
		dc.b   1,$60,  0,$20,  0,$20,  0,$16,  0, $A	; 32

byte_282AC:
		dc.b   0,$28,  0,  0,  0,  0,$FF,$EA,  0, $A,$FF,$E0,  0,$20,$FF,$E0 ; 0
		dc.b   1,$E0,$FF,$EA,  1,$F6,  0,  0,  2,  0,  0,$16,  1,$F6,  0,$20 ; 16
		dc.b   1,$E0,  0,$20,  0,$20,  0,$16,  0, $A	; 32

off_282D6:	index offset(*)
		ptr byte_282DC					; 0
		ptr byte_2830E					; 1
		ptr byte_28340					; 2

byte_282DC:
		dc.b   0,  7,  0,  0,  0,  0,  0,  1,$FF,$E0,  0,$3A,  0,  3,$FF,$E0 ; 0
		dc.b   0,$80,  0,  3,$FF,$E0,  0,$C6,  0,  3,  0,  0,  1,  0,  0,  6 ; 16
		dc.b   0,$20,  0,$C6,  0,  8,  0,$20,  0,$80,  0,  8,  0,$20,  0,$3A ; 32
		dc.b   0,  8					; 48

byte_2830E:
		dc.b   0,  7,  0,  0,  0,  0,  0,$11,$FF,$E0,  0,$5A,  0,$13,$FF,$E0 ; 0
		dc.b   0,$C0,  0,$13,$FF,$E0,  1,$26,  0,$13,  0,  0,  1,$80,  0,$16 ; 16
		dc.b   0,$20,  1,$26,  0,$18,  0,$20,  0,$C0,  0,$18,  0,$20,  0,$5A ; 32
		dc.b   0,$18					; 48

byte_28340:
		dc.b   0,  7,  0,  0,  0,  0,  0,$21,$FF,$E0,  0,$7A,  0,$23,$FF,$E0 ; 0
		dc.b   1,  0,  0,$23,$FF,$E0,  1,$86,  0,$23,  0,  0,  2,  0,  0,$26 ; 16
		dc.b   0,$20,  1,$86,  0,$28,  0,$20,  1,  0,  0,$28,  0,$20,  0,$7A ; 32
		dc.b   0,$28					; 48
; ===========================================================================

		include "mappings/sprite/MTZ Conveyer Platforms.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo20_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo34_DeleteObject:
		jmp	(DeleteObject).l
JmpTo8_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo35_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo5_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo15_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 6E - MTZ large circling platform
; ----------------------------------------------------------------------------

LargeRotatingPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_283BA(pc,d0.w),d1
		jmp	off_283BA(pc,d1.w)
; ===========================================================================
off_283BA:	index offset(*),,2
		ptr loc_283C8					; 0
		ptr loc_28432					; 2
		ptr loc_284BC					; 4

byte_283C0:
		dc.b $10, $C					; 0
		dc.b $28,  8					; 2
		dc.b $60,$18					; 4
		dc.b  $C, $C					; 6
; ===========================================================================

loc_283C8:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_CirclePlat,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo36_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	byte_283C0(pc,d0.w),a3
		move.b	(a3)+,ost_displaywidth(a0)
		move.b	(a3)+,ost_height(a0)
		lsr.w	#1,d0
		move.b	d0,ost_frame(a0)
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$30(a0)
		cmpi.b	#3,d0
		bne.s	loc_28432
		addq.b	#2,ost_primary_routine(a0)
		move.w	#tile_Nem_WheelIndent+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo36_AdjustVRAM2P
		move.b	#5,ost_priority(a0)
		bra.w	loc_284BC
; ===========================================================================

loc_28432:
		move.w	ost_x_pos(a0),-(sp)
		move.b	($FFFFFE80).w,d1
		subi.b	#$38,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$38,d2
		ext.w	d2
		btst	#0,ost_subtype(a0)
		beq.s	loc_28456
		neg.w	d1
		neg.w	d2

loc_28456:
		btst	#1,ost_subtype(a0)
		beq.s	loc_28462
		neg.w	d1
		exg	d1,d2

loc_28462:
		add.w	$34(a0),d1
		move.w	d1,ost_x_pos(a0)
		add.w	$30(a0),d2
		move.w	d2,ost_y_pos(a0)
		move.w	(sp)+,d4
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo15_SolidObject
		move.w	$34(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_284A4
		jmp	(DisplaySprite).l
; ===========================================================================

loc_284A4:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_284B6
		bclr	#7,2(a2,d0.w)

loc_284B6:
		jmp	(DeleteObject).l
; ===========================================================================

loc_284BC:
		move.b	($FFFFFE80).w,d1
		lsr.b	#1,d1
		subi.b	#$1C,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		lsr.b	#1,d2
		subi.b	#$1C,d2
		ext.w	d2
		btst	#0,ost_subtype(a0)
		beq.s	loc_284E0
		neg.w	d1
		neg.w	d2

loc_284E0:
		btst	#1,ost_subtype(a0)
		beq.s	loc_284EC
		neg.w	d1
		exg	d1,d2

loc_284EC:
		add.w	$34(a0),d1
		move.w	d1,ost_x_pos(a0)
		add.w	$30(a0),d2
		move.w	d2,ost_y_pos(a0)
		move.w	$34(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_28514
		jmp	(DisplaySprite).l
; ===========================================================================

loc_28514:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_28526
		bclr	#7,2(a2,d0.w)

loc_28526:
		jmp	(DeleteObject).l
; ===========================================================================

		include "mappings/sprite/MTZ Large Circling Platform.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo36_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo15_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 70 - MTZ giant cog
; Only the cog teeth are part of this object; the body of the cog is part
; of the level foreground.
; ----------------------------------------------------------------------------

Cog:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_285CE(pc,d0.w),d1
		jmp	off_285CE(pc,d1.w)
; ===========================================================================
off_285CE:	index offset(*),,2
		ptr loc_285D2					; 0
		ptr loc_28652					; 2
; ===========================================================================

loc_285D2:
		moveq	#7,d1
		moveq	#0,d4
		lea	(byte_28726).l,a2
		movea.l	a0,a1
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		bset	#status_broken_bit,ost_primary_status(a0)
		bra.s	loc_285F4
; ===========================================================================

loc_285EE:
		jsrto	FindNextFreeObj,JmpTo14_FindNextFreeObj
		bne.s	loc_2864E

loc_285F4:
		_move.b	ost_id(a0),ost_id(a1)
		addq.b	#2,ost_primary_routine(a1)
		move.l	#Map_CogTeeth,ost_mappings(a1)
		move.w	#tile_Nem_GiantCog+tile_pal4,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo4_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.w	d2,$32(a1)
		move.w	d3,$30(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,ost_x_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	d3,d0
		move.w	d0,ost_y_pos(a1)
		move.b	(a2)+,ost_frame(a1)
		move.w	d4,$34(a1)
		addq.w	#3,d4
		move.b	ost_primary_status(a0),ost_primary_status(a1)

loc_2864E:
		dbf	d1,loc_285EE

loc_28652:
		move.w	ost_x_pos(a0),-(sp)
		move.b	(v_frame_counter_low).w,d0
		move.b	d0,d1
		andi.w	#$F,d0
		bne.s	loc_286CA
		move.w	$36(a0),d1
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_28684
		subi.w	#$18,d1
		bcc.s	loc_286A2
		moveq	#$48,d1
		subq.w	#3,$34(a0)
		bcc.s	loc_286A2
		move.w	#$15,$34(a0)
		bra.s	loc_286A2
; ===========================================================================

loc_28684:
		addi.w	#$18,d1
		cmpi.w	#$60,d1
		bcs.s	loc_286A2
		moveq	#0,d1
		addq.w	#3,$34(a0)
		cmpi.w	#$18,$34(a0)
		bcs.s	loc_286A2
		move.w	#0,$34(a0)

loc_286A2:
		move.w	d1,$36(a0)
		add.w	$34(a0),d1
		lea	byte_28726(pc,d1.w),a1
		move.b	(a1)+,d0
		ext.w	d0
		add.w	$32(a0),d0
		move.w	d0,ost_x_pos(a0)
		move.b	(a1)+,d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,ost_y_pos(a0)
		move.b	(a1)+,ost_frame(a0)

loc_286CA:
		move.b	ost_frame(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		moveq	#0,d1
		moveq	#0,d2
		move.b	byte_28706(pc,d0.w),d1
		move.b	byte_28706+1(pc,d0.w),d2
		move.w	d2,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo16_SolidObject
		move.w	$32(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_28700
		jmp	(DisplaySprite).l
; ===========================================================================

loc_28700:
		jmp	(DeleteObject).l
; ===========================================================================
byte_28706:
		dc.b $10,$10					; 0
		dc.b $10,$10					; 2
		dc.b $10,$10					; 4
		dc.b $10,$10					; 6
		dc.b $10,$10					; 8
		dc.b $10,$10					; 10
		dc.b $10,$10					; 12
		dc.b $10, $C					; 14
		dc.b $10,  8					; 16
		dc.b $10, $C					; 18
		dc.b $10,$10					; 20
		dc.b $10,$10					; 22
		dc.b $10,$10					; 24
		dc.b $10,$10					; 26
		dc.b $10,$10					; 28
		dc.b $10,$10					; 30

byte_28726:
		; initial positions
		; ost_x_pos, ost_y_pos, ost_frame
		dc.b   0,$B8,  0
		dc.b $32,$CE,  4
		dc.b $48,  0,  8
		dc.b $32,$32, $C
		dc.b   0,$48,$10
		dc.b $CE,$32,$14
		dc.b $B8,  0,$18
		dc.b $CE,$CE,$1C

		dc.b  $D,$B8,  1
		dc.b $3F,$DA,  5
		dc.b $48, $C,  9
		dc.b $27,$3C, $D
		dc.b $F3,$48,$11
		dc.b $C1,$26,$15
		dc.b $B8,$F4,$19
		dc.b $D9,$C4,$1D

		dc.b $19,$BC,  2
		dc.b $46,$E9,  6
		dc.b $46,$17, $A
		dc.b $19,$44, $E
		dc.b $E7,$44,$12
		dc.b $BA,$17,$16
		dc.b $BA,$E9,$1A
		dc.b $E7,$BC,$1E

		dc.b $27,$C4,  3
		dc.b $48,$F4,  7
		dc.b $3F,$26, $B
		dc.b  $D,$48, $F
		dc.b $D9,$3C,$13
		dc.b $B8, $C,$17
		dc.b $C1,$DA,$1B
		dc.b $F3,$B8,$1F
		even
; ===========================================================================

		include "mappings/sprite/MTZ Giant Cog.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo14_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo4_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo16_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 72 - CNZ and WFZ conveyor belts
; Invisible object, the visible belt is actually part of the level foreground.
; ----------------------------------------------------------------------------
ConveyerBelt:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Conv_Index(pc,d0.w),d1
		jmp	Conv_Index(pc,d1.w)
; ===========================================================================
Conv_Index:	index offset(*),,2
		ptr loc_2894E					; 0
		ptr loc_28980					; 2
; ===========================================================================

loc_2894E:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$30,$3C(a0)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_28964
		move.w	#$70,$3C(a0)

loc_28964:
		andi.b	#$7F,d0
		lsl.b	#4,d0
		move.b	d0,$38(a0)
		move.w	#2,$36(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_28980
		neg.w	$36(a0)

loc_28980:
		lea	(v_ost_player1).w,a1
		bsr.s	loc_28990
		lea	(v_ost_player2).w,a1
		bsr.s	loc_28990
		jmpto	DespawnObject3,JmpTo5_DespawnObject3
; ===========================================================================

loc_28990:
		moveq	#0,d2
		move.b	$38(a0),d2
		move.w	d2,d3
		add.w	d3,d3
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.s	locret_289CA
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		move.w	$3C(a0),d0
		add.w	d0,d1
		cmp.w	d0,d1
		bcc.s	locret_289CA
		btst	#1,ost_primary_status(a1)
		bne.s	locret_289CA
		move.w	$36(a0),d0
		add.w	d0,ost_x_pos(a1)

locret_289CA:
		rts
; ===========================================================================

	if RemoveJmpTos=0
JmpTo5_DespawnObject3:
		jmp	(DespawnObject3).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 73 - MCZ solid rotating ring thing
; (unused, but can be seen in debug mode)
; ----------------------------------------------------------------------------
MysticCaveRotatingRings:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_289E2(pc,d0.w),d1
		jmp	off_289E2(pc,d1.w)
; ===========================================================================
off_289E2:	index offset(*),,2
		ptr loc_289E8					; 0
		ptr loc_28AD6					; 2
		ptr loc_28B7E					; 4
; ===========================================================================

loc_289E8:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_MCZRotRings,ost_mappings(a0)
		move.w	#tile_Nem_Ring+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo37_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$3A(a0)
		move.w	ost_y_pos(a0),$38(a0)
		move.b	#0,ost_col_type(a0)
		bset	#status_broken_bit,ost_primary_status(a0)
		move.b	ost_subtype(a0),d1
		andi.b	#-$10,d1
		ext.w	d1
		asl.w	#3,d1
		move.w	d1,$3E(a0)
		move.b	ost_primary_status(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,ost_angle(a0)
		lea	$29(a0),a2
		move.b	ost_subtype(a0),d1
		andi.w	#7,d1
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		move.b	d3,$3C(a0)
		subq.w	#1,d1
		bcs.s	loc_28AC8
		btst	#3,ost_subtype(a0)
		beq.s	loc_28A6E
		subq.w	#1,d1
		bcs.s	loc_28AC8

loc_28A6E:
		jsrto	FindFreeObj,JmpTo9_FindFreeObj
		bne.s	loc_28AC8
		addq.b	#1,$29(a0)
		move.w	a1,d5
		subi.w	#-$5000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,ost_primary_routine(a1)
		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	ost_priority(a0),ost_priority(a1)
		move.b	ost_displaywidth(a0),ost_displaywidth(a1)
		move.b	ost_col_type(a0),ost_col_type(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		subi.b	#$10,d3
		move.b	d3,$3C(a1)
		dbf	d1,loc_28A6E

loc_28AC8:
		move.w	a0,d5
		subi.w	#-$5000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+

loc_28AD6:
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	loc_28AF4
		move.w	#8,d1
		move.w	#8,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo17_SolidObject
		bra.w	loc_28B46
; ===========================================================================

loc_28AF4:
		move.w	$3E(a0),d0
		add.w	d0,ost_angle(a0)
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		lea	$29(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_28B16:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#-$5000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	$3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,ost_y_pos(a1)
		move.w	d5,ost_x_pos(a1)
		dbf	d6,loc_28B16
		rts
; ===========================================================================

loc_28B46:
		move.w	$3A(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	loc_28B5E
		jmpto	DisplaySprite,JmpTo21_DisplaySprite
; ===========================================================================

loc_28B5E:
		moveq	#0,d2
		lea	$29(a0),a2
		move.b	(a2)+,d2

loc_28B66:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#-$5000,d0
		movea.l	d0,a1
		jsrto	DeleteChild,JmpTo_DeleteChild
		dbf	d2,loc_28B66
		rts
; ===========================================================================

loc_28B7E:
		move.w	#8,d1
		move.w	#8,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	$36(a0),d4
		bsr.w	JmpTo17_SolidObject
		move.w	ost_x_pos(a0),$36(a0)
		jmpto	DisplaySprite,JmpTo21_DisplaySprite
; ===========================================================================

		include "mappings/sprite/MCZ Rotating Rings.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo21_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo9_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo_DeleteChild:
		jmp	(DeleteChild).l
JmpTo37_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo17_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 75 - MCZ brick and spikeball chain
; ----------------------------------------------------------------------------

BrickAndSpikeChain:
		btst	#render_subsprites_bit,ost_render(a0)
		bne.w	loc_28BE0
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_28BE8(pc,d0.w),d1
		jmp	off_28BE8(pc,d1.w)
; ===========================================================================

loc_28BE0:
		move.w	#$280,d0
		jmpto	DisplaySprite3,JmpTo_DisplaySprite3
; ===========================================================================
off_28BE8:	index offset(*),,2
		ptr loc_28BEE					; 0
		ptr loc_28CCA					; 2
		ptr loc_28D6C					; 4
; ===========================================================================

loc_28BEE:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_BrckSpkChn,ost_mappings(a0)
		move.w	#tile_LevelArt+tile_pal2,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo38_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#5,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.b	ost_subtype(a0),d1
		move.b	d1,d0
		andi.w	#$F,d1
		andi.b	#-$10,d0
		ext.w	d0
		asl.w	#3,d0
		move.w	d0,$34(a0)
		move.b	ost_primary_status(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,ost_angle(a0)
		cmpi.b	#$F,d1
		bne.s	loc_28C5E
		addq.b	#2,ost_primary_routine(a0)
		move.b	#4,ost_priority(a0)
		move.b	#id_Frame_Bricks,ost_frame(a0)
		rts
; ===========================================================================

loc_28C5E:
		move.b	#id_col_12x12+id_col_hurt,ost_col_type(a0)
		jsrto	FindNextFreeObj,JmpTo15_FindNextFreeObj
		bne.s	loc_28CCA
		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#$40,ost_mainspr_width(a1)
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		move.b	d1,ost_mainspr_childsprites(a1)
		subq.w	#1,d1
		lea	ost_subspr2_x_pos(a1),a2

loc_28CA0:
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	#1,(a2)+
		dbf	d1,loc_28CA0
		move.w	d2,ost_x_pos(a1)
		move.w	d3,ost_y_pos(a1)
		move.b	#id_Frame_Spikeball,ost_mainspr_frame(a1)
		move.l	a1,$3C(a0)
		move.b	#$40,ost_mainspr_height(a1)
		bset	#render_useheight_bit,ost_render(a1)

loc_28CCA:
		moveq	#0,d0
		moveq	#0,d1
		move.w	$34(a0),d0
		add.w	d0,ost_angle(a0)
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo8_CalcSine
		move.w	$32(a0),d2
		move.w	$30(a0),d3
		moveq	#0,d6
		movea.l	$3C(a0),a1
		move.b	ost_mainspr_childsprites(a1),d6
		subq.w	#1,d6
		bcs.s	loc_28D3E
		swap	d0
		swap	d1
		asr.l	#4,d0
		asr.l	#4,d1
		moveq	#0,d4
		moveq	#0,d5
		lea	ost_subspr2_x_pos(a1),a2

loc_28D04:
		movem.l	d4-d5,-(sp)
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,(a2)+
		move.w	d4,(a2)+
		movem.l	(sp)+,d4-d5
		add.l	d0,d4
		add.l	d1,d5
		addq.w	#next_subspr-4,a2
		dbf	d6,loc_28D04
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,ost_x_pos(a0)
		move.w	d4,ost_y_pos(a0)
		move.w	ost_subspr6_x_pos(a1),ost_x_pos(a1)
		move.w	ost_subspr6_y_pos(a1),ost_y_pos(a1)

loc_28D3E:
		tst.w	(f_two_player).w
		beq.s	loc_28D48
		jmpto	DisplaySprite,JmpTo22_DisplaySprite
; ===========================================================================

loc_28D48:
		move.w	$30(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	loc_28D60
		jmpto	DisplaySprite,JmpTo22_DisplaySprite
; ===========================================================================

loc_28D60:
		movea.l	$3C(a0),a1
		jsrto	DeleteChild,JmpTo2_DeleteChild
		jmpto	DeleteObject,JmpTo38_DeleteObject
; ===========================================================================

loc_28D6C:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo18_SolidObject
		jmpto	DespawnObject,JmpTo22_DespawnObject
; ===========================================================================

		include "mappings/sprite/MCZ Spikeball on Chain.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_DisplaySprite3:
		jmp	(DisplaySprite3).l
JmpTo22_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo38_DeleteObject:
		jmp	(DeleteObject).l
JmpTo22_DespawnObject:
		jmp	(DespawnObject).l
JmpTo2_DeleteChild:
		jmp	(DeleteChild).l
JmpTo15_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo38_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo8_CalcSine:
		jmp	(CalcSine).l
JmpTo18_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 76 - MCZ sliding spike block
; ----------------------------------------------------------------------------

SlidingSpikePlat:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SlidSpks_Index(pc,d0.w),d1
		jmp	SlidSpks_Index(pc,d1.w)
; ===========================================================================
SlidSpks_Index:	index offset(*),,2
		ptr loc_28E0E					; 0
		ptr loc_28E5E					; 2

SlidSpks_InitData:
		dc.b $40					; 0
		dc.b $10					; 1
		dc.b   0					; 2
		even
; ===========================================================================

loc_28E0E:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SlidSpks,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo39_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)

		; It seems that at one point this object was going to have different sizes determined
		; by subtype, with these five lines fetching the appropriate height, width, and mapping
		; frame from an array. This was apparently never implemented, rendering these lines
		; pointless. They could be replaced with "lea SlidSpks_InitData(pc),a2".
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	SlidSpks_InitData(pc,d0.w),a2
		move.b	(a2)+,ost_displaywidth(a0)
		move.b	(a2)+,ost_height(a0)
		move.b	(a2)+,ost_frame(a0)
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$30(a0)
		andi.w	#$F,ost_subtype(a0)

loc_28E5E:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.w	SlidSpks_Modes(pc,d0.w),d1
		jsr	SlidSpks_Modes(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	ost_render(a0)
		bpl.s	loc_28EC2
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo19_SolidObject
		swap	d6
		andi.w	#3,d6
		beq.s	loc_28EC2
		move.b	d6,d0
		andi.b	#1,d0
		beq.s	loc_28EAE
		lea	($FFFFB000).w,a1
		jsrto	React_ChkHurt2,JmpTo_React_ChkHurt2
		bclr	#5,ost_primary_status(a0)

loc_28EAE:
		andi.b	#2,d6
		beq.s	loc_28EC2
		lea	($FFFFB040).w,a1
		jsrto	React_ChkHurt2,JmpTo_React_ChkHurt2
		bclr	#status_underwater_bit,ost_primary_status(a0)

loc_28EC2:
		move.w	$34(a0),d0
		jmpto	DespawnObject2,JmpTo5_DespawnObject2
; ===========================================================================
SlidSpks_Modes:	index offset(*),,2
		ptr SlidSpks_ChkPlayer				; 0
		ptr SlidSpks_SlideOut				; 2
; ===========================================================================

SlidSpks_ChkPlayer:
		lea	(v_ost_player1).w,a1
		bsr.s	loc_28ED8
		lea	(v_ost_player2).w,a1

loc_28ED8:
		btst	#1,ost_primary_status(a1)
		bne.s	locret_28F1C
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$C0,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_28EF8
		subi.w	#$100,d0

loc_28EF8:
		cmpi.w	#$80,d0
		bcc.s	locret_28F1C
		move.w	ost_y_pos(a1),d0
		sub.w	ost_y_pos(a0),d0
		addi.w	#$10,d0
		cmpi.w	#$20,d0
		bcc.s	locret_28F1C
		move.b	#id_SlidSpks_SlideOut,ost_subtype(a0)
		move.w	#$80,$36(a0)

locret_28F1C:
		rts
; ===========================================================================

SlidSpks_SlideOut:
		tst.w	$36(a0)
		beq.s	locret_28F38
		subq.w	#1,$36(a0)
		moveq	#-1,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_28F34
		neg.w	d0

loc_28F34:
		add.w	d0,ost_x_pos(a0)

locret_28F38:
		rts
; ===========================================================================

		include "mappings/sprite/MCZ Sliding Spike Block.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_React_ChkHurt2:
		jmp	(React_ChkHurt2).l
JmpTo39_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo19_SolidObject:
		jmp	(SolidObject).l
JmpTo5_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 77 - MCZ double-leaf bridge (opens downward in two parts)
; ----------------------------------------------------------------------------

DoubleDrawbridge:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_28F96(pc,d0.w),d1
		jmp	off_28F96(pc,d1.w)
; ===========================================================================
off_28F96:	index offset(*),,2
		ptr loc_28F9A					; 0
		ptr loc_28FBC					; 2
; ===========================================================================

loc_28F9A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_DBridge,ost_mappings(a0)
		move.w	#tile_Nem_DrawbridgeLogs+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo40_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#-$80,ost_displaywidth(a0)

loc_28FBC:
		tst.b	$34(a0)
		bne.s	loc_28FF0
		lea	(v_button_state).w,a2
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_28FF0
		move.b	#1,$34(a0)
		bchg	#0,ost_anim(a0)
		tst.b	ost_render(a0)
		bpl.s	loc_28FF0
		move.w	#$BB,d0
		jsr	(PlaySound).l

loc_28FF0:
		lea	(Ani_DBridge).l,a1			; could be PC relative
		jsr	(AnimateSprite).l
		tst.b	ost_frame(a0)
		bne.s	loc_2901A
		move.w	#$4B,d1
		move.w	#8,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo20_SolidObject
		jmpto	DespawnObject,JmpTo23_DespawnObject
; ===========================================================================

loc_2901A:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	loc_2904C
		move.b	d0,d1
		andi.b	#8,d0
		beq.s	loc_29036
		lea	($FFFFB000).w,a1
		bclr	#3,ost_primary_status(a1)

loc_29036:
		andi.b	#$10,d1
		beq.s	loc_29046
		lea	($FFFFB040).w,a1
		bclr	#3,ost_primary_status(a1)

loc_29046:
		andi.b	#-$19,ost_primary_status(a0)

loc_2904C:
		jmpto	DespawnObject,JmpTo23_DespawnObject
; ===========================================================================

Ani_DBridge:	index offset(*)
		ptr Ani_DBridge_Close				; 0
		ptr Ani_DBridge_Open				; 1

Ani_DBridge_Close:
		dc.b   3,  4,  3,  2,  1,  0,$FE,  1

Ani_DBridge_Open:
		dc.b   3,  0,  1,  2,  3,  4,$FE,  1

; ===========================================================================

		include "mappings/sprite/MCZ Double-Leaf Drawridge.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo23_DespawnObject:
		jmp	(DespawnObject).l
JmpTo40_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo20_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 78 - CPZ stair blocks
; ----------------------------------------------------------------------------

StairBlocks:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_291E2(pc,d0.w),d1
		jsr	off_291E2(pc,d1.w)
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo6_DespawnObject2
; ===========================================================================
off_291E2:	index offset(*),,2
		ptr loc_291E8					; 0
		ptr loc_2926C					; 2
		ptr loc_29280					; 4
; ===========================================================================

loc_291E8:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#$34,d3
		moveq	#2,d4
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_291FC
		moveq	#$3A,d3
		moveq	#-2,d4

loc_291FC:
		move.w	ost_x_pos(a0),d2
		movea.l	a0,a1
		moveq	#4-1,d1
		bra.s	loc_29214
; ===========================================================================

loc_29206:
		jsrto	FindNextFreeObj,JmpTo16_FindNextFreeObj
		bne.w	loc_2926C
		move.b	#4,ost_primary_routine(a1)

loc_29214:
		_move.b	ost_id(a0),ost_id(a1)
		move.l	#Map_StairBlock,ost_mappings(a1)
		move.w	#tile_Nem_StairBlock+tile_pal4,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo5_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	ost_subtype(a0),ost_subtype(a1)
		move.w	d2,ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_x_pos(a0),$30(a1)
		move.w	ost_y_pos(a1),$32(a1)
		addi.w	#$20,d2
		move.b	d3,$2F(a1)
		move.l	a0,$3C(a1)
		add.b	d4,d3
		dbf	d1,loc_29206

loc_2926C:
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	off_292B8(pc,d0.w),d1
		jsr	off_292B8(pc,d1.w)

loc_29280:
		movea.l	$3C(a0),a2
		moveq	#0,d0
		move.b	$2F(a0),d0
		move.w	(a2,d0.w),d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo21_SolidObject
		swap	d6
		or.b	d6,$2E(a2)
		rts
; ===========================================================================
off_292B8:	index offset(*)
		ptr loc_292C8					; 0
		ptr loc_29334					; 1
		ptr loc_292EC					; 2
		ptr loc_29334					; 3
		ptr loc_292C8					; 4
		ptr loc_2935E					; 5
		ptr loc_292EC					; 6
		ptr loc_2935E					; 7
; ===========================================================================

loc_292C8:
		tst.w	$2C(a0)
		bne.s	loc_292E0
		move.b	$2E(a0),d0
		andi.b	#$30,d0
		beq.s	locret_292DE
		move.w	#$1E,$2C(a0)

locret_292DE:
		rts
; ===========================================================================

loc_292E0:
		subq.w	#1,$2C(a0)
		bne.s	locret_292DE
		addq.b	#1,ost_subtype(a0)
		rts
; ===========================================================================

loc_292EC:
		tst.w	$2C(a0)
		bne.s	loc_29304
		move.b	$2E(a0),d0
		andi.b	#$C,d0
		beq.s	locret_29302
		move.w	#$3C,$2C(a0)

locret_29302:
		rts
; ===========================================================================

loc_29304:
		subq.w	#1,$2C(a0)
		bne.s	loc_29310
		addq.b	#1,ost_subtype(a0)
		rts
; ===========================================================================

loc_29310:
		lea	$34(a0),a1
		move.w	$2C(a0),d0
		lsr.b	#2,d0
		andi.b	#1,d0
		move.w	d0,(a1)+
		eori.b	#1,d0
		move.w	d0,(a1)+
		eori.b	#1,d0
		move.w	d0,(a1)+
		eori.b	#1,d0
		move.w	d0,(a1)+
		rts
; ===========================================================================

loc_29334:
		lea	$34(a0),a1
		cmpi.w	#$80,(a1)
		beq.s	locret_2935C
		addq.w	#1,(a1)
		moveq	#0,d1
		move.w	(a1)+,d1
		swap	d1
		lsr.l	#1,d1
		move.l	d1,d2
		lsr.l	#1,d1
		move.l	d1,d3
		add.l	d2,d3
		swap	d1
		swap	d2
		swap	d3
		move.w	d3,(a1)+
		move.w	d2,(a1)+
		move.w	d1,(a1)+

locret_2935C:
		rts
; ===========================================================================

loc_2935E:
		lea	$34(a0),a1
		cmpi.w	#-$80,(a1)
		beq.s	locret_29386
		subq.w	#1,(a1)
		moveq	#0,d1
		move.w	(a1)+,d1
		swap	d1
		asr.l	#1,d1
		move.l	d1,d2
		asr.l	#1,d1
		move.l	d1,d3
		add.l	d2,d3
		swap	d1
		swap	d2
		swap	d3
		move.w	d3,(a1)+
		move.w	d2,(a1)+
		move.w	d1,(a1)+

locret_29386:
		rts
; ===========================================================================

	if RemoveJmpTos=0
JmpTo16_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo5_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo21_SolidObject:
		jmp	(SolidObject).l
JmpTo6_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 7A - CPZ rail platform and MCZ small horizontally moving platform
; ----------------------------------------------------------------------------

TrackPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TrackPlat_Index(pc,d0.w),d1
		jmp	TrackPlat_Index(pc,d1.w)
; ===========================================================================
TrackPlat_Index:	index offset(*),,2
		ptr loc_293CC					; 0
		ptr loc_2948E					; 2
		ptr loc_294EA					; 4

byte_293B4:
		dc.b   0					; 0
		dc.b $68					; 1
		dc.b $FF					; 2
		dc.b $98					; 3
		dc.b   0					; 4
		dc.b   0					; 5

		dc.b   1					; 6
		dc.b $A8					; 7
		dc.b $FF					; 8
		dc.b $50					; 9
		dc.b   0					; 10
		dc.b $40					; 11

		dc.b   1					; 12
		dc.b $E8					; 13
		dc.b $FF					; 14
		dc.b $80					; 15
		dc.b   0					; 16
		dc.b $80					; 17

		dc.b   0					; 18
		dc.b $68					; 19
		dc.b   0					; 20
		dc.b $67					; 21
		dc.b   0					; 22
		dc.b   0					; 23
; ===========================================================================

loc_293CC:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_TrackPlat,ost_mappings(a0)
		move.w	#tile_Nem_StairBlock+tile_pal4+tile_hi,ost_tile(a0)
		cmpi.b	#id_MCZ,(v_zone).w
		bne.s	loc_293F4
		move.l	#Map_Swing_Track_CPZ_MCZ,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)

loc_293F4:
		jsrto	AdjustVRAM2P,JmpTo41_AdjustVRAM2P
		moveq	#0,d1
		move.b	ost_subtype(a0),d1
		lea	byte_293B4(pc,d1.w),a2
		move.b	(a2)+,d1
		movea.l	a0,a1
		bra.s	loc_29426
; ===========================================================================

loc_29408:
		jsrto	FindNextFreeObj,JmpTo17_FindNextFreeObj
		bne.s	loc_2944A
		_move.b	ost_id(a0),ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

loc_29426:
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$18,ost_displaywidth(a1)
		move.w	ost_x_pos(a1),$30(a1)

loc_2944A:
		dbf	d1,loc_29408
		move.l	a0,$3C(a1)
		move.l	a1,$3C(a0)
		cmpi.b	#$C,ost_subtype(a0)
		bne.s	loc_29464
		move.b	#1,$36(a0)

loc_29464:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	$30(a0),d0
		sub.w	d1,d0
		move.w	d0,$32(a0)
		move.w	d0,$32(a1)
		add.w	d1,d0
		add.w	d1,d0
		move.w	d0,$34(a0)
		move.w	d0,$34(a1)
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a0)
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a1)

loc_2948E:
		bsr.s	loc_294F4
		tst.w	(f_two_player).w
		beq.s	loc_2949A
		jmpto	DisplaySprite,JmpTo24_DisplaySprite
; ===========================================================================

loc_2949A:
		move.w	$32(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bls.s	loc_294BE
		move.w	$34(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_294C4

loc_294BE:
		jmp	(DisplaySprite).l
; ===========================================================================

loc_294C4:
		movea.l	$3C(a0),a1
		cmpa.l	a0,a1
		beq.s	loc_294D2
		jsr	(DeleteChild).l

loc_294D2:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_294E4
		bclr	#7,2(a2,d0.w)

loc_294E4:
		jmp	(DeleteObject).l
; ===========================================================================

loc_294EA:
		bsr.s	loc_294F4
		bsr.s	loc_2953E
		jmp	(DisplaySprite).l
; ===========================================================================

loc_294F4:
		move.w	ost_x_pos(a0),-(sp)
		tst.b	$36(a0)
		beq.s	loc_29516
		move.w	ost_x_pos(a0),d0
		subq.w	#1,d0
		cmp.w	$32(a0),d0
		bne.s	loc_29510
		move.b	#0,$36(a0)

loc_29510:
		move.w	d0,ost_x_pos(a0)
		bra.s	loc_2952C
; ===========================================================================

loc_29516:
		move.w	ost_x_pos(a0),d0
		addq.w	#1,d0
		cmp.w	$34(a0),d0
		bne.s	loc_29528
		move.b	#1,$36(a0)

loc_29528:
		move.w	d0,ost_x_pos(a0)

loc_2952C:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		move.w	#8,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform,JmpTo6_DetectPlatform
		rts
; ===========================================================================

loc_2953E:
		movea.l	$3C(a0),a1
		move.w	ost_x_pos(a0),d0
		subi.w	#$18,d0
		move.w	ost_x_pos(a1),d2
		addi.w	#$18,d2
		cmp.w	d0,d2
		bne.s	locret_29562
		eori.b	#1,$36(a0)
		eori.b	#1,$36(a1)

locret_29562:
		rts
; ===========================================================================

		include "mappings/sprite/CPZ Track Platform and MCZ Small Moving Platform.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo24_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo17_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo41_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo6_DetectPlatform:
		jmp	(DetectPlatform).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 7B - CPZ spin tube exit lid and spring
; ----------------------------------------------------------------------------

SpinTubeLid:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TubeLid_Index(pc,d0.w),d1
		jsr	TubeLid_Index(pc,d1.w)
		tst.w	(f_two_player).w
		beq.s	loc_295A8
		jmpto	DisplaySprite,JmpTo25_DisplaySprite
; ===========================================================================

loc_295A8:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	JmpTo40_DeleteObject
		jmpto	DisplaySprite,JmpTo25_DisplaySprite

    if RemoveJmpTos
JmpTo40_DeleteObject:
		jmp	(DeleteObject).l
    endc
; ===========================================================================
TubeLid_Index:	index offset(*),,2
		ptr loc_295C8					; 0
		ptr loc_295FE					; 2
byte_295C4:
		; Speed applied on Sonic
		dc.w -$1000
		dc.w  -$A80
; ===========================================================================

loc_295C8:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_TubeLid,ost_mappings(a0)
		move.w	#tile_Nem_TubeLid,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	ost_subtype(a0),d0
		andi.w	#2,d0
		move.w	byte_295C4(pc,d0.w),$30(a0)
		jsrto	AdjustVRAM2P,JmpTo42_AdjustVRAM2P

loc_295FE:
		cmpi.b	#1,ost_frame(a0)
		beq.s	loc_29648
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	ost_x_pos(a0),d4
		lea	(v_ost_player1).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo4_SolidObject_NoRenderChk_SingleCharacter
		btst	#3,ost_primary_status(a0)
		beq.s	loc_29630
		bsr.w	loc_296C2

loc_29630:
		movem.l	(sp)+,d1-d4
		lea	(v_ost_player2).w,a1
		moveq	#4,d6
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo4_SolidObject_NoRenderChk_SingleCharacter
		btst	#4,ost_primary_status(a0)
		beq.s	loc_29648
		bsr.s	loc_296C2

loc_29648:
		move.w	ost_x_pos(a0),d4
		move.w	d4,d5
		subi.w	#$10,d4
		addi.w	#$10,d5
		move.w	ost_y_pos(a0),d2
		move.w	d2,d3
		addi.w	#$30,d3
		move.w	($FFFFB008).w,d0
		cmp.w	d4,d0
		bcs.s	loc_29686
		cmp.w	d5,d0
		bcc.s	loc_29686
		move.w	($FFFFB00C).w,d0
		cmp.w	d2,d0
		bcs.s	loc_29686
		cmp.w	d3,d0
		bcc.s	loc_29686
		cmpi.b	#2,ost_anim_restart(a0)
		beq.s	loc_29686
		move.b	#2,ost_anim(a0)

loc_29686:
		move.w	($FFFFB048).w,d0
		cmp.w	d4,d0
		bcs.s	loc_296B6
		cmp.w	d5,d0
		bcc.s	loc_296B6
		move.w	($FFFFB04C).w,d0
		cmp.w	d2,d0
		bcs.s	loc_296B6
		cmp.w	d3,d0
		bcc.s	loc_296B6
		cmpi.w	#4,(v_tails_cpu_routine).w
		beq.w	loc_296B6
		cmpi.b	#3,ost_anim_restart(a0)
		beq.s	loc_296B6
		move.b	#3,ost_anim(a0)

loc_296B6:
		lea	(Ani_TubeLid).l,a1
		jmpto	AnimateSprite,JmpTo8_AnimateSprite
; ===========================================================================
		rts						; dead code
; ===========================================================================

loc_296C2:
		move.w	#$100,ost_anim(a0)
		addq.w	#4,ost_y_pos(a1)
		move.w	$30(a0),ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#$10,ost_anim(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_296F6
		move.w	#0,ost_x_vel(a1)

loc_296F6:
		btst	#0,d0
		beq.s	loc_29736
		move.w	#1,ost_inertia(a1)
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#0,$2C(a1)
		move.b	#4,$2D(a1)
		btst	#1,d0
		bne.s	loc_29726
		move.b	#1,$2C(a1)

loc_29726:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_29736
		neg.b	ost_flip_angle(a1)
		neg.w	ost_inertia(a1)

loc_29736:
		andi.b	#$C,d0
		cmpi.b	#4,d0
		bne.s	loc_2974C
		move.b	#$C,$3E(a1)
		move.b	#$D,$3F(a1)

loc_2974C:
		cmpi.b	#8,d0
		bne.s	loc_2975E
		move.b	#$E,$3E(a1)
		move.b	#$F,$3F(a1)

loc_2975E:
		move.w	#sfx_Spring,d0
		jmp	(PlaySound).l
; ===========================================================================
Ani_TubeLid:	index offset(*)
		ptr byte_29770					; 0
		ptr byte_29773					; 1
		ptr byte_29777					; 2
		ptr byte_29777					; 3

byte_29770:
		dc.b  $F,  0,$FF				; 0
		rev02even

byte_29773:
		dc.b   0,  3,$FD,  0
		rev02even

byte_29777:
		dc.b   5,  1,  2,  2,  2,  4,$FD,  0
		even
; ===========================================================================

		include "mappings/sprite/CPZ Spin Tube Lid.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo25_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo40_DeleteObject:
		jmp	(DeleteObject).l
JmpTo8_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo42_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo4_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 7F - MCZ vine switch
; ----------------------------------------------------------------------------

VineSwitch:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_297F2(pc,d0.w),d1
		jmp	off_297F2(pc,d1.w)
; ===========================================================================
off_297F2:	index offset(*),,2
		ptr loc_297F6					; 0
		ptr loc_2981E					; 2
; ===========================================================================

loc_297F6:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_VineSwitch,ost_mappings(a0)
		move.w	#tile_Nem_VineSwitch+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo43_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)

loc_2981E:
		lea	$30(a0),a2
		lea	(v_ost_player1).w,a1
		move.w	(v_joypad_hold_actual).w,d0
		bsr.s	loc_2983C
		lea	(v_ost_player2).w,a1
		addq.w	#1,a2
		move.w	(v_joypad2_hold_actual).w,d0
		bsr.s	loc_2983C
		jmpto	DespawnObject,JmpTo24_DespawnObject
; ===========================================================================

loc_2983C:
		tst.b	(a2)
		beq.s	loc_29890
		andi.b	#$70,d0
		beq.w	locret_29936
		clr.b	$2A(a1)
		clr.b	(a2)
		move.b	#$12,2(a2)
		andi.w	#$F00,d0
		beq.s	loc_29860
		move.b	#$3C,2(a2)

loc_29860:
		move.w	#-$300,ost_y_vel(a1)
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lea	(v_button_state).w,a3
		lea	(a3,d0.w),a3
		bclr	#0,(a3)

loc_2987A:
		move.b	#id_Frame_VSwitch_Idle,ost_frame(a0)
		tst.w	$30(a0)
		beq.s	loc_2988C
		move.b	#id_Frame_VSwitch_Pulled,ost_frame(a0)

loc_2988C:
		bra.w	locret_29936
; ===========================================================================

loc_29890:
		tst.b	2(a2)
		beq.s	loc_2989E
		subq.b	#1,2(a2)
		bne.w	locret_29936

loc_2989E:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$C,d0
		cmpi.w	#$18,d0
		bcc.w	locret_29936
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		subi.w	#$28,d1
		cmpi.w	#$10,d1
		bcc.w	locret_29936
		tst.b	$2A(a1)
		bmi.s	locret_29936
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_29936
		tst.w	(v_debug_active).w
		bne.s	locret_29936
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		clr.w	ost_inertia(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$30,ost_y_pos(a1)
		move.b	#$14,ost_anim(a1)
		move.b	#1,$2A(a1)
		move.b	#1,(a2)
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lea	(v_button_state).w,a3
		bset	#0,(a3,d0.w)
		move.w	#$CD,d0
		jsr	(PlaySound).l
		move.b	#0,ost_frame(a0)
		tst.w	$30(a0)
		beq.s	locret_29936
		move.b	#1,ost_frame(a0)

locret_29936:
		rts
; ===========================================================================

		include "mappings/sprite/MCZ Vine Switch.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo24_DespawnObject:
		jmp	(DespawnObject).l
JmpTo43_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 80 - MCZ ascending/descending vines and WFZ crane hooks
; ----------------------------------------------------------------------------

VineHook:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	VineHook_Index(pc,d0.w),d1
		jmp	VineHook_Index(pc,d1.w)
; ===========================================================================
VineHook_Index:	index offset(*),,2
		ptr VineHook_Main				; 0
		ptr VineHook_Vine				; 2
		ptr VineHook_Hook				; 4
; ===========================================================================

VineHook_Main:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.b	#-$80,ost_height(a0)
		bset	#render_useheight_bit,ost_render(a0)
		move.w	ost_y_pos(a0),$3C(a0)
		cmpi.b	#id_WFZ,(v_zone).w
		bne.s	loc_29A1C
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Hook,ost_mappings(a0)
		move.w	#(tile_Nem_Hook+4)+tile_pal2,ost_tile(a0) ; +4 is workaround for bugged mappings
		jsrto	AdjustVRAM2P,JmpTo44_AdjustVRAM2P
		move.w	#$A0,$2E(a0)
		move.b	ost_subtype(a0),d0
		move.b	d0,d1
		andi.b	#$F,d0
		beq.s	loc_299EE
		move.w	#$60,$2E(a0)

loc_299EE:
		move.b	ost_subtype(a0),d0
		move.w	#2,$3A(a0)
		andi.b	#$70,d1
		beq.s	loc_29A18
		move.w	$2E(a0),d0
		move.w	d0,$38(a0)
		move.b	#1,$36(a0)
		add.w	d0,ost_y_pos(a0)
		lsr.w	#4,d0
		addq.w	#1,d0
		move.b	d0,ost_frame(a0)

loc_29A18:
		bra.w	VineHook_Hook
; ===========================================================================

loc_29A1C:
		move.l	#Map_VinePulley,ost_mappings(a0)
		move.w	#tile_Nem_VinePulley+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo44_AdjustVRAM2P
		move.w	#$B0,$2E(a0)
		move.b	ost_subtype(a0),d0
		bpl.s	loc_29A40
		move.b	#1,$34(a0)

loc_29A40:
		move.w	#2,$3A(a0)
		andi.b	#$70,d0
		beq.s	VineHook_Vine
		move.w	$2E(a0),d0
		move.w	d0,$38(a0)
		move.b	#1,$36(a0)
		add.w	d0,ost_y_pos(a0)
		lsr.w	#5,d0
		addq.w	#1,d0
		move.b	d0,ost_frame(a0)

VineHook_Vine:
		tst.b	$36(a0)
		beq.s	loc_29A74
		tst.w	$30(a0)
		bne.s	loc_29A8A
		bra.s	loc_29A7A
; ===========================================================================

loc_29A74:
		tst.w	$30(a0)
		beq.s	loc_29A8A

loc_29A7A:
		move.w	$38(a0),d2
		cmp.w	$2E(a0),d2
		beq.s	loc_29AAE
		add.w	$3A(a0),d2
		bra.s	loc_29A94
; ===========================================================================

loc_29A8A:
		move.w	$38(a0),d2
		beq.s	loc_29AAE
		sub.w	$3A(a0),d2

loc_29A94:
		move.w	d2,$38(a0)
		move.w	$3C(a0),d0
		add.w	d2,d0
		move.w	d0,ost_y_pos(a0)
		move.w	d2,d0
		beq.s	loc_29AAA
		lsr.w	#5,d0
		addq.w	#1,d0

loc_29AAA:
		move.b	d0,ost_frame(a0)

loc_29AAE:
		lea	$30(a0),a2
		lea	(v_ost_player1).w,a1
		move.w	(v_joypad_hold_actual).w,d0
		bsr.s	loc_29ACC
		lea	(v_ost_player2).w,a1
		addq.w	#1,a2
		move.w	(v_joypad2_hold_actual).w,d0
		bsr.s	loc_29ACC
		jmpto	DespawnObject,JmpTo25_DespawnObject
; ===========================================================================

loc_29ACC:
		tst.b	(a2)
		beq.w	loc_29B5E
		tst.b	ost_render(a1)
		bpl.s	loc_29B42
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	loc_29B42
		andi.b	#$70,d0
		beq.w	loc_29B50
		clr.b	$2A(a1)
		clr.b	(a2)
		move.b	#$12,2(a2)
		andi.w	#$F00,d0
		beq.w	loc_29B02
		move.b	#$3C,2(a2)

loc_29B02:
		btst	#$A,d0
		beq.s	loc_29B0E
		move.w	#-$200,ost_x_vel(a1)

loc_29B0E:
		btst	#$B,d0
		beq.s	loc_29B1A
		move.w	#$200,ost_x_vel(a1)

loc_29B1A:
		move.w	#-$380,ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		tst.b	$34(a0)
		beq.s	locret_29B40
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lea	(v_button_state).w,a3
		lea	(a3,d0.w),a3
		bclr	#0,(a3)

locret_29B40:
		rts
; ===========================================================================

loc_29B42:
		clr.b	$2A(a1)
		clr.b	(a2)
		move.b	#$3C,2(a2)
		rts
; ===========================================================================

loc_29B50:
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$94,ost_y_pos(a1)
		rts
; ===========================================================================

loc_29B5E:
		tst.b	2(a2)
		beq.s	loc_29B6C
		subq.b	#1,2(a2)
		bne.w	locret_29BF8

loc_29B6C:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$10,d0
		cmpi.w	#$20,d0
		bcc.w	locret_29BF8
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		subi.w	#$88,d1
		cmpi.w	#$18,d1
		bcc.w	locret_29BF8
		tst.b	$2A(a1)
		bmi.s	locret_29BF8
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_29BF8
		tst.w	(v_debug_active).w
		bne.s	locret_29BF8
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		clr.w	ost_inertia(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$94,ost_y_pos(a1)
		move.b	#$14,ost_anim(a1)
		move.b	#1,$2A(a1)
		move.b	#1,(a2)
		tst.b	$34(a0)
		beq.s	locret_29BF8
		move.b	ost_subtype(a0),d0
		andi.w	#$F,d0
		lea	(v_button_state).w,a3
		bset	#0,(a3,d0.w)
		move.w	#$CD,d0
		jsr	(PlaySound).l

locret_29BF8:
		rts
; ===========================================================================

VineHook_Hook:
		tst.b	$36(a0)
		beq.s	loc_29C08
		tst.w	$30(a0)
		bne.s	loc_29C1E
		bra.s	loc_29C0E
; ===========================================================================

loc_29C08:
		tst.w	$30(a0)
		beq.s	loc_29C1E

loc_29C0E:
		move.w	$38(a0),d2
		cmp.w	$2E(a0),d2
		beq.s	loc_29C42
		add.w	$3A(a0),d2
		bra.s	loc_29C28
; ===========================================================================

loc_29C1E:
		move.w	$38(a0),d2
		beq.s	loc_29C42
		sub.w	$3A(a0),d2

loc_29C28:
		move.w	d2,$38(a0)
		move.w	$3C(a0),d0
		add.w	d2,d0
		move.w	d0,ost_y_pos(a0)
		move.w	d2,d0
		beq.s	loc_29C3E
		lsr.w	#4,d0
		addq.w	#1,d0

loc_29C3E:
		move.b	d0,ost_frame(a0)

loc_29C42:
		lea	$30(a0),a2
		lea	(v_ost_player1).w,a1
		move.w	(v_joypad_hold_actual).w,d0
		bsr.w	loc_29ACC
		lea	(v_ost_player2).w,a1
		addq.w	#1,a2
		move.w	(v_joypad2_hold_actual).w,d0
		bsr.w	loc_29ACC
		jmpto	DespawnObject,JmpTo25_DespawnObject
; ===========================================================================

		include "mappings/sprite/MCZ Pulley Vines.asm"
		include "mappings/sprite/WFZ Crane Hooks.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo25_DespawnObject:
		jmp	(DespawnObject).l
JmpTo44_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 81 - MCZ drawbridge gate
; ----------------------------------------------------------------------------

SingleDrawbridge:
		btst	#render_subsprites_bit,ost_render(a0)
		bne.w	loc_2A018
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2A020(pc,d0.w),d1
		jmp	off_2A020(pc,d1.w)
; ===========================================================================

loc_2A018:
		move.w	#$280,d0
		jmpto	DisplaySprite3,JmpTo2_DisplaySprite3
; ===========================================================================
off_2A020:	index offset(*),,2
		ptr loc_2A026					; 0
		ptr loc_2A0FE					; 2
		ptr loc_2A18A					; 4
; ===========================================================================

loc_2A026:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SBridge,ost_mappings(a0)
		move.w	#tile_Nem_DrawbridgeLogs+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo45_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#5,ost_priority(a0)
		move.b	#8,ost_displaywidth(a0)
		ori.b	#-$80,ost_primary_status(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		subi.w	#$48,ost_y_pos(a0)
		move.b	#-$40,ost_angle(a0)
		moveq	#-$10,d4
		btst	#1,ost_primary_status(a0)
		beq.s	loc_2A084
		addi.w	#$90,ost_y_pos(a0)
		move.b	#$40,ost_angle(a0)
		neg.w	d4

loc_2A084:
		move.w	#$100,d1
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2A092
		neg.w	d1

loc_2A092:
		move.w	d1,$34(a0)
		jsrto	FindNextFreeObj,JmpTo18_FindNextFreeObj
		bne.s	loc_2A0FE
		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#$40,ost_mainspr_width(a1)
		move.w	$30(a0),d2
		move.w	$32(a0),d3
		moveq	#8,d1
		move.b	d1,ost_mainspr_childsprites(a1)
		subq.w	#1,d1
		lea	ost_subspr2_x_pos(a1),a2

loc_2A0D4:
		add.w	d4,d3
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	#1,(a2)+
		dbf	d1,loc_2A0D4
		move.w	ost_subspr6_x_pos(a1),ost_x_pos(a1)
		move.w	ost_subspr6_y_pos(a1),ost_y_pos(a1)
		move.l	a1,$3C(a0)
		move.b	#$40,ost_mainspr_height(a1)
		bset	#render_useheight_bit,ost_render(a1)

loc_2A0FE:
		lea	(v_button_state).w,a2
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_2A13A
		tst.b	$36(a0)
		bne.s	loc_2A13A
		move.b	#1,$36(a0)
		move.w	#$E7,d0
		jsr	(PlaySound2).l
		cmpi.b	#-$7F,ost_primary_status(a0)
		bne.s	loc_2A13A
		move.w	$30(a0),ost_x_pos(a0)
		subi.w	#$48,ost_x_pos(a0)

loc_2A13A:
		tst.b	$36(a0)
		beq.s	loc_2A188
		move.w	#$48,d1
		tst.b	ost_angle(a0)
		beq.s	loc_2A154
		cmpi.b	#-$80,ost_angle(a0)
		bne.s	loc_2A180
		neg.w	d1

loc_2A154:
		move.w	$32(a0),ost_y_pos(a0)
		move.w	$30(a0),ost_x_pos(a0)
		add.w	d1,ost_x_pos(a0)
		move.b	#$40,ost_displaywidth(a0)
		move.b	#0,$36(a0)
		move.w	#$E9,d0
		jsr	(PlaySound).l
		addq.b	#2,ost_primary_routine(a0)
		bra.s	loc_2A188
; ===========================================================================

loc_2A180:
		move.w	$34(a0),d0
		add.w	d0,ost_angle(a0)

loc_2A188:
		bsr.s	loc_2A1EA

loc_2A18A:
		move.w	#$13,d1
		move.w	#$40,d2
		move.w	#$41,d3
		move.b	ost_angle(a0),d0
		beq.s	loc_2A1A8
		cmpi.b	#$40,d0
		beq.s	loc_2A1B4
		cmpi.b	#-$40,d0
		bcc.s	loc_2A1B4

loc_2A1A8:
		move.w	#$4B,d1
		move.w	#8,d2
		move.w	#9,d3

loc_2A1B4:
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo22_SolidObject
		tst.w	(f_two_player).w
		beq.s	loc_2A1C6
		jmpto	DisplaySprite,JmpTo26_DisplaySprite
; ===========================================================================

loc_2A1C6:
		move.w	$30(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	loc_2A1DE
		jmpto	DisplaySprite,JmpTo26_DisplaySprite
; ===========================================================================

loc_2A1DE:
		movea.l	$3C(a0),a1
		jsrto	DeleteChild,JmpTo3_DeleteChild
		jmpto	DeleteObject,JmpTo41_DeleteObject
; ===========================================================================

loc_2A1EA:
		tst.b	$36(a0)
		beq.s	locret_2A24C
		moveq	#0,d0
		moveq	#0,d1
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo9_CalcSine
		move.w	$32(a0),d2
		move.w	$30(a0),d3
		moveq	#0,d6
		movea.l	$3C(a0),a1
		move.b	ost_mainspr_childsprites(a1),d6
		subq.w	#1,d6
		bcs.s	locret_2A24C
		swap	d0
		swap	d1
		asr.l	#4,d0
		asr.l	#4,d1
		move.l	d0,d4
		move.l	d1,d5
		lea	ost_subspr2_x_pos(a1),a2

loc_2A222:
		movem.l	d4-d5,-(sp)
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,(a2)+
		move.w	d4,(a2)+
		movem.l	(sp)+,d4-d5
		add.l	d0,d4
		add.l	d1,d5
		addq.w	#2,a2
		dbf	d6,loc_2A222
		move.w	ost_subspr6_x_pos(a1),ost_x_pos(a1)
		move.w	ost_subspr6_y_pos(a1),ost_y_pos(a1)

locret_2A24C:
		rts
; ===========================================================================

		include "mappings/sprite/MCZ Single-Leaf Drawbridge.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo2_DisplaySprite3:
		jmp	(DisplaySprite3).l
JmpTo26_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo41_DeleteObject:
		jmp	(DeleteObject).l
JmpTo3_DeleteChild:
		jmp	(DeleteChild).l
JmpTo18_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo45_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo9_CalcSine:
		jmp	(CalcSine).l
JmpTo22_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 82 - ARZ pillar platforms
; ----------------------------------------------------------------------------

PillarPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	PillPlat_Index(pc,d0.w),d1
		jmp	PillPlat_Index(pc,d1.w)
; ===========================================================================
PillPlat_Index:	index offset(*),,2
		ptr PillPlat_Main				; 0
		ptr loc_2A312					; 2

PillPlat_Sizes:
		; ost_displaywidth, ost_height
		; Only the second pair is used.
		dc.b $20					; 0
		dc.b   8					; 1
		dc.b $1C					; 2
		dc.b $30					; 3
		; Unused, and will cause a crash if used,
		; as there is no associated mapping frame.
		dc.b $10					; 4
		dc.b $10					; 5
		dc.b $10					; 6
		dc.b $10					; 7
; ===========================================================================

PillPlat_Main:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_PillPlat,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo46_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	PillPlat_Sizes(pc,d0.w),a2
		move.b	(a2)+,ost_displaywidth(a0)
		move.b	(a2),ost_height(a0)
		lsr.w	#1,d0
		move.b	d0,ost_frame(a0)
		move.w	ost_x_pos(a0),$34(a0)
		move.w	ost_y_pos(a0),$30(a0)
		move.b	ost_subtype(a0),d0
		andi.b	#$F,d0
		beq.s	loc_2A30C
		cmpi.b	#7,d0
		beq.s	loc_2A30C
		move.b	#1,$38(a0)

loc_2A30C:
		andi.b	#$F,ost_subtype(a0)

loc_2A312:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		add.w	d0,d0
		move.w	off_2A358(pc,d0.w),d1
		jsr	off_2A358(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	ost_render(a0)
		bpl.s	loc_2A350
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	ost_height(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsrto	SolidObject,JmpTo23_SolidObject
		swap	d6
		move.b	d6,$3F(a0)
		bsr.w	loc_2A432

loc_2A350:
		move.w	$34(a0),d0
		jmpto	DespawnObject2,JmpTo7_DespawnObject2
; ===========================================================================
off_2A358:	index offset(*)
		ptr locret_2A368				; 0
		ptr loc_2A36A					; 2
		ptr loc_2A392					; 4
		ptr loc_2A36A					; 6
		ptr loc_2A3B6					; 8
		ptr loc_2A3D8					; $A
		ptr loc_2A392					; $C
		ptr loc_2A3EC					; $E
; ===========================================================================

locret_2A368:
		rts
; ===========================================================================

loc_2A36A:
		tst.w	$36(a0)
		bne.s	loc_2A382
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_2A380
		move.w	#$1E,$36(a0)

locret_2A380:
		rts
; ===========================================================================

loc_2A382:
		subq.w	#1,$36(a0)
		bne.s	locret_2A380
		addq.b	#1,ost_subtype(a0)
		clr.b	$38(a0)
		rts
; ===========================================================================

loc_2A392:
		jsrto	SpeedToPos,JmpTo16_SpeedToPos
		addi_.w	#8,ost_y_vel(a0)
		jsrto	FindFloorObj,JmpTo2_FindFloorObj
		tst.w	d1
		bpl.w	locret_2A3B4
		addq.w	#1,d1
		add.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		clr.b	ost_subtype(a0)

locret_2A3B4:
		rts
; ===========================================================================

loc_2A3B6:
		jsrto	SpeedToPos,JmpTo16_SpeedToPos
		subi_.w	#8,ost_y_vel(a0)
		jsrto	FindCeilingObj,JmpTo_FindCeilingObj
		tst.w	d1
		bpl.w	locret_2A3D6
		sub.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		clr.b	ost_subtype(a0)

locret_2A3D6:
		rts
; ===========================================================================

loc_2A3D8:
		move.b	$3F(a0),d0
		andi.b	#3,d0
		beq.s	locret_2A3EA
		addq.b	#1,ost_subtype(a0)
		clr.b	$38(a0)

locret_2A3EA:
		rts
; ===========================================================================

loc_2A3EC:
		move.w	(v_water_height_actual).w,d0
		sub.w	ost_y_pos(a0),d0
		beq.s	locret_2A430
		bcc.s	loc_2A414
		cmpi.w	#-2,d0
		bge.s	loc_2A400
		moveq	#-2,d0

loc_2A400:
		add.w	d0,ost_y_pos(a0)
		jsrto	FindCeilingObj,JmpTo_FindCeilingObj
		tst.w	d1
		bpl.w	locret_2A412
		sub.w	d1,ost_y_pos(a0)

locret_2A412:
		rts
; ===========================================================================

loc_2A414:
		cmpi.w	#2,d0
		ble.s	loc_2A41C
		moveq	#2,d0

loc_2A41C:
		add.w	d0,ost_y_pos(a0)
		jsrto	FindFloorObj,JmpTo2_FindFloorObj
		tst.w	d1
		bpl.w	locret_2A430
		addq.w	#1,d1
		add.w	d1,ost_y_pos(a0)

locret_2A430:
		rts
; ===========================================================================

loc_2A432:
		tst.b	$38(a0)
		beq.s	locret_2A474
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_2A44E
		tst.b	$3E(a0)
		beq.s	locret_2A474
		subq.b	#4,$3E(a0)
		bra.s	loc_2A45A
; ===========================================================================

loc_2A44E:
		cmpi.b	#$40,$3E(a0)
		beq.s	locret_2A474
		addq.b	#4,$3E(a0)

loc_2A45A:
		move.b	$3E(a0),d0
		jsr	(CalcSine).l
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$30(a0),d0
		move.w	d0,ost_y_pos(a0)

locret_2A474:
		rts
; ===========================================================================

		include "mappings/sprite/ARZ Pillar Platform.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo2_FindFloorObj:
		jmp	(FindFloorObj).l
JmpTo46_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_FindCeilingObj:
		jmp	(FindCeilingObj).l
JmpTo23_SolidObject:
		jmp	(SolidObject).l
JmpTo7_DespawnObject2:
		jmp	(DespawnObject2).l
JmpTo16_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 83 - ARZ circling platforms
; ----------------------------------------------------------------------------

CirclingPlatform:
		btst	#render_subsprites_bit,ost_render(a0)
		bne.w	loc_2A514
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Circ_Index(pc,d0.w),d1
		jmp	Circ_Index(pc,d1.w)
; ===========================================================================

loc_2A514:
		move.w	#$280,d0
		jmpto	DisplaySprite3,JmpTo3_DisplaySprite3
; ===========================================================================
Circ_Index:	index offset(*),,2
		ptr loc_2A522					; 0
		ptr loc_2A620					; 2
		ptr loc_2A74E					; 4
; ===========================================================================

loc_2A522:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_ARZPlats,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo47_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.b	ost_subtype(a0),d1
		move.b	d1,d0
		andi.w	#$F,d1
		andi.b	#-$10,d0
		ext.w	d0
		asl.w	#3,d0
		move.w	d0,$2E(a0)

		move.b	ost_primary_status(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,ost_angle(a0)

		jsrto	FindNextFreeObj,JmpTo19_FindNextFreeObj
		bne.s	loc_2A5DC

		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#$40,ost_mainspr_width(a1)
		moveq	#8,d1
		move.b	d1,ost_mainspr_childsprites(a1)
		subq.w	#1,d1
		lea	ost_subspr2_x_pos(a1),a2

loc_2A5B0:
		addq.w	#4,a2
		move.w	#1,(a2)+
		dbf	d1,loc_2A5B0
		move.b	#1,ost_mainspr_frame(a1)
		move.b	#$40,ost_mainspr_height(a1)
		bset	#render_useheight_bit,ost_render(a1)
		move.l	a1,$34(a0)
		bsr.s	loc_2A5DE
		move.l	a1,$38(a0)
		bsr.s	loc_2A5DE
		move.l	a1,$3C(a0)

loc_2A5DC:
		bra.s	loc_2A620
; ===========================================================================

loc_2A5DE:
		jsrto	FindNextFreeObj,JmpTo19_FindNextFreeObj
		bne.s	locret_2A61E
		addq.b	#4,ost_primary_routine(a1)
		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.w	ost_x_pos(a0),$30(a1)
		move.w	ost_y_pos(a0),$32(a1)
		move.w	ost_x_pos(a0),$2C(a1)

locret_2A61E:
		rts
; ===========================================================================

loc_2A620:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		moveq	#0,d1
		move.w	$2E(a0),d0
		add.w	d0,ost_angle(a0)
		move.w	$32(a0),d2
		move.w	$30(a0),d3
		moveq	#0,d6
		movea.l	$34(a0),a1
		lea	ost_subspr2_x_pos(a1),a2
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo10_CalcSine
		swap	d0
		swap	d1
		asr.l	#4,d0
		asr.l	#4,d1
		move.l	d0,d4
		move.l	d1,d5
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,ost_x_pos(a1)
		move.w	d4,ost_y_pos(a1)
		move.l	d0,d4
		move.l	d1,d5
		add.l	d0,d4
		add.l	d1,d5
		moveq	#1,d6
		bsr.w	loc_2A72E
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,ost_x_pos(a0)
		move.w	d4,ost_y_pos(a0)
		move.b	ost_angle(a0),d0
		addi.b	#$55,d0
		jsrto	CalcSine,JmpTo10_CalcSine
		swap	d0
		swap	d1
		asr.l	#4,d0
		asr.l	#4,d1
		move.l	d0,d4
		move.l	d1,d5
		moveq	#2,d6
		bsr.w	loc_2A72E
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		movea.l	$38(a0),a1
		move.w	d5,ost_x_pos(a1)
		move.w	d4,ost_y_pos(a1)
		move.b	ost_angle(a0),d0
		subi.b	#$55,d0
		jsrto	CalcSine,JmpTo10_CalcSine
		swap	d0
		swap	d1
		asr.l	#4,d0
		asr.l	#4,d1
		move.l	d0,d4
		move.l	d1,d5
		moveq	#2,d6
		bsr.w	loc_2A72E
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		movea.l	$3C(a0),a1
		move.w	d5,ost_x_pos(a1)
		move.w	d4,ost_y_pos(a1)
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	(sp)+,d4
		jsrto	DetectPlatform,JmpTo7_DetectPlatform
		tst.w	(f_two_player).w
		beq.s	loc_2A70A
		jmpto	DisplaySprite,JmpTo27_DisplaySprite
; ===========================================================================

loc_2A70A:
		move.w	$30(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.w	loc_2A722
		jmpto	DisplaySprite,JmpTo27_DisplaySprite
; ===========================================================================

loc_2A722:
		movea.l	$34(a0),a1
		jsrto	DeleteChild,JmpTo4_DeleteChild
		jmpto	DeleteObject,JmpTo42_DeleteObject
; ===========================================================================

loc_2A72E:
		movem.l	d4-d5,-(sp)
		swap	d4
		swap	d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d5,(a2)+
		move.w	d4,(a2)+
		movem.l	(sp)+,d4-d5
		add.l	d0,d4
		add.l	d1,d5
		addq.w	#2,a2
		dbf	d6,loc_2A72E
		rts
; ===========================================================================

loc_2A74E:
		moveq	#0,d1
		move.b	ost_displaywidth(a0),d1
		addi.w	#$B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	$2C(a0),d4
		jsrto	DetectPlatform,JmpTo7_DetectPlatform
		move.w	ost_x_pos(a0),$2C(a0)
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo8_DespawnObject2
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo3_DisplaySprite3:
		jmp	(DisplaySprite3).l
JmpTo27_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo42_DeleteObject:
		jmp	(DeleteObject).l
JmpTo4_DeleteChild:
		jmp	(DeleteChild).l
JmpTo19_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo47_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo10_CalcSine:
		jmp	(CalcSine).l
JmpTo7_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo8_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 3F - OOZ fan
; ----------------------------------------------------------------------------

Fan:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Fan_Index(pc,d0.w),d1
		jmp	Fan_Index(pc,d1.w)
; ===========================================================================
Fan_Index:	index offset(*),,2
		ptr loc_2A7C4					; 0
		ptr loc_2A802					; 2
		ptr loc_2A8FE					; 4
; ===========================================================================

loc_2A7C4:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_HorizFan,ost_mappings(a0)
		move.w	#tile_Nem_Fan+tile_pal4,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo48_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		tst.b	ost_subtype(a0)
		bpl.s	loc_2A802
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_VertFan,ost_mappings(a0)
		bra.w	loc_2A8FE
; ===========================================================================

loc_2A802:
		btst	#1,ost_subtype(a0)
		bne.s	loc_2A82A
		subq.w	#1,$30(a0)
		bpl.s	loc_2A82A
		move.w	#0,$34(a0)
		move.w	#$78,$30(a0)
		bchg	#0,$32(a0)
		beq.s	loc_2A82A
		move.w	#$B4,$30(a0)

loc_2A82A:
		tst.b	$32(a0)
		beq.w	loc_2A84E
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2A890
		cmpi.w	#$400,$34(a0)
		bcc.s	loc_2A890
		addi.w	#$2A,$34(a0)
		move.b	$34(a0),ost_anim_time(a0)
		bra.s	loc_2A86A
; ===========================================================================

loc_2A84E:
		lea	($FFFFB000).w,a1
		bsr.w	loc_2A894
		lea	($FFFFB040).w,a1
		bsr.w	loc_2A894
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2A890
		move.b	#0,ost_anim_time(a0)

loc_2A86A:
		addq.b	#1,ost_anim_frame(a0)
		cmpi.b	#6,ost_anim_frame(a0)
		bcs.s	loc_2A87C
		move.b	#0,ost_anim_frame(a0)

loc_2A87C:
		moveq	#0,d0
		btst	#0,ost_subtype(a0)
		beq.s	loc_2A888
		moveq	#5,d0

loc_2A888:
		add.b	ost_anim_frame(a0),d0
		move.b	d0,ost_frame(a0)

loc_2A890:
		jmpto	DespawnObject,JmpTo26_DespawnObject
; ===========================================================================

loc_2A894:
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_2A8FC
		tst.b	$2A(a1)
		bne.s	locret_2A8FC
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_2A8B4
		neg.w	d0

loc_2A8B4:
		addi.w	#$50,d0
		cmpi.w	#$F0,d0
		bcc.s	locret_2A8FC
		move.w	ost_y_pos(a1),d1
		addi.w	#$60,d1
		sub.w	ost_y_pos(a0),d1
		bcs.s	locret_2A8FC
		cmpi.w	#$70,d1
		bcc.s	locret_2A8FC
		subi.w	#$50,d0
		bcc.s	loc_2A8DC
		not.w	d0
		add.w	d0,d0

loc_2A8DC:
		addi.w	#$60,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_2A8EA
		neg.w	d0

loc_2A8EA:
		neg.b	d0
		asr.w	#4,d0
		btst	#0,ost_subtype(a0)
		beq.s	loc_2A8F8
		neg.w	d0

loc_2A8F8:
		add.w	d0,ost_x_pos(a1)

locret_2A8FC:
		rts
; ===========================================================================

loc_2A8FE:
		btst	#1,ost_subtype(a0)
		bne.s	loc_2A926
		subq.w	#1,$30(a0)
		bpl.s	loc_2A926
		move.w	#0,$34(a0)
		move.w	#$78,$30(a0)
		bchg	#0,$32(a0)
		beq.s	loc_2A926
		move.w	#$B4,$30(a0)

loc_2A926:
		tst.b	$32(a0)
		beq.w	loc_2A94A
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2A98C
		cmpi.w	#$400,$34(a0)
		bcc.s	loc_2A98C
		addi.w	#$2A,$34(a0)
		move.b	$34(a0),ost_anim_time(a0)
		bra.s	loc_2A966
; ===========================================================================

loc_2A94A:
		lea	($FFFFB000).w,a1
		bsr.w	loc_2A990
		lea	($FFFFB040).w,a1
		bsr.w	loc_2A990
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2A98C
		move.b	#0,ost_anim_time(a0)

loc_2A966:
		addq.b	#1,ost_anim_frame(a0)
		cmpi.b	#6,ost_anim_frame(a0)
		bcs.s	loc_2A978
		move.b	#0,ost_anim_frame(a0)

loc_2A978:
		moveq	#0,d0
		btst	#0,ost_subtype(a0)
		beq.s	loc_2A984
		moveq	#5,d0

loc_2A984:
		add.b	ost_anim_frame(a0),d0
		move.b	d0,ost_frame(a0)

loc_2A98C:
		jmpto	DespawnObject,JmpTo26_DespawnObject
; ===========================================================================

loc_2A990:
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_2AA10
		tst.b	$2A(a1)
		bne.s	locret_2AA10
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$80,d0
		bcc.s	locret_2AA10
		moveq	#0,d1
		move.b	($FFFFFE74).w,d1
		add.w	ost_y_pos(a1),d1
		addi.w	#$60,d1
		sub.w	ost_y_pos(a0),d1
		bcs.s	locret_2AA10
		cmpi.w	#$90,d1
		bcc.s	locret_2AA10
		subi.w	#$60,d1
		bcs.s	loc_2A9D4
		not.w	d1
		add.w	d1,d1

loc_2A9D4:
		addi.w	#$60,d1
		neg.w	d1
		asr.w	#4,d1
		add.w	d1,ost_y_pos(a1)
		bset	#1,ost_primary_status(a1)
		move.w	#0,ost_y_vel(a1)
		move.w	#1,ost_inertia(a1)
		tst.b	ost_flip_angle(a1)
		bne.s	locret_2AA10
		move.b	#1,ost_flip_angle(a1)
		move.b	#0,ost_anim(a1)
		move.b	#$7F,$2C(a1)
		move.b	#8,$2D(a1)

locret_2AA10:
		rts
; ===========================================================================

		include "mappings/sprite/OOZ Fan (Horizontal).asm"
		include "mappings/sprite/OOZ Fan (Vertical).asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo26_DespawnObject:
		jmp	(DespawnObject).l
JmpTo48_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 85 - CNZ pinball launcher
; ----------------------------------------------------------------------------

PinballLauncher:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	PLaunch_Index(pc,d0.w),d1
		jsr	PLaunch_Index(pc,d1.w)
		move.w	#$200,d0
		tst.w	(f_two_player).w
		beq.s	loc_2ABA0
		jmpto	DisplaySprite3,JmpTo4_DisplaySprite3
; ===========================================================================

loc_2ABA0:
		move.w	ost_x_pos(a0),d1
		andi.w	#-$80,d1
		sub.w	(v_camera_x_pos_coarse).w,d1
		cmpi.w	#$280,d1
		bhi.w	loc_2ABB8				; could be optimized to .s
		jmpto	DisplaySprite3,JmpTo4_DisplaySprite3
; ===========================================================================

loc_2ABB8:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	BranchTo_JmpTo43_DeleteObject
		bclr	#7,2(a2,d0.w)

BranchTo_JmpTo43_DeleteObject:
		jmpto	DeleteObject,JmpTo43_DeleteObject
; ===========================================================================
PLaunch_Index:	index offset(*),,2
		ptr loc_2ABD4					; 0
		ptr loc_2AC84					; 2
		ptr loc_2AE56					; 4
; ===========================================================================

loc_2ABD4:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_VertLauncher,ost_mappings(a0)
		move.w	#tile_Nem_VertLauncher,ost_tile(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_2ABFA
		move.l	#Map_DiagLauncher,ost_mappings(a0)
		move.w	#tile_Nem_DiagLauncher,ost_tile(a0)

loc_2ABFA:
		jsrto	AdjustVRAM2P,JmpTo49_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#1,ost_mainspr_frame(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_2AC54
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$20,ost_mainspr_width(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.w	ost_x_pos(a0),$2E(a0)
		move.w	ost_y_pos(a0),$34(a0)
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		addi.w	#0,d3
		move.b	#1,ost_mainspr_childsprites(a0)
		lea	ost_subspr2_x_pos(a0),a2
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	#2,(a2)+
		bra.w	loc_2AE56
; ===========================================================================

loc_2AC54:
		move.b	#$18,ost_mainspr_width(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.w	ost_y_pos(a0),$34(a0)
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		addi.w	#$20,d3
		move.b	#1,ost_mainspr_childsprites(a0)
		lea	ost_subspr2_x_pos(a0),a2
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	#2,(a2)+

loc_2AC84:
		move.b	#0,$3A(a0)
		move.w	$34(a0),d0
		add.w	$38(a0),d0
		move.w	d0,ost_y_pos(a0)
		move.b	#2,ost_subspr2_frame(a0)
		cmpi.w	#$10,$38(a0)
		bcs.s	loc_2ACAA
		move.b	#3,ost_subspr2_frame(a0)

loc_2ACAA:
		move.w	#$23,d1
		move.w	#$20,d2
		move.w	#$1D,d3
		move.w	ost_x_pos(a0),d4
		lea	$36(a0),a2
		lea	($FFFFB000).w,a1
		move.w	(v_joypad_hold).w,d5
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_2AD26
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		addq.w	#1,a2
		move.w	(v_joypad2_hold_actual).w,d5
		moveq	#4,d6
		bsr.s	loc_2AD26
		tst.w	$36(a0)
		beq.s	loc_2AD14
		tst.w	$38(a0)
		beq.s	locret_2AD24
		moveq	#0,d0
		cmpi.b	#1,$36(a0)
		bne.s	loc_2ACFA
		or.w	(v_joypad_hold).w,d0

loc_2ACFA:
		cmpi.b	#1,$37(a0)
		bne.s	loc_2AD06
		or.w	(v_joypad2_hold_actual).w,d0

loc_2AD06:
		andi.w	#$7000,d0
		bne.s	locret_2AD24
		move.w	#$202,$36(a0)
		rts
; ===========================================================================

loc_2AD14:
		move.b	#1,ost_mainspr_frame(a0)
		subq.w	#4,$38(a0)
		bcc.s	locret_2AD24
		clr.w	$38(a0)

locret_2AD24:
		rts
; ===========================================================================

loc_2AD26:
		move.b	(a2),d0
		bne.s	loc_2AD7A

loc_2AD2A:
		tst.w	(v_debug_active).w
		bne.s	locret_2AD78
		tst.w	ost_y_vel(a1)
		bmi.s	locret_2AD78
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo5_SolidObject_NoRenderChk_SingleCharacter
		btst	d6,ost_primary_status(a0)
		beq.s	locret_2AD78
		move.b	#-$7F,$2A(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		move.w	#0,ost_inertia(a1)
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		addq.b	#1,(a2)

locret_2AD78:
		rts
; ===========================================================================

loc_2AD7A:
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_2AD78
		subq.b	#1,d0
		bne.w	loc_2AE0C
		tst.b	ost_render(a1)
		bmi.s	loc_2ADB0
		bclr	d6,ost_primary_status(a0)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$2A(a1)
		move.b	#0,(a2)
		rts
; ===========================================================================

loc_2ADB0:
		andi.w	#$7000,d5
		beq.s	loc_2ADFE
		tst.b	$3A(a0)
		bne.s	loc_2ADFE
		move.b	#1,$3A(a0)
		subq.b	#1,$32(a0)
		bpl.s	loc_2ADDA
		move.b	#3,$32(a0)
		cmpi.w	#$20,$38(a0)
		beq.s	loc_2ADDA
		addq.w	#1,$38(a0)

loc_2ADDA:
		subq.b	#1,$33(a0)
		bpl.s	loc_2ADF8
		move.w	$38(a0),d0
		subi.w	#$20,d0
		neg.w	d0
		lsr.w	#1,d0
		move.b	d0,$33(a0)
		bchg	#2,ost_mainspr_frame(a0)
		bra.s	loc_2ADFE
; ===========================================================================

loc_2ADF8:
		move.b	#1,ost_mainspr_frame(a0)

loc_2ADFE:
		move.w	ost_y_pos(a0),d0
		subi.w	#$2E,d0
		move.w	d0,ost_y_pos(a1)
		rts
; ===========================================================================

loc_2AE0C:
		move.b	#0,(a2)
		bclr	d6,ost_primary_status(a0)
		beq.w	loc_2AD2A
		move.w	$38(a0),d0
		addi.w	#$10,d0
		lsl.w	#7,d0
		neg.w	d0
		move.w	d0,ost_y_vel(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#$800,ost_inertia(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$2A(a1)
		move.w	#$E2,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_2AE56:
		move.b	#0,$3A(a0)
		move.w	$38(a0),d1
		lsr.w	#1,d1
		move.w	$2E(a0),d0
		sub.w	d1,d0
		move.w	d0,ost_x_pos(a0)
		move.w	$34(a0),d0
		add.w	d1,d0
		move.w	d0,ost_y_pos(a0)
		move.b	#2,ost_subspr2_frame(a0)
		cmpi.w	#$10,$38(a0)
		bcs.s	loc_2AE8A
		move.b	#3,ost_subspr2_frame(a0)

loc_2AE8A:
		move.w	#$23,d1
		move.w	#8,d2
		move.w	#5,d3
		move.w	ost_x_pos(a0),d4
		lea	$36(a0),a2
		lea	($FFFFB000).w,a1
		move.w	(v_joypad_hold).w,d5
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		bsr.s	loc_2AF06
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		addq.w	#1,a2
		move.w	(v_joypad2_hold_actual).w,d5
		moveq	#4,d6
		bsr.s	loc_2AF06
		tst.w	$36(a0)
		beq.s	loc_2AEF4
		tst.w	$38(a0)
		beq.s	locret_2AF04
		moveq	#0,d0
		cmpi.b	#1,$36(a0)
		bne.s	loc_2AEDA
		or.w	(v_joypad_hold).w,d0

loc_2AEDA:
		cmpi.b	#1,$37(a0)
		bne.s	loc_2AEE6
		or.w	(v_joypad2_hold_actual).w,d0

loc_2AEE6:
		andi.w	#$7000,d0
		bne.s	locret_2AF04
		move.w	#$202,$36(a0)
		rts
; ===========================================================================

loc_2AEF4:
		move.b	#1,ost_mainspr_frame(a0)
		subq.w	#4,$38(a0)
		bcc.s	locret_2AF04
		clr.w	$38(a0)

locret_2AF04:
		rts
; ===========================================================================

loc_2AF06:
		move.b	(a2),d0
		bne.s	loc_2AF7A
		tst.w	(v_debug_active).w
		bne.s	locret_2AF78
		tst.w	ost_y_vel(a1)
		bmi.s	locret_2AF78
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo5_SolidObject_NoRenderChk_SingleCharacter
		btst	d6,ost_primary_status(a0)
		bne.s	loc_2AF2E
		move.b	d6,d0
		addq.b	#2,d0
		btst	d0,ost_primary_status(a0)
		beq.s	locret_2AF78
		bset	d6,ost_primary_status(a0)

loc_2AF2E:
		move.b	#$81,$2A(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		addi.w	#$13,ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		subi.w	#$13,ost_y_pos(a1)
		move.w	#0,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		move.w	#0,ost_inertia(a1)
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		addq.b	#1,(a2)

locret_2AF78:
		rts
; ===========================================================================

loc_2AF7A:
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	locret_2AF78
		subq.b	#1,d0
		bne.w	loc_2B018
		tst.b	ost_render(a1)
		bmi.s	loc_2AFB0
		bclr	d6,ost_primary_status(a0)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$2A(a1)
		move.b	#0,(a2)
		rts
; ===========================================================================

loc_2AFB0:
		andi.w	#$7000,d5
		beq.s	loc_2AFFE
		tst.b	$3A(a0)
		bne.s	loc_2AFFE
		move.b	#1,$3A(a0)
		subq.b	#1,$32(a0)
		bpl.s	loc_2AFDA
		move.b	#3,$32(a0)
		cmpi.w	#$1C,$38(a0)
		beq.s	loc_2AFDA
		addq.w	#1,$38(a0)

loc_2AFDA:
		subq.b	#1,$33(a0)
		bpl.s	loc_2AFF8
		move.w	$38(a0),d0
		subi.w	#$1C,d0
		neg.w	d0
		lsr.w	#1,d0
		move.b	d0,$33(a0)
		bchg	#2,ost_mainspr_frame(a0)
		bra.s	loc_2AFFE
; ===========================================================================

loc_2AFF8:
		move.b	#1,ost_mainspr_frame(a0)

loc_2AFFE:
		move.w	ost_x_pos(a0),d0
		addi.w	#$13,d0
		move.w	d0,ost_x_pos(a1)
		move.w	ost_y_pos(a0),d0
		subi.w	#$13,d0

loc_2B012:
		move.w	d0,ost_y_pos(a1)
		rts
; ===========================================================================

loc_2B018:
		move.b	#0,(a2)
		bclr	d6,ost_primary_status(a0)
		beq.w	locret_2AF78
		move.w	$38(a0),d0
		addi_.w	#4,d0
		lsl.w	#7,d0
		move.w	d0,ost_x_vel(a1)
		neg.w	d0
		move.w	d0,ost_y_vel(a1)
		move.w	#$800,ost_inertia(a1)
		bset	#1,ost_primary_status(a1)

loc_2B044:
		bclr	#3,ost_primary_status(a1)
		tst.b	ost_subtype(a0)
		bpl.s	loc_2B068
		neg.w	d0
		move.w	d0,ost_inertia(a1)
		bclr	#status_xflip_bit,ost_primary_status(a1)
		bclr	#1,ost_primary_status(a1)
		move.b	#-$20,ost_angle(a1)

loc_2B068:
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$2A(a1)
		move.w	#$E2,d0
		jmp	(PlaySound).l
; ===========================================================================

		include "mappings/sprite/CNZ Pinball Launcher (Vertical).asm"
		include "mappings/sprite/CNZ Pinball Launcher (Diagonal).asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo4_DisplaySprite3:
		jmp	(DisplaySprite3).l
JmpTo43_DeleteObject:
		jmp	(DeleteObject).l
JmpTo49_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo5_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 86 - CNZ flipper
; ----------------------------------------------------------------------------

Flipper:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Flip_Index(pc,d0.w),d1
		jsr	Flip_Index(pc,d1.w)
		jmpto	DespawnObject,JmpTo27_DespawnObject
; ===========================================================================
Flip_Index:	index offset(*),,2
		ptr loc_2B158					; 0
		ptr loc_2B194					; 2
		ptr loc_2B312					; 4
; ===========================================================================

loc_2B158:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Flip,ost_mappings(a0)
		move.w	#tile_Nem_Flipper+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo50_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_2B194
		addq.b	#2,ost_primary_routine(a0)
		move.b	#2,ost_anim(a0)
		bra.w	loc_2B312
; ===========================================================================

loc_2B194:
		tst.w	(v_debug_active).w
		bne.s	locret_2B208
		lea	(byte_2B3C6).l,a2
		move.b	ost_frame(a0),d0
		beq.s	loc_2B1B6
		lea	(byte_2B3EA).l,a2
		subq.b	#1,d0
		beq.s	loc_2B1B6
		lea	(byte_2B40E).l,a2

loc_2B1B6:
		move.w	#$23,d1
		move.w	#6,d2
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject_Heightmap,JmpTo2_SolidObject_Heightmap
		lea	$36(a0),a3
		lea	($FFFFB000).w,a1
		move.w	(v_joypad_hold).w,d5
		moveq	#3,d6
		bsr.s	loc_2B20A
		addq.w	#1,a3
		lea	($FFFFB040).w,a1
		move.w	(v_joypad2_hold_actual).w,d5
		moveq	#4,d6
		bsr.s	loc_2B20A
		tst.b	$38(a0)
		beq.s	loc_2B1FE
		clr.b	$38(a0)
		bsr.w	loc_2B290
		subq.w	#1,a3
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		bsr.w	loc_2B290

loc_2B1FE:
		lea	(Ani_Flip).l,a1
		jmpto	AnimateSprite,JmpTo9_AnimateSprite
; ===========================================================================

locret_2B208:
		rts
; ===========================================================================

loc_2B20A:
		move.b	(a3),d0
		bne.s	loc_2B23C
		btst	d6,ost_primary_status(a0)
		beq.s	locret_2B208
		move.b	#1,$2A(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		bset	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_2B238
		addq.w	#5,ost_y_pos(a1)

loc_2B238:
		addq.b	#1,(a3)
		rts
; ===========================================================================

loc_2B23C:
		andi.w	#$70,d5
		bne.s	loc_2B288
		btst	d6,ost_primary_status(a0)
		bne.s	loc_2B254
		move.b	#0,$2A(a1)
		move.b	#0,(a3)
		rts
; ===========================================================================

loc_2B254:
		moveq	#0,d1
		move.b	ost_frame(a0),d1
		subq.w	#1,d1
		bset	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_2B272
		neg.w	d1
		bclr	#status_xflip_bit,ost_primary_status(a1)

loc_2B272:
		add.w	d1,ost_x_pos(a1)
		lsl.w	#8,d1
		move.w	d1,ost_x_vel(a1)
		move.w	d1,ost_inertia(a1)
		move.w	#0,ost_y_vel(a1)
		rts
; ===========================================================================

loc_2B288:
		move.b	#1,$38(a0)
		rts
; ===========================================================================

loc_2B290:
		bclr	d6,ost_primary_status(a0)
		beq.w	locret_2B208
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2B2AA
		neg.w	d0

loc_2B2AA:
		addi.w	#$23,d0
		move.w	d0,d2
		cmpi.w	#$40,d2
		bcs.s	loc_2B2BA
		move.w	#$40,d2

loc_2B2BA:
		lsl.w	#5,d2
		addi.w	#$800,d2
		neg.w	d2
		asr.w	#2,d0
		addi.w	#$40,d0
		jsrto	CalcSine,JmpTo11_CalcSine
		muls.w	d2,d0
		muls.w	d2,d1
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,ost_y_vel(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2B2E2
		neg.w	d1

loc_2B2E2:
		move.w	d1,ost_x_vel(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,$2A(a1)
		move.b	#1,ost_anim(a0)
		move.b	#0,(a3)
		move.w	#$E3,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_2B312:
		move.w	#$13,d1
		move.w	#$18,d2
		move.w	#$19,d3
		move.w	ost_x_pos(a0),d4
		lea	($FFFFB000).w,a1
		moveq	#3,d6
		movem.l	d1-d4,-(sp)
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo6_SolidObject_NoRenderChk_SingleCharacter
		btst	#5,ost_primary_status(a0)
		beq.s	loc_2B33A
		bsr.s	loc_2B35C

loc_2B33A:
		movem.l	(sp)+,d1-d4
		lea	($FFFFB040).w,a1
		moveq	#4,d6
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo6_SolidObject_NoRenderChk_SingleCharacter
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_2B352
		bsr.s	loc_2B35C

loc_2B352:
		lea	(Ani_Flip).l,a1
		jmpto	AnimateSprite,JmpTo9_AnimateSprite
; ===========================================================================

loc_2B35C:
		move.w	#$300,ost_anim(a0)
		move.w	#-$1000,ost_x_vel(a1)
		addq.w	#8,ost_x_pos(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		move.w	ost_x_pos(a0),d0
		sub.w	ost_x_pos(a1),d0
		bcc.s	loc_2B392
		bclr	#status_xflip_bit,ost_primary_status(a1)
		subi.w	#$10,ost_x_pos(a1)
		neg.w	ost_x_vel(a1)
		move.w	#$400,ost_anim(a0)

loc_2B392:
		move.w	#$F,$2E(a1)
		move.w	ost_x_vel(a1),ost_inertia(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)
		bset	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_2B3BC
		addq.w	#5,ost_y_pos(a1)

loc_2B3BC:
		move.w	#$E3,d0
		jmp	(PlaySound).l
; ===========================================================================
; Fliper heightmaps
byte_2B3C6:
		dc.b   7,  7,  7,  7,  7,  7,  7,  8,  9, $A, $B, $A,  9,  8,  7,  6 ; 0
		dc.b   5,  4,  3,  2,  1,  0,$FF,$FE,$FD,$FC,$FB,$FA,$F9,$F8,$F7,$F6 ; 16
		dc.b $F5,$F4,$F3,$F2				; 32

byte_2B3EA:
		dc.b   6,  6,  6,  6,  6,  6,  7,  8,  9,  9,  9,  9,  9,  9,  8,  8 ; 0
		dc.b   8,  8,  8,  8,  7,  7,  7,  7,  6,  6,  6,  6,  5,  5,  4,  4 ; 16
		dc.b   4,  4,  4,  4				; 32

byte_2B40E:
		dc.b   5,  5,  5,  5,  5,  6,  7,  8,  9, $A, $B, $B, $C, $C, $D, $D ; 0
		dc.b  $E, $E, $F, $F,$10,$10,$11,$11,$12,$12,$11,$11,$10,$10,$10,$10 ; 16
		dc.b $10,$10,$10,$10				; 32

Ani_Flip:	index offset(*)
		ptr byte_2B43C					; 0
		ptr byte_2B43F					; 1
		ptr byte_2B445					; 2
		ptr byte_2B448					; 3
		ptr byte_2B451					; 4
byte_2B43C:	dc.b  $F,  0,$FF				; 0
byte_2B43F:	dc.b   3,  1,  2,  1,$FD,  0			; 0
byte_2B445:	dc.b  $F,  4,$FF				; 0
byte_2B448:	dc.b   0,  5,  4,  3,  3,  3,  3,$FD,  2	; 0
byte_2B451:	dc.b   0,  3,  4,  5,  5,  5,  5,$FD,  2	; 0
; ===========================================================================

		include "mappings/sprite/CNZ Pinball Flipper.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo27_DespawnObject:
		jmp	(DespawnObject).l
JmpTo9_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo50_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo11_CalcSine:
		jmp	(CalcSine).l
JmpTo6_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l
JmpTo2_SolidObject_Heightmap:
		jmp	(SolidObject_Heightmap).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D2 - CNZ snake platforms
; ----------------------------------------------------------------------------

SnakePlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Snake_Index(pc,d0.w),d1
		jmp	Snake_Index(pc,d1.w)
; ===========================================================================
Snake_Index:	index offset(*),,2
		ptr loc_2B53A					; 0
		ptr loc_2B57E					; 2
; ===========================================================================

loc_2B53A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Snake,ost_mappings(a0)
		move.w	#tile_Nem_SnakePlats+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo51_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#8,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#4,d0
		move.w	d0,$38(a0)
		bsr.w	loc_2B60C

loc_2B57E:
		tst.w	$38(a0)
		beq.s	loc_2B58C
		subq.w	#1,$38(a0)
		jmpto	DespawnObject3,JmpTo6_DespawnObject3
; ===========================================================================

loc_2B58C:
		subq.w	#1,$3A(a0)
		bpl.s	loc_2B5EC
		move.w	#$F,$3A(a0)
		addq.b	#1,ost_frame(a0)

loc_2B59C:
		andi.b	#$F,ost_frame(a0)
		bne.s	loc_2B5EA
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#4,d0
		move.w	d0,$38(a0)
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	loc_2B5E2
		bclr	#3,ost_primary_status(a0)
		beq.s	loc_2B5CE
		bclr	#3,($FFFFB022).w
		bset	#1,($FFFFB022).w

loc_2B5CE:
		bclr	#4,ost_primary_status(a0)
		beq.s	loc_2B5E2
		bclr	#3,($FFFFB062).w
		bset	#1,($FFFFB062).w

loc_2B5E2:
		move.w	$30(a0),ost_x_pos(a0)
		bra.s	loc_2B60C
; ===========================================================================

loc_2B5EA:
		bsr.s	loc_2B60C

loc_2B5EC:
		move.w	$34(a0),d1
		addi.w	#$B,d1
		move.w	$36(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo24_SolidObject
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo9_DespawnObject2
; ===========================================================================

loc_2B60C:
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		add.w	d0,d0
		add.w	d0,d0
		lea	byte_2B654(pc,d0.w),a1
		move.b	(a1)+,d0
		ext.w	d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2B628
		neg.w	d0

loc_2B628:
		add.w	$30(a0),d0
		move.w	d0,ost_x_pos(a0)
		move.b	(a1)+,d0
		ext.w	d0
		add.w	$32(a0),d0
		move.w	d0,ost_y_pos(a0)
		moveq	#0,d1
		moveq	#0,d2
		moveq	#0,d3
		move.b	(a1)+,d1
		move.b	(a1)+,d2
		move.w	d1,$34(a0)
		move.b	d1,ost_displaywidth(a0)
		move.w	d2,$36(a0)
		rts
; ===========================================================================
byte_2B654:
		dc.b $D8,$18,  8,  8,$D8,$10,  8,$10,$D8,  8,  8,$18,$D8,  0,  8,$20 ; 0
		dc.b $E0,  0,$10,$20,$E8,$F8,$18,$18,$F0,$F0,$20,$10,$F8,$E8,$28,  8 ; 16
		dc.b   8,$E8,$28,  8,$10,$F0,$20,$10,$18,$F8,$18,$18,$20,  0,$10,$20 ; 32
		dc.b $28,  0,  8,$20,$28,  8,  8,$18,$28,$10,  8,$10,$28,$18,  8,  8 ; 48
; ===========================================================================

		include "mappings/sprite/CNZ Snake Platform.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo6_DespawnObject3:
		jmp	(DespawnObject3).l
JmpTo51_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo24_SolidObject:
		jmp	(SolidObject).l
JmpTo9_DespawnObject2:
		jmp	(DespawnObject2).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D3 - CNZ bomb penalty
; Uses almost the same OST properties as the ring prize object
; ----------------------------------------------------------------------------

BombPenalty:

		rsobj	BombPenalty,$2A
ost_casinobmb_childcnt_ptr:		rs.l 1			; $2A; pointer to parent cage's child object counter
		rsset $2E
ost_casinobmb_angle:			rs.w 1			; $2E; spawn angle of bomb
ost_casinobmb_x_pos: 			rs.l 1			; $30; X position of the bomb with greater precision
ost_casinobmb_y_pos:			rs.l 1			; $34; Y position of the bomb with greater precision
ost_casinobmb_machine_x_pos:	rs.w 1				; $38; X position of the slot machine cage that generated the bomb
ost_casinobmb_machine_y_pos:	rs.w 1				; $3A; Y position of the slot machine cage that generated the bomb
ost_casinobmb_display_delay:	rs.w 1				; $3C; number of frames that bomb is displated
ost_casinobmb_player:			rs.w 1			; $3E; character this bomb is being 'awarded' to
ost_casinobmb_player_low:		equ __rs-1		; $3F; tested to check which player to deduct rings from
		rsobjend

		; Make bomb move toward the cage each frame.
		moveq	#0,d1
		move.w	ost_casinobmb_machine_x_pos(a0),d1	; get x pos of cage associated with slot machine
		swap	d1					; swap to high word
		move.l	ost_casinobmb_x_pos(a0),d0		; get current x pos of bomb
		sub.l	d1,d0					; get difference
		asr.l	#4,d0					; divide by 16
		sub.l	d0,ost_casinobmb_x_pos(a0)		; subtract from old x pos to get new x pos
		move.w	ost_casinobmb_x_pos(a0),ost_x_pos(a0)	; set new x pos of bomb
		moveq	#0,d1
		move.w	ost_casinobmb_machine_y_pos(a0),d1	; get y pos of cage associated with slot machine
		swap	d1					; swap to high word
		move.l	ost_casinobmb_y_pos(a0),d0		; get current y pos of bomb
		sub.l	d1,d0					; get difference
		asr.l	#4,d0					; divide by 16
		sub.l	d0,ost_casinobmb_y_pos(a0)		; subtract from old y pos to get new y pos
		move.w	ost_casinobmb_y_pos(a0),ost_y_pos(a0)	; set new y pos of bomb
		subq.w	#1,ost_casinobmb_display_delay(a0)	; decrement delay timer
		bne.w	JmpTo28_DisplaySprite			; branch if time remains

		movea.l	ost_casinobmb_childcnt_ptr(a0),a1	; parent's cage's child counter
		subq.w	#1,(a1)					; decrement child counter
		cmpi.w	#5,(v_casinobmb_snd_delay).w		; is sound delay counter over 5?
		bcs.s	.skip_sound				; if not, branch
		clr.w	(v_casinobmb_snd_delay).w		; reset sound delay counter
		move.w	#sfx_SpikeHit,d0			; play spike hit sound
		jsr	(PlaySound2).l

	.skip_sound:
		tst.b	ost_casinobmb_player_low(a0)
		beq.s	.player1				; branch if bombs are for player 1
		tst.w	(v_rings_p2).w
		beq.s	.chk2P					; branch if player 2 doesn't have any rings
		subq.w	#1,(v_rings_p2).w			; decrement player 2's ring counter
		ori.b	#$81,(v_hud_rings_update_p2).w		; set flag to reset ring counter to 0

	.chk2P:
		tst.w	(f_two_player).w			; is it two-player mode?
		bne.s	.delete					; if so, branch

	.player1:
		tst.w	(v_rings).w
		beq.s	.delete					; branch if player 1 doesn't have any rings
		subq.w	#1,(v_rings).w				; decrement player 1's ring counter
		ori.b	#$81,(v_hud_rings_update).w		; set flag to reset ring counter to 0

	.delete:
		jmpto	DeleteObject,JmpTo44_DeleteObject

	if RemoveJmpTos
JmpTo28_DisplaySprite:
		jmp	(DisplaySprite).l
	endc

; ===========================================================================

		include "mappings/sprite/CNZ Bomb Penalty.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo28_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo44_DeleteObject:
		jmp	(DeleteObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D4 - CNZ large moving blue block
; ----------------------------------------------------------------------------

LargeMovingBlock:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	LrgMovBlock_Index(pc,d0.w),d1
		jmp	LrgMovBlock_Index(pc,d1.w)
; ===========================================================================
LrgMovBlock_Index:	index offset(*),,2
		ptr loc_2B8FE					; 0
		ptr loc_2B96E					; 2
; ===========================================================================

loc_2B8FE:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_LrgMovBlock,ost_mappings(a0)
		move.w	#tile_Nem_LargeMovingBlock+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo52_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.w	#$8000,ost_x_sub(a0)
		move.w	#$8000,ost_y_sub(a0)
		tst.b	ost_subtype(a0)
		bne.s	loc_2B95A
		subi.w	#$60,ost_x_pos(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2B96E
		addi.w	#$C0,ost_x_pos(a0)
		bra.s	loc_2B96E
; ===========================================================================

loc_2B95A:
		subi.w	#$60,ost_y_pos(a0)
		btst	#1,ost_primary_status(a0)
		beq.s	loc_2B96E
		addi.w	#$C0,ost_y_pos(a0)

loc_2B96E:
		move.w	ost_x_pos(a0),-(sp)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		move.w	off_2B99E(pc,d0.w),d1
		jsr	off_2B99E(pc,d1.w)
		jsrto	SpeedToPos,JmpTo17_SpeedToPos
		move.w	#$2B,d1
		move.w	#$20,d2
		move.w	#$21,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo25_SolidObject
		move.w	$30(a0),d0
		jmpto	DespawnObject2,JmpTo10_DespawnObject2
; ===========================================================================
off_2B99E:	index offset(*),,2
		ptr loc_2B9A2					; 0
		ptr loc_2B9B6					; 2
; ===========================================================================

loc_2B9A2:
		moveq	#4,d1
		move.w	$30(a0),d0
		cmp.w	ost_x_pos(a0),d0
		bhi.s	loc_2B9B0
		neg.w	d1

loc_2B9B0:
		add.w	d1,ost_x_vel(a0)
		rts
; ===========================================================================

loc_2B9B6:
		moveq	#4,d1
		move.w	$32(a0),d0
		cmp.w	ost_y_pos(a0),d0
		bhi.s	loc_2B9C4
		neg.w	d1

loc_2B9C4:
		add.w	d1,ost_y_vel(a0)
		rts
; ===========================================================================

		include "mappings/sprite/CNZ Large Moving Block.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo52_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo25_SolidObject:
		jmp	(SolidObject).l
JmpTo10_DespawnObject2:
		jmp	(DespawnObject2).l
JmpTo17_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D5 - CNZ Elevator
; ----------------------------------------------------------------------------

Elevator:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2BA16(pc,d0.w),d1
		jmp	off_2BA16(pc,d1.w)
; ===========================================================================
off_2BA16:	index offset(*),,2
		ptr loc_2BA1A					; 0
		ptr loc_2BA68					; 2
; ===========================================================================

loc_2BA1A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Elevator,ost_mappings(a0)
		move.w	#tile_Nem_CNZElevator+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo53_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		move.w	ost_y_pos(a0),$32(a0)
		move.w	#-$8000,ost_y_sub(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#2,d0
		sub.w	d0,ost_y_pos(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2BA68
		add.w	d0,d0
		add.w	d0,ost_y_pos(a0)

loc_2BA68:
		jsrto	SpeedToPos,JmpTo18_SpeedToPos
		move.w	$34(a0),d0
		move.w	off_2BA94(pc,d0.w),d1
		jsr	off_2BA94(pc,d1.w)
		cmpi.w	#6,$34(a0)
		bcc.s	loc_2BA90
		move.w	#$10,d1
		move.w	#9,d3
		move.w	ost_x_pos(a0),d4
		jsrto	DetectPlatform3,JmpTo_DetectPlatform3

loc_2BA90:
		jmpto	DespawnObject,JmpTo28_DespawnObject
; ===========================================================================
off_2BA94:	index offset(*),,2
		ptr loc_2BA9C					; 0
		ptr loc_2BAB6					; 2
		ptr loc_2BAEE					; 4
		ptr loc_2BB08					; 6
; ===========================================================================

loc_2BA9C:
		move.b	ost_primary_status(a0),d0
		andi.w	#$18,d0
		beq.s	locret_2BAB4
		move.w	#$D6,d0
		jsr	(PlaySound).l
		addq.w	#2,$34(a0)

locret_2BAB4:
		rts
; ===========================================================================

loc_2BAB6:
		moveq	#8,d1
		move.w	$32(a0),d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	loc_2BAC4
		neg.w	d1

loc_2BAC4:
		add.w	d1,ost_y_vel(a0)
		bne.s	locret_2BAEC
		addq.w	#2,$34(a0)
		move.w	d0,ost_y_pos(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#2,d0
		sub.w	d0,ost_y_pos(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	locret_2BAEC
		add.w	d0,d0
		add.w	d0,ost_y_pos(a0)

locret_2BAEC:
		rts
; ===========================================================================

loc_2BAEE:
		move.b	ost_primary_status(a0),d0
		andi.w	#$18,d0
		bne.s	locret_2BB06
		move.w	#$D6,d0
		jsr	(PlaySound).l
		addq.w	#2,$34(a0)

locret_2BB06:
		rts
; ===========================================================================

loc_2BB08:
		moveq	#8,d1
		move.w	$32(a0),d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	loc_2BB16
		neg.w	d1

loc_2BB16:
		add.w	d1,ost_y_vel(a0)
		bne.s	locret_2BB3E
		clr.w	$34(a0)
		move.w	d0,ost_y_pos(a0)
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#2,d0
		sub.w	d0,ost_y_pos(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	locret_2BB3E
		add.w	d0,d0
		add.w	d0,ost_y_pos(a0)

locret_2BB3E:
		rts
; ===========================================================================

		include "mappings/sprite/CNZ Elevator.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo28_DespawnObject:
		jmp	(DespawnObject).l
JmpTo53_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_DetectPlatform3:
		jmp	(DetectPlatform3).l
JmpTo18_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D6 - CNZ pinball cages
; (Whose idea was it to call these "point pokeys" in Sonic 2 AS?)
; ----------------------------------------------------------------------------

Cage:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Cage_Index(pc,d0.w),d1
		jmp	Cage_Index(pc,d1.w)
; ===========================================================================
Cage_Index:	index offset(*),,2
		ptr Cage_Main					; 0
		ptr Cage_Action					; 2

		rsobj Cage,$2A
ost_cage_bombcount:		rs.w 1				; $2A ; number of bombs left to spawn
ost_cage_childcount:	rs.w 1					; $2C ; number of rings or bombs spawned; no more than 16 of each are allowed at any given time
ost_cage_prize_angle:	rs.w 1					; $2E ; angle at which next ring or bomb is spawned
ost_cage_p1_routine:	rs.w 1					; $30 ; player 1 secondary routine
ost_cage_p1_timer:		rs.w 1				; $32 ; timer for player 1
ost_cage_p2_routine:	rs.w 1					; $34 ; player 2 secondary routine
ost_cage_p2_timer:		rs.w 1				; $36 ; timer for player 2
		rsset $3E
ost_cage_player:		rs.w 1				; $3E ; player currently in the cage; used to set parent of slot reward objects
		rsobjend
; ===========================================================================

Cage_Main: ; Routine 0
		addq.b	#2,ost_primary_routine(a0)		; go to Cage_Action next
		move.l	#Map_Cage,ost_mappings(a0)
		move.w	#tile_Nem_Cage,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo54_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)

Cage_Action: ; Routine 2
		move.w	#($46/2),d1				; width of cage/2
		move.w	#($20/2),d2				; height of cage/2
		move.w	#($22/2),d3				; height of cage standing/2
		move.w	ost_x_pos(a0),d4
		lea	ost_cage_p1_routine(a0),a2		; (a2) = secondary routine counter for player 1
		lea	(v_ost_player1).w,a1
		moveq	#status_p1_platform_bit,d6
		pushr.l	d1-d4					; back up registers so we can use them again for player 2
		bsr.w	.run_action				; run action for main character	(could be bsr.s)
		popr.l	d1-d4					; restore registers
		lea	ost_cage_p2_routine(a0),a2		; (a2) = secondary routine counter for player 2
		lea	(v_ost_player2).w,a1
		moveq	#status_p2_platform_bit,d6
		bsr.w	.run_action				; run action for player 2 (could be bsr.s)
		lea	(Ani_Cage).l,a1
		jsrto	AnimateSprite,JmpTo10_AnimateSprite
		jmpto	DespawnObject,JmpTo29_DespawnObject
; ===========================================================================

.run_action:
		move.w	(a2),d0					; (a2) = secondary routine counter
		move.w	Cage_ActionIndex(pc,d0.w),d0
		jmp	Cage_ActionIndex(pc,d0.w)
; ===========================================================================

Cage_ActionIndex:	index offset(*),,2
		ptr Cage_Detect					; 0
		ptr Cage_Active					; 2
		ptr Cage_Ignore					; 4
; ===========================================================================

Cage_Detect: ; Subroutine 0
		tst.b	ost_obj_control(a1)			; is player already in the cage?
		bne.w	.return					; if so, branch
		tst.b	ost_subtype(a0)				; is it a slot machine cage?
		beq.s	.chkcollision				; if not, branch
		tst.w	(f_slot_use).w				; is the slot machine already running?
		bne.s	.return					; if so, branch

	.chkcollision:
		jsrto	SolidObject_NoRenderChk_SingleCharacter,JmpTo7_SolidObject_NoRenderChk_SingleCharacter ; check for collision even if cage is off-screen
		tst.w	d4
		bpl.s	.return					; branch if player did not collide with top or bottom of cage

	;.catch_player:
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; position player inside the cage
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#0,ost_x_vel(a1)			; zero their movement
		move.w	#0,ost_y_vel(a1)
		move.w	#0,ost_inertia(a1)
		move.b	#$81,ost_obj_control(a1)		; lock their controls
		bset	#status_jump_bit,ost_primary_status(a1)
		move.b	#$E,ost_height(a1)
		move.b	#7,ost_width(a1)
		move.b	#2,ost_anim(a1)				; use rolling animation
		move.b	#id_Ani_Cage_Flash,ost_anim(a0)		; make cage flash
		addq.w	#2,(a2)+				; go to Cage_Active next
		move.w	#(countof_ntsc_fps*2),(a2)		; player stays in cage for 2 seconds; (a2) = player's timer
		move.w	a1,ost_cage_player(a0)			; player is now parent of this object
		tst.b	ost_subtype(a0)				; is it a slot machine cage?
		beq.s	.return					; if not, exit
		cmpi.b	#id_Slot_Null,(v_slot_routine).w	; is the slot machine set to the null routine?
		bne.s	.return					; if not, exit; machine is already in use
		move.b	#id_Slot_Start,(v_slot_routine).w	; start the slot machine
		clr.w	ost_cage_prize_angle(a0)		; clear prize spawn angle
		move.w	#-1,(f_slot_use).w			; set slot machine flag
		move.w	#-1,ost_cage_bombcount(a0)		; not sure what this is for

	.return:
		rts
; ===========================================================================

Cage_GiveSlotReward:
		move.w	(v_slot_reward).w,d0			; get reward from slot machine
		bpl.w	Cage_GiveRings				; branch if it's rings
		tst.w	ost_cage_bombcount(a0)
		bpl.s	Cage_GivePenalty			; branch if flag is not set
		move.w	#100,ost_cage_bombcount(a0)		; pelt character with 100 bombs

; ----------------------------------------------------------------------------
; Subroutine to spawn bomb penalties
; ----------------------------------------------------------------------------

Cage_GivePenalty:
		tst.w	ost_cage_bombcount(a0)
		beq.w	.chkbombcount				; branch if there are no more bombs to spawn
		btst	#0,(v_frame_counter_low).w
		beq.w	.return					; spawn a bomb every other frame
		cmpi.w	#$10,ost_cage_childcount(a0)
		bcc.w	.return					; don't load more than 16 bombs at any one time
		jsrto	FindFreeObj,JmpTo10_FindFreeObj		; find free OST slot
		bne.w	.return					; branch if not found
		_move.b	#id_BombPenalty,ost_id(a1)		; load bomb penalty object
		move.l	#Map_BombPenalty,ost_mappings(a1)
		move.w	#tile_Nem_BombPenalty,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo6_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.w	#30,ost_casinobmb_display_delay(a1)	; delay display for 30 frames
		move.w	ost_cage_prize_angle(a0),ost_casinobmb_angle(a1) ; set spawn angle
		addi.w	#$90,ost_cage_prize_angle(a0)		; increment angle
		move.w	ost_x_pos(a0),ost_casinobmb_machine_x_pos(a1) ; set location of slot machine that spawned bomb
		move.w	ost_y_pos(a0),ost_casinobmb_machine_y_pos(a1)
		move.w	ost_casinobmb_angle(a1),d0		; get spawn angle of bomb
		jsrto	CalcSine,JmpTo12_CalcSine		; convert to sine and cosine
		asr.w	#1,d1					; divide cosine by 2
		add.w	ost_casinobmb_machine_x_pos(a1),d1	; add x pos of cage
		move.w	d1,ost_casinobmb_x_pos(a1)		; result is initial x pos of the bomb
		move.w	d1,ost_x_pos(a1)
		asr.w	#1,d0					; divide sine by 2
		add.w	ost_casinobmb_machine_y_pos(a1),d0	; add y pos of cage
		move.w	d0,ost_casinobmb_y_pos(a1)		; result is initial y pos of the bomb
		move.w	d0,ost_y_pos(a1)
		lea	ost_cage_childcount(a0),a2
		move.l	a2,ost_casinobmb_childcnt_ptr(a1)	; set pointer to cage's child counter
		move.w	ost_cage_player(a0),ost_casinobmb_player(a1) ; parent of cage is also parent of bomb
		addq.w	#1,ost_cage_childcount(a0)		; add to child counter
		subq.w	#1,ost_cage_bombcount(a0)		; decrement number of bombs remaining

	.chkbombcount:
		tst.w	ost_cage_childcount(a0)			; have all bombs despawned?
		beq.w	Cage_ReleasePlayer			; if so, branch

	.return:
		addq.w	#1,(v_casinobmb_snd_delay).w		; increment sound delay counter
		rts

; ----------------------------------------------------------------------------
; Subroutine to spawn prize rings
; ----------------------------------------------------------------------------

Cage_GiveRings:
		beq.w	.chkringcount				; branch if there are no more rings to spawn
		btst	#0,(v_frame_counter_low).w
		beq.w	.return					; spawn a ring every other frame
		cmpi.w	#$10,ost_cage_childcount(a0)
		bcc.w	.return					; don't load more than 16 rings at any one time
		jsrto	FindFreeObj,JmpTo10_FindFreeObj		; find free OST slot
		bne.w	.return					; branch if not found
		_move.b	#id_RingPrize,ost_id(a1)		; load ring prize object
		move.l	#Map_Ring,ost_mappings(a1)
		move.w	#tile_Nem_Ring+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo6_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#8,ost_displaywidth(a1)
		move.w	#26,ost_casinoprz_display_delay(a1)	; delay display for 26 frames
		move.w	ost_cage_prize_angle(a0),ost_casinoprz_angle(a1) ; set spawn angle
		addi.w	#$89,ost_cage_prize_angle(a0)		; increment angle
		move.w	ost_x_pos(a0),ost_casinoprz_machine_x_pos(a1) ; set location of slot machine that spawned bomb
		move.w	ost_y_pos(a0),ost_casinoprz_machine_y_pos(a1)
		move.w	ost_casinoprz_angle(a1),d0		; get spawn angle of ring
		jsrto	CalcSine,JmpTo12_CalcSine		; convert to sine and cosine
		asr.w	#1,d1					; divide cosine by 2
		add.w	ost_casinoprz_machine_x_pos(a1),d1	; add x pos of cage
		move.w	d1,ost_casinoprz_x_pos(a1)		; result is initial x pos of the ring
		move.w	d1,ost_x_pos(a1)
		asr.w	#1,d0					; divide sine by 2
		add.w	ost_casinoprz_machine_y_pos(a1),d0	; add y pos of cage
		move.w	d0,ost_casinoprz_y_pos(a1)		; result is initial y pos of the ring
		move.w	d0,ost_y_pos(a1)
		lea	ost_cage_childcount(a0),a2
		move.l	a2,ost_casinoprz_childcnt_ptr(a1)	; set pointer to cage's child counter
		move.w	ost_cage_player(a0),ost_casinoprz_player(a1) ; parent of cage is also parent of ring
		addq.w	#1,ost_cage_childcount(a0)		; add to child counter
		subq.w	#1,(v_slot_reward).w			; decrement number of rings remaining

	.chkringcount:
		tst.w	ost_cage_childcount(a0)			; have all rings despawned?
		beq.s	Cage_ReleasePlayer			; if so, branch

	.return:
		rts
; ===========================================================================

Cage_Active: ; Subroutine 2
		tst.b	ost_render(a0)				; is cage on-screen?
		bpl.s	Cage_ReleasePlayer			; if not, branch
		tst.b	ost_subtype(a0)				; is it a slot machine cage?
		beq.s	.chkpoints				; if not, branch
		move.w	a1,ost_cage_player(a0)
		cmpi.b	#id_Slot_Null,(v_slot_routine).w	; is slot set to null routine?
		beq.w	Cage_GiveSlotReward			; is so, branch
		move.b	(v_vblank_counter_byte).w,d0		; get byte that increments every frame
		andi.w	#$F,d0
		bne.s	.skip_sound
		move.w	#sfx_SlotMachine,d0
		jsr	(PlaySound).l				; play 'ding' sound every 16 frames (could be jmp)

	.skip_sound:
		rts
; ===========================================================================

.chkpoints:
		subq.w	#1,ost_cage_p1_timer-ost_cage_p1_routine(a2) ; decrement timer
		bpl.s	Cage_GivePoints				; branch if time remains

Cage_ReleasePlayer:
		move.w	#0,ost_cage_childcount(a0)
		move.b	#id_Ani_Cage_Idle,ost_anim(a0)
		move.b	#0,ost_obj_control(a1)			; unlock player's controls
		bclr	d6,ost_primary_status(a0)		; clear cage's platform flag
		bclr	#status_platform_bit,ost_primary_status(a1)
		bset	#status_air_bit,ost_primary_status(a1)
		move.w	#$400,ost_y_vel(a1)			; make character fall from cage
		addq.w	#2,(a2)+				; go to Cage_Ignore next
		move.w	#30,(a2)				; character will not be recaught in cage for 30 frames
		rts
; ===========================================================================

Cage_GivePoints:
		move.w	ost_cage_p1_timer-ost_cage_p1_routine(a2),d0 ; get timer
		andi.w	#$F,d0
		bne.s	.return					; play 'ding' sound and give 100 points every 16th frame
		move.w	#sfx_SlotMachine,d0
		jsr	(PlaySound).l
		moveq	#100/10,d0
		movea.w	a1,a3
		jsr	(AddPoints2).l				; add 100 points to player's score
		jsrto	FindFreeObj,JmpTo10_FindFreeObj		; find free OST slot
		bne.s	.return					; branch if not found
		_move.b	#id_Points,ost_id(a1)			; load points object
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#id_Frame_Points_100,ost_frame(a1)

	.return:
		rts
; ===========================================================================

Cage_Ignore: ; Subroutine 4
		subq.w	#1,2(a2)				; decrement timer
		bpl.s	.return					; branch if time remains
		clr.w	(a2)					; character can now be caught by cage again
		tst.b	ost_subtype(a0)				; is it a slot machine cage?
		beq.s	.return					; if not, exit
		clr.w	(f_slot_use).w				; clear slot use flag

	.return:
		rts
; ===========================================================================
Ani_Cage:	index offset(*)
		ptr Ani_Cage_Idle				; 0
		ptr Ani_Cage_Flash				; 1

Ani_Cage_Idle:
		dc.b $F
		dc.b id_Frame_Cage_Dark
		dc.b afEnd

Ani_Cage_Flash:
		dc.b 1
		dc.b id_Frame_Cage_Lit
		dc.b id_Frame_Cage_Dark
		dc.b afEnd
		even

; ===========================================================================

		include "mappings/sprite/CNZ Pinball Cages.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Psuedoobject that runs the CNZ slot machines.
; Offset constants are defined in RAM Addresses.asm.
; ---------------------------------------------------------------------------
SlotMachine:
		lea	(slot_machine_vars).w,a4
		moveq	#0,d0
		_move.b	slot_primary_routine(a4),d0
		jmp	SlotMachine_Index(pc,d0.w)
; ===========================================================================

SlotMachine_Index: bra_index
		braptr	Slot_Init				; 0
		braptr	Slot_Ready				; 4
		braptr	Slot_Start				; 8
		braptr	Slot_SpeedUp				; $C
		braptr	Slot_Run				; $10
		braptr	Slot_Finished				; $14 (index is never set to this)
		id_Slot_Null:	equ offset(*)-index_start	; $18
		rts

; IDs for slot faces
		rsreset
id_Slot_Sonic:		rs.b 1					; 0
id_Slot_Tails:		rs.b 1					; 1
id_Slot_Robotnik:	rs.b 1					; 2
id_Slot_Jackpot:	rs.b 1					; 3
id_Slot_Ring:		rs.b 1					; 4
id_Slot_Bar:		rs.b 1					; 5

; ------------------------------------------------------------------------------
; Initializes the slot machine and load the initial faces during level load
; ------------------------------------------------------------------------------

Slot_Init: ; Routine 0
		movea.l	a4,a1
		moveq	#(sizeof_slot_machine_vars/2)-1,d0	; $12 bytes

	.loop:
		clr.w	(a1)+					; clear the slot machine variables
		dbf	d0,.loop

		; Randomize the start of the slots.
		move.b	(v_vblank_counter_byte).w,d0		; frame counter is used as a psuedorandom seed
		move.b	d0,slot1_index(a4)			; only use lowest three bits
		ror.b	#3,d0					; rotate to the next three bits
		move.b	d0,slot2_index(a4)			; use the new lowest three
		ror.b	#3,d0					; rotate again (only two bits now)
		move.b	d0,slot3_index(a4)			; use the remaining two
		move.b	#8,slot1_offset(a4)			; set initial speeds and offsets
		move.b	#8,slot2_offset(a4)			; this entire block could be optimized to 'moveq #8,d0' and a series of 'move.b d0,destination'
		move.b	#8,slot3_offset(a4)
		move.b	#8,slot1_speed(a4)
		move.b	#8,slot2_speed(a4)
		move.b	#8,slot3_speed(a4)
		move.b	#1,slot_timer(a4)			; roll each slot once
		_addq.b	#4,slot_primary_routine(a4)		; go to Slot_Ready next
		rts

; ===========================================================================

Slot_Ready:	 ; Routine 4
		bsr.w	Slot_Draw				; draw the slots
		tst.b	slot_timer(a4)				; are we still rolling?
		beq.s	.done					; if not, branch
		rts
; ===========================================================================

	.done:
		_move.b	#id_Slot_Null,slot_primary_routine(a4)	; set null routine
		clr.w	slot1_speed(a4)				; clear slot speeds
		clr.w	slot2_speed(a4)
		clr.w	slot3_speed(a4)
		rts
; ===========================================================================

Slot_Start: ; Routine 8
		move.b	(v_vblank_counter_byte).w,d0		; use low byte of frame counter as pseudorandom seed
		andi.b	#7,d0					; only need lowest three bits
		subq.b	#4,d0					; three pairs of these two instructions can be optimized to 'addi.b $2C,d0'
		addi.b	#$30,d0
		move.b	d0,slot1_speed(a4)			; start speed for slot 1
		move.b	(v_vblank_counter_byte).w,d0		; use low byte of frame counter as pseudorandom seed
		rol.b	#4,d0					; only need top nybble
		andi.b	#7,d0					; discard sign bit
		subq.b	#4,d0
		addi.b	#$30,d0					; add $2C
		move.b	d0,slot2_speed(a4)			; start speed for slot 2
		move.b	(v_vblank_counter_word).w,d0		; use high byte of frame counter as pseudorandom seed
		andi.b	#7,d0					; only need lowest three bits
		subq.b	#4,d0
		addi.b	#$30,d0					; add $2C
		move.b	d0,slot3_speed(a4)			; start speed for slot 3
		move.b	#2,slot_timer(a4)			; roll each slot twice with these settings
		clr.b	slot_index(a4)
		clr.b	slot1_rout(a4)
		clr.b	slot2_rout(a4)
		clr.b	slot3_rout(a4)
		_addq.b	#4,slot_primary_routine(a4)		; go to Slot_SpeedUp next
		move.b	(v_vblank_counter_byte).w,d0		; use low byte of frame counter as pseudorandom seed
		ror.b	#3,d0					; shuffle it a bit
		lea	(Slot_TargetValues).l,a2		; could be PC relative

	.loop:
		sub.b	(a2),d0					; subtract value in array from seed value
		bcs.s	.islower				; branch if difference is lower than array value
		addq.w	#3,a2					; otherwise, advance 3 bytes..
		bra.s	.loop					; ...and loop
; ===========================================================================

	.islower:
		cmpi.b	#-1,(a2)				; was the previous value -1?
		beq.s	.end_of_array				; if so, branch (we've reached the end of the TargetValues array)
		move.b	1(a2),slot_targ1(a4)			; set target values using two sequential bytes from the TargetValuesarray
		move.b	2(a2),slot_targ23(a4)
		rts
; ===========================================================================

.end_of_array:
		; Select two bytes at random from the TargetValues array
		move.b	d0,d1					; copy seed value
		andi.w	#7,d1					; lowest three bits are index for slot 1 (but see below)
		lea	(SlotSequence1).l,a1
	if FixBugs
		move.b	(a1,d1.w),slot_targ1(a4)		; set slot 1 target
	else
		; This should be using d1 as the index, not d0!
		move.b	(a1,d0.w),slot_targ1(a4)		; set slot 1 target
	endc
		ror.b	#3,d0					; shuffle seed a bit
		move.b	d0,d1
		andi.w	#7,d1					; lowest three bits are index for slot 2
		lea	(SlotSequence2).l,a1
		move.b	(a1,d1.w),d2				; get slot 2 target
		lsl.b	#4,d2					; move to high nybble
		ror.b	#3,d0					; shuffle seed again
		andi.w	#7,d0					; lowest three bits are index for slot 3
		lea	(SlotSequence3).l,a1
		or.b	(a1,d0.w),d2				; get slot 3 target
		move.b	d2,slot_targ23(a4)			; set targets for slots 2 and 3
		rts
; ===========================================================================

Slot_SpeedUp: ; Routine $C
		bsr.w	Slot_Draw				; draw the slots
		tst.b	slot_timer(a4)				; has timer reached zero?
		beq.s	.timeleft				; if so, branch
		rts
; ===========================================================================

	.timeleft:
		addi.b	#$30,slot1_speed(a4)			; increase all slot speeds
		addi.b	#$30,slot2_speed(a4)
		addi.b	#$30,slot3_speed(a4)
		move.b	(v_vblank_counter_byte).w,d0		; use low byte of frame counter as pseudorandom seed
		andi.b	#$F,d0					; only need low nybble
		addi.b	#$C,d0					; add $C
		move.b	d0,slot_timer(a4)			; set new timer
		clr.b	2(a4)					; clear otherwise unused variable
		_addq.b	#4,slot_primary_routine(a4)		; go to Slot_Run next
		rts
; ===========================================================================

Slot_Run: ; Routine $10
		bsr.w	Slot_Draw				; draw the slots
		cmpi.b	#id_Slot_Done,slot1_rout(a4)		; is slot done?
		bne.s	.notdone				; branch if not
		cmpi.b	#id_Slot_Done,slot2_rout(a4)		; is slot done?
		bne.s	.notdone				; branch if not
		cmpi.b	#id_Slot_Done,slot3_rout(a4)		; is slot done?
		beq.w	Slot_Finished				; branch if so

	.notdone:
		moveq	#0,d0
		move.b	slot_index(a4),d0			; get current slot
		lea	slot_data(a4),a1			; a1 = start of slot data
		adda.w	d0,a1					; add slot index to get pointer to current slot data
		lea	(SlotSequence1).l,a3			; a3 = pointer to slot sequences
		add.w	d0,d0					; double current slot index
		adda.w	d0,a3					; add to a3 to get current slot sequence
		moveq	#0,d0
		move.b	slot_secondary_routine(a1),d0
		jmp	Slot_Run_Index(pc,d0.w)
; ===========================================================================

Slot_Run_Index: bra_index
		braptr	Slot_RunNormal				; 0
		braptr	Slot_NearTarget				; 4
		braptr	Slot_AtTarget				; 8
		braptr	Slot_Done				; $C
; ===========================================================================

Slot_GetSlotTarget:
		move.w	slot_targs(a4),d1			; d1 = target slot faces
		move.b	slot_index(a4),d0			; get current slot
		beq.s	.is_slot_1				; branch if it's slot 1
		lsr.w	d0,d1					; shift slot targets 2 and 3 to correct position

	.is_slot_1:
		andi.w	#7,d1					; only 6 slot faces
		cmpi.b	#id_Slot_Bar,d1				; have we gone above bar?
		bgt.s	.wrap_slot				; if so, branch
		rts
; ===========================================================================

	.wrap_slot:
		subq.b	#2,d1					; wrap back to ring or bar
		rts
; ===========================================================================

Slot_ChangeTarget:
		move.w	#$FFF0,d2				; bitmask to keep faces in high byte
		andi.w	#$F,d1					; d1 = new target
		move.b	slot_index(a4),d0			; get current slot
		beq.s	.is_slot_1				; branch if it's slot 1
		lsl.w	d0,d1					; shift new target to correct position
		rol.w	d0,d2					; shift face bitmask to correct position

	.is_slot_1:
		and.w	d2,slot_targs(a4)			; clear slot to be replaced
		or.w	d1,slot_targs(a4)			; replace with new target value
		andi.w	#$777,slot_targs(a4)			; slots are only 0-7
		rts
; ===========================================================================

Slot_RunNormal: ; Subroutine 0
		tst.b	slot_index(a4)				; is this slot 1?
		bne.s	.not_slot_1				; if not, branch
		tst.b	slot_timer(a4)				; has time run out (underflowed to negative)?
		bmi.s	.time_zero_or_prev_stopped		; if so, branch
		rts
; ===========================================================================

	.not_slot_1:
		cmpi.b	#id_Slot_AtTarget,slot1_rout-slot2_index(a1) ; has previous slot stopped?
		bge.s	.time_zero_or_prev_stopped		; if so, branch
		rts
; ===========================================================================

.time_zero_or_prev_stopped:
		bsr.s	Slot_GetSlotTarget			; get current slot target
		move.w	(a1),d0					; get current slot index/offset
		subi.w	#20*8,d0				; subtract 20 lines (2.5 tiles) from it
		lsr.w	#8,d0					; get effective slot index
		andi.w	#7,d0					; only need lowest three bits
		move.b	(a3,d0.w),d0				; get slot pic ID from sequence data
		cmp.b	d1,d0					; are we close to target?
		beq.s	.near_target				; if so, branch
		rts
; ===========================================================================

	.near_target:
		addq.b	#4,slot_secondary_routine(a1)		; go to Slot_NearTarget next
		move.b	#$60,slot_speed(a1)			; decrease slot speed
		rts
; ===========================================================================

Slot_NearTarget: ; Subroutine 4
		bsr.s	Slot_GetSlotTarget			; get current slot target
		move.w	(a1),d0					; get current slot index/offset
		addi.w	#30*8,d0				; add 30 lines (3.75 tiles) to it
		andi.w	#$700,d0				; limit to 8 pics
		lsr.w	#8,d0					; get effective slot index
		move.b	(a3,d0.w),d0				; get slot pic ID from sequence data
		cmp.b	d0,d1					; are we close to target?
		beq.s	.at_target				; if so, branch
		cmpi.b	#$20,slot_speed(a1)			; is slot speed greater than $20?
		bls.s	.no_speed_change			; if not, branch
		subi.b	#$C,slot_speed(a1)			; decrease slot speed

	.no_speed_change:
		cmpi.b	#$18,slot_speed(a1)			; is slot speed $18 or less?
		bgt.s	.chkoffset				; if not, branch
		rts
; ===========================================================================

	.chkoffset:
		cmpi.b	#$80,slot_offset(a1)			; is offset $80 or lesS?
		bls.s	.reduce_speed				; if so, branch
		rts
; ===========================================================================

	.reduce_speed:
		subq.b	#2,slot_speed(a1)			; decrease slot speed
		rts
; ===========================================================================

.at_target:
		move.w	(a1),d0					; get current slot index/offset
		addi.w	#16*8,d0				; subtract 16 lines (2 tiles) from it
		move.w	d0,d1					; copy to d1
		andi.w	#$700,d1				; limit to 8 pics
		subi.w	#2*8,d1					; subtract 2 lines (1/4 tile) from it
		move.w	d1,(a1)					; store new index/offset
		lsr.w	#8,d0					; use previous index value
		andi.w	#7,d0					; limit to 8 pics
		move.b	(a3,d0.w),d1				; get slot pic ID from sequence data
		bsr.w	Slot_ChangeTarget			; set slot index to pic ID in lieu of sequence index
		move.b	#-8,slot_speed(a1)			; rotate slowly backwards
		addq.b	#4,slot_secondary_routine(a1)		; go to Slot_AtTarget next
		rts
; ===========================================================================

Slot_AtTarget: ; Subroutine 8
		tst.b	slot_offset(a1)				; is offset 0?
		beq.s	.stop_slot				; if so, branch
		rts
; ===========================================================================

	.stop_slot:
		clr.b	slot_speed(a1)				; stop slot
		addq.b	#4,slot_secondary_routine(a1)		; go to Slot_Done next
		rts
; ===========================================================================

Slot_Done: ; Subroutine $C
		rts
; ===========================================================================

Slot_Finished: ;  Routine $14
		clr.w	slot1_speed(a4)				; stop all slots
		clr.w	slot2_speed(a4)
		clr.w	slot3_speed(a4)
		clr.b	slot_timer(a4)				; stop drawing the slots
		bsr.w	Slot_ChooseReward			; determine the winnings
		_move.b	#id_Slot_Null,slot_primary_routine(a4)	; we are done until next time
		rts

; ---------------------------------------------------------------------------
; Subroutine to draw the slot machine faces
; ---------------------------------------------------------------------------

Slot_Draw:
		moveq	#0,d0
		move.b	slot_index(a4),d0			; d0 = index of slot to draw
		lea	slot_data(a4),a1			; a1 = start of slot data
		adda.w	d0,a1					; add slot index to get pointer to current slot data
		lea	(SlotSequence1).l,a3			; first slot sequence
		adda.w	d0,a3					; add slot index twice
		adda.w	d0,a3
		jmp	Slot_Draw_Index(pc,d0.w)
; ===========================================================================

Slot_Draw_Index:
		bra.w	Slot_Draw1				; 0
		bra.w	Slot_Draw2				; 4
		; index 8 branches directly to the start of Slot_Draw3
; ===========================================================================
Slot_Draw3:
		clr.b	slot_index(a4)				; go to Slot_DrawSlot1 next
		subq.b	#1,slot_timer(a4)			; decrement timer
		move.w	#vram_SlotPics3,d2			; DMA destination
		bra.s	Slot_DrawChk
; ===========================================================================

Slot_Draw1:
		addq.b	#4,slot_index(a4)			; go to Slot_DrawSlot2 next
		move.w	#vram_SlotPics1,d2			; DMA destination
		bra.w	Slot_DrawChk				; could be optimized to bra.s
; ===========================================================================

Slot_Draw2:
		addq.b	#4,slot_index(a4)			; go to Slot_DrawSlot3 next
		move.w	#vram_SlotPics2,d2			; DMA destination
		; continue directly into Slot_DrawChk

Slot_DrawChk:
		move.w	(a1),d0					; get last pixel offset
		move.b	slot_speed(a1),d1			; get slot rotation speed
		ext.w	d1					; extend to word
		sub.w	d1,(a1)					; modify pixel offset
		move.w	(a1),d3					; get current pixel offset
		andi.w	#$7F8,d0				; only need bits 3-10 of both
		andi.w	#$7F8,d3
		cmp.w	d0,d3					; are they equal?
		bne.s	.update_slot_art			; if not, branch
		rts

; ---------------------------------------------------------------------------
; Subroutine to update slot machine art and queue a DMA transfer
; Slot art is stored in a buffer in the 16x16 block table
; ---------------------------------------------------------------------------

.update_slot_art:
		bsr.w	.get_pixel_row				; get pointer to pixel row
		lea	(v_16x16_tiles+$1000).w,a1		; destination

		move.w	#(16*2)-1,d1				; each slot pic is 4 16x16 blocks, so 32 pixel rows to update

	.pixel_row_loop:
		; a2 = current pixel row in Art_CNZSlotPics
		move.l	$80(a2),$80(a1)				; copy row for second column
		move.l	$100(a2),$100(a1)			; copy row for third column
		move.l	$180(a2),$180(a1)			; copy row for fourth column
		move.l	(a2)+,(a1)+				; copy row for first column and advance pointers
		addq.b	#8,d3					; increment offset by 8
		bne.s	.notzero				; branch if not zero
		addi.w	#$100,d3				; advance to next slot picture
		andi.w	#$700,d3				; limit to 8 pictures
		bsr.w	.get_pixel_row				; get pointer for next pixel row

	.notzero:
		dbf	d1,.pixel_row_loop			; loop for 32 pixel rows

		move.l	#(v_16x16_tiles+$1000)&$FFFFFF,d1	; DMA source
		tst.w	(f_two_player).w			; is it two-player mode?
		beq.s	.not2P					; if not, branch
		addi.w	#vram_SlotPics1_2p-vram_SlotPics1,d2	; adjust DMA destination

	.not2P:
		move.w	#sizeof_SlotPic/2,d3			; DMA length in words
		jsr	(AddDMA).l				; could be jmp
		rts
; ===========================================================================

.get_pixel_row:
		move.w	d3,d0					; d0 = pixel offset into slot picture
		lsr.w	#8,d0					; convert offset into index
		andi.w	#7,d0					; limit to 8 pics
		move.b	(a3,d0.w),d0				; get slot pic ID from sequence data
		andi.w	#7,d0					; only lower 3 bits; leaves space for 2 more images
		ror.w	#7,d0					; equal to shifting left 9 places
		lea	(Art_CNZSlotPics).l,a2
		adda.w	d0,a2					; a2 = pointer to first tile of slot picture
		move.w	d3,d0
		andi.w	#$F8,d0					; strip high word
		lsr.w	#1,d0					; convert to bytes
		adda.w	d0,a2					; a2 = pointer to desired pixel row
		rts
; ===========================================================================

Slot_ChooseReward:
		move.b	slot_targ23(a4),d2			; get target of slots 2 and 3
		move.b	d2,d3
		andi.w	#$F0,d2					; d2 = target of slot 2
		lsr.w	#4,d2					; shift slot 2 to low nybble
		andi.w	#$F,d3					; d3 = target of slot 3
		moveq	#0,d0
		cmp.b	slot_targ1(a4),d2			; are slots 1 and 2 equal?
		bne.s	.nomatch_1_2				; if not, branch
		addq.w	#4,d0

	.nomatch_1_2:
		cmp.b	slot_targ1(a4),d3			; are slots 1 and 3 equal?
		bne.s	.nomatch_1_3				; branch if not
		addq.w	#8,d0

	.nomatch_1_3:
		jmp	Slot_RewardIndex(pc,d0.w)
; ===========================================================================

Slot_RewardIndex:	bra_index
		braptr	Slot_Unmatched1				; 0
		braptr	Slot_Match12				; 4
		braptr	Slot_Match13				; 8
		id_Slot_TripleMatch:	equ offset(*)-index_start ; $C

Slot_TripleMatch:
		move.w	d2,d0
		bsr.w	Slot_GetReward
		move.w	d0,slot_targs(a4)			; store reward
		rts
; ===========================================================================

Slot_Match13:
		cmpi.b	#id_Slot_Jackpot,d3			; is slot 3 a jackpot?
		bne.s	.notjackpot				; if not, branch
		move.w	d2,d0					; slot 2 is reward index
		bsr.w	Slot_GetReward
		bsr.w	Slot_QuadrupleReward
		move.w	d0,slot_targs(a4)
		rts
; ===========================================================================

	.notjackpot:
		cmpi.b	#id_Slot_Jackpot,d2			; is slot 2 a jackpot?
		bne.w	Slot_Unmatched1				; if not, branch
		move.w	d3,d0					; slot 3 is reward index
		bsr.w	Slot_GetReward
		bsr.w	Slot_DoubleReward
		move.w	d0,slot_targs(a4)			; store reward
		rts
; ===========================================================================

Slot_Match12:
		cmpi.b	#id_Slot_Jackpot,d2			; is slot 2 a jackpot?
		bne.s	.notjackpot				; if not, branch
		move.w	d3,d0					; slot 3 is reward index
		bsr.s	Slot_GetReward
		bsr.w	Slot_QuadrupleReward
		move.w	d0,slot_targs(a4)			; store reward
		rts
; ===========================================================================

	.notjackpot:
		cmpi.b	#id_Slot_Jackpot,d3
		bne.w	Slot_Unmatched1
		move.w	d2,d0					; slot 2 is reward index
		bsr.s	Slot_GetReward
		bsr.w	Slot_DoubleReward
		move.w	d0,slot_targs(a4)			; store reward
		rts
; ===========================================================================

Slot_Unmatched1:
		cmp.b	d2,d3					; are slots 2 and 3 equal?
		bne.s	Slot_CheckBars				; if not, branch
		cmpi.b	#id_Slot_Jackpot,slot_targ1(a4)		; is slot 1 a jackpot?
		bne.s	.notjackpot				; if not, branch
		move.w	d2,d0					; slot 2 is reward index
		bsr.s	Slot_GetReward
		bsr.w	Slot_DoubleReward
		move.w	d0,slot_targs(a4)			; store reward
		rts
; ===========================================================================

	.notjackpot:
		cmpi.b	#id_Slot_Jackpot,d2			; is slot 1 a jackpot?
		bne.s	Slot_CheckBars				; if not, branch
		move.b	slot_targ1(a4),d0			; slot 1 is reward index
		andi.w	#$F,d0					; (after stripping the high nybble)
		bsr.s	Slot_GetReward
		bsr.w	Slot_QuadrupleReward
		move.w	d0,slot_targs(a4)			; store reward
		rts
; ===========================================================================

Slot_CheckBars:
		moveq	#2,d1					; number of rings per bar
		moveq	#0,d0					; 0 if no bars are found
		cmpi.b	#id_Slot_Bar,slot_targ1(a4)		; is slot 1 a bar?
		bne.s	.notslot1				; if not, branch
		add.w	d1,d0					; gain 2 rings

	.notslot1:
		cmpi.b	#id_Slot_Bar,d2				; is slot 2 a bar?
		bne.s	.notslot2				; if not, branch
		add.w	d1,d0					; gain 2 rings

	.notslot2:
		cmpi.b	#id_Slot_Bar,d3				; is slot 3 a bar?
		bne.s	.notslot3				; if not, branch
		add.w	d1,d0					; gain 2 rings

	.notslot3:
		move.w	d0,slot_targs(a4)

	if FixBugs
		; For bars, the code past this line is useless. There should be an rts here.
		rts
	endc
; ===========================================================================

Slot_GetReward:
		add.w	d0,d0					; double to get index
		lea	(Slot_RingRewards).l,a2			; ring reward array (could be PC-relative)
		move.w	(a2,d0.w),d0				; get ring reward
		rts

; ----------------------------------------------------------------------------
; One-instruction subroutines to double and quadruple ring rewards.
; It would be much faster to simply place these instructions in-line instead
; of branching to them.
; ----------------------------------------------------------------------------

Slot_QuadrupleReward:
		asl.w	#2,d0
		rts
; ===========================================================================

Slot_DoubleReward:
		add.w	d0,d0
		rts

; ----------------------------------------------------------------------------
; Slot machine ring rewards
; -1 is a flag indicating player will receive a bomb penalty instead.
; ----------------------------------------------------------------------------

Slot_RingRewards:
		dc.w   30,  25,  -1, 150,  10,  20

; ----------------------------------------------------------------------------
; Slot machine target values
; Each byte represents the final positions for two slot faces: one in each
; nybble. Note that several of these values exceed 5; these are reduced to
; 4 or 5 by Slot_GetSlotTarget if so required. Depending on the frame counter
; seed, either two bytes after a multiple of 3 up to $F (e.g., bytes 4 and 5)
; are used, or two bytes anywhere in the array are selected at random.
; ----------------------------------------------------------------------------

Slot_TargetValues:
		dc.b id_Slot_Sonic<<4|(id_Slot_Sonic|8)		; 0
		dc.b id_Slot_Sonic<<4|id_Slot_Jackpot
		dc.b id_Slot_Jackpot<<4|id_Slot_Jackpot
		dc.b id_Slot_Tails<<4|id_Slot_Robotnik		; 3
		dc.b id_Slot_Sonic<<4|id_Slot_Sonic
		dc.b id_Slot_Sonic<<4|id_Slot_Sonic
		dc.b id_Slot_Tails<<4|id_Slot_Robotnik		; 6
		dc.b id_Slot_Sonic<<4|id_Slot_Tails
		dc.b id_Slot_Tails<<4|id_Slot_Tails
		dc.b id_Slot_Robotnik<<4|id_Slot_Ring		; 9
		dc.b id_Slot_Sonic<<4|id_Slot_Robotnik
		dc.b id_Slot_Robotnik<<4|id_Slot_Robotnik
		dc.b id_Slot_Tails<<4|(id_Slot_Ring+$A)		; $C
		dc.b id_Slot_Sonic<<4|id_Slot_Ring
		dc.b id_Slot_Ring<<4|id_Slot_Ring
		dc.b id_Slot_Tails<<4|(id_Slot_Ring+$A)		; $F
		dc.b id_Slot_Sonic<<4|id_Slot_Bar
		dc.b id_Slot_Bar<<4|id_Slot_Bar
		dc.b (id_Slot_Bar+$A)<<4|(id_Slot_Bar+$A)	; $12
		dc.b id_Slot_Sonic<<4|(id_Slot_Bar+$A)
		dc.b (id_Slot_Bar+$A)<<4|(id_Slot_Bar+$A)
		rev02even

; ----------------------------------------------------------------------------
; Slot machine face sequences
; ----------------------------------------------------------------------------

SlotSequence1:
		dc.b id_Slot_Jackpot
		dc.b id_Slot_Sonic
		dc.b id_Slot_Tails
		dc.b id_Slot_Ring
		dc.b id_Slot_Robotnik
		dc.b id_Slot_Bar
		dc.b id_Slot_Ring
		dc.b id_Slot_Tails
		rev02even

SlotSequence2:
		dc.b id_Slot_Jackpot
		dc.b id_Slot_Sonic
		dc.b id_Slot_Tails
		dc.b id_Slot_Ring
		dc.b id_Slot_Robotnik
		dc.b id_Slot_Bar
		dc.b id_Slot_Sonic
		dc.b id_Slot_Robotnik
		rev02even

SlotSequence3:
		dc.b id_Slot_Jackpot
		dc.b id_Slot_Sonic
		dc.b id_Slot_Tails
		dc.b id_Slot_Ring
		dc.b id_Slot_Robotnik
		dc.b id_Slot_Bar
		dc.b id_Slot_Ring
		dc.b id_Slot_Tails
		even

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo10_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo29_DespawnObject:
		jmp	(DespawnObject).l
JmpTo10_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo6_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo54_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo12_CalcSine:
		jmp	(CalcSine).l
JmpTo7_SolidObject_NoRenderChk_SingleCharacter:
		jmp	(SolidObject_NoRenderChk_SingleCharacter).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D7 - CNZ hexagonal bumper
; ----------------------------------------------------------------------------

HexagonalBumper:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	HexBump_Index(pc,d0.w),d1
		jmp	HexBump_Index(pc,d1.w)
; ===========================================================================
HexBump_Index:	index offset(*),,2
		ptr loc_2C45A					; 0
		ptr loc_2C4AC					; 2
; ===========================================================================

loc_2C45A:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_HexBump,ost_mappings(a0)
		move.w	#tile_Nem_HexBumper+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo55_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	#id_col_16x8+id_col_custom,ost_col_type(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2C496
		move.b	#1,$34(a0)

loc_2C496:
		move.w	ost_x_pos(a0),d0
		move.w	d0,d1
		subi.w	#$60,d0
		move.w	d0,$30(a0)
		addi.w	#$60,d1
		move.w	d1,$32(a0)

loc_2C4AC:
		move.b	ost_col_property(a0),d0
		beq.w	loc_2C57E
		lea	($FFFFB000).w,a1
		bclr	#0,ost_col_property(a0)
		beq.s	loc_2C4C2
		bsr.s	loc_2C4D8

loc_2C4C2:
		lea	($FFFFB040).w,a1
		bclr	#1,ost_col_property(a0)
		beq.s	loc_2C4D0
		bsr.s	loc_2C4D8

loc_2C4D0:
		clr.b	ost_col_property(a0)
		bra.w	loc_2C57E
; ===========================================================================

loc_2C4D8:
		move.w	ost_x_pos(a0),d1
		move.w	ost_y_pos(a0),d2
		sub.w	ost_x_pos(a1),d1
		sub.w	ost_y_pos(a1),d2
		jsr	(CalcAngle).l
		addi.b	#$20,d0
		andi.w	#$C0,d0
		cmpi.w	#$40,d0
		beq.s	loc_2C516
		cmpi.w	#$80,d0
		beq.s	loc_2C534
		cmpi.w	#$C0,d0
		beq.s	loc_2C542
		move.w	#-$800,ost_x_vel(a1)
		move.b	#2,ost_anim(a0)
		bra.s	loc_2C55E
; ===========================================================================

loc_2C516:
		subi.w	#$200,ost_x_vel(a1)
		tst.w	d1
		bpl.s	loc_2C526
		addi.w	#$400,ost_x_vel(a1)

loc_2C526:
		move.w	#-$800,ost_y_vel(a1)
		move.b	#1,ost_anim(a0)
		bra.s	loc_2C55E
; ===========================================================================

loc_2C534:
		move.w	#$800,ost_x_vel(a1)
		move.b	#2,ost_anim(a0)
		bra.s	loc_2C55E
; ===========================================================================

loc_2C542:
		subi.w	#$200,ost_x_vel(a1)
		tst.w	d1
		bpl.s	loc_2C552
		addi.w	#$400,ost_x_vel(a1)

loc_2C552:
		move.w	#$800,ost_y_vel(a1)
		move.b	#1,ost_anim(a0)

loc_2C55E:
		bset	#1,ost_primary_status(a1)
		bclr	#4,ost_primary_status(a1)
		bclr	#5,ost_primary_status(a1)
		clr.b	$3C(a1)
		move.w	#$B4,d0
		jmp	(PlaySound).l
; ===========================================================================

loc_2C57E:
		lea	(Ani_HexBump).l,a1
		jsrto	AnimateSprite,JmpTo11_AnimateSprite
		tst.b	ost_subtype(a0)
		beq.w	JmpTo30_DespawnObject
		tst.b	$34(a0)
		beq.s	loc_2C5AE
		move.w	ost_x_pos(a0),d0
		subq.w	#1,d0
		cmp.w	$30(a0),d0
		bne.s	loc_2C5A8
		move.b	#0,$34(a0)

loc_2C5A8:
		move.w	d0,ost_x_pos(a0)
		bra.s	loc_2C5C4
; ===========================================================================

loc_2C5AE:
		move.w	ost_x_pos(a0),d0
		addq.w	#1,d0
		cmp.w	$32(a0),d0
		bne.s	loc_2C5C0
		move.b	#1,$34(a0)

loc_2C5C0:
		move.w	d0,ost_x_pos(a0)

loc_2C5C4:
		tst.w	(f_two_player).w
		beq.s	loc_2C5CE
		jmpto	DisplaySprite,JmpTo30_DisplaySprite
; ===========================================================================

loc_2C5CE:
		move.w	$30(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bls.s	loc_2C5F2
		move.w	$32(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		cmpi.w	#$280,d0
		bhi.s	loc_2C5F8

loc_2C5F2:
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2C5F8:
		lea	(v_respawn_list).w,a2
		moveq	#0,d0
		move.b	ost_respawn(a0),d0
		beq.s	loc_2C60A
		bclr	#7,2(a2,d0.w)

loc_2C60A:
		jmp	(DeleteObject).l

    if RemoveJmpTos
JmpTo30_DespawnObject:
		jmp	(DespawnObject).l
    endc
; ===========================================================================
Ani_HexBump:	index offset(*)
		ptr byte_2C616					; 0
		ptr byte_2C619					; 1
		ptr byte_2C61F					; 2

byte_2C616:
		dc.b  $F,  0,$FF
		rev02even
byte_2C619:
		dc.b   3,  1,  0,  1,$FD,  0
		rev02even
byte_2C61F:
		dc.b   3,  2,  0,  2,$FD,  0
		even
; ===========================================================================
		include "mappings/sprite/CNZ Hexagonal Bumper.asm"
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo30_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo30_DespawnObject:
		jmp	(DespawnObject).l
JmpTo11_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo55_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object D8 - CNZ saucer bumper
; ----------------------------------------------------------------------------

SaucerBumper:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SauceBump_Index(pc,d0.w),d1
		jmp	SauceBump_Index(pc,d1.w)
; ===========================================================================
SauceBump_Index:	index offset(*),,2
		ptr loc_2C6C0					; 0
		ptr loc_2C6FC					; 2
		ptr loc_2C884					; 4
; ===========================================================================

loc_2C6C0:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_SauceBump,ost_mappings(a0)
		move.w	#tile_Nem_SaucerBumper+tile_pal3,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo56_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#1,ost_priority(a0)
		move.b	#id_col_8x8_2+id_col_custom,ost_col_type(a0)
		move.b	ost_subtype(a0),d0
		rol.b	#2,d0
		andi.b	#3,d0
		move.b	d0,ost_anim(a0)

loc_2C6FC:
		move.b	ost_col_property(a0),d0
		bne.w	loc_2C70A
		tst.w	$30(a0)
		beq.s	loc_2C740

loc_2C70A:
		lea	$30(a0),a4
		tst.b	(a4)
		beq.s	loc_2C716
		subq.b	#1,(a4)
		bra.s	loc_2C724
; ===========================================================================

loc_2C716:
		lea	($FFFFB000).w,a1
		bclr	#0,ost_col_property(a0)
		beq.s	loc_2C724
		bsr.s	loc_2C74E

loc_2C724:
		addq.w	#1,a4
		tst.b	(a4)
		beq.s	loc_2C72E
		subq.b	#1,(a4)
		bra.s	loc_2C73C
; ===========================================================================

loc_2C72E:
		lea	($FFFFB040).w,a1
		bclr	#1,ost_col_property(a0)
		beq.s	loc_2C73C
		bsr.s	loc_2C74E

loc_2C73C:
		clr.b	ost_col_property(a0)

loc_2C740:
		lea	(Ani_SauceBump).l,a1
		jsrto	AnimateSprite,JmpTo12_AnimateSprite
		jmpto	DespawnObject,JmpTo31_DespawnObject
; ===========================================================================

loc_2C74E:
		move.b	ost_frame(a0),d0
		subq.b	#3,d0
		beq.s	loc_2C75C
		bcc.s	loc_2C77A
		addq.b	#3,d0
		bne.s	loc_2C77A

loc_2C75C:
		move.b	#3,ost_anim(a0)
		move.w	#-$700,ost_y_vel(a1)
		move.w	ost_y_pos(a0),d2
		sub.w	ost_y_pos(a1),d2
		bpl.s	loc_2C776
		neg.w	ost_y_vel(a1)

loc_2C776:
		bra.w	loc_2C806
; ===========================================================================

loc_2C77A:
		subq.b	#1,d0
		bne.s	loc_2C7EC
		move.b	#4,ost_anim(a0)
		move.w	#$20,d3
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_2C794
		move.w	#$60,d3

loc_2C794:
		move.w	ost_x_vel(a1),d1
		move.w	ost_y_vel(a1),d2
		jsr	(CalcAngle).l
		sub.w	d3,d0
		move.w	d0,d1
		bpl.s	loc_2C7AA
		neg.w	d1

loc_2C7AA:
		neg.w	d0
		add.w	d3,d0
		cmpi.b	#$40,d1
		bcc.s	loc_2C7BE
		cmpi.b	#$38,d1
		bcs.s	loc_2C7D0
		move.w	d3,d0
		bra.s	loc_2C7D0
; ===========================================================================

loc_2C7BE:
		subi.w	#$80,d1
		neg.w	d1
		cmpi.b	#$38,d1
		bcs.s	loc_2C7D0
		move.w	d3,d0
		addi.w	#$80,d0

loc_2C7D0:
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a1)
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a1)
		bra.s	loc_2C806
; ===========================================================================

loc_2C7EC:
		move.b	#5,ost_anim(a0)
		move.w	#-$700,ost_x_vel(a1)
		move.w	ost_x_pos(a0),d2
		sub.w	ost_x_pos(a1),d2
		bpl.s	loc_2C806
		neg.w	ost_x_vel(a1)

loc_2C806:
		bset	#1,ost_primary_status(a1)
		bclr	#4,ost_primary_status(a1)
		bclr	#5,ost_primary_status(a1)
		clr.b	$3C(a1)
		move.w	#$D8,d0
		jsr	(PlaySound).l
		movea.w	a1,a3
		moveq	#4,d3
		moveq	#1,d0
		subi.w	#tile_pal2,ost_tile(a0)
		bcc.s	loc_2C85C
		addi.w	#tile_pal2,ost_tile(a0)
		move.b	#4,ost_primary_routine(a0)
		lea	(v_cnz_saucer_data).w,a1
		move.b	ost_subtype(a0),d1
		andi.w	#$3F,d1
		lea	(a1,d1.w),a1
		addq.b	#1,(a1)
		cmpi.b	#3,(a1)
		bcs.s	loc_2C85C
		moveq	#2,d3
		moveq	#$32,d0

loc_2C85C:
		jsr	(AddPoints2).l
		jsrto	FindFreeObj,JmpTo11_FindFreeObj
		bne.s	loc_2C87E
		_move.b	#id_Points,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	d3,ost_frame(a1)

loc_2C87E:
		move.b	#4,(a4)
		rts
; ===========================================================================

loc_2C884:
		lea	(Ani_SauceBump).l,a1
		jsrto	AnimateSprite,JmpTo12_AnimateSprite
		cmpi.b	#3,ost_anim(a0)
		bcs.w	JmpTo46_DeleteObject
		jmpto	DespawnObject,JmpTo31_DespawnObject

    if RemoveJmpTos
JmpTo46_DeleteObject:
		jmp	(DeleteObject).l
    endc
; ===========================================================================
Ani_SauceBump:	index offset(*)
		ptr byte_2C8A8					; 0
		ptr byte_2C8AB					; 1
		ptr byte_2C8AE					; 2
		ptr byte_2C8B1					; 3
		ptr byte_2C8B7					; 4
		ptr byte_2C8BD					; 5

byte_2C8A8:
		dc.b  $F,  0,$FF
		rev02even

byte_2C8AB:
		dc.b  $F,  1,$FF
		rev02even

byte_2C8AE:
		dc.b  $F,  2,$FF
		rev02even

byte_2C8B1:
		dc.b   3,  3,  0,  3,$FD,  0
		rev02even

byte_2C8B7:
		dc.b   3,  4,  1,  4,$FD,  1
		rev02even

byte_2C8BD:
		dc.b   3,  5,  2,  5,$FD,  2,  0
		even
; ===========================================================================
		include "mappings/sprite/CNZ Saucer Bumper.asm"
; ===========================================================================

	if RemoveJmpTos=0
JmpTo46_DeleteObject:
		jmp	(DeleteObject).l
JmpTo11_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo31_DespawnObject:
		jmp	(DespawnObject).l
JmpTo12_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo56_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc
; ===========================================================================
; ----------------------------------------------------------------------------
; Object D9 - invisible grab block (e.g. the rails in WFZ)
; ----------------------------------------------------------------------------

InvisibleGrabBlock:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2C93A(pc,d0.w),d1
		jmp	off_2C93A(pc,d1.w)
; ===========================================================================
off_2C93A:	index offset(*),,2
		ptr loc_2C93E					; 0
		ptr loc_2C954					; 2
; ===========================================================================

loc_2C93E:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#$18,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)

loc_2C954:
		lea	$30(a0),a2
		lea	($FFFFB000).w,a1
		move.w	(v_joypad_hold_actual).w,d0
		bsr.s	loc_2C972
		lea	($FFFFB040).w,a1
		addq.w	#1,a2
		move.w	(v_joypad2_hold_actual).w,d0
		bsr.s	loc_2C972
		jmpto	DespawnObject3,JmpTo7_DespawnObject3
; ===========================================================================

loc_2C972:
		tst.b	(a2)
		beq.s	loc_2C9A0
		andi.b	#$70,d0
		beq.w	locret_2CA08
		clr.b	$2A(a1)
		clr.b	(a2)
		move.b	#$12,2(a2)
		andi.w	#$F00,d0
		beq.s	loc_2C996
		move.b	#$3C,2(a2)

loc_2C996:
		move.w	#-$300,ost_y_vel(a1)
		bra.w	locret_2CA08
; ===========================================================================

loc_2C9A0:
		tst.b	2(a2)
		beq.s	loc_2C9AE
		subq.b	#1,2(a2)
		bne.w	locret_2CA08

loc_2C9AE:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$18,d0
		cmpi.w	#$30,d0
		bcc.w	locret_2CA08
		move.w	ost_y_pos(a1),d1
		sub.w	ost_y_pos(a0),d1
		cmpi.w	#$10,d1
		bcc.w	locret_2CA08
		tst.b	$2A(a1)
		bmi.s	locret_2CA08
		cmpi.b	#6,ost_primary_routine(a1)
		bcc.s	locret_2CA08
		tst.w	(v_debug_active).w
		bne.s	locret_2CA08
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		clr.w	ost_inertia(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$14,ost_anim(a1)
		move.b	#1,$2A(a1)
		move.b	#1,(a2)

locret_2CA08:
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo7_DespawnObject3:
		jmp	(DespawnObject3).l
		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 4A - Octus
; ----------------------------------------------------------------------------

Octus:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2CA22(pc,d0.w),d1
		jmp	off_2CA22(pc,d1.w)
; ===========================================================================
off_2CA22:	index offset(*),,2
		ptr loc_2CA52					; 0
		ptr loc_2CAB8					; 2
		ptr loc_2CA46					; 4
		ptr loc_2CA2A					; 6
; ===========================================================================

loc_2CA2A:
		subi_.w	#1,$2C(a0)
		bmi.s	loc_2CA34
		rts
; ===========================================================================

loc_2CA34:
		jsrto	SpeedToPos,JmpTo19_SpeedToPos
		lea	(Ani_Octus).l,a1
		jsrto	AnimateSprite,JmpTo13_AnimateSprite
		jmpto	DespawnObject,JmpTo32_DespawnObject
; ===========================================================================

loc_2CA46:
		subq.w	#1,$2C(a0)
		beq.w	JmpTo47_DeleteObject
		jmpto	DisplaySprite,JmpTo31_DisplaySprite

    if RemoveJmpTos
JmpTo47_DeleteObject:
		jmp	(DeleteObject).l
    endc
; ===========================================================================

loc_2CA52:
		move.l	#Map_Octus,ost_mappings(a0)
		move.w	#tile_Nem_Octus+tile_pal2,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#id_col_16x8,ost_col_type(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#$B,ost_height(a0)
		move.b	#8,ost_width(a0)
		jsrto	ObjectFall,JmpTo2_ObjectFall
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_2CAB0
		add.w	d1,ost_y_pos(a0)
		move.w	#0,ost_y_vel(a0)
		addq.b	#2,ost_primary_routine(a0)
		move.w	ost_x_pos(a0),d0
		sub.w	($FFFFB008).w,d0
		bpl.s	loc_2CAB0
		bchg	#status_xflip_bit,ost_primary_status(a0)

loc_2CAB0:
		move.w	ost_y_pos(a0),$2A(a0)
		rts
; ===========================================================================

loc_2CAB8:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2CAD4(pc,d0.w),d1
		jsr	off_2CAD4(pc,d1.w)
		lea	(Ani_Octus).l,a1
		jsrto	AnimateSprite,JmpTo13_AnimateSprite
		jmpto	DespawnObject,JmpTo32_DespawnObject
; ===========================================================================
off_2CAD4:	index offset(*),,2
		ptr loc_2CADE					; 0
		ptr loc_2CB04					; 2
		ptr loc_2CB20					; 4
		ptr loc_2CB3A					; 6
		ptr loc_2CB48					; 8
; ===========================================================================

loc_2CADE:
		move.w	ost_x_pos(a0),d0
		sub.w	(v_ost_player1+ost_x_pos).w,d0
		cmpi.w	#$80,d0
		bgt.s	locret_2CB02
		cmpi.w	#-$80,d0
		blt.s	locret_2CB02
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_anim(a0)
		move.w	#$20,$2C(a0)

locret_2CB02:
		rts
; ===========================================================================

loc_2CB04:
		subq.w	#1,$2C(a0)
		bmi.s	loc_2CB0C
		rts
; ===========================================================================

loc_2CB0C:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#4,ost_anim(a0)
		move.w	#-$200,ost_y_vel(a0)
		jmpto	SpeedToPos,JmpTo19_SpeedToPos
; ===========================================================================

loc_2CB20:
		addi.w	#$10,ost_y_vel(a0)
		bpl.s	loc_2CB2C
		jmpto	SpeedToPos,JmpTo19_SpeedToPos
; ===========================================================================

loc_2CB2C:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$3C,$2C(a0)
		bra.w	loc_2CB70
; ===========================================================================

loc_2CB3A:
		subq.w	#1,$2C(a0)
		bmi.s	loc_2CB42
		rts
; ===========================================================================

loc_2CB42:
		addq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_2CB48:
		addi.w	#$10,ost_y_vel(a0)
		move.w	ost_y_pos(a0),d0
		cmp.w	$2A(a0),d0
		bcc.s	loc_2CB5C
		jmpto	SpeedToPos,JmpTo19_SpeedToPos
; ===========================================================================

loc_2CB5C:
		clr.b	ost_secondary_routine(a0)
		clr.b	ost_anim(a0)
		clr.w	ost_y_vel(a0)
		move.b	#1,ost_frame(a0)
		rts
; ===========================================================================

loc_2CB70:
		; In the Simon Wai beta, the object loads another object
		; here, which makes it look angry as it fires.
		; This object would have used Obj4A_Angry.
		jsr	(FindFreeObj).l
		bne.s	locret_2CBDA
		_move.b	#id_Octus,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.l	#Map_Octus,ost_mappings(a1)
		move.w	#tile_Nem_Octus+tile_pal2,ost_tile(a1)
		move.b	#4,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#$F,$2C(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	#2,ost_anim(a1)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a1)
		move.w	#-$200,ost_x_vel(a1)
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	locret_2CBDA
		neg.w	ost_x_vel(a1)

locret_2CBDA:
		rts
; ===========================================================================
Ani_Octus:	index offset(*)
		ptr byte_2CBE6					; 0
		ptr byte_2CBEA					; 1
		ptr byte_2CBEF					; 2
		ptr byte_2CBF4					; 3
		ptr byte_2CBF8					; 4

byte_2CBE6:
		dc.b  $F,  1,  0,$FF
		rev02even

byte_2CBEA:
		dc.b   3,  1,  2,  3,$FF
		rev02even

byte_2CBEF:
		dc.b   2,  5,  6,$FF
		even

byte_2CBF4:
		dc.b  $F,  4,$FF
		even

byte_2CBF8:
		dc.b   7,  0,  1,$FD,  1
		even

; ===========================================================================

		include "mappings/sprite/Octus.asm"

	if RemoveJmpTos=0
		align 4
	endc
; ===========================================================================

	if RemoveJmpTos=0
JmpTo31_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo47_DeleteObject:
		jmp	(DeleteObject).l
JmpTo32_DespawnObject:
		jmp	(DespawnObject).l
JmpTo13_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo2_ObjectFall:
		jmp	(ObjectFall).l
JmpTo19_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 50 - Aquis
; ----------------------------------------------------------------------------

Aquis:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_2CCD6(pc,d0.w),d1
		jmp	off_2CCD6(pc,d1.w)
; ===========================================================================
off_2CCD6:	index offset(*),,2
		ptr loc_2CCDE					; 0
		ptr loc_2CDA2					; 2
		ptr loc_2CDCA					; 4
		ptr loc_2CDF4					; 6
; ===========================================================================

loc_2CCDE:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Aquis,ost_mappings(a0)
		move.w	#tile_Nem_Aquis+tile_pal2,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#id_col_16x8,ost_col_type(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.w	#-$100,ost_x_vel(a0)
		move.b	ost_subtype(a0),d0
		move.b	d0,d1
		andi.w	#$F0,d1
		lsl.w	#4,d1
		move.w	d1,$2E(a0)
		move.w	d1,$30(a0)
		andi.w	#$F,d0
		lsl.w	#4,d0
		subq.w	#1,d0
		move.w	d0,$32(a0)
		move.w	d0,$34(a0)
		move.w	ost_y_pos(a0),$2A(a0)
		move.w	(v_water_height_actual).w,$3A(a0)
		move.b	#3,$2E(a0)
		jsrto	FindFreeObj,JmpTo12_FindFreeObj
		bne.s	loc_2CDA2
		_move.b	#id_Aquis,ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$A,ost_x_pos(a1)
		addi.w	#-6,ost_y_pos(a1)
		move.l	#Map_Aquis,ost_mappings(a1)
		move.w	#tile_Nem_Aquis+tile_pal2,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	#3,ost_anim(a1)
		move.l	a1,$36(a0)
		move.l	a0,$36(a1)
		bset	#render_subsprites_bit,ost_primary_status(a0) ; pointless, as this object does not have any child sprites, and they set the bit in the wrong OST variable

loc_2CDA2:
		lea	(Ani_Aquis).l,a1
		jsrto	AnimateSprite,JmpTo14_AnimateSprite
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2CDC2(pc,d0.w),d1
		jsr	off_2CDC2(pc,d1.w)
		bsr.w	loc_2CF32
		jmpto	DespawnObject,JmpTo33_DespawnObject
; ===========================================================================
off_2CDC2:	index offset(*),,2
		ptr loc_2CE06					; 0
		ptr loc_2CE14					; 2
		ptr loc_2CE1A					; 4
		ptr loc_2CF2E					; 6
; ===========================================================================

loc_2CDCA:
		movea.l	$36(a0),a1
		tst.b	ost_id(a1)				; redundant check
		beq.w	JmpTo48_DeleteObject
		cmpi.b	#id_Aquis,ost_id(a1)
		bne.w	JmpTo48_DeleteObject
		btst	#status_broken_bit,ost_primary_status(a1)
		bne.w	JmpTo48_DeleteObject
		lea	(Ani_Aquis).l,a1
		jsrto	AnimateSprite,JmpTo14_AnimateSprite
		jmpto	DisplaySprite,JmpTo32_DisplaySprite
; ===========================================================================

loc_2CDF4:
		jsrto	SpeedToPos,JmpTo20_SpeedToPos
		lea	(Ani_Aquis).l,a1
		jsrto	AnimateSprite,JmpTo14_AnimateSprite
		jmpto	DespawnObject,JmpTo33_DespawnObject
; ===========================================================================

loc_2CE06:
		tst.b	ost_render(a0)
		bmi.s	loc_2CE0E
		rts
; ===========================================================================

loc_2CE0E:
		addq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_2CE14:
		bsr.w	loc_2CEAE
		rts
; ===========================================================================

loc_2CE1A:
		bsr.w	loc_2CEF8
		bsr.w	loc_2CE24
		rts
; ===========================================================================

loc_2CE24:
		tst.b	$2D(a0)
		bne.w	locret_2CEAC
		st.b	$2D(a0)
		jsrto	FindPlayer,JmpTo_FindPlayer
		tst.w	d1
		beq.s	locret_2CEAC
	if FixBugs=0
		cmpi.w	#-$10,d1				; ...? d1 can only be 0 or 2 here
		bcc.s	locret_2CEAC
	endc

		jsrto	FindFreeObj,JmpTo12_FindFreeObj
		bne.s	locret_2CEAC
		_move.b	#id_Aquis,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	#Map_Aquis,ost_mappings(a1)
		move.w	#tile_Nem_Aquis+tile_pal2,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$A,d0
		move.w	#$10,d1
		move.w	#-$300,d2
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2CE9A
		neg.w	d1
		neg.w	d2

loc_2CE9A:
		sub.w	d0,ost_y_pos(a1)
		sub.w	d1,ost_x_pos(a1)
		move.w	d2,ost_x_vel(a1)
		move.w	#$200,ost_y_vel(a1)

locret_2CEAC:
		rts
; ===========================================================================

loc_2CEAE:
		subq.b	#1,$3C(a0)
		bmi.s	loc_2CEEA
		jsrto	FindPlayer,JmpTo_FindPlayer
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	d0
		beq.s	loc_2CEC8
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_2CEC8:
		move.w	word_2CEE6(pc,d0.w),d2
		add.w	d2,ost_x_vel(a0)
		move.w	word_2CEE6(pc,d1.w),d2
		add.w	d2,ost_y_vel(a0)
		move.w	#$100,d0
		move.w	d0,d1
		jsrto	CapSpeed,JmpTo_CapSpeed
		jmpto	SpeedToPos,JmpTo20_SpeedToPos
; ===========================================================================
word_2CEE6:
		dc.w -$10					; 0
		dc.w  $10					; 2
; ===========================================================================

loc_2CEEA:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$20,$3C(a0)
		jmpto	MoveStop,JmpTo_MoveStop
; ===========================================================================

loc_2CEF8:
		subq.b	#1,$3C(a0)
		bmi.s	loc_2CF00
		rts
; ===========================================================================

loc_2CF00:
		subq.b	#1,$2E(a0)
		bmi.s	loc_2CF1C
		subq.b	#2,ost_secondary_routine(a0)
		move.w	#-$100,ost_y_vel(a0)
		move.b	#-$80,$3C(a0)
		clr.b	$2D(a0)
		rts
; ===========================================================================

loc_2CF1C:
		move.b	#6,ost_secondary_routine(a0)
		move.w	#-$200,ost_x_vel(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_2CF2E:
		jmpto	SpeedToPos,JmpTo20_SpeedToPos
; ===========================================================================

loc_2CF32:
		moveq	#$A,d0
		moveq	#-6,d1
		movea.l	$36(a0),a1
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	ost_respawn(a0),ost_respawn(a1)
		move.b	ost_render(a0),ost_render(a1)
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_2CF62
		neg.w	d0

loc_2CF62:
		add.w	d0,ost_x_pos(a1)
		add.w	d1,ost_y_pos(a1)
		rts
; ===========================================================================
Ani_Aquis:
		dc.w byte_2CF78-Ani_Aquis			; 0
		dc.w byte_2CF7B-Ani_Aquis			; 1
		dc.w byte_2CF83-Ani_Aquis			; 2
		dc.w byte_2CF89-Ani_Aquis			; 3
		dc.w byte_2CF8D-Ani_Aquis			; 4
		dc.w byte_2CF90-Ani_Aquis			; 5

byte_2CF78:
		dc.b  $E,  0,$FF
		rev02even

byte_2CF7B:
		dc.b   5,  3,  4,  3,  4,  3,  4,$FF
		rev02even

byte_2CF83:
		dc.b   3,  5,  6,  7,  6,$FF
		rev02even

byte_2CF89:
		dc.b   3,  1,  2,$FF
		rev02even

byte_2CF8D:
		dc.b   1,  5,$FF
		rev02even

byte_2CF90:
		dc.b  $E,  8,$FF
		even

; ===========================================================================
		include "mappings/sprite/Aquis.asm"
; ===========================================================================

	if RemoveJmpTos
JmpTo48_DeleteObject:
		jmp	(DeleteObject).l
	else
JmpTo32_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo48_DeleteObject:
		jmp	(DeleteObject).l
JmpTo12_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo33_DespawnObject:
		jmp	(DespawnObject).l
JmpTo14_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo_FindPlayer:
		jmp	(FindPlayer).l
JmpTo_CapSpeed:
		jmp	(CapSpeed).l
JmpTo_MoveStop:
		jmp	(MoveStop).l
JmpTo20_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 4B - Buzzer
; ----------------------------------------------------------------------------

Buzzer:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Buzz_Index(pc,d0.w),d1
		jmp	Buzz_Index(pc,d1.w)
; ===========================================================================
Buzz_Index:	index offset(*),,2
		ptr Buzz_Main					; 0
		ptr Buzz_Action					; 2
		ptr Buzz_Flame					; 4
		ptr Buzz_Projectile				; 6
; ===========================================================================

Buzz_Projectile:
		jsrto	SpeedToPos,JmpTo21_SpeedToPos
		lea	(Ani_Buzz).l,a1
		jsrto	AnimateSprite,JmpTo15_AnimateSprite
		jmpto	DespawnObject4,JmpTo_DespawnObject4
; ===========================================================================

Buzz_Flame:
		movea.l	$2A(a0),a1
	if FixBugs
		cmpi.b	#id_Buzzer,ost_id(a1)			; is parent buzzer still loaded?
		bne.w	JmpTo49_DeleteObject			; if not, branch
	else
		; This check doesn't really work: it's possible for an object to be
		; loaded into the parent's slot before this object can check if the
		; slot is empty. In fact, it will always be immediately occupied by
		; the explosion object. This defect causes the flame to linger for a
		; while after the Buzzer is destroyed.
		tst.b	ost_id(a1)				; is parent slot empty?
		beq.w	JmpTo49_DeleteObject			; if so, branch (but see bug description above)
	endc
		tst.w	$30(a1)
		bmi.s	loc_2D0A2
		rts
; ===========================================================================

loc_2D0A2:
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		lea	(Ani_Buzz).l,a1
		jsrto	AnimateSprite,JmpTo15_AnimateSprite
		jmpto	DespawnObject4,JmpTo_DespawnObject4
; ===========================================================================

Buzz_Main:
		move.l	#Map_Buzz,ost_mappings(a0)
		move.w	#tile_Nem_Buzzer,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo57_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#id_col_16x8,ost_col_type(a0)
		move.b	#4,ost_priority(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.b	#$10,ost_height(a0)
		move.b	#$18,ost_width(a0)
		move.b	#3,ost_priority(a0)
		addq.b	#2,ost_primary_routine(a0)
		jsrto	FindNextFreeObj,JmpTo20_FindNextFreeObj
		bne.s	locret_2D172
		_move.b	#id_Buzzer,ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.l	#Map_Buzz,ost_mappings(a1)
		move.w	#tile_Nem_Buzzer,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo7_AdjustVRAM2P2
		move.b	#4,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#1,ost_anim(a1)
		move.l	a0,$2A(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#$100,$2E(a0)
		move.w	#-$100,ost_x_vel(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	locret_2D172
		neg.w	ost_x_vel(a0)

locret_2D172:
		rts
; ===========================================================================

Buzz_Action:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	Buzz_Action_Index(pc,d0.w),d1
		jsr	Buzz_Action_Index(pc,d1.w)
		lea	(Ani_Buzz).l,a1
		jsrto	AnimateSprite,JmpTo15_AnimateSprite
		jmpto	DespawnObject4,JmpTo_DespawnObject4
; ===========================================================================
Buzz_Action_Index:	index offset(*),,2
		ptr Buzz_Roaming				; 0
		ptr Buzz_Shooting				; 2
; ===========================================================================

Buzz_Roaming:
		bsr.w	loc_2D1D6
		subq.w	#1,$30(a0)
		move.w	$30(a0),d0
		cmpi.w	#$F,d0
		beq.s	loc_2D1BA
		tst.w	d0
		bpl.s	locret_2D1B8
		subq.w	#1,$2E(a0)
		bgt.w	JmpTo21_SpeedToPos
		move.w	#$1E,$30(a0)

	locret_2D1B8:
		rts
; ===========================================================================

loc_2D1BA:
		sf.b	$32(a0)
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		bchg	#status_xflip_bit,ost_primary_status(a0)
		move.w	#$100,$2E(a0)
		rts
; ===========================================================================

loc_2D1D6:
		tst.b	$32(a0)
		bne.w	locret_2D232
		move.w	ost_x_pos(a0),d0
		lea	($FFFFB000).w,a1
		btst	#0,(v_vblank_counter_byte).w
		beq.s	loc_2D1F2
		lea	($FFFFB040).w,a1

loc_2D1F2:
		sub.w	ost_x_pos(a1),d0
		move.w	d0,d1
		bpl.s	loc_2D1FC
		neg.w	d0

loc_2D1FC:
		cmpi.w	#$28,d0
		blt.s	locret_2D232
		cmpi.w	#$30,d0
		bgt.s	locret_2D232
		tst.w	d1
		bpl.s	loc_2D216
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	locret_2D232
		bra.s	loc_2D21E
; ===========================================================================

loc_2D216:
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	locret_2D232

loc_2D21E:
		st.b	$32(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_anim(a0)
		move.w	#$32,$34(a0)

locret_2D232:
		rts
; ===========================================================================

Buzz_Shooting:
		move.w	$34(a0),d0
		subq.w	#1,d0
		blt.s	loc_2D248
		move.w	d0,$34(a0)
		cmpi.w	#$14,d0
		beq.s	loc_2D24E
		rts
; ===========================================================================

loc_2D248:
		subq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_2D24E:
		jsr	(FindNextFreeObj).l
		bne.s	loc_2D2C8
		_move.b	#id_Buzzer,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.l	#Map_Buzz,ost_mappings(a1)
		move.w	#tile_Nem_Buzzer,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo7_AdjustVRAM2P2
		move.b	#4,ost_priority(a1)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#2,ost_anim(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$18,ost_y_pos(a1)
		move.w	#$D,d0
		move.w	#$180,ost_y_vel(a1)
		move.w	#-$180,ost_x_vel(a1)
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_2D2C8
		neg.w	ost_x_vel(a1)
		neg.w	d0

loc_2D2C8:
		add.w	d0,ost_x_pos(a1)
		rts
; ===========================================================================
Ani_Buzz:	index offset(*)
		ptr byte_2D2D6					; 0
		ptr byte_2D2D9					; 1
		ptr byte_2D2DD					; 2
		ptr byte_2D2E1					; 3

byte_2D2D6:
		dc.b  $F,  0,$FF
		rev02even

byte_2D2D9:
		dc.b   2,  3,  4,$FF
		rev02even

byte_2D2DD:
		dc.b   3,  5,  6,$FF
		rev02even

byte_2D2E1:
		dc.b   9,  1,  1,  1,  1,  1,$FD,  0
		even
; ===========================================================================

		include "mappings/sprite/Buzzer.asm"

	if RemoveJmpTos=0
		align 4
	endc
; ===========================================================================

	JmpTo49_DeleteObject:
		jmp	(DeleteObject).l

	if RemoveJmpTos
JmpTo21_SpeedToPos:
		jmp	(SpeedToPos).l
	else
JmpTo20_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo15_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo7_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo_DespawnObject4:
		jmp	(DespawnObject4).l
JmpTo57_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo21_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 5C - Masher
; ----------------------------------------------------------------------------

Masher:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Mash_Index(pc,d0.w),d1
		jsr	Mash_Index(pc,d1.w)
		jmpto	DespawnObject,JmpTo34_DespawnObject
; ===========================================================================
Mash_Index:	index offset(*),,2
		ptr loc_2D3AA					; 0
		ptr loc_2D3E4					; 2
; ===========================================================================

loc_2D3AA:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_Mash,ost_mappings(a0)
		move.w	#tile_Nem_Masher,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo58_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#id_col_12x16,ost_col_type(a0)
		move.b	#$10,ost_displaywidth(a0)
		move.w	#-$400,ost_y_vel(a0)
		move.w	ost_y_pos(a0),$30(a0)

loc_2D3E4:
		lea	(Ani_Mash).l,a1
		jsrto	AnimateSprite,JmpTo16_AnimateSprite
		jsrto	SpeedToPos,JmpTo22_SpeedToPos
		addi.w	#$18,ost_y_vel(a0)
		move.w	$30(a0),d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	loc_2D40C
		move.w	d0,ost_y_pos(a0)
		move.w	#-$500,ost_y_vel(a0)

loc_2D40C:
		move.b	#1,ost_anim(a0)
		subi.w	#$C0,d0
		cmp.w	ost_y_pos(a0),d0
		bcc.s	locret_2D42E
		move.b	#0,ost_anim(a0)
		tst.w	ost_y_vel(a0)
		bmi.s	locret_2D42E
		move.b	#2,ost_anim(a0)

locret_2D42E:
		rts
; ===========================================================================
Ani_Mash:	index offset(*)
		ptr byte_2D436					; 0
		ptr byte_2D43A					; 1
		ptr byte_2D43E					; 2

byte_2D436:
		dc.b   7,  0,  1,$FF

byte_2D43A:
		dc.b   3,  0,  1,$FF

byte_2D43E:
		dc.b   7,  0,$FF
		even
; ===========================================================================

		include "mappings/sprite/Masher.asm"

	if RemoveJmpTos=0
		align 4
	endc
; ===========================================================================

	if RemoveJmpTos=0
JmpTo34_DespawnObject:
		jmp	(DespawnObject).l
JmpTo16_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo58_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo22_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 58 - Boss explosion
; ----------------------------------------------------------------------------

ExplosionBomb:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ExBom_Index(pc,d0.w),d1
		jmp	ExBom_Index(pc,d1.w)
; ===========================================================================
ExBom_Index:	index offset(*),,2
		ptr loc_2D4A6					; 0
		ptr loc_2D4EC					; 2
; ===========================================================================

loc_2D4A6:
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_ExplodeBomb,ost_mappings(a0)
		move.w	#tile_Nem_FieryExplosion+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo59_AdjustVRAM2P
		move.b	#render_rel,ost_render(a0)
		move.b	#0,ost_priority(a0)
		move.b	#0,ost_col_type(a0)
		move.b	#$C,ost_displaywidth(a0)
		move.b	#7,ost_anim_time(a0)
		move.b	#0,ost_frame(a0)
		move.w	#$C4,d0
		jmp	(PlaySound).l
; ===========================================================================
		rts						; dead code
; ===========================================================================

loc_2D4EC:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2D506
		move.b	#7,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#7,ost_frame(a0)
		beq.w	JmpTo50_DeleteObject

loc_2D506:
		jmpto	DisplaySprite,JmpTo33_DisplaySprite

    if RemoveJmpTos
JmpTo50_DeleteObject:
		jmp	(DeleteObject).l
    endif
; ===========================================================================

		include "mappings/sprite/Boss Explosion.asm"

; ===========================================================================
		; Unused Sonic 1 leftover: a small fragment of code from BGHZ_Update
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	(v_boss_y_pos).w,d0
		move.w	d0,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		addq.b	#2,ost_boss_wobble(a0)
		; end dead code


BOOZ_Hit:	; only used by OOZ boss; all others handle hits in their own code
		cmpi.b	#8,ost_boss_routine(a0)
		bcc.s	locret_2D5C2
		tst.b	ost_boss_hitcount2(a0)
		beq.s	loc_2D5C4
		tst.b	ost_col_type(a0)
		bne.s	locret_2D5C2
		tst.b	ost_boss_flash_time(a0)
		bne.s	loc_2D5A6
		move.b	#$20,ost_boss_flash_time(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_2D5A6:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_2D5B4
		move.w	#$EEE,d0

loc_2D5B4:
		move.w	d0,(a1)
		subq.b	#1,ost_boss_flash_time(a0)
		bne.s	locret_2D5C2
		move.b	#id_col_24x24,ost_col_type(a0)

locret_2D5C2:
		rts
; ===========================================================================

loc_2D5C4:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo_AddPoints
		move.w	#$B3,(v_boss_timer).w
		move.b	#8,ost_boss_routine(a0)
		moveq	#$40,d0
		jsrto	AddPLC,JmpTo4_AddPLC
		rts
; ===========================================================================

BossMove:
		move.l	($FFFFF750).w,d2
		move.l	(v_boss_y_pos).w,d3
		move.w	(v_boss_x_vel).w,d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	(v_boss_y_vel).w,d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,($FFFFF750).w
		move.l	d3,(v_boss_y_pos).w
		rts
; ===========================================================================

BossAnimate:
		moveq	#0,d6
		movea.l	a1,a4
		lea	($FFFFF740).w,a2
		lea	ost_mainspr_frame(a0),a3
		tst.b	(a3)
		bne.s	loc_2D618
		addq.w	#2,a2
		bra.s	loc_2D61C
; ===========================================================================

loc_2D618:
		bsr.w	loc_2D62A

loc_2D61C:
		moveq	#0,d6
		move.b	ost_mainspr_childsprites(a0),d6
		subq.w	#1,d6
		bmi.s	locret_2D690
		lea	ost_subspr2_frame(a0),a3

loc_2D62A:
		movea.l	a4,a1
		moveq	#0,d0
		moveq	#0,d1
		moveq	#0,d2
		moveq	#0,d4
		move.b	(a2)+,d0
		move.b	d0,d1
		lsr.b	#4,d1
		andi.b	#$F,d0
		move.b	d0,d2
		cmp.b	d0,d1
		beq.s	loc_2D646
		st.b	d4

loc_2D646:
		move.b	d0,d5
		lsl.b	#4,d5
		or.b	d0,d5
		move.b	(a2)+,d0
		move.b	d0,d1
		lsr.b	#4,d1
		tst.b	d4
		beq.s	loc_2D65A
		moveq	#0,d0
		moveq	#0,d1

loc_2D65A:
		andi.b	#$F,d0
		subi_.b	#1,d0
		bpl.s	loc_2D67C
		add.w	d2,d2
		adda.w	(a1,d2.w),a1
		move.b	(a1),d0
		move.b	1(a1,d1.w),d2
		bmi.s	loc_2D692

loc_2D672:
		andi.b	#$7F,d2
		move.b	d2,(a3)
		addi_.b	#1,d1

loc_2D67C:
		lsl.b	#4,d1
		or.b	d1,d0
		move.b	d0,-1(a2)
		move.b	d5,-2(a2)
		adda_.w	#6,a3
		dbf	d6,loc_2D62A

locret_2D690:
		rts
; ===========================================================================

loc_2D692:
		addq.b	#1,d2
		bne.s	loc_2D6A0
		move.b	#0,d1
		move.b	1(a1),d2
		bra.s	loc_2D672
; ===========================================================================

loc_2D6A0:
		addq.b	#1,d2
		bne.s	loc_2D6AC
		addi_.b	#2,ost_angle(a0)
		rts
; ===========================================================================

loc_2D6AC:
		addq.b	#1,d2
		bne.s	loc_2D6BA
		andi.b	#-$10,d5
		or.b	2(a1,d1.w),d5
		bra.s	loc_2D67C
; ===========================================================================

loc_2D6BA:
		addq.b	#1,d2
		bne.s	locret_2D6CA
		moveq	#0,d3
		move.b	2(a1,d1.w),d1
		move.b	1(a1,d1.w),d2
		bra.s	loc_2D672
; ===========================================================================

locret_2D6CA:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to load explosions when a boss is beaten
; ---------------------------------------------------------------------------

BossExplode:
		move.b	(v_vblank_counter_byte).w,d0		; get byte that increments every frame
		andi.b	#7,d0					; read bits 0-2
		bne.s	.fail					; branch if any are set
		jsr	(FindFreeObj).l				; find free OST slot
		bne.s	.fail					; branch if not found
		_move.b	#id_ExplosionBomb,ost_id(a1)		; load boss explosion object every 8 frames
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; copy position from parent boss object
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1					; this is pointless, as d1 is cleared immediately after
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,ost_x_pos(a1)			; randomize position
		lsr.w	#8,d0
		lsr.b	#2,d0
		subi.w	#$20,d0
		add.w	d0,ost_y_pos(a1)

	.fail:
		rts
; ===========================================================================

	if RemoveJmpTos=0
JmpTo33_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo50_DeleteObject:
		jmp	(DeleteObject).l
JmpTo4_AddPLC:
		jmp	(AddPLC).l
JmpTo_AddPoints:
		jmp	(AddPoints).l
JmpTo59_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 5D - CPZ boss
; ----------------------------------------------------------------------------

BossChemicalPlant:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	BCPZ_Index(pc,d0.w),d1
		jmp	BCPZ_Index(pc,d1.w)
; ===========================================================================
BCPZ_Index:	index offset(*),,2
		ptr BCPZ_Main					; 0
		ptr BCPZ_ShipMain				; 2
		ptr BCPZ_Pipe					; 4
		ptr BCPZ_Pipe_Pump				; 6
		ptr BCPZ_Pipe_Retract				; 8
		ptr BCPZ_Dripper				; $A
		ptr BCPZ_Gunk					; $C
		ptr BCPZ_PipeSegment				; $E
		ptr BCPZ_Container				; $10
		ptr BCPZ_Pump					; $12
		ptr BCPZ_FallingParts				; $14
		ptr BCPZ_Eggman					; $16
		ptr BCPZ_Flame					; $18
		ptr BCPZ_Smoke					; $1A

		rsobj BossChemicalPlant,$2A
	; Some of these are only used by certain subobjects of this object,
	; hence the overlap.
ost_bcpz_timer2:			rs.w 1			; $2A
ost_bcpz_pipe_segments:		rs.w 1				; $2C
ost_bcpz_primary_status:	equ __rs-1			; $2D
ost_bcpz_x_vel:				rs.w 1			; $2E
ost_bcpz_secondary_status:	equ	ost_bcpz_x_vel		; $2E; read as byte
ost_bcpz_x_pos_next:		rs.l 1				; $30
ost_bcpz_timer:				equ	ost_bcpz_x_pos_next ; $30; read as byte
ost_bcpz_y_offset:			equ __rs-3		; $31; read as byte
ost_bcpz_timer3:			equ __rs-2		; $32; read as byte
ost_bcpz_parent:			rs.l 1			; $34
ost_bcpz_y_pos_next:		rs.l 1				; $38
ost_bcpz_defeat_timer:		rs.w 1				; $3C
ost_bcpz_flag:				equ ost_bcpz_defeat_timer ; $3C; read as byte
ost_bcpz_timer4:			equ ost_bcpz_defeat_timer ; $3C; read as byte
ost_bcpz_invulnerable_time:	rs.b 1				; $3E
ost_bcpz_hover_counter:		rs.b 1				; $3F

		rsobjend
; ===========================================================================

BCPZ_Main:
		move.l	#Map_BCPZ_Eggpod,ost_mappings(a0)
		move.w	#tile_Nem_Eggpod_CPZ+tile_pal2,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.w	#$2B80,ost_x_pos(a0)
		move.w	#$4B0,ost_y_pos(a0)
		move.b	#3,ost_priority(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_col_property(a0)
		addq.b	#2,ost_primary_routine(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$38(a0)
		bclr	#3,$2D(a0)
		jsrto	AdjustVRAM2P,JmpTo60_AdjustVRAM2P
		jsr	(FindNextFreeObj).l
		bne.w	loc_2D8AC
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	a1,$34(a0)
		move.l	#Map_BCPZ_Eggpod,ost_mappings(a1)
		move.w	#tile_Nem_Eggpod_CPZ,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#3,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$16,ost_primary_routine(a1)
		move.b	#1,ost_anim(a1)
		move.b	ost_render(a0),ost_render(a1)
		jsrto	AdjustVRAM2P2,JmpTo8_AdjustVRAM2P2
		tst.b	ost_subtype(a0)
		bmi.w	loc_2D8AC
		jsr	(FindNextFreeObj).l
		bne.w	loc_2D8AC
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_EggpodJets,ost_mappings(a1)
		move.w	#tile_Nem_EggpodJets_CPZ,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo8_AdjustVRAM2P2
		move.b	#1,ost_anim_time(a0)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#3,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$18,ost_primary_routine(a1)
		move.b	ost_render(a0),ost_render(a1)
		jsr	(FindNextFreeObj).l
		bne.s	loc_2D8AC
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$12,ost_primary_routine(a1)

loc_2D8AC:
		jsr	(FindNextFreeObj).l
		bne.s	loc_2D908
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		subi.w	#$38,ost_y_pos(a1)
		subi.w	#$10,ost_x_pos(a1)
		move.w	#-$10,$2E(a1)
		addi.b	#$10,ost_primary_routine(a1)
		move.b	#6,ost_anim(a1)

loc_2D908:
		jsr	(FindNextFreeObj).l
		bne.s	locret_2D94C
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#4,ost_primary_routine(a1)

locret_2D94C:
		rts
; ===========================================================================

BCPZ_ShipMain:
		bsr.w	loc_2D992
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	BCPZ_Ship_Index(pc,d0.w),d1
		jsr	BCPZ_Ship_Index(pc,d1.w)
		lea	(Ani_BCPZ_Eggman).l,a1
		jsr	(AnimateSprite).l
		move.b	ost_primary_status(a0),d0
		andi.b	#3,d0
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d0,ost_render(a0)
		jmp	(DisplaySprite).l
; ===========================================================================
BCPZ_Ship_Index:	index offset(*),,2
		ptr loc_2DA62					; 0
		ptr loc_2DB98					; 2
		ptr loc_2DC00					; 4
		ptr loc_2DC14					; 6
		ptr loc_2D9B4					; 8
		ptr loc_2D9D8					; $A
		ptr loc_2DA22					; $C
; ===========================================================================

loc_2D992:
		cmpi.b	#8,ost_secondary_routine(a0)
		bge.s	locret_2D9AA
		move.w	(v_ost_player1+ost_x_pos).w,d0
		sub.w	ost_x_pos(a0),d0
		bgt.s	loc_2D9AC
		bclr	#status_xflip_bit,ost_primary_status(a0)

	locret_2D9AA:
		rts
; ===========================================================================

loc_2D9AC:
		bset	#status_xflip_bit,ost_primary_status(a0)
		rts
; ===========================================================================

loc_2D9B4:
		subq.w	#1,$3C(a0)
		bpl.w	loc_2DB34
		bset	#status_xflip_bit,ost_primary_status(a0)
		bclr	#status_broken_bit,ost_primary_status(a0)
		clr.w	ost_x_vel(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#-$26,$3C(a0)
		rts
; ===========================================================================

loc_2D9D8:
		addq.w	#1,$3C(a0)
		beq.s	loc_2D9E8
		bpl.s	loc_2D9EE
		addi.w	#$18,ost_y_vel(a0)
		bra.s	loc_2DA1A
; ===========================================================================

loc_2D9E8:
		clr.w	ost_y_vel(a0)
		bra.s	loc_2DA1A
; ===========================================================================

loc_2D9EE:
		cmpi.w	#$30,$3C(a0)
		bcs.s	loc_2DA06
		beq.s	loc_2DA0E
		cmpi.w	#$38,$3C(a0)
		bcs.s	loc_2DA1A
		addq.b	#2,ost_secondary_routine(a0)
		bra.s	loc_2DA1A
; ===========================================================================

loc_2DA06:
		subi_.w	#8,ost_y_vel(a0)
		bra.s	loc_2DA1A
; ===========================================================================

loc_2DA0E:
		clr.w	ost_y_vel(a0)
		jsrto	RestoreLevelMusic,JmpTo_RestoreLevelMusic
		jsrto	LoadAnimalExplosionArt,JmpTo_LoadAnimalExplosionArt

loc_2DA1A:
		bsr.w	loc_2DB0E
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DA22:
		bset	#6,$2E(a0)
		move.w	#$400,ost_x_vel(a0)
		move.w	#-$40,ost_y_vel(a0)
		cmpi.w	#$2C30,(v_boundary_right).w
		bcc.s	loc_2DA42
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_2DA48
; ===========================================================================

loc_2DA42:
		tst.b	ost_render(a0)
		bpl.s	loc_2DA50

loc_2DA48:
		bsr.w	loc_2DB0E
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DA50:
		addq.l	#4,sp
		movea.l	$34(a0),a1
		jsr	(DeleteChild).l

    if RemoveJmpTos
JmpTo51_DeleteObject:
    endc

		jmp	(DeleteObject).l
; ===========================================================================

loc_2DA62:
		move.w	#$100,ost_y_vel(a0)
		bsr.w	loc_2DB0E
		cmpi.w	#$4C0,$38(a0)
		bne.s	loc_2DA7E
		move.w	#0,ost_y_vel(a0)
		addq.b	#2,ost_secondary_routine(a0)

loc_2DA7E:
		move.b	$3F(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$38(a0),d0
		move.w	d0,ost_y_pos(a0)
		move.w	$30(a0),ost_x_pos(a0)
		addq.b	#2,$3F(a0)
		cmpi.b	#8,ost_secondary_routine(a0)
		bcc.s	locret_2DAE8
		tst.b	ost_primary_status(a0)
		bmi.s	loc_2DAEA
		tst.b	ost_col_type(a0)
		bne.s	locret_2DAE8
		tst.b	$3E(a0)
		bne.s	loc_2DAC6
		move.b	#$20,$3E(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_2DAC6:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_2DAD4
		move.w	#$EEE,d0

loc_2DAD4:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_2DAE8
		move.b	#id_col_24x24,ost_col_type(a0)
		bclr	#1,$2D(a0)

locret_2DAE8:
		rts
; ===========================================================================

loc_2DAEA:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo2_AddPoints
		move.b	#8,ost_secondary_routine(a0)
		move.w	#$B3,$3C(a0)
		movea.l	$34(a0),a1
		move.b	#4,ost_anim(a1)
		moveq	#$40,d0
		jmpto	AddPLC,JmpTo5_AddPLC
; ===========================================================================
		rts						; dead code
; ===========================================================================

loc_2DB0E:
		move.l	$30(a0),d2
		move.l	$38(a0),d3
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,$30(a0)
		move.l	d3,$38(a0)
		rts
; ===========================================================================

loc_2DB34:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#7,d0
		bne.s	locret_2DB7A
		jsr	(FindFreeObj).l
		bne.s	locret_2DB7A
		_move.b	#id_ExplosionBomb,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,ost_x_pos(a1)
		lsr.w	#8,d0
		lsr.b	#2,d0
		subi.w	#$20,d0
		add.w	d0,ost_y_pos(a1)

locret_2DB7A:
		rts
; ===========================================================================

loc_2DB7C:
		jsr	(FindFreeObj).l
		bne.s	locret_2DB96
		_move.b	#id_ExplosionBomb,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

locret_2DB96:
		rts
; ===========================================================================

loc_2DB98:
		btst	#3,$2D(a0)
		bne.s	loc_2DBA6
		move.w	#$2B30,d0
		bra.s	loc_2DBAA
; ===========================================================================

loc_2DBA6:
		move.w	#$2A50,d0

loc_2DBAA:
		move.w	d0,d1
		sub.w	$30(a0),d0
		bpl.s	loc_2DBB4
		neg.w	d0

loc_2DBB4:
		cmpi.w	#3,d0
		ble.s	loc_2DBD6
		cmp.w	$30(a0),d1
		bgt.s	loc_2DBC8
		move.w	#-$300,ost_x_vel(a0)
		bra.s	loc_2DBCE
; ===========================================================================

loc_2DBC8:
		move.w	#$300,ost_x_vel(a0)

loc_2DBCE:
		bsr.w	loc_2DB0E
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DBD6:
		cmpi.w	#$4C0,$38(a0)
		bne.w	loc_2DA7E
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bchg	#3,$2D(a0)
		bset	#0,$2E(a0)
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DC00:
		btst	#0,$2E(a0)
		beq.s	loc_2DC0C
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DC0C:
		addq.b	#2,ost_secondary_routine(a0)
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DC14:
		move.w	($FFFFB008).w,d0
		addi.w	#$4C,d0
		cmp.w	$30(a0),d0
		bgt.s	loc_2DC42
		beq.w	loc_2DA7E
		subi.l	#loc_10000,$30(a0)
		cmpi.w	#$2A28,$30(a0)
		bgt.w	loc_2DA7E
		move.w	#$2A28,$30(a0)
		bra.w	loc_2DA7E
; ===========================================================================

loc_2DC42:
		addi.l	#loc_10000,$30(a0)
		cmpi.w	#$2B70,$30(a0)
		blt.w	loc_2DA7E
		move.w	#$2B70,$30(a0)
		bra.w	loc_2DA7E
; ===========================================================================

BCPZ_FallingParts:
		cmpi.b	#-7,$30(a0)
		beq.s	loc_2DC80
		subi_.b	#1,$30(a0)
		bgt.w	JmpTo34_DisplaySprite
		bsr.w	loc_2DB7C
		move.b	#-7,$30(a0)
		move.w	#$1E,$2A(a0)

loc_2DC80:
		subq.w	#1,$2A(a0)
		bpl.w	JmpTo34_DisplaySprite
		move.w	ost_x_vel(a0),d0
		add.w	d0,ost_x_pos(a0)
		move.l	ost_y_pos(a0),d3
		move.w	ost_y_vel(a0),d0
		addi.w	#$38,ost_y_vel(a0)
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,ost_y_pos(a0)
		cmpi.l	#$5800000,d3
		bcc.w	JmpTo51_DeleteObject
		jmpto	DespawnObject,JmpTo35_DespawnObject
; ===========================================================================

BCPZ_Pump:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.s	loc_2DCEC
		movea.l	$34(a0),a1
		move.l	ost_x_pos(a1),ost_x_pos(a0)
		move.l	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_render(a1),ost_render(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		movea.l	#Ani_BCPZ_Pump,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2DCEC:
		moveq	#$22,d3
		move.b	#$78,$30(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	d3,ost_frame(a0)
		move.b	#$14,ost_primary_routine(a0)
		jsr	(RandomNumber).l
		asr.w	#8,d0
		asr.w	#6,d0
		move.w	d0,ost_x_vel(a0)
		move.w	#-$380,ost_y_vel(a0)
		moveq	#1,d2
		addq.w	#1,d3

loc_2DD26:
		jsr	(FindFreeObj).l
		bne.w	JmpTo51_DeleteObject
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.b	d3,ost_frame(a1)
		move.b	#$14,ost_primary_routine(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	ost_render(a0),ost_render(a1)
		jsr	(RandomNumber).l
		asr.w	#8,d0
		asr.w	#6,d0
		move.w	d0,ost_x_vel(a1)
		move.w	#-$380,ost_y_vel(a1)
		swap	d0
		addi.b	#$1E,d0
		andi.w	#$7F,d0
		move.b	d0,$30(a1)
		addq.w	#1,d3
		dbf	d2,loc_2DD26
		rts
; ===========================================================================

BCPZ_Pipe:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	BCPZ_Pipe_Index(pc,d0.w),d1
		jmp	BCPZ_Pipe_Index(pc,d1.w)
; ===========================================================================
BCPZ_Pipe_Index:	index offset(*),,2
		ptr BCPZ_Pipe_Init				; 0
		ptr BCPZ_Pipe_LoadSegment			; 2
; ===========================================================================

BCPZ_Pipe_Init:
		movea.l	ost_bcpz_parent(a0),a1
		btst	#0,ost_bcpz_secondary_status(a1)
		bne.s	.load_first_segment
		rts
; ===========================================================================

	.load_first_segment:
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addi.w	#$18,ost_y_pos(a0)

	if FixBugs
		; Reduce the pipe segment counter by one so BCPZ_Pipe_LoadSegment
		; allocates the correct number of object slots.
		move.w	#$C-1,ost_bcpz_pipe_segments(a0)
	else
		move.w	#$C,ost_bcpz_pipe_segments(a0)
	endc
		addq.b	#2,ost_secondary_routine(a0)
		movea.l	a0,a1
		bra.s	BCPZ_Pipe_LoadSegment_2
; ===========================================================================

BCPZ_Pipe_LoadSegment:
    if FixBugs
		; See the bugfix in BCPZ_Pipe_LoadSegment_2.
		subq.w  #1,ost_bcpz_pipe_segments(a0)		; is pipe fully extended?
		blt.s   loc_2DE56				; if yes, branch
    endc
		jsr	(FindNextFreeObj).l			; find next free OST slot
		beq.s	.found					; branch if found
		rts
; ===========================================================================

	.found:
		move.l	a0,ost_bcpz_parent(a1)

BCPZ_Pipe_LoadSegment_2:
	if FixBugs=0
	    ; This check should be done before the call to FindNextFreeObj.
	    ; By placing it after that call, one more OST slot than necessary
	    ; is allocated, leaving a partially initialized object in memory.
		subq.w	#1,ost_bcpz_pipe_segments(a0)
		blt.s	loc_2DE56
	endc
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#5,ost_priority(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	$2C(a0),d0
		subi.w	#$B,d0
		neg.w	d0
		lsl.w	#3,d0
		move.w	d0,$38(a1)
		add.w	d0,ost_y_pos(a1)
		move.b	#1,ost_anim(a1)
		cmpi.b	#2,ost_secondary_routine(a1)
		beq.w	BCPZ_PipeSegment
		move.b	#$E,ost_primary_routine(a1)
		bra.w	BCPZ_PipeSegment
; ===========================================================================

loc_2DE56:
		move.b	#0,ost_secondary_routine(a0)
		move.b	#6,ost_primary_routine(a0)
		bra.w	BCPZ_PipeSegment
; ===========================================================================

BCPZ_Pipe_Pump:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2DE74(pc,d0.w),d1
		jmp	off_2DE74(pc,d1.w)
; ===========================================================================
off_2DE74:	index offset(*),,2
		ptr loc_2DE7A					; 0
		ptr loc_2DF08					; 2
		ptr loc_2DF76					; 4
; ===========================================================================

loc_2DE7A:
		jsr	(FindNextFreeObj).l
		bne.w	BCPZ_PipeSegment
		move.b	#$E,ost_primary_routine(a0)
		move.b	#6,ost_primary_routine(a1)
		move.b	#2,ost_secondary_routine(a1)
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.b	#2,$32(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#$58,d0
		move.b	d0,$31(a1)
		add.w	d0,ost_y_pos(a1)
		move.b	#2,ost_anim(a1)
		move.l	a0,$34(a1)
		move.b	#$12,$30(a1)
		jsr	(FindNextFreeObj).l
		bne.s	loc_2DF04
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.b	#$A,ost_primary_routine(a1)
		move.l	$34(a0),$34(a1)

loc_2DF04:
		bra.w	BCPZ_PipeSegment
; ===========================================================================

loc_2DF08:
		movea.l	$34(a0),a1
		movea.l	$34(a1),a2
		btst	#status_broken_bit,ost_primary_status(a2)
		bne.w	JmpTo51_DeleteObject
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		subi_.b	#1,$30(a0)
		bne.s	loc_2DF5A
		move.b	#$12,$30(a0)
		subi_.b	#8,$31(a0)
		bgt.s	loc_2DF5A
		bmi.s	loc_2DF4C
		move.b	#3,ost_anim(a0)
		move.b	#$C,$30(a0)
		bra.s	loc_2DF5A
; ===========================================================================

loc_2DF4C:
		move.b	#6,$30(a0)
		move.b	#4,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_2DF5A:
		moveq	#0,d0
		move.b	$31(a0),d0
		add.w	d0,ost_y_pos(a0)
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2DF76:
		subi_.b	#1,$30(a0)
		beq.s	loc_2DF80
		rts
; ===========================================================================

loc_2DF80:
		subq.b	#1,$32(a0)
		beq.s	loc_2DF9E
		move.b	#2,ost_anim(a0)
		move.b	#$12,$30(a0)
		move.b	#2,ost_secondary_routine(a0)
		move.b	#$58,$31(a0)

loc_2DF9E:
		movea.l	$34(a0),a1
		move.b	#8,ost_primary_routine(a1)
		move.b	#$58,$31(a1)
		bra.w	JmpTo51_DeleteObject
; ===========================================================================

BCPZ_Pipe_Retract:
		tst.b	$3C(a0)
		bne.s	loc_2DFEE
		moveq	#0,d0
		move.b	$31(a0),d0
		add.w	ost_y_pos(a0),d0
	if FixBugs
		lea	(v_ost_dynamic).w,a1
		moveq	#countof_ost_dynamic-1,d1
	else
		; This checks the entirety of the main OST, even though we only
		; need to search the dynamic OST slots.
		lea	(v_ost_all).w,a1
		moveq	#countof_ost-1,d1
	endc

loc_2DFC8:
		cmp.w	ost_y_pos(a1),d0
		beq.s	loc_2DFDE
		lea	$40(a1),a1
		dbf	d1,loc_2DFC8
		bra.s	BCPZ_PipeSegment
; ===========================================================================

loc_2DFD8:
		st.b	$3C(a0)
		bra.s	BCPZ_PipeSegment
; ===========================================================================

loc_2DFDE:
	if FixBugs
		cmpi.b	#id_BossChemicalPlant,ost_id(a1)	; is object a subtype of the CPZ boss?
	else
		; 'd7' should not be used here. This causes ExecuteObjects
		; to run too few or too many objects, causing all
		; sorts of errors.
		moveq	#0,d7
		move.b	#id_BossChemicalPlant,d7		; is object a subtype of the CPZ Boss?
		cmp.b	ost_id(a1),d7				; if so, branch
	endc
		beq.s	loc_2DFF0
	if FixBugs
		; There is no code to advance to the next object here.
		; This causes the loop to get stuck repeatedly checking the same
		; object until 'd1' reaches 0. If the boss' hovering motion is
		; disabled, then it's actually possible to get the boss'
		; pipe stuck because of this bug by positioning Sonic or Tails at the
		; same Y-coordinate as a pipe segment. Even if the boss's hovering
		; motion isn't disabled, this bug can still cause the pipe's updating
		; to be delayed by a frame.
		lea sizeof_ost(a1),a1
	endc
		dbf	d1,loc_2DFC8
		bra.s	BCPZ_PipeSegment
; ===========================================================================

loc_2DFEE:
		movea.l	a0,a1

loc_2DFF0:
		bset	#status_broken_bit,ost_primary_status(a1)
		subi_.b	#8,$31(a0)
		beq.s	loc_2DFD8

BCPZ_PipeSegment:
		movea.l	$34(a0),a1
		movea.l	$34(a1),a2
		btst	#status_broken_bit,ost_primary_status(a2)
		bne.s	loc_2E04E
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		cmpi.b	#4,ost_secondary_routine(a0)
		bne.s	loc_2E028
		addi.w	#$18,ost_y_pos(a0)

loc_2E028:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.s	loc_2E04A
		move.w	$38(a0),d0
		add.w	d0,ost_y_pos(a0)
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E04A:
		bra.w	JmpTo51_DeleteObject
; ===========================================================================

loc_2E04E:
		move.b	#$14,ost_primary_routine(a0)
		jsr	(RandomNumber).l
		asr.w	#8,d0
		asr.w	#6,d0
		move.w	d0,ost_x_vel(a0)
		move.w	#-$380,ost_y_vel(a0)
		swap	d0
		addi.b	#$1E,d0
		andi.w	#$7F,d0
		move.b	d0,$30(a0)
		bra.w	JmpTo34_DisplaySprite
; ===========================================================================

BCPZ_Dripper:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.w	JmpTo51_DeleteObject
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2E092(pc,d0.w),d1
		jmp	off_2E092(pc,d1.w)
; ===========================================================================
off_2E092:	index offset(*),,2
		ptr loc_2E098					; 0
		ptr loc_2E0DE					; 2
		ptr loc_2E130					; 4
; ===========================================================================

loc_2E098:
		addq.b	#2,ost_secondary_routine(a0)
		_move.b	#id_BossChemicalPlant,ost_id(a0)
		move.l	#Map_BCPZ_Pump,ost_mappings(a0)
		move.w	#tile_Nem_CPZBoss+tile_pal4,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#4,ost_priority(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	#$F,$30(a0)
		move.b	#4,ost_anim(a0)

loc_2E0DE:
		subq.b	#1,$30(a0)
		bne.s	loc_2E102
		move.b	#5,ost_anim(a0)
		move.b	#4,$30(a0)
		addq.b	#2,ost_secondary_routine(a0)
		subi.w	#$24,ost_y_pos(a0)
		subi_.w	#2,ost_x_pos(a0)
		rts
; ===========================================================================

loc_2E102:
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E130:
		subq.b	#1,$30(a0)
		bne.s	loc_2E156
		move.b	#0,ost_secondary_routine(a0)
		movea.l	$34(a0),a1
		bset	#1,$2E(a1)
		addq.b	#1,$3C(a0)
		cmpi.b	#$C,$3C(a0)
		bge.w	JmpTo51_DeleteObject
		rts
; ===========================================================================

loc_2E156:
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		subi.w	#$24,ost_y_pos(a0)
		subi_.w	#2,ost_x_pos(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E180
		addi_.w	#4,ost_x_pos(a0)

loc_2E180:
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

BCPZ_Container:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2E1A0(pc,d0.w),d1
		jmp	off_2E1A0(pc,d1.w)
; ===========================================================================
off_2E1A0:	index offset(*),,2
		ptr loc_2E1AC					; 0
		ptr loc_2E25C					; 2
		ptr loc_2E610					; 4
		ptr loc_2E5A4					; 6
		ptr loc_2E666					; 8
		ptr loc_2E2E8					; $A
; ===========================================================================

loc_2E1AC:
		movea.l	$34(a0),a1
		btst	#7,$2E(a1)
		bne.s	loc_2E20E
		bset	#7,$2E(a1)
		jsr	(FindNextFreeObj).l
		bne.s	loc_2E20E
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$10,ost_primary_routine(a1)
		move.b	#4,ost_secondary_routine(a1)
		move.b	#9,ost_anim(a1)

loc_2E20E:
		jsr	(FindNextFreeObj).l
		bne.s	loc_2E258
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		addi.b	#$10,ost_primary_routine(a1)
		move.b	#6,ost_secondary_routine(a1)

loc_2E258:
		addq.b	#2,ost_secondary_routine(a0)

loc_2E25C:
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		subi.w	#$38,ost_y_pos(a0)
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.s	loc_2E2E0
		btst	#2,$2E(a1)
		beq.s	loc_2E28C
		bsr.w	loc_2E4CE
		bsr.w	loc_2E3F2
		bra.s	loc_2E2AC
; ===========================================================================

loc_2E28C:
		btst	#5,$2E(a1)
		beq.s	loc_2E2AC
		subq.w	#1,$2A(a0)
		bne.s	loc_2E2AC
		bclr	#5,$2E(a1)
		bset	#3,$2E(a1)
		bset	#4,$2E(a1)

loc_2E2AC:
		movea.l	$34(a0),a1
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		move.w	$2E(a0),d0
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E2CA
		neg.w	d0

loc_2E2CA:
		add.w	d0,ost_x_pos(a0)
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E2E0:
		move.b	#$A,ost_secondary_routine(a0)
		bra.s	loc_2E2AC
; ===========================================================================

loc_2E2E8:
		pushr.l	d7
		move.b	#$1E,$30(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		subi.w	#$38,ost_y_pos(a0)
		move.w	$2E(a0),d0
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E314
		neg.w	d0

loc_2E314:
		add.w	d0,ost_x_pos(a0)
		move.b	#$20,ost_frame(a0)
		move.b	#$14,ost_primary_routine(a0)
		jsr	(RandomNumber).l
		asr.w	#8,d0
		asr.w	#6,d0
		move.w	d0,ost_x_vel(a0)
		move.w	#-$380,ost_y_vel(a0)
		moveq	#0,d7
		move.w	$2E(a0),d0
		addi.w	#$18,d0
		bge.s	loc_2E356
		addi.w	#$18,d0
		bge.s	loc_2E354
		addi.w	#$18,d0
		bge.s	loc_2E352
		addq.w	#1,d7

loc_2E352:
		addq.w	#1,d7

loc_2E354:
		addq.w	#1,d7

loc_2E356:
		subq.w	#1,d7
		bmi.w	loc_2E3E6

loc_2E35C:
		jsr	(FindFreeObj).l
		bne.w	JmpTo51_DeleteObject
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.b	#$21,ost_frame(a1)
		move.b	#$14,ost_primary_routine(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi_.w	#8,ost_y_pos(a1)
		move.w	d7,d2
		add.w	d2,d2
		move.w	word_2E3EC(pc,d2.w),d3
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E3BC
		neg.w	d3

loc_2E3BC:
		add.w	d3,ost_x_pos(a1)
		jsr	(RandomNumber).l
		asr.w	#8,d0
		asr.w	#6,d0
		move.w	d0,ost_x_vel(a1)
		move.w	#-$380,ost_y_vel(a1)
		swap	d0
		addi.b	#$1E,d0
		andi.w	#$7F,d0
		move.b	d0,$30(a1)
		dbf	d7,loc_2E35C

loc_2E3E6:
		popr.l	d7

    if RemoveJmpTos
JmpTo34_DisplaySprite:
    endc

		jmpto	DisplaySprite,JmpTo34_DisplaySprite
; ===========================================================================
word_2E3EC:
		dc.w   $18					; 0
		dc.w   $30					; 1
		dc.w   $48					; 2
; ===========================================================================

loc_2E3F2:
		btst	#3,$2E(a1)
		bne.w	locret_2E4CC
		btst	#4,$2E(a1)

loc_2E402:
		bne.w	locret_2E4CC

loc_2E406:
		cmpi.w	#-$14,$2E(a0)
		blt.s	loc_2E426
		btst	#1,$2D(a1)
		beq.w	locret_2E4CC
		bclr	#1,$2D(a1)
		bset	#2,$2D(a1)
		bra.s	loc_2E464
; ===========================================================================

loc_2E426:
		cmpi.w	#-$40,$2E(a0)
		bge.w	locret_2E4CC
		move.w	(v_ost_player1+ost_x_pos).w,d1
		subi_.w	#8,d1
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E454
		add.w	$2E(a0),d1
		sub.w	ost_x_pos(a0),d1
		bgt.w	locret_2E4CC
		cmpi.w	#-$18,d1
		bge.s	loc_2E464
		rts
; ===========================================================================

loc_2E454:
		sub.w	$2E(a0),d1
		sub.w	ost_x_pos(a0),d1
		blt.s	locret_2E4CC
		cmpi.w	#$18,d1
		bgt.s	locret_2E4CC

loc_2E464:
		bset	#5,$2E(a1)
		bclr	#2,$2E(a1)
		move.w	#$12,$2A(a0)
		jsr	(FindNextFreeObj).l
		bne.s	locret_2E4CC
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.b	#$10,ost_primary_routine(a1)
		move.b	#8,ost_secondary_routine(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#5,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$B,ost_anim(a1)
		move.w	#$24,$2A(a1)

locret_2E4CC:
		rts
; ===========================================================================

loc_2E4CE:
		moveq	#1,d0
		btst	#4,$2E(a1)
		bne.s	loc_2E4DA
		moveq	#-1,d0

loc_2E4DA:
		cmpi.w	#-$10,$2E(a0)
		bne.s	loc_2E552
		bclr	#4,$2E(a1)
		beq.s	loc_2E552
		bclr	#2,$2E(a1)
		clr.b	ost_secondary_routine(a0)
		movea.l	a1,a2
		jsr	(FindNextFreeObj).l
		bne.s	locret_2E550
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	$34(a0),$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#4,ost_primary_routine(a1)
		move.b	#0,ost_secondary_routine(a0)
		bra.s	locret_2E550
; ===========================================================================
		move.b	#$A,ost_primary_routine(a1)
		move.l	$34(a0),$34(a1)

locret_2E550:
		rts
; ===========================================================================

loc_2E552:
		move.w	$2E(a0),d1
		cmpi.w	#-$28,d1
		bge.s	loc_2E59C
		cmpi.w	#-$40,d1
		bge.s	loc_2E594
		move.b	#8,ost_anim(a0)
		cmpi.w	#-$58,d1
		blt.s	loc_2E57E
		bgt.s	loc_2E578
		btst	#4,$2E(a1)
		beq.s	locret_2E57C

loc_2E578:
		add.w	d0,$2E(a0)

locret_2E57C:
		rts
; ===========================================================================

loc_2E57E:
		move.w	#-$58,$2E(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E578
		move.w	#$58,$2E(a0)
		bra.s	loc_2E578
; ===========================================================================

loc_2E594:
		move.b	#7,ost_anim(a0)
		bra.s	loc_2E578
; ===========================================================================

loc_2E59C:
		move.b	#6,ost_anim(a0)
		bra.s	loc_2E578
; ===========================================================================

loc_2E5A4:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.w	JmpTo51_DeleteObject
		movea.l	$34(a0),a1
		move.l	$34(a1),d0
		beq.w	JmpTo51_DeleteObject
		movea.l	d0,a1
		bclr	#3,$2E(a1)
		beq.s	loc_2E5D8
		move.b	#$C,ost_primary_routine(a0)
		move.b	#0,ost_secondary_routine(a0)
		move.b	#id_col_6x6+id_col_hurt,ost_col_type(a0)
		bra.s	loc_2E638
; ===========================================================================

loc_2E5D8:
		bclr	#1,$2E(a1)
		bne.s	loc_2E5E8
		tst.b	ost_anim(a0)
		bne.s	loc_2E638
		rts
; ===========================================================================

loc_2E5E8:
		tst.b	ost_anim(a0)
		bne.s	loc_2E5F4
		move.b	#$B,ost_anim(a0)

loc_2E5F4:
		addi_.b	#1,ost_anim(a0)
		cmpi.b	#$17,ost_anim(a0)
		blt.s	loc_2E638
		bclr	#0,$2E(a1)
		bset	#2,$2E(a1)
		bra.s	loc_2E638
; ===========================================================================

loc_2E610:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.w	JmpTo51_DeleteObject
		movea.l	$34(a0),a1
		movea.l	$34(a1),a1
		btst	#5,$2E(a1)
		beq.s	loc_2E638
		cmpi.b	#9,ost_anim(a0)
		bne.s	loc_2E638
		move.b	#$A,ost_anim(a0)

loc_2E638:
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_render(a1),ost_render(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E666:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.w	JmpTo51_DeleteObject
		subq.w	#1,$2A(a0)
		beq.w	JmpTo51_DeleteObject
		bra.s	loc_2E638
; ===========================================================================

BCPZ_Gunk:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2E688(pc,d0.w),d1
		jmp	off_2E688(pc,d1.w)
; ===========================================================================
off_2E688:	index offset(*),,2
		ptr loc_2E692					; 0
		ptr loc_2E6CA					; 2
		ptr loc_2E7D0					; 4
		ptr loc_2E746					; 6
		ptr loc_2E790					; 8
; ===========================================================================

loc_2E692:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$20,ost_height(a0)
		move.b	#$19,ost_anim(a0)
		move.w	#0,ost_y_vel(a0)
		movea.l	$34(a0),a1
		movea.l	$34(a1),a1
		btst	#2,$2D(a1)
		beq.s	loc_2E6CA
		bclr	#2,$2D(a1)
		move.b	#6,ost_secondary_routine(a0)
		move.w	#9,$2A(a0)

loc_2E6CA:
		jsrto	ObjectFall,JmpTo3_ObjectFall
		jsr	(FindFloorObj).l
		tst.w	d1
		bmi.s	loc_2E6F2
		cmpi.w	#$518,ost_y_pos(a0)
		bge.s	loc_2E728
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E6F2:
		add.w	d1,ost_y_pos(a0)
		movea.l	$34(a0),a1
		movea.l	$34(a1),a1
		bset	#2,$2E(a1)
		bset	#4,$2E(a1)
		move.b	#2,ost_secondary_routine(a1)
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#0,ost_subtype(a0)
		move.w	#$E6,d0
		jsrto	PlaySound,JmpTo5_PlaySound
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E728:
		movea.l	$34(a0),a1
		movea.l	$34(a1),a1
		bset	#2,$2E(a1)
		bset	#4,$2E(a1)
		move.b	#2,ost_secondary_routine(a1)
		bra.w	JmpTo51_DeleteObject
; ===========================================================================

loc_2E746:
		subi_.w	#1,$2A(a0)
		bpl.s	loc_2E77A
		move.b	#2,ost_priority(a0)
		move.b	#$25,ost_frame(a0)
		movea.l	$34(a0),a1
		movea.l	$34(a1),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#8,ost_anim_time(a0)
		bra.s	loc_2E790
; ===========================================================================

loc_2E77A:
		jsrto	SpeedToPos,JmpTo23_SpeedToPos
		lea	(Ani_BCPZ_Pump).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E790:
		subi_.b	#1,ost_anim_time(a0)
		bpl.s	loc_2E7B6
		addi_.b	#1,ost_frame(a0)
		move.b	#8,ost_anim_time(a0)
		cmpi.b	#$27,ost_frame(a0)
		bgt.w	loc_2E728
		blt.s	loc_2E7B6
		addi.b	#$C,ost_anim_time(a0)

loc_2E7B6:
		movea.l	$34(a0),a1
		movea.l	$34(a1),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		jmp	(DisplaySprite).l
; ===========================================================================

loc_2E7D0:
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		bne.w	loc_2E8CC
		addi.w	#$18,ost_y_pos(a0)
		addi.w	#$C,ost_x_pos(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2E7F4
		subi.w	#$18,ost_x_pos(a0)

loc_2E7F4:
		move.b	#4,ost_height(a0)
		move.b	#4,ost_width(a0)

loc_2E800:
		addq.b	#1,ost_subtype(a0)

loc_2E804:
		move.b	#9,ost_frame(a0)

loc_2E80A:
		move.w	ost_y_vel(a0),d0
		lsr.w	#1,d0
		neg.w	d0
		move.w	d0,ost_y_vel(a0)
		jsr	(RandomNumber).l
		asr.w	#6,d0
		bmi.s	loc_2E824
		addi.w	#$200,d0

loc_2E824:
		addi.w	#-$100,d0
		move.w	d0,ost_x_vel(a0)
		move.b	#0,ost_col_type(a0)
		moveq	#3,d3

loc_2E834:
		jsr	(FindNextFreeObj).l
		bne.w	BranchTo_JmpTo34_DisplaySprite
		_move.b	#id_BossChemicalPlant,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_BCPZ_Pump,ost_mappings(a1)
		move.w	#tile_Nem_CPZBoss+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#4,ost_height(a1)
		move.b	#4,ost_width(a1)
		move.b	#9,ost_frame(a1)
		move.b	#$C,ost_primary_routine(a1)
		move.b	#4,ost_secondary_routine(a1)
		move.b	#1,ost_subtype(a1)
		move.w	ost_y_vel(a0),ost_y_vel(a1)
		move.b	ost_col_type(a0),ost_col_type(a1)
		jsr	(RandomNumber).l
		asr.w	#6,d0
		bmi.s	loc_2E8B2
		addi.w	#$80,d0

loc_2E8B2:
		addi.w	#-$80,d0
		move.w	d0,ost_x_vel(a1)
		swap	d0
		andi.w	#$3FF,d0
		sub.w	d0,ost_y_vel(a1)
		dbf	d3,loc_2E834

BranchTo_JmpTo34_DisplaySprite:
		jmpto	DisplaySprite,JmpTo34_DisplaySprite
; ===========================================================================

loc_2E8CC:
		jsrto	ObjectFall,JmpTo3_ObjectFall
		jsr	(FindFloorObj).l
		tst.w	d1
		bmi.s	loc_2E8DE
		jmpto	DespawnObject,JmpTo35_DespawnObject
; ===========================================================================

loc_2E8DE:
		bra.w	JmpTo51_DeleteObject
; ===========================================================================

		; a bit of unused/dead code here
		add.w	d1,ost_y_pos(a0)
		move.w	ost_y_vel(a0),d0
		lsr.w	#1,d0
		neg.w	d0
		move.w	d0,ost_y_vel(a0)
		jmpto	DisplaySprite,JmpTo34_DisplaySprite
; ===========================================================================

BCPZ_Eggman:
		movea.l	$34(a0),a1
		move.l	ost_x_pos(a1),ost_x_pos(a0)
		move.l	ost_y_pos(a1),ost_y_pos(a0)

loc_2E906:
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		move.b	$3E(a1),d0
		cmpi.b	#$1F,d0
		bne.s	loc_2E922
		move.b	#2,ost_anim(a0)

loc_2E922:
		cmpi.b	#4,($FFFFB024).w
		beq.s	loc_2E932
		cmpi.b	#4,($FFFFB064).w
		bne.s	loc_2E938

loc_2E932:
		move.b	#3,ost_anim(a0)

loc_2E938:
		lea	(Ani_BCPZ_Eggman).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================
byte_2E94A:
		dc.b   0					; 0
		dc.b $FF					; 1
		dc.b   1					; 2
		dc.b   0					; 3
; ===========================================================================

BCPZ_Flame:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.s	loc_2E9A8
		movea.l	$34(a0),a1
		move.l	ost_x_pos(a1),ost_x_pos(a0)
		move.l	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_2E996
		move.b	#1,ost_anim_time(a0)
		move.b	$2A(a0),d0
		addq.b	#1,d0
		cmpi.b	#2,d0
		ble.s	loc_2E98C
		moveq	#0,d0

loc_2E98C:
		move.b	byte_2E94A(pc,d0.w),ost_frame(a0)
		move.b	d0,$2A(a0)

loc_2E996:
		cmpi.b	#-1,ost_frame(a0)
		bne.w	JmpTo34_DisplaySprite
		move.b	#0,ost_frame(a0)
		rts
; ===========================================================================

loc_2E9A8:
		movea.l	$34(a0),a1
		btst	#6,$2E(a1)
		bne.s	loc_2E9B6
		rts
; ===========================================================================

loc_2E9B6:
    if FixBugs
		addq.b	#2,ost_primary_routine(a0)
   	 else
		; Eggman is supposed to starting leaving a trail of smoke here, but
		; this code is incorrect which prevents it from appearing.
		; This should be 'ost_primary_routine' instead of 'ost_secondary_routine'...
		addq.b	#2,ost_secondary_routine(a0)
    endc
		move.l	#Map_BCPZ_Smoke,ost_mappings(a0)
	if FixBugs
		; ...and this should be 'tile_Nem_BossSmoke_CPZ+tile_pal2' instead.
		move.w	#tile_Nem_BossSmoke_CPZ+tile_pal2,ost_tile(a0)
	else
		move.w	#tile_Nem_EggpodJets_CPZ,ost_tile(a0)
	endc
		jsrto	AdjustVRAM2P,JmpTo60_AdjustVRAM2P
		move.b	#0,ost_frame(a0)
		move.b	#5,ost_anim_time(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addi_.w	#4,ost_y_pos(a0)
		subi.w	#$28,ost_x_pos(a0)
		rts
; ===========================================================================

BCPZ_Smoke:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	BranchTo2_JmpTo34_DisplaySprite
		move.b	#5,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#4,ost_frame(a0)
		bne.w	BranchTo2_JmpTo34_DisplaySprite
		move.b	#0,ost_frame(a0)
		movea.l	$34(a0),a1
		move.b	ost_id(a1),d0
		beq.w	JmpTo51_DeleteObject
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addi_.w	#4,ost_y_pos(a0)
		subi.w	#$28,ost_x_pos(a0)

BranchTo2_JmpTo34_DisplaySprite:
		jmpto	DisplaySprite,JmpTo34_DisplaySprite
; ===========================================================================
Ani_BCPZ_Pump:	index offset(*)
		ptr byte_2EA72					; 0
		ptr byte_2EA75					; 1
		ptr byte_2EA78					; 2
		ptr byte_2EA7D					; 3
		ptr byte_2EA81					; 4
		ptr byte_2EA88					; 5
		ptr byte_2EA8B					; 6
		ptr byte_2EA8E					; 7
		ptr byte_2EA91					; 8
		ptr byte_2EA94					; 9
		ptr byte_2EA97					; 10
		ptr byte_2EAA3					; 11
		ptr byte_2EAAE					; 12
		ptr byte_2EAB1					; 13
		ptr byte_2EAB4					; 14
		ptr byte_2EAB7					; 15
		ptr byte_2EABA					; 16
		ptr byte_2EABD					; 17
		ptr byte_2EAC0					; 18
		ptr byte_2EAC3					; 19
		ptr byte_2EAC6					; 20
		ptr byte_2EAC9					; 21
		ptr byte_2EACC					; 22
		ptr byte_2EACF					; 23
		ptr byte_2EAD2					; 24
		ptr byte_2EAD5					; 25
		ptr byte_2EAD9					; 26
byte_2EA72:	dc.b  $F,  0,$FF				; 0
byte_2EA75:	dc.b  $F,  1,$FF				; 0
byte_2EA78:	dc.b   5,  2,  3,  2,$FF			; 0
byte_2EA7D:	dc.b   5,  2,  3,$FF				; 0
byte_2EA81:	dc.b   2,  4,  5,  6,  7,  8,$FF		; 0
byte_2EA88:	dc.b   3,  9,$FF				; 0
byte_2EA8B:	dc.b  $F, $A,$FF				; 0
byte_2EA8E:	dc.b  $F,$1C,$FF				; 0
byte_2EA91:	dc.b  $F,$1E,$FF				; 0
byte_2EA94:	dc.b  $F, $B,$FF				; 0
byte_2EA97:	dc.b   3, $C, $C, $D, $D, $D, $D, $D, $C, $C,$FD,  9 ; 0
byte_2EAA3:	dc.b   3, $E, $E, $F, $F, $F, $F, $F, $E, $E,$FF ; 0
byte_2EAAE:	dc.b  $F,$10,$FF				; 0
byte_2EAB1:	dc.b  $F,$11,$FF				; 0
byte_2EAB4:	dc.b  $F,$12,$FF				; 0
byte_2EAB7:	dc.b  $F,$13,$FF				; 0
byte_2EABA:	dc.b  $F,$14,$FF				; 0
byte_2EABD:	dc.b  $F,$15,$FF				; 0
byte_2EAC0:	dc.b  $F,$16,$FF				; 0
byte_2EAC3:	dc.b  $F,$17,$FF				; 0
byte_2EAC6:	dc.b  $F,$18,$FF				; 0
byte_2EAC9:	dc.b  $F,$19,$FF				; 0
byte_2EACC:	dc.b  $F,$1A,$FF				; 0
byte_2EACF:	dc.b  $F,$1B,$FF				; 0
byte_2EAD2:	dc.b  $F,$1C,$FF				; 0
byte_2EAD5:	dc.b   1,$1D,$1F,$FF				; 0
byte_2EAD9:	dc.b  $F,$1E,$FF				; 0
; ===========================================================================

		include "mappings/sprite/CPZ Boss.asm"

; ===========================================================================

Ani_BCPZ_Eggman:	index offset(*)
		ptr byte_2ED66					; 0
		ptr byte_2ED69					; 1
		ptr byte_2ED6D					; 2
		ptr byte_2ED76					; 3
		ptr byte_2ED7F					; 4
byte_2ED66:	dc.b  $F,  0,$FF				; 0
byte_2ED69:	dc.b   7,  1,  2,$FF				; 0
byte_2ED6D:	dc.b   7,  5,  5,  5,  5,  5,  5,$FD,  1	; 0
byte_2ED76:	dc.b   7,  3,  4,  3,  4,  3,  4,$FD,  1	; 0
byte_2ED7F:	dc.b  $F,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,$FD,  1 ; 0
; ===========================================================================

		include_CPZEggpodSmoke_Maps			; mappings/sprite/CPZ Boss.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo34_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo51_DeleteObject:
		jmp	(DeleteObject).l
JmpTo35_DespawnObject:
		jmp	(DespawnObject).l
JmpTo5_PlaySound:
		jmp	(PlaySound).l
JmpTo8_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo5_AddPLC:
		jmp	(AddPLC).l
JmpTo2_AddPoints:
		jmp	(AddPoints).l
JmpTo60_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l
JmpTo3_ObjectFall:
		jmp	(ObjectFall).l
JmpTo23_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 56 - EHZ boss
; the fuselage of Eggman's helicopter is the parent object
; ----------------------------------------------------------------------------

BossEmeraldHill:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	BEHZ_Index(pc,d0.w),d1
		jmp	BEHZ_Index(pc,d1.w)
; ===========================================================================
BEHZ_Index:	index offset(*),,2
		ptr loc_2EF36					; 0
		ptr loc_2F262					; 2
		ptr loc_2F54E					; 4
		ptr loc_2F5F6					; 6
		ptr loc_2F664					; 8
		ptr loc_2F7F4					; $A
		ptr loc_2F52A					; $C
		ptr loc_2F8DA					; $E

; #7,status(ax) set via collision response routine (Touch_Enemy_Part2)
; 	when after a hit collision_property(ax) = hitcount has reached zero
; objoff_2A(ax) used as timer (countdown)
; objoff_2C(ax) tertiary rountine counter
; #0,objoff_2D(ax) set when Robotnik is on ground
; #1,objoff_2D(ax) set when Robotnik is active (moving back & forth)
; #2,objoff_2D(ax) set when Robotnik is flying off after being defeated
; #3,objoff_2D(ax) flag to separate spike from vehicle
; objoff_2E(ax)	y_position of wheels
; objoff_34(ax) parent object
; objoff_3C(ax)	timer after defeat

; ===========================================================================

loc_2EF36:
		move.l	#Map_BEHZ_Eggman,ost_mappings(a0)
		move.w	#tile_Nem_Eggpod_EHZ+tile_pal2,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$81,ost_subtype(a0)
		move.w	#$29D0,ost_x_pos(a0)
		move.w	#$426,ost_y_pos(a0)
		move.b	#$20,ost_displaywidth(a0)
		move.b	#$14,ost_height(a0)
		move.b	#4,ost_priority(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_col_property(a0)
		addq.b	#2,ost_primary_routine(a0)
		move.w	ost_x_pos(a0),$30(a0)
		move.w	ost_y_pos(a0),$38(a0)
		jsrto	AdjustVRAM2P,JmpTo61_AdjustVRAM2P

		jsr	(FindNextFreeObj).l
		bne.w	loc_2EFE4

		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	a1,$34(a0)
		move.l	#Map_BEHZ_Eggman,ost_mappings(a1)
		move.w	#tile_Nem_Eggpod_EHZ,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$E,ost_primary_routine(a1)
		move.b	#1,ost_anim(a1)
		move.b	ost_render(a0),ost_render(a1)

loc_2EFE4:
		jsr	(FindNextFreeObj).l			; find free OST slot after parent
		bne.s	loc_2F032				; branch if not found

		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Drillster,ost_mappings(a1)
		move.w	#tile_Nem_EHZBoss,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$30,ost_displaywidth(a1)
		move.b	#$10,ost_height(a1)
		move.b	#3,ost_priority(a1)
		move.w	#$2AF0,ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#6,ost_primary_routine(a1)

loc_2F032:
		bsr.w	loc_2F098
		subi_.w	#8,$38(a0)
		move.w	#$2AF0,ost_x_pos(a0)
		move.w	#$2F8,ost_y_pos(a0)
		jsr	(FindNextFreeObj).l
		bne.s	locret_2F096
		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Rotor,ost_mappings(a1)
		move.w	#tile_Nem_EggChopperBlades+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$40,ost_displaywidth(a1)
		move.b	#3,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#$1E,$2A(a1)
		move.b	#4,ost_primary_routine(a1)

locret_2F096:
		rts
; ===========================================================================

loc_2F098:
		jsr	(FindNextFreeObj).l
		bne.s	loc_2F110
		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Drillster,ost_mappings(a1)
		move.w	#tile_Nem_EHZBoss+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.b	#$10,ost_height(a1)
		move.b	#$10,ost_width(a1)
		move.w	#$2AF0,ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$1C,ost_x_pos(a1)
		addi.w	#$C,ost_y_pos(a1)
		move.b	#8,ost_primary_routine(a1)
		move.b	#4,ost_frame(a1)
		move.b	#1,ost_anim(a1)
		move.w	#$A,$2A(a1)
		move.b	#0,ost_subtype(a1)

loc_2F110:
		jsr	(FindNextFreeObj).l
		bne.s	loc_2F188
		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Drillster,ost_mappings(a1)
		move.w	#tile_Nem_EHZBoss+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.b	#$10,ost_height(a1)
		move.b	#$10,ost_width(a1)
		move.w	#$2AF0,ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#-$C,ost_x_pos(a1)
		addi.w	#$C,ost_y_pos(a1)
		move.b	#8,ost_primary_routine(a1)
		move.b	#4,ost_frame(a1)
		move.b	#1,ost_anim(a1)
		move.w	#$A,$2A(a1)
		move.b	#1,ost_subtype(a1)

loc_2F188:
		jsr	(FindNextFreeObj).l
		bne.s	loc_2F200
		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Drillster,ost_mappings(a1)
		move.w	#tile_Nem_EHZBoss+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#3,ost_priority(a1)
		move.b	#$10,ost_height(a1)
		move.b	#$10,ost_width(a1)
		move.w	#$2AF0,ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#-$2C,ost_x_pos(a1)
		addi.w	#$C,ost_y_pos(a1)
		move.b	#8,ost_primary_routine(a1)
		move.b	#6,ost_frame(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$A,$2A(a1)
		move.b	#2,ost_subtype(a1)

loc_2F200:
		jsr	(FindNextFreeObj).l
		bne.s	locret_2F260

		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Drillster,ost_mappings(a1)
		move.w	#tile_Nem_EHZBoss+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#2,ost_priority(a1)
		move.w	#$2AF0,ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#-$36,ost_x_pos(a1)
		addi_.w	#8,ost_y_pos(a1)
		move.b	#$A,ost_primary_routine(a1)
		move.b	#1,ost_frame(a1)
		move.b	#0,ost_anim(a1)

locret_2F260:
		rts
; ===========================================================================

loc_2F262:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2F270(pc,d0.w),d1
		jmp	off_2F270(pc,d1.w)
; ===========================================================================
off_2F270:	index offset(*),,2
		ptr loc_2F27C					; 0
		ptr loc_2F2A8					; 2
		ptr loc_2F304					; 6
		ptr loc_2F336					; 8
		ptr loc_2F374					; $A
		ptr loc_2F38A					; $C
; ===========================================================================

loc_2F27C:
		move.b	#0,ost_col_type(a0)
		cmpi.w	#$29D0,ost_x_pos(a0)
		ble.s	loc_2F29A
		subi_.w	#1,ost_x_pos(a0)
		addi_.w	#1,ost_y_pos(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F29A:
		move.w	#$29D0,ost_x_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F2A8:
		moveq	#0,d0
		move.b	$2C(a0),d0
		move.w	off_2F2B6(pc,d0.w),d1
		jmp	off_2F2B6(pc,d1.w)
; ===========================================================================
off_2F2B6:	index offset(*),,2
		ptr loc_2F2BA					; 0
		ptr loc_2F2E0					; 2
; ===========================================================================

loc_2F2BA:
		cmpi.w	#$41E,ost_y_pos(a0)
		bge.s	loc_2F2CC
		addi_.w	#1,ost_y_pos(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F2CC:
		addq.b	#2,$2C(a0)
		bset	#0,$2D(a0)
		move.w	#$3C,$2A(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F2E0:
		subi_.w	#1,$2A(a0)
		bpl.w	JmpTo35_DisplaySprite
		move.w	#-$200,ost_x_vel(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		bset	#1,$2D(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F304:
		bsr.w	loc_2F4A6
		bsr.w	loc_2F484
		move.w	$2E(a0),d0
		lsr.w	#1,d0
		subi.w	#$14,d0
		move.w	d0,ost_y_pos(a0)
		move.w	#0,$2E(a0)
		move.l	ost_x_pos(a0),d2
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,ost_x_pos(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F336:
		subq.w	#1,$3C(a0)
		bmi.s	loc_2F35C
		bsr.w	BossExplode
		jsrto	ObjectFall,JmpTo4_ObjectFall
		jsrto	FindFloorObj,JmpTo3_FindFloorObj
		tst.w	d1
		bpl.w	JmpTo35_DisplaySprite
		add.w	d1,ost_y_pos(a0)
		move.w	#0,ost_y_vel(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F35C:
		clr.w	ost_x_vel(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#-$26,$3C(a0)
		move.w	#$C,$2A(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F374:
		subq.w	#1,$2A(a0)
		bpl.w	JmpTo35_DisplaySprite
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#0,$2C(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F38A:
		moveq	#0,d0
		move.b	$2C(a0),d0
		move.w	off_2F39C(pc,d0.w),d1
		jsr	off_2F39C(pc,d1.w)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================
off_2F39C:	index offset(*),,2
		ptr loc_2F3A2					; 0
		ptr loc_2F424					; 2
		ptr loc_2F442					; 4
; ===========================================================================

loc_2F3A2:
		bclr	#0,$2D(a0)
		jsrto	FindNextFreeObj,JmpTo21_FindNextFreeObj
		bne.w	locret_2F422
		_move.b	#id_BossEmeraldHill,ost_id(a1)
		move.l	a0,$34(a1)
		move.l	#Map_Rotor,ost_mappings(a1)
		move.w	#tile_Nem_EggChopperBlades+tile_pal2,ost_tile(a1)
		jsrto	AdjustVRAM2P2,JmpTo9_AdjustVRAM2P2
		move.b	#render_rel,ost_render(a1)
		move.b	#$20,ost_displaywidth(a1)
		move.b	#3,ost_priority(a1)
		move.l	ost_x_pos(a0),ost_x_pos(a1)
		move.l	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$C,ost_y_pos(a1)
		move.b	ost_primary_status(a0),ost_primary_status(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#$C,ost_primary_routine(a1)
		move.b	#2,ost_anim(a1)
		move.w	#$10,$2A(a1)
		move.w	#$32,$2A(a0)
		addq.b	#2,$2C(a0)
		jsrto	RestoreLevelMusic,JmpTo2_RestoreLevelMusic
		move.b	#1,(v_boss_status).w

locret_2F422:
		rts
; ===========================================================================

loc_2F424:
		subi_.w	#1,$2A(a0)
		bpl.s	locret_2F440
		bset	#2,$2D(a0)
		move.w	#$60,$2A(a0)
		addq.b	#2,$2C(a0)
		jsrto	LoadAnimalExplosionArt,JmpTo2_LoadAnimalExplosionArt

locret_2F440:
		rts
; ===========================================================================

loc_2F442:
		subi_.w	#1,$2A(a0)
		bpl.s	loc_2F45C
		bset	#status_xflip_bit,ost_primary_status(a0)
		bset	#render_xflip_bit,ost_render(a0)
		addq.w	#6,ost_x_pos(a0)
		bra.s	loc_2F460
; ===========================================================================

loc_2F45C:
		subq.w	#1,ost_y_pos(a0)

loc_2F460:
		cmpi.w	#$2AB0,(v_boundary_right).w
		bcc.s	loc_2F46E
		addq.w	#2,(v_boundary_right).w
		bra.s	locret_2F482
; ===========================================================================

loc_2F46E:
		tst.b	ost_render(a0)
		bmi.s	locret_2F482
		addq.w	#4,sp
		movea.l	$34(a0),a1
		jsrto	DeleteChild,JmpTo5_DeleteChild
		jmpto	DeleteObject,JmpTo52_DeleteObject
; ===========================================================================

locret_2F482:
		rts
; ===========================================================================

loc_2F484:
		move.w	ost_x_pos(a0),d0
		cmpi.w	#$28A0,d0
		ble.s	loc_2F494
		cmpi.w	#$2B08,d0
		blt.s	locret_2F4A4

loc_2F494:
		bchg	#status_xflip_bit,ost_primary_status(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		neg.w	ost_x_vel(a0)

locret_2F4A4:
		rts
; ===========================================================================

loc_2F4A6:
		cmpi.b	#6,ost_secondary_routine(a0)
		bcc.s	locret_2F4EC
		tst.b	ost_primary_status(a0)
		bmi.s	loc_2F4EE
		tst.b	ost_col_type(a0)
		bne.s	locret_2F4EC
		tst.b	$3E(a0)
		bne.s	loc_2F4D0
		move.b	#$20,$3E(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_2F4D0:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_2F4DE
		move.w	#$EEE,d0

loc_2F4DE:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_2F4EC
		move.b	#id_col_24x24,ost_col_type(a0)

locret_2F4EC:
		rts
; ===========================================================================

loc_2F4EE:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo3_AddPoints
		move.b	#6,ost_secondary_routine(a0)
		move.w	#0,ost_x_vel(a0)

loc_2F500:
		move.w	#-$180,ost_y_vel(a0)
		move.w	#$B3,$3C(a0)
		bset	#3,$2D(a0)
		movea.l	$34(a0),a1
		move.b	#4,ost_anim(a1)
		move.b	#6,ost_frame(a1)
		moveq	#$40,d0
		jmpto	AddPLC,JmpTo6_AddPLC
; ===========================================================================
		rts						; dead code
; ===========================================================================

loc_2F52A:
		subi_.w	#1,ost_y_pos(a0)
		subi_.w	#1,$2A(a0)
		bpl.w	JmpTo35_DisplaySprite
		move.b	#4,ost_primary_routine(a0)
		lea	(Ani_Rotor).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F54E:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2F55C(pc,d0.w),d1
		jmp	off_2F55C(pc,d1.w)
; ===========================================================================
off_2F55C:	index offset(*),,2
		ptr loc_2F560					; 0
		ptr loc_2F5C6					; 2
; ===========================================================================

loc_2F560:
		movea.l	$34(a0),a1
		cmpi.b	#id_BossEmeraldHill,ost_id(a1)
		bne.w	JmpTo52_DeleteObject
		btst	#0,$2D(a1)
		beq.s	loc_2F58E
		move.b	#1,ost_anim(a0)
		move.w	#$18,$2A(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#-8,d0
		jsrto	PlaySound,JmpTo6_PlaySound
		bra.s	loc_2F5A0
; ===========================================================================

loc_2F58E:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_2F5A0
		move.b	#-$22,d0
		jsrto	PlaySound,JmpTo6_PlaySound

loc_2F5A0:
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		lea	(Ani_Rotor).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F5C6:
		subi_.w	#1,$2A(a0)
		bpl.s	loc_2F5E8
		cmpi.w	#-$10,$2A(a0)
		ble.w	JmpTo52_DeleteObject
		move.b	#4,ost_priority(a0)
		addi_.w	#1,ost_y_pos(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F5E8:
		lea	(Ani_Rotor).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F5F6:
		tst.b	ost_secondary_routine(a0)
		bne.s	loc_2F626
		cmpi.w	#$28F0,(v_boundary_left).w
		bcs.w	JmpTo35_DisplaySprite
		cmpi.w	#$29D0,ost_x_pos(a0)
		ble.s	loc_2F618
		subi_.w	#1,ost_x_pos(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F618:
		move.w	#$29D0,ost_x_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F626:
		movea.l	$34(a0),a1
		btst	#1,$2D(a1)
		beq.w	JmpTo35_DisplaySprite
		btst	#2,$2D(a1)
		bne.w	JmpTo35_DisplaySprite
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addi_.w	#8,ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		bmi.w	JmpTo35_DisplaySprite
		move.b	ost_render(a1),ost_render(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F664:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2F672(pc,d0.w),d1
		jmp	off_2F672(pc,d1.w)
; ===========================================================================
off_2F672:	index offset(*),,2
		ptr loc_2F67C					; 0
		ptr loc_2F714					; 2
		ptr loc_2F746					; 4
		ptr loc_2F7A6					; 6
		ptr loc_2F7D2					; 8
; ===========================================================================

loc_2F67C:
		cmpi.w	#$28F0,(v_boundary_left).w
		bcs.w	JmpTo35_DisplaySprite
		move.w	#$100,ost_y_vel(a0)
		cmpi.b	#1,ost_subtype(a0)
		bgt.s	loc_2F6B6
		beq.s	loc_2F6A6
		cmpi.w	#$29EC,ost_x_pos(a0)
		ble.s	loc_2F6C6
		subi_.w	#1,ost_x_pos(a0)
		bra.s	loc_2F6E8
; ===========================================================================

loc_2F6A6:
		cmpi.w	#$29C4,ost_x_pos(a0)
		ble.s	loc_2F6D2
		subi_.w	#1,ost_x_pos(a0)
		bra.s	loc_2F6E8
; ===========================================================================

loc_2F6B6:
		cmpi.w	#$29A4,ost_x_pos(a0)
		ble.s	loc_2F6DE
		subi_.w	#1,ost_x_pos(a0)
		bra.s	loc_2F6E8
; ===========================================================================

loc_2F6C6:
		move.w	#$29EC,ost_x_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.s	loc_2F6E8
; ===========================================================================

loc_2F6D2:
		move.w	#$29C4,ost_x_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.s	loc_2F6E8
; ===========================================================================

loc_2F6DE:
		move.w	#$29A4,ost_x_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)

loc_2F6E8:
		jsrto	ObjectFall,JmpTo4_ObjectFall
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_2F6FA
		add.w	d1,ost_y_pos(a0)

loc_2F6FA:
		tst.b	ost_secondary_routine(a0)
		beq.s	loc_2F706

loc_2F700:
		move.w	#-$200,ost_x_vel(a0)

loc_2F706:
		lea	(Ani_Drillster).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F714:
		movea.l	$34(a0),a1
		cmpi.b	#id_BossEmeraldHill,ost_id(a1)
		bne.w	JmpTo52_DeleteObject
		btst	#1,$2D(a1)
		beq.w	JmpTo35_DisplaySprite
		addq.b	#2,ost_secondary_routine(a0)
		cmpi.b	#2,ost_priority(a0)
		bne.s	loc_2F742
		move.w	ost_y_pos(a0),d0
		movea.l	$34(a0),a1
		add.w	d0,$2E(a1)

loc_2F742:
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F746:
		movea.l	$34(a0),a1
		cmpi.b	#id_BossEmeraldHill,ost_id(a1)
		bne.w	JmpTo52_DeleteObject
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		tst.b	ost_primary_status(a0)
		bpl.s	loc_2F768
		addq.b	#2,ost_secondary_routine(a0)

loc_2F768:
		bsr.w	loc_2F484
		jsrto	ObjectFall,JmpTo4_ObjectFall
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_2F77E
		add.w	d1,ost_y_pos(a0)

loc_2F77E:
		move.w	#$100,ost_y_vel(a0)
		cmpi.b	#2,ost_priority(a0)
		bne.s	loc_2F798
		move.w	ost_y_pos(a0),d0
		movea.l	$34(a0),a1
		add.w	d0,$2E(a1)

loc_2F798:
		lea	(Ani_Drillster).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F7A6:
		subi_.w	#1,$2A(a0)
		bpl.w	JmpTo35_DisplaySprite
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$A,$2A(a0)
		move.w	#-$300,ost_y_vel(a0)
		cmpi.b	#2,ost_priority(a0)
		beq.w	JmpTo35_DisplaySprite
		neg.w	ost_x_vel(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F7D2:
		subq.w	#1,$2A(a0)
		bpl.w	JmpTo35_DisplaySprite
		jsrto	ObjectFall,JmpTo4_ObjectFall
		jsrto	FindFloorObj,JmpTo3_FindFloorObj
		tst.w	d1
		bpl.s	loc_2F7F0
		move.w	#-$200,ost_y_vel(a0)
		add.w	d1,ost_y_pos(a0)

loc_2F7F0:
		jmpto	DespawnObject,JmpTo36_DespawnObject
; ===========================================================================

loc_2F7F4:
		tst.b	ost_secondary_routine(a0)
		bne.s	loc_2F824
		cmpi.w	#$28F0,(v_boundary_left).w

loc_2F800:
		bcs.w	JmpTo35_DisplaySprite
		cmpi.w	#$299A,ost_x_pos(a0)
		ble.s	loc_2F816
		subi_.w	#1,ost_x_pos(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F816:
		move.w	#$299A,ost_x_pos(a0)
		addq.b	#2,ost_secondary_routine(a0)
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F824:
		movea.l	$34(a0),a1
		cmpi.b	#id_BossEmeraldHill,ost_id(a1)
		bne.w	JmpTo52_DeleteObject
		btst	#3,$2D(a1)
		bne.s	loc_2F88A
		bsr.w	loc_2F8AA
		btst	#1,$2D(a1)
		beq.w	JmpTo35_DisplaySprite
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a0)
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		addi.w	#$10,ost_y_pos(a0)
		move.w	#-$36,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2F878
		neg.w	d0

loc_2F878:
		add.w	d0,ost_x_pos(a0)
		lea	(Ani_Drillster).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F88A:
		move.w	#-3,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_2F898
		neg.w	d0

loc_2F898:
		add.w	d0,ost_x_pos(a0)
		lea	(Ani_Drillster).l,a1
		jsrto	AnimateSprite,JmpTo17_AnimateSprite
		bra.w	JmpTo35_DisplaySprite
; ===========================================================================

loc_2F8AA:
		cmpi.b	#1,ost_col_property(a1)
		beq.s	loc_2F8B4
		rts
; ===========================================================================

loc_2F8B4:
		move.w	ost_x_pos(a0),d0
		sub.w	($FFFFB008).w,d0
		bpl.s	loc_2F8C8
		btst	#status_xflip_bit,ost_primary_status(a1)
		bne.s	loc_2F8D2
		rts
; ===========================================================================

loc_2F8C8:
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_2F8D2
		rts
; ===========================================================================

loc_2F8D2:
		bset	#3,$2D(a1)
		rts
; ===========================================================================

loc_2F8DA:
		movea.l	$34(a0),a1
		move.l	ost_x_pos(a1),ost_x_pos(a0)
		move.l	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_render(a1),ost_render(a0)
		move.b	$3E(a1),d0
		cmpi.b	#$1F,d0
		bne.s	loc_2F906

loc_2F900:
		move.b	#2,ost_anim(a0)

loc_2F906:
		cmpi.b	#4,($FFFFB024).w
		beq.s	loc_2F916
		cmpi.b	#4,($FFFFB064).w
		bne.s	loc_2F924

loc_2F916:
		cmpi.b	#2,ost_anim(a0)
		beq.s	loc_2F924
		move.b	#3,ost_anim(a0)

loc_2F924:
		lea	(Ani_BEHZ_Eggman).l,a1
		jsr	(AnimateSprite).l
		jmp	(DisplaySprite).l
; ===========================================================================
Ani_Rotor:	index offset(*)
		ptr byte_2F93C					; 0
		ptr byte_2F940					; 1
		ptr byte_2F956					; 2

byte_2F93C:
		dc.b   1,  5,  6,$FF

byte_2F940:
		dc.b   1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  0,  0,  0
		dc.b   0,  0,  0,  0,  0,$FF

byte_2F956:
		dc.b   1,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  4,  3,  3,  3,  2
		dc.b   2,  2,  1,  1,  1,  5,  6,$FE,  2,  0
; ===========================================================================

		include "mappings/sprite/EHZ Boss.asm"

; ===========================================================================

Ani_Drillster:	index offset(*)
		ptr byte_2FA4A					; 0
		ptr byte_2FA4F					; 1
		ptr byte_2FA53					; 2
byte_2FA4A:	dc.b   5,  1,  2,  3,$FF			; 0
byte_2FA4F:	dc.b   1,  4,  5,$FF				; 0
byte_2FA53:	dc.b   1,  6,  7,$FF,  0			; 0
; ===========================================================================

		include_EggDrillster_Maps			; mappings/sprite/EHZ Boss.asm

; ===========================================================================

Ani_BEHZ_Eggman:	index offset(*)
		ptr byte_2FAD2					; 0
		ptr byte_2FAD5					; 1
		ptr byte_2FAD9					; 2
		ptr byte_2FAE2					; 3
		ptr byte_2FAEB					; 4
byte_2FAD2:	dc.b  $F,  0,$FF				; 0
byte_2FAD5:	dc.b   7,  1,  2,$FF				; 0
byte_2FAD9:	dc.b   7,  5,  5,  5,  5,  5,  5,$FD,  1	; 0
byte_2FAE2:	dc.b   7,  3,  4,  3,  4,  3,  4,$FD,  1	; 0
byte_2FAEB:	dc.b  $F,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,$FD,  1 ; 0
; ===========================================================================

		include_BEHZ_Eggman_Maps			; mappings/sprite/EHZ Boss.asm

; ===========================================================================

	if RemoveJmpTos
JmpTo52_DeleteObject:
		jmp	(DeleteObject).l
JmpTo35_DisplaySprite:
		jmp	(DisplaySprite).l
	else
JmpTo35_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo52_DeleteObject:
		jmp	(DeleteObject).l
JmpTo36_DespawnObject:
		jmp	(DespawnObject).l
JmpTo5_DeleteChild:
		jmp	(DeleteChild).l
JmpTo6_PlaySound:
		jmp	(PlaySound).l
JmpTo21_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo17_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo9_AdjustVRAM2P2:
		jmp	(AdjustVRAM2P2).l
JmpTo3_FindFloorObj:
		jmp	(FindFloorObj).l
JmpTo6_AddPLC:
		jmp	(AddPLC).l
JmpTo3_AddPoints:
		jmp	(AddPoints).l
JmpTo61_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo2_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo2_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l
JmpTo4_ObjectFall:
		jmp	(ObjectFall).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 52 - HTZ boss
; ----------------------------------------------------------------------------

BossHillTop:
		moveq	#0,d0
		move.b	ost_boss_subtype(a0),d0
		move.w	BHTZ_Index(pc,d0.w),d1
		jmp	BHTZ_Index(pc,d1.w)
; ===========================================================================
BHTZ_Index:	index offset(*),,2
		ptr loc_2FC68					; 0
		ptr loc_2FD00					; 2
		ptr loc_2FEF0					; 4
		ptr loc_2FF66					; 6
		ptr loc_30210					; 8
; ===========================================================================

loc_2FC68:
		move.l	#Map_BHTZ_Eggpod,ost_mappings(a0)
		move.w	#tile_Nem_Eggpod_HTZ,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$90,ost_mainspr_width(a0)
	if FixBugs=0
		; This instruction is pointless, as render_useheight_bit is not
		; set. Additionally, it clashes with 'ost_boss_flash_time', as they
		; use the same OST offset. Unlike the Casino Night Zone boss, this does
		; not result in any bugs, because 'ost_boss_flash_time' is cleared
		; right after this.
		move.b	#$90,ost_mainspr_height(a0)
	endc
		move.b	#4,ost_priority(a0)
		move.w	#$3040,ost_x_pos(a0)
		move.w	#$580,ost_y_pos(a0)
		move.b	#1,ost_boss_defeated(a0)
		move.b	#1,ost_mainspr_frame(a0)
		addq.b	#2,ost_boss_subtype(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#id_col_32x28,ost_col_type(a0)
		move.b	#8,ost_boss_hitcount2(a0)
		move.w	#-$E0,(v_boss_y_vel).w
		move.w	ost_x_pos(a0),($FFFFF750).w
		move.w	ost_y_pos(a0),(v_boss_y_pos).w
	if FixBugs=0
		; Possibly a workaround for the above bug? In any case, no longer needed
		; with the bug fixed.
		clr.b	ost_boss_flash_time(a0)
	endc
		move.w	ost_x_pos(a0),ost_subspr2_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr2_y_pos(a0)
		move.b	#2,ost_subspr2_frame(a0)
		bsr.w	loc_2FCEA
		rts
; ===========================================================================

loc_2FCEA:
		lea	($FFFFF740).w,a2
		move.b	#6,(a2)+
		move.b	#0,(a2)+
		move.b	#$10,(a2)+
		move.b	#0,(a2)+
		rts
; ===========================================================================

loc_2FD00:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_2FD0E(pc,d0.w),d1
		jmp	off_2FD0E(pc,d1.w)
; ===========================================================================
off_2FD0E:	index offset(*),,2
		ptr loc_2FD18					; 0
		ptr loc_2FD5E					; 2
		ptr loc_2FDDA					; 4
		ptr loc_2FE0E					; 6
		ptr loc_30106					; 8
; ===========================================================================

loc_2FD18:
		move.b	#0,(v_boss_collision_routine).w
		bsr.w	BossMove
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_2FD32
		cmpi.w	#$518,(v_boss_y_pos).w
		bgt.s	loc_2FD50
		bra.s	loc_2FD3A
; ===========================================================================

loc_2FD32:
		cmpi.w	#$4FC,(v_boss_y_pos).w
		bgt.s	loc_2FD50

loc_2FD3A:
		move.w	#0,(v_boss_y_vel).w
		move.b	#4,ost_boss_wobble(a0)
		addq.b	#2,ost_boss_routine(a0)
		move.b	#$3C,$3E(a0)

loc_2FD50:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		bsr.w	loc_300A4

    if RemoveJmpTos
JmpTo36_DisplaySprite:
    endc

		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_2FD5E:
		subi_.b	#1,$3E(a0)
		bpl.s	loc_2FDC0
		move.b	#1,(v_boss_collision_routine).w
		move.b	#1,ost_mainspr_childsprites(a0)
		cmpi.b	#-$18,$3E(a0)
		bne.s	loc_2FDC0
		jsrto	FindFreeObj,JmpTo13_FindFreeObj
		bne.s	loc_2FDAA
		_move.b	#id_BossHillTop,ost_id(a1)
		move.b	#4,ost_boss_subtype(a1)
		move.b	ost_render(a0),ost_render(a1)
		andi.b	#render_xflip,ost_render(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#$2F,$3E(a0)

loc_2FDAA:
		bsr.w	loc_300A4
		bsr.w	loc_2FEDE
		lea	(Ani_BHTZ).l,a1
		bsr.w	BossAnimate
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_2FDC0:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#7,d1
		add.w	(v_boss_y_pos).w,d1
		move.w	d1,ost_y_pos(a0)
		addq.b	#4,ost_boss_wobble(a0)
		bra.s	loc_2FDAA
; ===========================================================================

loc_2FDDA:
		move.b	#0,(v_boss_collision_routine).w
		move.b	#0,ost_mainspr_childsprites(a0)
		move.b	#$10,($FFFFF742).w
		move.b	#0,($FFFFF743).w
		subi_.b	#1,$3E(a0)
		bne.w	loc_2FDC0
		move.w	#$E0,(v_boss_y_vel).w
		addq.b	#2,ost_boss_routine(a0)
		bsr.w	loc_2FEDE
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_2FE0E:
		bsr.w	BossMove
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_2FE22
		cmpi.w	#$538,(v_boss_y_pos).w
		blt.s	loc_2FE58
		bra.s	loc_2FE2A
; ===========================================================================

loc_2FE22:
		cmpi.w	#$548,(v_boss_y_pos).w
		blt.s	loc_2FE58

loc_2FE2A:
		tst.b	$38(a0)
		bne.s	loc_2FE58
		st.b	$38(a0)
		jsrto	FindFreeObj,JmpTo13_FindFreeObj
		bne.s	loc_2FE58
		move.b	#id_BossHillTop,ost_id(a1)
		move.b	#6,ost_boss_subtype(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#-$52,d0
		jsrto	Playsound,JmpTo7_PlaySound

loc_2FE58:
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_2FE6E
		cmpi.w	#$5A0,(v_boss_y_pos).w
		blt.s	loc_2FED0
		move.w	#$5A0,(v_boss_y_pos).w
		bra.s	loc_2FE7C
; ===========================================================================

loc_2FE6E:
		cmpi.w	#$580,(v_boss_y_pos).w
		blt.s	loc_2FED0
		move.w	#$580,(v_boss_y_pos).w

loc_2FE7C:
		move.w	#-$E0,(v_boss_y_vel).w
		move.b	#0,ost_boss_routine(a0)
		sf.b	$38(a0)
		move.w	($FFFFB008).w,d0
		subi.w	#$2FC0,d0
		bmi.s	loc_2FEA8
		move.w	#$580,(v_boss_y_pos).w
		move.w	#$3040,ost_x_pos(a0)
		st.b	ost_boss_defeated(a0)
		bra.s	loc_2FEB8
; ===========================================================================

loc_2FEA8:
		move.w	#$2F40,ost_x_pos(a0)
		move.w	#$5A0,(v_boss_y_pos).w
		sf.b	ost_boss_defeated(a0)

loc_2FEB8:
		move.w	ost_x_pos(a0),d0
		cmp.w	($FFFFB008).w,d0
		bgt.s	loc_2FECA
		bset	#render_xflip_bit,ost_render(a0)
		bra.s	loc_2FED0
; ===========================================================================

loc_2FECA:
		bclr	#render_xflip_bit,ost_render(a0)

loc_2FED0:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		bsr.w	loc_300A4
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_2FEDE:
		move.w	ost_x_pos(a0),d0
		move.w	ost_y_pos(a0),d1
		move.w	d0,ost_subspr2_x_pos(a0)
		move.w	d1,ost_subspr2_y_pos(a0)
		rts
; ===========================================================================

loc_2FEF0:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2FEFE(pc,d0.w),d1
		jmp	off_2FEFE(pc,d1.w)
; ===========================================================================
off_2FEFE:	index offset(*),,2
		ptr loc_2FF02					; 0
		ptr loc_2FF50					; 2
; ===========================================================================

loc_2FF02:
		move.l	#Map_BHTZ_Eggpod,ost_mappings(a0)
		move.w	#tile_Nem_HTZBoss,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#5,ost_anim(a0)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a0)
		subi.w	#$1C,ost_y_pos(a0)
		move.w	#-$70,d0
		move.w	#-4,d1
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_2FF46
		neg.w	d0
		neg.w	d1

loc_2FF46:
		add.w	d0,ost_x_pos(a0)
		move.w	d1,ost_x_vel(a0)
		rts
; ===========================================================================

loc_2FF50:
		move.w	ost_x_vel(a0),d1
		add.w	d1,ost_x_pos(a0)
		lea	(Ani_BHTZ).l,a1
		jsrto	AnimateSprite,JmpTo18_AnimateSprite
		jmpto	DespawnObject,JmpTo37_DespawnObject
; ===========================================================================

loc_2FF66:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_2FF74(pc,d0.w),d1
		jmp	off_2FF74(pc,d1.w)
; ===========================================================================
off_2FF74:	index offset(*),,2
		ptr loc_2FF78					; 0
		ptr loc_30008					; 2
; ===========================================================================

loc_2FF78:
		movea.l	a0,a1
		moveq	#0,d2
		moveq	#1,d1
		bra.s	loc_2FF94
; ===========================================================================

loc_2FF80:
		jsrto	FindFreeObj,JmpTo13_FindFreeObj
		bne.w	locret_30006
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

loc_2FF94:
		move.b	#id_BossHillTop,ost_id(a1)
		move.b	#6,ost_boss_subtype(a1)
		move.l	#Map_BHTZ_Eggpod,ost_mappings(a1)
		move.w	#tile_Nem_HTZBoss,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		addq.b	#2,ost_secondary_routine(a1)
		move.b	#7,ost_anim(a1)
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a1)
		move.b	d2,$2E(a1)
		move.b	#8,ost_height(a1)
		move.b	#8,ost_width(a1)
		move.w	ost_x_pos(a1),$2A(a1)
		move.w	#$1C00,d0
		tst.w	d2
		bne.s	loc_2FFE8
		neg.w	d0

loc_2FFE8:
		move.w	d0,ost_x_vel(a1)
		move.w	#-$5400,ost_y_vel(a1)
		cmpi.w	#$2F40,ost_x_pos(a1)
		beq.s	loc_30000
		move.w	#-$6400,ost_y_vel(a1)

loc_30000:
		addq.w	#1,d2

loc_30002:
		dbf	d1,loc_2FF80

locret_30006:
		rts
; ===========================================================================

loc_30008:
		bsr.w	loc_30072

loc_3000C:
		jsrto	FindFloorObj,JmpTo4_FindFloorObj
		tst.w	d1
		bpl.s	loc_30064
		add.w	d1,ost_y_pos(a0)
		move.b	#id_LavaBubble,ost_id(a0)
		move.b	#$A,ost_primary_routine(a0)
		move.b	#2,ost_anim(a0)
		move.b	#4,ost_frame(a0)

loc_3002E:
		move.w	#0,ost_y_vel(a0)
		move.l	#Map_Fireball1,ost_mappings(a0)
		move.w	#tile_Nem_Fireball1+tile_hi,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo62_AdjustVRAM2P
		move.b	#0,ost_frame(a0)
		move.w	#9,$32(a0)
		move.b	#3,$36(a0)
		move.b	#-$4D,d0
		jsrto	Playsound,JmpTo7_PlaySound
		jmpto	LavaBubble,JmpTo_LavaBubble
; ===========================================================================

loc_30064:
		lea	(Ani_BHTZ).l,a1
		jsrto	AnimateSprite,JmpTo18_AnimateSprite
		jmpto	DespawnObject,JmpTo37_DespawnObject
; ===========================================================================

loc_30072:
		move.l	$2A(a0),d2
		move.l	ost_y_pos(a0),d3
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#4,d0
		add.l	d0,d2
		move.w	ost_y_vel(a0),d0
		addi.w	#$380,ost_y_vel(a0)
		ext.l	d0
		asl.l	#4,d0
		add.l	d0,d3
		move.l	d2,$2A(a0)
		move.l	d3,ost_y_pos(a0)
		move.w	$2A(a0),ost_x_pos(a0)
		rts
; ===========================================================================

loc_300A4:
		cmpi.b	#8,ost_boss_routine(a0)
		bcc.s	locret_300EA
		tst.b	ost_boss_hitcount2(a0)
		beq.s	loc_300EC
		tst.b	ost_col_type(a0)
		bne.s	locret_300EA
		tst.b	ost_boss_flash_time(a0)
		bne.s	loc_300CE
		move.b	#$20,ost_boss_flash_time(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_300CE:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_300DC
		move.w	#$EEE,d0

loc_300DC:
		move.w	d0,(a1)
		subq.b	#1,ost_boss_flash_time(a0)
		bne.s	locret_300EA
		move.b	#id_col_32x28,ost_col_type(a0)

locret_300EA:
		rts
; ===========================================================================

loc_300EC:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo4_AddPoints
		move.w	#$B3,(v_boss_timer).w
		move.b	#8,ost_boss_routine(a0)
		moveq	#id_PLC_Capsule,d0
		jsrto	AddPLC,JmpTo7_AddPLC
		rts
; ===========================================================================

loc_30106:
		move.b	#0,ost_mainspr_childsprites(a0)
		subi_.w	#1,(v_boss_timer).w
		bmi.s	loc_30142
		cmpi.w	#$1E,(v_boss_timer).w
		bgt.s	loc_3013A
		move.b	#$10,ost_mainspr_frame(a0)
		bsr.w	BossExplode
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.w	JmpTo36_DisplaySprite
		bsr.w	loc_301B4
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_3013A:
		bsr.w	BossExplode
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_30142:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.w	loc_30152
		bsr.w	loc_301B4

loc_30152:
		cmpi.w	#-$3C,(v_boss_timer).w
		bgt.w	JmpTo36_DisplaySprite
		tst.b	(v_boss_status).w
		bne.s	loc_30170
		jsrto	RestoreLevelMusic,JmpTo3_RestoreLevelMusic
		jsrto	LoadAnimalExplosionArt,JmpTo3_LoadAnimalExplosionArt
		move.b	#1,(v_boss_status).w

loc_30170:
		addq.w	#2,ost_y_pos(a0)
		cmpi.w	#$3160,(v_boundary_right).w
		bcc.s	loc_30182
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_301A6
; ===========================================================================

loc_30182:
		tst.b	ost_render(a0)
		bpl.s	loc_301AA
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_3019C
		cmpi.w	#$578,ost_y_pos(a0)
		bgt.w	loc_301AA
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_3019C:
		cmpi.w	#$588,ost_y_pos(a0)
		bgt.w	loc_301AA

loc_301A6:
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

loc_301AA:
		move.w	#$3160,(v_boundary_right).w

    if RemoveJmpTos
JmpTo53_DeleteObject:
    endc

		jmpto	DeleteObject,JmpTo53_DeleteObject
; ===========================================================================

loc_301B4:
		jsrto	FindFreeObj,JmpTo13_FindFreeObj
		bne.s	locret_3020E
		move.b	#id_BossHillTop,ost_id(a1)
		move.b	#8,ost_boss_subtype(a1)
		move.l	#Map_BHTZ_Smoke,ost_mappings(a1)
		move.w	#tile_Nem_BossSmoke_HTZ,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#1,ost_priority(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_x_pos(a0),$2A(a1)
		subi.w	#$28,ost_y_pos(a1)
		move.w	#-$60,ost_x_vel(a1)
		move.w	#-$C0,ost_y_vel(a1)
		move.b	#0,ost_frame(a1)
		move.b	#$11,ost_anim_time(a1)

locret_3020E:
		rts
; ===========================================================================

loc_30210:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_3022A
		move.b	#$11,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#4,ost_frame(a0)
		beq.w	JmpTo53_DeleteObject

loc_3022A:
		move.l	$2A(a0),d2
		move.l	ost_y_pos(a0),d3
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,$2A(a0)
		move.w	$2A(a0),ost_x_pos(a0)
		move.l	d3,ost_y_pos(a0)
		jmpto	DisplaySprite,JmpTo36_DisplaySprite
; ===========================================================================

		include "mappings/sprite/HTZ Boss.asm"

; ===========================================================================

Ani_BHTZ:	index offset(*)
		ptr byte_30298					; 0
		ptr byte_3029D					; 1
		ptr byte_302A2					; 2
		ptr byte_302A7					; 3
		ptr byte_302AC					; 4
		ptr byte_302B0					; 5
		ptr byte_302B4					; 6
		ptr byte_302B7					; 7
byte_30298:	dc.b   1,  2,  3,$FD,  1			; 0
byte_3029D:	dc.b   2,  4,  5,$FD,  2			; 0
byte_302A2:	dc.b   3,  6,  7,$FD,  3			; 0
byte_302A7:	dc.b   4,  8,  9,$FD,  4			; 0
byte_302AC:	dc.b   5, $A, $B,$FE				; 0
byte_302B0:	dc.b   3, $C, $D,$FF				; 0
byte_302B4:	dc.b  $F,  1,$FF				; 0
byte_302B7:	dc.b   3, $E, $F,$FF,  0			; 0
; ===========================================================================

		include_HTZEggpod_Maps

; ===========================================================================

	if RemoveJmpTos=0
		align 4
    endc

; ===========================================================================

	if RemoveJmpTos=0
JmpTo36_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo53_DeleteObject:
		jmp	(DeleteObject).l
JmpTo13_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo37_DespawnObject:
		jmp	(DespawnObject).l
JmpTo7_PlaySound:
		jmp	(PlaySound).l
JmpTo18_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo4_FindFloorObj:
		jmp	(FindFloorObj).l
JmpTo7_AddPLC:
		jmp	(AddPLC).l
JmpTo_LavaBubble:
		jmp	(LavaBubble).l
JmpTo4_AddPoints:
		jmp	(AddPoints).l
JmpTo62_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo3_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo3_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 89 - ARZ boss
; ----------------------------------------------------------------------------

BossAquaticRuin:
		moveq	#0,d0
		move.b	ost_boss_subtype(a0),d0
		move.w	BARZ_Index(pc,d0.w),d1
		jmp	BARZ_Index(pc,d1.w)
; ===========================================================================
BARZ_Index:	index offset(*),,2
		ptr loc_30494					; 0
		ptr loc_30620					; 2
		ptr loc_309A8					; 4

; OST Variables:
; Main Vehicle
;obj89_hammer_y_vel	= objoff_2E		; falling hammer's y velocity
;obj89_target		= objoff_38
;obj89_hammer_y_pos	= objoff_3A		; falling hammer's y position
;obj89_hammer_flags	= objoff_3E

; Pillars & Arrows
;obj89_pillar_parent		= objoff_2A	; address of main vehicle
;obj89_pillar_shake_time		= objoff_30
;obj89_pillar_shaking		= objoff_38
;obj89_eyes_timer		= objoff_30
;obj89_arrow_routine		= objoff_2A
;obj89_arrow_timer		= objoff_30
;obj89_arrow_parent2		= objoff_34
;obj89_arrow_parent		= objoff_38	; address of main vehicle
; ===========================================================================

loc_30494:
		tst.l	(v_plc_buffer).w
		beq.s	loc_3049C
		rts
; ===========================================================================

loc_3049C:
		tst.w	(v_player_mode).w
		bne.s	loc_304D4
		move.w	($FFFFB008).w,d0
		cmpi.w	#$2A60,d0
		blt.w	loc_305F4
		cmpi.w	#$2B60,d0
		bgt.w	loc_305F4
		cmpi.b	#-$7F,($FFFFB06A).w
		beq.w	loc_304D4
		move.w	($FFFFB048).w,d0
		cmpi.w	#$2A60,d0
		blt.w	loc_305F4
		cmpi.w	#$2B60,d0
		bgt.w	loc_305F4

loc_304D4:
		move.b	#1,(f_screen_shake).w
		move.w	#tile_Nem_ARZBoss,ost_tile(a0)
		move.l	#Map_BARZ_EggPod,ost_mappings(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#$20,ost_mainspr_width(a0)
		move.b	#2,ost_priority(a0)
		move.b	#2,ost_boss_subtype(a0)
		move.w	#$2AE0,ost_x_pos(a0)
		move.w	#$388,ost_y_pos(a0)
		move.w	#$2AE0,($FFFFF750).w
		move.w	#$388,(v_boss_y_pos).w
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#3,ost_mainspr_childsprites(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_boss_hitcount2(a0)
		move.b	#8,ost_mainspr_frame(a0)
		move.w	#-$380,$2E(a0)
		clr.b	(v_boss_collision_routine).w
		move.w	#$2AE0,ost_subspr2_x_pos(a0)
		move.w	#$488,ost_subspr2_y_pos(a0)
		move.b	#0,ost_subspr2_frame(a0)
		move.w	#$2AE0,ost_subspr3_x_pos(a0)
		move.w	#$488,ost_subspr3_y_pos(a0)
		move.b	#9,ost_subspr3_frame(a0)
		move.w	#$2AE0,ost_subspr4_x_pos(a0)
		move.w	#$488,ost_subspr4_y_pos(a0)
		move.b	#6,ost_subspr4_frame(a0)
		move.w	#$100,(v_boss_y_vel).w

		jsrto	FindFreeObj,JmpTo14_FindFreeObj
		bne.w	loc_305F4
		move.b	#id_BossAquaticRuin,ost_id(a1)
		move.l	#Map_BARZ_Pillar,ost_mappings(a1)
		ori.b	#render_rel,ost_render(a1)
		move.w	#tile_Nem_ARZBoss,ost_tile(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#4,ost_priority(a1)
		move.w	#$2A50,ost_x_pos(a1)
		move.w	#$510,ost_y_pos(a1)
		addq.b	#4,ost_boss_subtype(a1)
		move.l	a0,$2A(a1)
		move.b	#0,ost_frame(a1)
		move.b	#2,ost_priority(a1)
		move.b	#$20,ost_height(a1)
		movea.l	a1,a2
		jsrto	FindNextFreeObj,JmpTo22_FindNextFreeObj
		bne.s	loc_305F4
		moveq	#0,d0
		move.w	#$F,d1

loc_305DC:
		move.l	(a2,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_305DC
		bset	#render_xflip_bit,ost_render(a1)
		move.w	#$2B70,ost_x_pos(a1)

loc_305F4:
		bsr.w	loc_305FA
		rts
; ===========================================================================

loc_305FA:
		lea	($FFFFF740).w,a2
		move.b	#4,(a2)+
		move.b	#0,(a2)+
		move.b	#0,(a2)+
		move.b	#0,(a2)+
		move.b	#2,(a2)+
		move.b	#0,(a2)+
		move.b	#1,(a2)+
		move.b	#0,(a2)+
		rts
; ===========================================================================

loc_30620:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_3062E(pc,d0.w),d1
		jmp	off_3062E(pc,d1.w)
; ===========================================================================
off_3062E:	index offset(*),,2
		ptr loc_3063C					; 0
		ptr loc_3067A					; 2
		ptr loc_306B8					; 4
		ptr loc_30706					; 6
		ptr loc_3088C					; 8
		ptr loc_308F4					; $A
		ptr loc_3095C					; $C
; ===========================================================================

loc_3063C:
		bsr.w	BossMove
		bsr.w	loc_3075C
		bsr.w	loc_30824
		cmpi.w	#$430,(v_boss_y_pos).w
		blt.s	loc_3066C
		move.w	#$430,(v_boss_y_pos).w
		addi_.b	#2,ost_boss_routine(a0)
		move.w	#0,(v_boss_y_vel).w
		move.w	#-$C8,(v_boss_x_vel).w
		st.b	$38(a0)

loc_3066C:
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_3067A:
		bsr.w	BossMove
		bsr.w	loc_3075C
		bsr.w	loc_30824
		tst.b	$38(a0)
		bne.s	loc_30696
		cmpi.w	#$2B10,($FFFFF750).w
		blt.s	loc_306AA
		bra.s	loc_3069E
; ===========================================================================

loc_30696:
		cmpi.w	#$2AB0,($FFFFF750).w
		bgt.s	loc_306AA

loc_3069E:
		addi_.b	#2,ost_boss_routine(a0)
		move.w	#0,(v_boss_x_vel).w

loc_306AA:
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_306B8:
		bsr.w	BossMove
		bsr.w	loc_3075C
		bsr.w	loc_30824
		cmpi.b	#-$40,ost_boss_wobble(a0)
		bne.s	loc_306F8
		lea	($FFFFF740).w,a1
		andi.b	#-$10,4(a1)
		ori.b	#3,4(a1)
		addq.b	#2,ost_boss_routine(a0)
		btst	#render_xflip_bit,ost_render(a0)
		sne	$38(a0)
		move.w	#$1E,(v_boss_timer).w
		move.b	#-$43,d0
		jsrto	PlaySound,JmpTo8_PlaySound

loc_306F8:
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30706:
		cmpi.w	#$14,(v_boss_timer).w
		bne.s	loc_3071A
		bset	#0,$3E(a0)
		move.b	#1,(v_boss_collision_routine).w

loc_3071A:
		subi_.w	#1,(v_boss_timer).w
		bpl.s	loc_30742
		clr.b	(v_boss_collision_routine).w
		move.b	#2,ost_boss_routine(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3073C
		move.w	#-$C8,(v_boss_x_vel).w
		bra.s	loc_30742
; ===========================================================================

loc_3073C:
		move.w	#$C8,(v_boss_x_vel).w

loc_30742:
		bsr.w	BossMove
		bsr.w	loc_3075C
		bsr.w	loc_30824
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_3075C:
		bsr.w	loc_3078E
		cmpi.b	#4,($FFFFB024).w
		beq.s	loc_30770
		cmpi.b	#4,($FFFFB064).w
		bne.s	loc_3077A

loc_30770:
		lea	($FFFFF740).w,a1
		move.b	#$31,3(a1)

loc_3077A:
		cmpi.b	#64-1,ost_boss_flash_time(a0)
		bne.s	locret_3078C
		lea	($FFFFF740).w,a1
		move.b	#-$40,3(a1)

locret_3078C:
		rts
; ===========================================================================

loc_3078E:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	(v_boss_y_pos).w,d0
		move.w	d0,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		addq.b	#2,ost_boss_wobble(a0)
		cmpi.b	#8,ost_boss_routine(a0)
		bcc.s	locret_307F2
		tst.b	ost_boss_hitcount2(a0)
		beq.s	loc_307F4
		tst.b	ost_col_type(a0)
		bne.s	locret_307F2
		tst.b	ost_boss_flash_time(a0)
		bne.s	loc_307D6
		move.b	#$40,ost_boss_flash_time(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_307D6:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_307E4
		move.w	#$EEE,d0

loc_307E4:
		move.w	d0,(a1)
		subq.b	#1,ost_boss_flash_time(a0)
		bne.s	locret_307F2
		move.b	#id_col_24x24,ost_col_type(a0)

locret_307F2:
		rts
; ===========================================================================

loc_307F4:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo5_AddPoints
		move.w	#$B3,(v_boss_timer).w
		move.b	#8,ost_boss_routine(a0)

loc_30806:
		lea	($FFFFF740).w,a1
		move.b	#5,2(a1)
		move.b	#0,3(a1)
		moveq	#id_PLC_Capsule,d0
		jsrto	AddPLC,JmpTo8_AddPLC
		move.b	#5,ost_subspr2_frame(a0)
		rts
; ===========================================================================

loc_30824:
		move.w	ost_x_pos(a0),d0
		move.w	ost_y_pos(a0),d1
		move.w	d0,ost_subspr2_x_pos(a0)
		move.w	d1,ost_subspr2_y_pos(a0)
		move.w	d0,ost_subspr4_x_pos(a0)
		move.w	d1,ost_subspr4_y_pos(a0)
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_30850
		move.w	d0,ost_subspr3_x_pos(a0)
		move.w	d1,ost_subspr3_y_pos(a0)
		move.w	d1,$3A(a0)
		rts
; ===========================================================================

loc_30850:
		cmpi.w	#$78,(v_boss_timer).w
		bgt.s	locret_3088A
		subi_.w	#1,ost_subspr3_x_pos(a0)
		move.l	$3A(a0),d0
		move.w	$2E(a0),d1
		addi.w	#$38,$2E(a0)
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d0
		move.l	d0,$3A(a0)
		move.w	$3A(a0),ost_subspr3_y_pos(a0)
		cmpi.w	#$540,ost_subspr3_y_pos(a0)
		blt.s	locret_3088A
		move.w	#0,$2E(a0)

locret_3088A:
		rts
; ===========================================================================

loc_3088C:
		st.b	ost_boss_defeated(a0)
		subq.w	#1,(v_boss_timer).w
		bmi.s	loc_3089C
		bsr.w	BossExplode
		bra.s	loc_308D6
; ===========================================================================

loc_3089C:
		move.b	#3,ost_mainspr_childsprites(a0)
		lea	($FFFFF740).w,a2
		move.b	#1,4(a2)
		move.b	#0,5(a2)
		move.b	#0,2(a2)
		move.b	#0,3(a2)
		bset	#render_xflip_bit,ost_render(a0)
		clr.w	(v_boss_x_vel).w
		clr.w	(v_boss_y_vel).w
		addq.b	#2,ost_boss_routine(a0)
		move.w	#-$12,(v_boss_timer).w

loc_308D6:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_30824
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_308F4:
		addq.w	#1,(v_boss_timer).w
		beq.s	loc_30904
		bpl.s	loc_3090A
		addi.w	#$18,(v_boss_y_vel).w
		bra.s	loc_30936
; ===========================================================================

loc_30904:
		clr.w	(v_boss_y_vel).w
		bra.s	loc_30936
; ===========================================================================

loc_3090A:
		cmpi.w	#$18,(v_boss_timer).w
		bcs.s	loc_30922
		beq.s	loc_3092A
		cmpi.w	#$20,(v_boss_timer).w
		bcs.s	loc_30936
		addq.b	#2,ost_boss_routine(a0)
		bra.s	loc_30936
; ===========================================================================

loc_30922:
		subi_.w	#8,(v_boss_y_vel).w
		bra.s	loc_30936
; ===========================================================================

loc_3092A:
		clr.w	(v_boss_y_vel).w
		jsrto	RestoreLevelMusic,JmpTo4_RestoreLevelMusic
		jsrto	LoadAnimalExplosionArt,JmpTo4_LoadAnimalExplosionArt

loc_30936:
		bsr.w	BossMove
		bsr.w	loc_3078E
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_30824
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_3095C:
		move.w	#$400,(v_boss_x_vel).w
		move.w	#-$40,(v_boss_y_vel).w
		cmpi.w	#$2C00,(v_boundary_right).w
		bcc.s	loc_30976
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_3097C
; ===========================================================================

loc_30976:
		tst.b	ost_render(a0)
		bpl.s	loc_309A2

loc_3097C:
		bsr.w	BossMove
		bsr.w	loc_3078E
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		lea	(Ani_BARZ_EggPod).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_30824
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_309A2:
		jmp	(DeleteObject).l
; ===========================================================================

loc_309A8:
		moveq	#0,d0
		movea.l	$2A(a0),a1
		cmpi.b	#8,ost_boss_routine(a1)
		blt.s	loc_309BC
		move.b	#4,ost_secondary_routine(a0)

loc_309BC:
		move.b	ost_secondary_routine(a0),d0
		move.w	off_309C8(pc,d0.w),d1
		jmp	off_309C8(pc,d1.w)
; ===========================================================================
off_309C8:	index offset(*),,2
		ptr loc_309D2					; 0
		ptr loc_30A04					; 2
		ptr loc_30B4A					; 4
		ptr loc_30B9E					; 6
		ptr loc_30B6C					; 8
; ===========================================================================

loc_309D2:
		bsr.w	loc_30B7A
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_309E8
		move.w	#$E1,d0
		jsrto	PlaySound,JmpTo8_PlaySound

loc_309E8:
		subi_.w	#1,ost_y_pos(a0)
		cmpi.w	#$488,ost_y_pos(a0)
		bgt.s	loc_30A00
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#0,(f_screen_shake).w

loc_30A00:
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30A04:
		bsr.w	loc_30B7A
		movea.l	$2A(a0),a3
		btst	#0,$3E(a3)
		beq.s	loc_30A3A
		tst.b	$38(a3)
		beq.s	loc_30A24
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_30A3A
		bra.s	loc_30A2C
; ===========================================================================

loc_30A24:
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_30A3A

loc_30A2C:
		bclr	#0,$3E(a3)
		bsr.w	loc_30AB4
		st.b	$38(a0)

loc_30A3A:
		bsr.w	loc_30A42
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30A42:
		tst.b	$38(a0)
		beq.s	locret_30AAE
		tst.w	$30(a0)
		bgt.s	loc_30A54
		move.w	#$1F,$30(a0)

loc_30A54:
		subi_.w	#1,$30(a0)
		bgt.s	loc_30A82
		sf.b	$38(a0)
		move.w	#0,$30(a0)
		tst.b	$38(a3)
		bne.s	loc_30A74
		move.w	#$2A50,ost_x_pos(a0)
		bra.s	loc_30A7A
; ===========================================================================

loc_30A74:
		move.w	#$2B70,ost_x_pos(a0)

loc_30A7A:
		move.w	#$488,ost_y_pos(a0)
		bra.s	locret_30AAE
; ===========================================================================

loc_30A82:
		move.w	#$2A50,d1
		tst.b	$38(a3)
		beq.s	loc_30A90
		move.w	#$2B70,d1

loc_30A90:
		move.b	(v_vblank_counter_byte).w,d0
		andi.w	#1,d0
		add.w	d0,d0
		add.w	word_30AB0(pc,d0.w),d1
		move.w	d1,ost_x_pos(a0)
		move.w	#$488,d1
		add.w	word_30AB0(pc,d0.w),d1
		move.w	d1,ost_y_pos(a0)

locret_30AAE:
		rts
; ===========================================================================
word_30AB0:
		dc.w	 1					; 0
		dc.w $FFFF					; 1
; ===========================================================================

loc_30AB4:
		jsrto	FindFreeObj,JmpTo14_FindFreeObj
		bne.w	locret_30B40
		_move.b	#id_BossAquaticRuin,ost_id(a1)
		move.b	#4,ost_boss_subtype(a1)
		move.b	#8,ost_secondary_routine(a1)
		move.l	#Map_BARZ_Pillar,ost_mappings(a1)
		move.w	#tile_Nem_ARZBoss,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		moveq	#0,d6
		move.b	#2,ost_frame(a1)
		move.w	#$2A6A,ost_x_pos(a1)
		tst.b	$38(a3)
		beq.s	loc_30B04
		st.b	d6
		move.w	#$2B56,ost_x_pos(a1)
		bset	#render_xflip_bit,ost_render(a1)

loc_30B04:
		move.w	#$28,$30(a1)
		jsrto	RandomNumber,JmpTo3_RandomNumber
		andi.w	#3,d0
		add.w	d0,d0
		move.w	word_30B42(pc,d0.w),ost_y_pos(a1)
		movea.l	a1,a2
		jsrto	FindFreeObj,JmpTo14_FindFreeObj
		bne.s	locret_30B40
		_move.b	#id_BossAquaticRuin,ost_id(a1)
		move.b	#4,ost_boss_subtype(a1)
		move.b	#6,ost_secondary_routine(a1)
		move.l	a2,$34(a1)
		move.b	d6,ost_subtype(a1)
		move.l	a3,$38(a1)

locret_30B40:
		rts
; ===========================================================================
word_30B42:
		dc.w  $458					; 0
		dc.w  $478					; 1
		dc.w  $498					; 2
		dc.w  $4B8					; 3
; ===========================================================================

loc_30B4A:
		move.b	#1,(f_screen_shake).w
		addi_.w	#1,ost_y_pos(a0)
		cmpi.w	#$510,ost_y_pos(a0)
		blt.s	loc_30B68
		move.b	#0,(f_screen_shake).w
		jmpto	DeleteObject,JmpTo55_DeleteObject
; ===========================================================================

loc_30B68:
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30B6C:
		subi_.w	#1,$30(a0)
		beq.w	JmpTo55_DeleteObject
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30B7A:
		move.w	#$23,d1
		move.w	#$44,d2
		move.w	#$45,d3
		move.w	ost_x_pos(a0),d4
		move.w	ost_y_pos(a0),-(sp)
		addi_.w	#4,ost_y_pos(a0)
		jsrto	SolidObject,JmpTo26_SolidObject
		move.w	(sp)+,ost_y_pos(a0)
		rts
; ===========================================================================

loc_30B9E:
		moveq	#0,d0
		movea.l	$38(a0),a1
		cmpi.b	#8,ost_boss_routine(a1)
		blt.s	loc_30BB2
		move.b	#6,$2A(a0)

loc_30BB2:
		move.b	$2A(a0),d0
		move.w	off_30BBE(pc,d0.w),d1
		jmp	off_30BBE(pc,d1.w)
; ===========================================================================
off_30BBE:	index offset(*),,2
		ptr loc_30BC8					; 0
		ptr loc_30C36					; 2
		ptr loc_30C86					; 4
		ptr loc_30CAC					; 6
		ptr BranchTo_JmpTo55_DeleteObject		; 8
; ===========================================================================

loc_30BC8:
		move.l	#Map_BARZ_Pillar,ost_mappings(a0)
		move.w	#tile_Nem_ARZBoss,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#-$70,ost_mainspr_width(a0)
		move.b	#4,ost_priority(a0)
		addq.b	#2,$2A(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.w	#4,ost_y_vel(a0)
		move.b	#4,ost_frame(a0)
		addi.w	#9,ost_y_pos(a0)
		tst.b	ost_subtype(a0)
		beq.s	loc_30C28
		bset	#status_xflip_bit,ost_primary_status(a0)
		bset	#render_xflip_bit,ost_render(a0)
		move.w	#-3,ost_x_vel(a0)
		bra.s	loc_30C2E
; ===========================================================================

loc_30C28:
		move.w	#3,ost_x_vel(a0)

loc_30C2E:
		move.b	#id_col_16x1+id_col_hurt,ost_col_type(a0)
		rts
; ===========================================================================

loc_30C36:
		btst	#status_broken_bit,ost_primary_status(a0)
		beq.s	loc_30C44
		move.b	#8,$2A(a0)

loc_30C44:
		move.w	ost_x_pos(a0),d0
		add.w	ost_x_vel(a0),d0
		tst.w	ost_x_vel(a0)
		bpl.s	loc_30C5E
		cmpi.w	#$2A77,d0
		bgt.s	loc_30C7E
		move.w	#$2A77,d0
		bra.s	loc_30C68
; ===========================================================================

loc_30C5E:
		cmpi.w	#$2B49,d0
		blt.s	loc_30C7E
		move.w	#$2B49,d0

loc_30C68:
		addi_.b	#2,$2A(a0)
		move.w	d0,ost_x_pos(a0)
		move.b	#-$23,d0
		jsrto	PlaySound,JmpTo8_PlaySound
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30C7E:
		move.w	d0,ost_x_pos(a0)
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30C86:
		move.b	#0,ost_col_type(a0)
		btst	#status_broken_bit,ost_primary_status(a0)
		beq.s	loc_30C9A
		addi_.b	#2,$2A(a0)

loc_30C9A:
		bsr.w	loc_30CCC
		lea	(Ani_BARZ_Pillar).l,a1
		jsrto	AnimateSprite,JmpTo19_AnimateSprite
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

loc_30CAC:
		bsr.w	loc_30D04
		move.w	ost_y_pos(a0),d0
		add.w	ost_y_vel(a0),d0
		cmpi.w	#$4F0,d0
		bgt.w	JmpTo55_DeleteObject
		move.w	d0,ost_y_pos(a0)
		jmpto	DisplaySprite,JmpTo37_DisplaySprite
; ===========================================================================

    if RemoveJmpTos
JmpTo55_DeleteObject:
    endc

BranchTo_JmpTo55_DeleteObject:
		jmpto	DeleteObject,JmpTo55_DeleteObject
; ===========================================================================

loc_30CCC:
		tst.w	$30(a0)
		bne.s	loc_30CF4
		move.w	#$1B,d1
		move.w	#1,d2
		move.w	#2,d3
		move.w	ost_x_pos(a0),d4
		jsrto	DetectPlatform,JmpTo8_DetectPlatform
		btst	#3,ost_primary_status(a0)
		beq.s	locret_30D02
		move.w	#$1F,$30(a0)

loc_30CF4:
		subi_.w	#1,$30(a0)
		bne.s	locret_30D02
		move.b	#6,$2A(a0)

locret_30D02:
		rts
; ===========================================================================

loc_30D04:
		bclr	#3,ost_primary_status(a0)
		beq.s	loc_30D12
		lea	($FFFFB000).w,a1
		bsr.s	loc_30D1E

loc_30D12:
		bclr	#4,ost_primary_status(a0)
		beq.s	locret_30D2A
		lea	($FFFFB040).w,a1

loc_30D1E:
		bset	#1,ost_primary_status(a1)
		bclr	#3,ost_primary_status(a1)

locret_30D2A:
		rts
; ===========================================================================
Ani_BARZ_Pillar:	index offset(*)
		ptr byte_30D30					; 0
		ptr byte_30D47					; 1

byte_30D30:
		dc.b   1,  4,  6,  5,  4,  6,  4,  5,  4,  6,  4,  4,  6,  5,  4,  6 ; 0
		dc.b   4,  5,  4,  6,  4,$FD,  1		; 16

byte_30D47:
		dc.b  $F,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4 ; 0
		dc.b   4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,$F9 ; 16
		dc.b   0					; 32
; ===========================================================================

		include "mappings/sprite/ARZ Boss.asm"

; ===========================================================================

Ani_BARZ_EggPod:	index offset(*)
		ptr byte_30DD4					; 0
		ptr byte_30DEA					; 2
		ptr byte_30DEE					; 4
		ptr byte_30DF1					; 6
		ptr byte_30DFD					; 8
		ptr byte_30E00					; $A

byte_30DD4:
		dc.b   7,  0,  1,$FF,  2,  3,  2,  3,  2,  3,  2,  3,$FF,  4,  4,  4
		dc.b   4,  4,  4,  4,  4,$FF

byte_30DEA:
		dc.b   1,  6,  7,$FF

byte_30DEE:
		dc.b  $F,  9,$FF

byte_30DF1:
		dc.b   2, $A, $A, $B, $B, $B, $B, $B, $A, $A,$FD,  2

byte_30DFD:
		dc.b  $F,  8,$FF

byte_30E00:
		dc.b   7,  5,$FF,  0
; ===========================================================================

		include_ARZEggpod_Maps				; mappings/sprite/ARZ Boss.asm

; ===========================================================================

		if RemoveJmpTos=0
JmpTo37_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo55_DeleteObject:
		jmp	(DeleteObject).l
JmpTo14_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo8_PlaySound:
		jmp	(PlaySound).l
JmpTo22_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo19_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo3_RandomNumber:
		jmp	(RandomNumber).l
JmpTo8_AddPLC:
		jmp	(AddPLC).l
JmpTo5_AddPoints:
		jmp	(AddPoints).l
JmpTo4_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo4_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l
JmpTo8_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo26_SolidObject:
		jmp	(SolidObject).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 57 - MCZ boss
; ----------------------------------------------------------------------------

BossMysticCave:
		moveq	#0,d0
		move.b	ost_boss_subtype(a0),d0
		move.w	BMCZ_Index(pc,d0.w),d1
		jmp	BMCZ_Index(pc,d1.w)
; ===========================================================================
BMCZ_Index:	index offset(*),,2
		ptr loc_30FB8					; 0
		ptr loc_310BE					; 2
		ptr loc_315F2					; 4
; ===========================================================================

loc_30FB8:
		move.l	#Map_BMCZ,ost_mappings(a0)
		move.w	#tile_Nem_MCZBoss,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
	if FixBugs=0
		; Multi-sprite objects cannot use 'ost_priority' as it is
		; overwritten by 'ost_subspr3_y_pos'.
		move.b	#3,ost_priority(a0)
	endc
		move.w	#$21A0,ost_x_pos(a0)
		move.w	#$560,ost_y_pos(a0)
		move.b	#5,ost_mainspr_frame(a0)
		addq.b	#2,ost_boss_subtype(a0)
		move.b	#2,ost_boss_routine(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#4,ost_mainspr_childsprites(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_boss_hitcount2(a0)
		move.w	ost_x_pos(a0),(v_boss_x_pos).w
		move.w	ost_y_pos(a0),(v_boss_y_pos).w
		move.w	#$C0,(v_boss_y_vel).w
		move.b	#0,(v_boss_collision_routine).w
		move.b	#1,(f_screen_shake).w
		move.b	#$40,ost_mainspr_width(a0)
		move.w	ost_x_pos(a0),ost_subspr2_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr2_y_pos(a0)
		move.b	#2,ost_subspr2_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr3_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr3_y_pos(a0)
		move.b	#1,ost_subspr3_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr4_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr4_y_pos(a0)
		move.b	#$E,ost_subspr4_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr5_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr5_y_pos(a0)
		move.b	#2,ost_subspr5_frame(a0)
		subi.w	#$28,ost_subspr5_x_pos(a0)
		move.w	#$28,(v_boss_timer).w
		move.w	#-$380,$2E(a0)
		move.w	#-$380,$30(a0)
		bsr.w	loc_31090
		rts
; ===========================================================================

loc_31090:
		lea	($FFFFF740).w,a2
		move.b	#2,(a2)+
		move.b	#0,(a2)+
		move.b	#3,(a2)+
		move.b	#0,(a2)+
		move.b	#$10,(a2)+
		move.b	#0,(a2)+
		move.b	#$D,(a2)+
		move.b	#0,(a2)+
		move.b	#3,(a2)+
		move.b	#0,(a2)+
		rts
; ===========================================================================

loc_310BE:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_310CC(pc,d0.w),d1
		jmp	off_310CC(pc,d1.w)
; ===========================================================================
off_310CC:	index offset(*),,2
		ptr loc_310DA					; 0
		ptr loc_3116E					; 2
		ptr loc_311AA					; 4
		ptr loc_3124A					; 6
		ptr loc_314D2					; 8
		ptr loc_31526					; $A
		ptr loc_315A6					; $C
; ===========================================================================

loc_310DA:
		subi_.w	#1,(v_boss_timer).w
		bpl.s	loc_3112C
		move.b	#0,($FFFFF745).w
		bsr.w	BossMove
		cmpi.w	#$560,(v_boss_y_pos).w
		bgt.s	loc_3112C
		move.w	#$100,(v_boss_y_vel).w
		move.w	($FFFFB008).w,d3
		cmpi.w	#$2190,d3
		bcc.s	loc_3110A
		move.w	#$2200,d3
		bra.s	loc_3110E
; ===========================================================================

loc_3110A:
		move.w	#$2120,d3

loc_3110E:
		move.w	d3,($FFFFF750).w
		addq.b	#2,ost_boss_routine(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		move.w	($FFFFB008).w,d0
		sub.w	($FFFFF750).w,d0
		bmi.s	loc_3112C
		bset	#render_xflip_bit,ost_render(a0)

loc_3112C:
		cmpi.w	#$28,(v_boss_timer).w
		bne.s	loc_3113A
		move.b	#0,(v_boss_collision_routine).w

loc_3113A:
		cmpi.w	#$620,(v_boss_y_pos).w
		bge.s	loc_3114C
		move.b	#1,(f_screen_shake).w
		bsr.w	loc_313C6

loc_3114C:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_3143A
		lea	(Ani_BMCZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_3130A
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

loc_3116E:
		bsr.w	BossMove
		bsr.w	loc_313C6
		cmpi.w	#$620,(v_boss_y_pos).w
		blt.s	loc_31188
		addq.b	#2,ost_boss_routine(a0)
		move.b	#0,(f_screen_shake).w

loc_31188:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_3143A
		lea	(Ani_BMCZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_3130A
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

loc_311AA:
		bsr.w	BossMove
		cmpi.w	#$660,(v_boss_y_pos).w
		blt.s	loc_31228
		move.w	#$660,(v_boss_y_pos).w
		addq.b	#2,ost_boss_routine(a0)
		lea	($FFFFF740).w,a1
		andi.b	#-$10,2(a1)
		ori.b	#6,2(a1)
		andi.b	#-$10,ost_x_pos(a1)
		ori.b	#6,ost_x_pos(a1)
		andi.b	#-$10,6(a1)
		ori.b	#$D,6(a1)
		move.b	#$20,5(a1)
		move.w	#$64,(v_boss_timer).w
		move.b	#$30,1(a1)
		bclr	#render_xflip_bit,ost_render(a0)
		move.w	($FFFFB008).w,d0
		sub.w	($FFFFF750).w,d0
		bmi.s	loc_31210
		bset	#render_xflip_bit,ost_render(a0)

loc_31210:
		move.w	#-$200,(v_boss_x_vel).w
		move.w	#0,(v_boss_y_vel).w
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_31228
		neg.w	(v_boss_x_vel).w

loc_31228:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_3143A
		lea	(Ani_BMCZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_3130A

loc_31246:
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

loc_3124A:
		subi_.w	#1,(v_boss_timer).w
		cmpi.w	#$28,(v_boss_timer).w
		bgt.w	loc_312E8
		move.b	#1,(v_boss_collision_routine).w
		tst.w	(v_boss_timer).w
		bpl.w	loc_312E8

loc_31268:
		tst.b	ost_boss_hurtplayer(a0)
		beq.s	loc_31274
		sf.b	ost_boss_hurtplayer(a0)
		bra.s	loc_31298
; ===========================================================================

loc_31274:
		bsr.w	BossMove
		cmpi.w	#$2120,($FFFFF750).w
		bgt.s	loc_31288
		move.w	#$2120,($FFFFF750).w
		bra.s	loc_312A2
; ===========================================================================

loc_31288:
		cmpi.w	#$2200,($FFFFF750).w
		blt.s	loc_312E8
		move.w	#$2200,($FFFFF750).w
		bra.s	loc_312A2
; ===========================================================================

loc_31298:
		lea	($FFFFF740).w,a1
		move.b	#$30,7(a1)

loc_312A2:
		move.w	#0,(v_boss_x_vel).w
		move.b	#0,ost_boss_routine(a0)
		lea	($FFFFF740).w,a1
		andi.b	#-$10,2(a1)
		ori.b	#$B,2(a1)
		andi.b	#-$10,ost_x_pos(a1)
		ori.b	#$B,ost_x_pos(a1)
		move.b	#render_abs,ost_render(a1)
		andi.b	#-$10,6(a1)
		ori.b	#$D,6(a1)
		move.w	#$64,(v_boss_timer).w
		move.w	#-$C0,(v_boss_y_vel).w

loc_312E8:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		bsr.w	loc_3143A
		lea	(Ani_BMCZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_3130A
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

loc_3130A:
		move.w	ost_x_pos(a0),d0
		move.w	ost_y_pos(a0),d1
		move.w	d0,ost_subspr3_x_pos(a0)
		move.w	d1,ost_subspr3_y_pos(a0)
		move.w	d0,ost_subspr4_x_pos(a0)
		move.w	d1,ost_subspr4_y_pos(a0)
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_31358
		move.w	d0,ost_subspr5_x_pos(a0)
		move.w	d1,ost_subspr5_y_pos(a0)
		move.w	d0,ost_subspr2_x_pos(a0)
		move.w	d1,ost_subspr2_y_pos(a0)
		move.w	d1,$3A(a0)
		move.w	d1,$34(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_31350
		addi.w	#$28,ost_subspr5_x_pos(a0)
		rts
; ===========================================================================

loc_31350:
		subi.w	#$28,ost_subspr5_x_pos(a0)
		rts
; ===========================================================================

loc_31358:
		cmpi.w	#$78,(v_boss_timer).w
		bgt.s	locret_313C4
		subi_.w	#1,ost_subspr5_x_pos(a0)
		move.l	$3A(a0),d0
		move.w	$2E(a0),d1
		addi.w	#$38,$2E(a0)
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d0
		move.l	d0,$3A(a0)
		move.w	$3A(a0),ost_subspr5_y_pos(a0)
		cmpi.w	#$6F0,ost_subspr5_y_pos(a0)
		blt.s	loc_31392
		move.w	#0,$2E(a0)

loc_31392:
		addi_.w	#1,ost_subspr2_x_pos(a0)
		move.l	$34(a0),d0
		move.w	$30(a0),d1
		addi.w	#$38,$30(a0)
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d0
		move.l	d0,$34(a0)
		move.w	$34(a0),ost_subspr2_y_pos(a0)
		cmpi.w	#$6F0,ost_subspr2_y_pos(a0)
		blt.s	locret_313C4
		move.w	#0,$30(a0)

locret_313C4:
		rts
; ===========================================================================

loc_313C6:
		move.b	(v_vblank_counter_byte).w,d1
		sf.b	d2
		andi.b	#$1F,d1
		beq.s	loc_313DA
		andi.b	#7,d1
		bne.s	locret_31438
		st.b	d2

loc_313DA:
		jsrto	RandomNumber,JmpTo4_RandomNumber
		swap	d1
		andi.w	#$1FF,d1
		addi.w	#$20F0,d1
		cmpi.w	#$2230,d1
		bgt.s	loc_313DA
		jsrto	FindFreeObj,JmpTo15_FindFreeObj
		bne.s	locret_31438
		move.b	#id_BossMysticCave,ost_id(a1)
		move.b	#4,ost_boss_subtype(a1)
		move.w	d1,ost_x_pos(a1)
		move.w	#$5F0,ost_y_pos(a1)
		move.l	#Map_BMCZ,ost_mappings(a1)
		move.w	#vram_FallingRocks/sizeof_cell,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		move.b	#$D,ost_frame(a1)
		tst.b	d2
		bne.s	locret_31438
		move.b	#$14,ost_frame(a1)
		move.b	#id_col_2x8+id_col_hurt,ost_col_type(a1)

locret_31438:
		rts
; ===========================================================================

loc_3143A:
		bsr.w	loc_31470
		cmpi.b	#$1F,ost_boss_flash_time(a0)
		bne.s	locret_31450
		lea	($FFFFF740).w,a1
		move.b	#-$40,7(a1)

locret_31450:
		rts
; ===========================================================================

loc_31452:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	(v_boss_y_pos).w,d0
		move.w	d0,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		addq.b	#2,ost_boss_wobble(a0)

loc_31470:
		cmpi.b	#8,ost_boss_routine(a0)
		bcc.s	locret_314B6
		tst.b	ost_boss_hitcount2(a0)
		beq.s	loc_314B8
		tst.b	ost_col_type(a0)
		bne.s	locret_314B6
		tst.b	ost_boss_flash_time(a0)
		bne.s	loc_3149A
		move.b	#$20,ost_boss_flash_time(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_3149A:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_314A8
		move.w	#$EEE,d0

loc_314A8:
		move.w	d0,(a1)
		subq.b	#1,ost_boss_flash_time(a0)
		bne.s	locret_314B6
		move.b	#id_col_24x24,ost_col_type(a0)

locret_314B6:
		rts
; ===========================================================================

loc_314B8:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo6_AddPoints
		move.w	#$B3,(v_boss_timer).w
		move.b	#8,ost_boss_routine(a0)
		moveq	#$40,d0
		jsrto	AddPLC,JmpTo9_AddPLC
		rts
; ===========================================================================

loc_314D2:
		st.b	ost_boss_defeated(a0)
		move.b	#0,(f_screen_shake).w
		subq.w	#1,(v_boss_timer).w
		bmi.s	loc_314F4
		move.b	#$13,ost_subspr4_frame(a0)
		move.b	#7,ost_mainspr_frame(a0)
		bsr.w	BossExplode
		bra.s	loc_31512
; ===========================================================================

loc_314F4:
		bset	#render_xflip_bit,ost_render(a0)
		clr.w	(v_boss_x_vel).w
		clr.w	(v_boss_y_vel).w
		addq.b	#2,ost_boss_routine(a0)
		move.b	#$12,ost_subspr4_frame(a0)
		move.w	#-$12,(v_boss_timer).w

loc_31512:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_3130A
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

loc_31526:
		addq.w	#1,(v_boss_timer).w
		beq.s	loc_31542
		bpl.s	loc_31548
		cmpi.w	#$620,(v_boss_y_pos).w
		bcc.s	loc_3153A
		subq.w	#1,(v_boss_timer).w

loc_3153A:
		addi.w	#$10,(v_boss_y_vel).w
		bra.s	loc_3158A
; ===========================================================================

loc_31542:
		clr.w	(v_boss_y_vel).w
		bra.s	loc_3158A
; ===========================================================================

loc_31548:
		cmpi.w	#$18,(v_boss_timer).w
		bcs.s	loc_31576
		beq.s	loc_3157E
		cmpi.w	#$20,(v_boss_timer).w
		bcs.s	loc_3158A
		lea	(v_boss_anim_array).w,a1
		move.b	#$D,7(a1)
	if FixBugs
		move.b	#2,(a1)
    else
		; This should be 'a1' instead of 'a2'. A random part of RAM gets
		; written to instead.
		_move.b	#2,0(a2)
	endc
		move.b	#0,1(a1)
		addq.b	#2,ost_boss_routine(a0)
		bra.s	loc_3158A
; ===========================================================================

loc_31576:
		subi_.w	#8,(v_boss_y_vel).w
		bra.s	loc_3158A
; ===========================================================================

loc_3157E:
		clr.w	(v_boss_y_vel).w
		jsrto	RestoreLevelMusic,JmpTo5_RestoreLevelMusic
		jsrto	LoadAnimalExplosionArt,JmpTo5_LoadAnimalExplosionArt

loc_3158A:
		bsr.w	BossMove
		bsr.w	loc_31452
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_3130A
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

loc_315A6:
		move.w	#$400,(v_boss_x_vel).w
		move.w	#-$40,(v_boss_y_vel).w
		cmpi.w	#$2240,(v_boundary_right).w
		beq.s	loc_315C0
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_315C6
; ===========================================================================

loc_315C0:
		tst.b	ost_render(a0)
		bpl.s	JmpTo56_DeleteObject

loc_315C6:
		bsr.w	BossMove
		bsr.w	loc_31452
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		lea	(Ani_BMCZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_3130A
		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================

JmpTo56_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================

loc_315F2:
		jsrto	ObjectFall,JmpTo5_ObjectFall
		subi.w	#$28,ost_subspr2_y_pos(a0)
		cmpi.w	#$6F0,ost_y_pos(a0)

	if RemoveJmpTos
		bgt.s	JmpTo56_DeleteObject
	else
		bgt.w	JmpTo57_DeleteObject
	endc

		jmpto	DisplaySprite,JmpTo38_DisplaySprite
; ===========================================================================
Ani_BMCZ:	index offset(*)
		ptr byte_31628					; 0
		ptr byte_3162E					; 1
		ptr byte_31631					; 2
		ptr byte_31638					; 3
		ptr byte_31649					; 4
		ptr byte_3165A					; 5
		ptr byte_31661					; 6
		ptr byte_31673					; 7
		ptr byte_31684					; 8
		ptr byte_31695					; 9
		ptr byte_316A6					; 10
		ptr byte_316AD					; 11
		ptr byte_316BF					; 12
		ptr byte_316D1					; 13
		ptr byte_316E8					; 14

byte_31628:
		dc.b  $F,  1,$FF,  0,$FC,  2
		rev02even

byte_3162E:
		dc.b   5,  8,$FF
		rev02even

byte_31631:
		dc.b   1,  5,  6,$FF,  7,$FC,  3
		rev02even

byte_31638:
		dc.b   1,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,  4,  4,  4,$FD
		dc.b   4
		rev02even

byte_31649:
		dc.b   1,  2,  2,  2,  2,  3,  3,  3,  4,  4,  4,  2,  2,  3,  3,$FD
		dc.b   5
		rev02even

byte_3165A:
		dc.b   1,  4,  2,  3,  4,$FC,  1
		rev02even

byte_31661:
		dc.b   1,  2,  3,  4,  4,  2,  2,  3,  3,  3,  4,  4,  4,  2,  2,  2
		dc.b $FD,  7
		rev02even

byte_31673:
		dc.b   1,  2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  2,  8,  8,  8,$FD
		dc.b   8
		rev02even

byte_31684:
		dc.b   1,  9,  9,  9,  9,  9, $A, $A, $A, $A, $A, $B, $B, $B, $B,$FD
		dc.b   9
		rev02even

byte_31695:
		dc.b   1,  9,  9,  9,  9, $A, $A, $A, $B, $B, $B,  9,  9, $A, $A,$FD
		dc.b  $A
		rev02even

byte_316A6:
		dc.b   1, $B,  9, $A, $B,$FC,  1
		rev02even

byte_316AD:
		dc.b   1,  9, $A, $B, $B,  9,  9, $A, $A, $A, $B, $B, $B,  9,  9,  9
		dc.b $FD, $C
		rev02even

byte_316BF:
		dc.b   1,  9, $A, $A, $A, $A, $B, $B, $B, $B, $B,  9,  8,  8,  8,  8
		dc.b $FD,  3
		rev02even

byte_316D1:
		dc.b   7, $E, $F,$FF,$10,$11,$10,$11,$10,$11,$10,$11,$FF,$12,$12,$12
		dc.b $12,$12,$12,$12,$12,$12,$FF
		rev02even

byte_316E8:
		dc.b   7,$12,$FF
		even

; ===========================================================================

		include "mappings/sprite/MCZ Boss.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo38_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo57_DeleteObject:
		jmp	(DeleteObject).l
JmpTo15_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo4_RandomNumber:
		jmp	(RandomNumber).l
JmpTo9_AddPLC:
		jmp	(AddPLC).l
JmpTo6_AddPoints:
		jmp	(AddPoints).l
JmpTo5_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo5_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l
JmpTo5_ObjectFall:
		jmp	(ObjectFall).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 51 - CNZ boss
; ----------------------------------------------------------------------------

BossCasinoNight:
		moveq	#0,d0
		move.b	ost_boss_subtype(a0),d0
		move.w	BCNZ_Index(pc,d0.w),d1
		jmp	BCNZ_Index(pc,d1.w)
; ===========================================================================
BCNZ_Index:	index offset(*),,2
		ptr loc_31904					; 0
		ptr loc_31A04					; 2
		ptr loc_31F24					; 4
; ===========================================================================

loc_31904:
		move.l	#Map_BCNZ,ost_mappings(a0)
		move.w	#tile_Nem_CNZBoss-$60,ost_tile(a0)	; (badly) reused mappings
		ori.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.w	#$2A46,ost_x_pos(a0)
		move.w	#$654,ost_y_pos(a0)
		move.b	#0,ost_mainspr_frame(a0)
		move.b	#$20,ost_mainspr_width(a0)
	if FixBugs=0
		; This instruction is pointless, as render_useheight_bit of 'ost_render'
		; is not set for this object. Also, it clashes with 'ost_boss_flash_time',
		; as they use the same OST slot. Consequently, on the first hit,
		; loc_31CDC behaves as if the boss is already invulnerable, leading to
		; several incorrect behaviors: no hit sound plays, the boss is
		; invulnerable for 128 frames instead of 48, and Eggman takes a while
		; to react and show his hurt face.
		move.b	#$80,ost_mainspr_height(a0)
	endc
		addq.b	#2,ost_boss_subtype(a0)
		move.b	#0,ost_boss_routine(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#4,ost_mainspr_childsprites(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_boss_hitcount2(a0)
		move.w	ost_x_pos(a0),(v_boss_x_pos).w
		move.w	ost_y_pos(a0),(v_boss_y_pos).w
		move.w	ost_x_pos(a0),ost_subspr2_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr2_y_pos(a0)
		move.b	#5,ost_subspr2_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr3_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr3_y_pos(a0)
		move.b	#1,ost_subspr3_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr4_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr4_y_pos(a0)
		move.b	#6,ost_subspr4_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr5_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr5_y_pos(a0)
		move.b	#2,ost_subspr5_frame(a0)
		move.b	#0,$38(a0)
		move.w	#0,(v_boss_y_vel).w
		move.w	#-$180,(v_boss_x_vel).w
		move.b	#0,$2D(a0)
		move.w	#1,(v_boss_timer).w
		bsr.w	loc_319D6
		rts
; ===========================================================================

loc_319D6:
		lea	(v_boss_anim_array).w,a2
		move.b	#8,(a2)+
		move.b	#0,(a2)+
		move.b	#1,(a2)+
		move.b	#0,(a2)+
		move.b	#$10,(a2)+
		move.b	#0,(a2)+
		move.b	#3,(a2)+
		move.b	#0,(a2)+
		move.b	#2,(a2)+
		move.b	#0,(a2)+
		rts
; ===========================================================================

loc_31A04:
		tst.b	(v_boss_collision_routine).w
		beq.s	loc_31A1C
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_31A1C
		move.b	#-$30,d0
		jsrto	PlaySound,JmpTo9_PlaySound

loc_31A1C:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_31A2A(pc,d0.w),d1
		jmp	off_31A2A(pc,d1.w)
; ===========================================================================
off_31A2A:	index offset(*),,2
		ptr loc_31A36					; 0
		ptr loc_31BA8					; 2
		ptr loc_31C22					; 4
		ptr loc_31D5C					; 6
		ptr loc_31DCC					; 8
		ptr loc_31E2A					; $A
; ===========================================================================

loc_31A36:
		moveq	#0,d0
		move.b	$38(a0),d0
		move.w	off_31A44(pc,d0.w),d0
		jmp	off_31A44(pc,d0.w)
; ===========================================================================
off_31A44:	index offset(*),,2
		ptr loc_31A48					; 0
		ptr loc_31A78					; 2
; ===========================================================================

loc_31A48:
		cmpi.w	#$28C0,(v_boss_x_pos).w
		bgt.s	loc_31A74
		move.w	#$28C0,(v_boss_x_pos).w
		move.w	#0,(v_boss_y_vel).w
		move.w	#$180,(v_boss_x_vel).w
		move.b	#2,$38(a0)
		bset	#render_xflip_bit,ost_render(a0)
		move.b	#0,$2D(a0)

loc_31A74:
		bra.w	loc_31AA4
; ===========================================================================

loc_31A78:
		cmpi.w	#$29C0,(v_boss_x_pos).w
		blt.s	loc_31AA4
		move.w	#$29C0,(v_boss_x_pos).w
		move.w	#0,(v_boss_y_vel).w
		move.w	#-$180,(v_boss_x_vel).w
		move.b	#0,$38(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		move.b	#0,$2D(a0)

loc_31AA4:
		bsr.w	BossMove
		tst.b	$3F(a0)
		beq.s	loc_31AB6
		subq.b	#1,$3F(a0)
		bra.w	loc_31B46
; ===========================================================================

loc_31AB6:
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$10,d0
		cmpi.w	#$20,d0
		bcc.s	loc_31B46
		cmpi.w	#$6B0,($FFFFB00C).w
		bcs.s	loc_31B06
		cmpi.b	#3,$2D(a0)
		bcc.s	loc_31B46
		addq.b	#1,$2D(a0)
		addq.b	#2,ost_boss_routine(a0)
		move.b	#8,($FFFFF740).w
		move.b	#0,($FFFFF743).w
		move.b	#0,($FFFFF749).w
		move.b	#0,(v_boss_collision_routine).w
		bsr.w	loc_31BF2
		move.w	#$50,(v_boss_timer).w
		bra.w	loc_31C08
; ===========================================================================

loc_31B06:
		cmpi.w	#$67C,($FFFFB00C).w
		bcs.s	loc_31B46
		move.b	#$F,ost_mainspr_frame(a0)
		move.b	#2,(v_boss_collision_routine).w
		move.b	#$20,($FFFFF743).w
		move.b	#$20,($FFFFF749).w
		move.b	#9,($FFFFF740).w
		addq.b	#4,ost_boss_routine(a0)
		move.w	#0,(v_boss_x_vel).w
		move.w	#$180,(v_boss_y_vel).w
		move.b	#0,$3E(a0)
		bra.w	loc_31C08
; ===========================================================================

loc_31B46:
		bra.w	*+4					; pointless
		addi_.w	#1,(v_boss_timer).w
		move.w	(v_boss_timer).w,d0
		andi.w	#$3F,d0
		bne.w	loc_31C08
		btst	#6,($FFFFF75D).w
		beq.s	loc_31B86
		move.b	#$F,ost_mainspr_frame(a0)
		move.b	#2,(v_boss_collision_routine).w
		move.b	#$20,($FFFFF743).w
		move.b	#$20,($FFFFF749).w
		move.b	#9,($FFFFF740).w
		bra.w	loc_31C08
; ===========================================================================

loc_31B86:
		move.b	#$C,ost_mainspr_frame(a0)
		move.b	#1,(v_boss_collision_routine).w
		move.b	#0,($FFFFF743).w
		move.b	#0,($FFFFF749).w
		move.b	#4,($FFFFF740).w
		bra.w	loc_31C08
; ===========================================================================

loc_31BA8:
		move.b	#0,(v_boss_collision_routine).w
		subi_.w	#1,(v_boss_timer).w
		bne.s	loc_31BC6
		move.b	#$20,($FFFFF743).w
		move.b	#$20,($FFFFF749).w
		bra.w	loc_31C08
; ===========================================================================

loc_31BC6:
		cmpi.w	#-$14,(v_boss_timer).w
		bgt.w	loc_31C08
		move.b	#0,($FFFFF743).w
		move.b	#0,($FFFFF749).w
		move.b	#0,ost_boss_routine(a0)
		move.w	#-1,(v_boss_timer).w
		move.b	#$40,$3F(a0)
		bra.w	loc_31C08
; ===========================================================================

loc_31BF2:
		jsrto	FindFreeObj,JmpTo16_FindFreeObj
		bne.s	locret_31C06
		move.b	#id_BossCasinoNight,ost_id(a1)
		move.b	#4,ost_boss_subtype(a1)
		move.l	a0,$34(a1)

locret_31C06:
		rts
; ===========================================================================

loc_31C08:
		bsr.w	loc_31CDC
		bsr.w	loc_31E76
		bsr.w	loc_31C92
		lea	(Ani_BCNZ).l,a1
		bsr.w	BossAnimate

	if RemoveJmpTos&(FixBugs=0)
	; This has to be moved so that it doesn't point to 'DisplaySprite3'.
JmpTo39_DisplaySprite:
	endc

	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*3,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo39_DisplaySprite
	endc
; ===========================================================================

loc_31C22:
		bsr.w	BossMove
		tst.b	$3E(a0)
		bne.s	loc_31C60
		cmpi.w	#$680,ost_y_pos(a0)
		bcs.s	loc_31C08
		move.w	#0,(v_boss_x_vel).w
		move.w	#-$180,(v_boss_y_vel).w
		move.b	#-1,$3E(a0)
		move.b	#1,(v_boss_collision_routine).w
		move.b	#0,($FFFFF743).w
		move.b	#0,($FFFFF749).w
		move.b	#4,($FFFFF740).w
		bra.s	loc_31C08
; ===========================================================================

loc_31C60:
		cmpi.w	#$654,ost_y_pos(a0)
		bcc.s	loc_31C08
		move.b	#0,ost_boss_routine(a0)
		move.w	#0,(v_boss_y_vel).w
		move.w	#-$180,(v_boss_x_vel).w
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_31C8E
		move.w	#$180,(v_boss_x_vel).w
		move.b	#$C,ost_mainspr_frame(a0)

loc_31C8E:
		bra.w	loc_31C08
; ===========================================================================

loc_31C92:
		cmpi.b	#48-1,ost_boss_flash_time(a0)
		bne.s	loc_31CAC
		lea	($FFFFF740).w,a1
		andi.b	#-$10,6(a1)
		ori.b	#6,6(a1)
		rts
; ===========================================================================

loc_31CAC:
		cmpi.b	#4,($FFFFB024).w
		beq.s	loc_31CBC
		cmpi.b	#4,($FFFFB064).w
		bne.s	locret_31CDA

loc_31CBC:
		lea	($FFFFF740).w,a1
		move.b	6(a1),d0
		andi.b	#$F,d0
		cmpi.b	#6,d0
		beq.s	locret_31CDA
		andi.b	#-$10,6(a1)
		ori.b	#5,6(a1)

locret_31CDA:
		rts
; ===========================================================================

loc_31CDC:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	(v_boss_y_pos).w,d0
		move.w	d0,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		addq.b	#2,ost_boss_wobble(a0)
		cmpi.b	#6,ost_boss_routine(a0)
		bcc.s	locret_31D40
		tst.b	ost_boss_hitcount2(a0)
		beq.s	loc_31D42
		tst.b	ost_col_type(a0)
		bne.s	locret_31D40
		tst.b	ost_boss_flash_time(a0)
		bne.s	loc_31D24
		move.b	#48,ost_boss_flash_time(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_31D24:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_31D32
		move.w	#$EEE,d0

loc_31D32:
		move.w	d0,(a1)
		subq.b	#1,ost_boss_flash_time(a0)
		bne.s	locret_31D40
		move.b	#id_col_24x24,ost_col_type(a0)

locret_31D40:
		rts
; ===========================================================================

loc_31D42:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo7_AddPoints
		move.w	#$B3,(v_boss_timer).w
		move.b	#6,ost_boss_routine(a0)
		moveq	#$40,d0
		jsrto	AddPLC,JmpTo10_AddPLC
		rts
; ===========================================================================

loc_31D5C:
		st.b	ost_boss_defeated(a0)
		subq.w	#1,(v_boss_timer).w
		bmi.s	loc_31D7E
		move.b	#0,(v_boss_collision_routine).w
		move.b	#0,ost_mainspr_frame(a0)
		move.b	#$B,ost_col_property(a0)
		bsr.w	BossExplode
		bra.s	loc_31DB8
; ===========================================================================

loc_31D7E:
		bset	#render_xflip_bit,ost_render(a0)
		clr.w	(v_boss_x_vel).w
		clr.w	(v_boss_y_vel).w
		addq.b	#2,ost_boss_routine(a0)
		lea	($FFFFF740).w,a1
		andi.b	#-$10,6(a1)
		ori.b	#3,6(a1)
		_move.b	#8,0(a1)
		move.b	#-$23,($FFFF8C54).w
		move.b	#1,(f_screen_redraw).w
		move.w	#-$12,(v_boss_timer).w

loc_31DB8:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_31E76

	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*3,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo39_DisplaySprite
	endc
; ===========================================================================

loc_31DCC:
		addq.w	#1,(v_boss_timer).w
		beq.s	loc_31DDC
		bpl.s	loc_31DE2
		addi.w	#$18,(v_boss_y_vel).w
		bra.s	loc_31E0E
; ===========================================================================

loc_31DDC:
		clr.w	(v_boss_y_vel).w
		bra.s	loc_31E0E
; ===========================================================================

loc_31DE2:
		cmpi.w	#$18,(v_boss_timer).w
		bcs.s	loc_31DFA
		beq.s	loc_31E02
		cmpi.w	#$20,(v_boss_timer).w
		bcs.s	loc_31E0E
		addq.b	#2,ost_boss_routine(a0)
		bra.s	loc_31E0E
; ===========================================================================

loc_31DFA:
		subi_.w	#8,(v_boss_y_vel).w
		bra.s	loc_31E0E
; ===========================================================================

loc_31E02:
		clr.w	(v_boss_y_vel).w
		jsrto	RestoreLevelMusic,JmpTo6_RestoreLevelMusic
		jsrto	LoadAnimalExplosionArt,JmpTo6_LoadAnimalExplosionArt

loc_31E0E:
		bsr.w	BossMove
		bsr.w	loc_31CDC
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_31E76
	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*3,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo39_DisplaySprite
	endc
; ===========================================================================

loc_31E2A:
		move.w	#$400,(v_boss_x_vel).w
		move.w	#-$40,(v_boss_y_vel).w
		cmpi.w	#$2B20,(v_boundary_right).w
		beq.s	loc_31E44
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_31E4A
; ===========================================================================

loc_31E44:
		tst.b	ost_render(a0)
		bpl.s	JmpTo58_DeleteObject

loc_31E4A:
		bsr.w	BossMove
		bsr.w	loc_31CDC
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_31E76
		lea	(Ani_BCNZ).l,a1
		bsr.w	BossAnimate
	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*3,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo39_DisplaySprite
	endc
; ===========================================================================

    if RemoveJmpTos
JmpTo59_DeleteObject:
    endc

JmpTo58_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================

loc_31E76:
		move.w	ost_x_pos(a0),d0
		move.w	ost_y_pos(a0),d1
		move.w	d0,ost_subspr3_x_pos(a0)
		move.w	d1,ost_subspr3_y_pos(a0)
		move.w	d0,ost_subspr4_x_pos(a0)
		move.w	d1,ost_subspr4_y_pos(a0)
		tst.b	ost_boss_defeated(a0)
		bne.s	loc_31EAE
		move.w	d0,ost_subspr5_x_pos(a0)
		move.w	d1,ost_subspr5_y_pos(a0)
		move.w	d0,ost_subspr2_x_pos(a0)
		move.w	d1,ost_subspr2_y_pos(a0)
		move.w	d1,$3A(a0)
		move.w	d1,$34(a0)
		rts
; ===========================================================================

loc_31EAE:
		cmpi.w	#$78,(v_boss_timer).w
		bgt.s	locret_31F22
		subi_.w	#1,ost_subspr5_x_pos(a0)
		move.l	$3A(a0),d0
		move.w	$2E(a0),d1
		addi.w	#$38,$2E(a0)
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d0
		move.l	d0,$3A(a0)
		move.w	$3A(a0),ost_subspr5_y_pos(a0)
		cmpi.w	#$6F0,ost_subspr5_y_pos(a0)
		blt.s	loc_31EE8
		move.w	#0,$2E(a0)

loc_31EE8:
		cmpi.w	#$3C,(v_boss_timer).w
		bgt.s	locret_31F22
		addi_.w	#1,ost_subspr2_x_pos(a0)
		move.l	$34(a0),d0
		move.w	$30(a0),d1
		addi.w	#$38,$30(a0)
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d0
		move.l	d0,$34(a0)
		move.w	$34(a0),ost_subspr2_y_pos(a0)
		cmpi.w	#$6F0,ost_subspr2_y_pos(a0)
		blt.s	locret_31F22
		move.w	#0,$30(a0)

locret_31F22:
		rts
; ===========================================================================

loc_31F24:
		movea.l	$34(a0),a1
		cmpi.b	#6,ost_boss_routine(a1)
		bcc.w	JmpTo59_DeleteObject
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_31F40(pc,d0.w),d1
		jmp	off_31F40(pc,d1.w)
; ===========================================================================
off_31F40:	index offset(*),,2
		ptr loc_31F48					; 0
		ptr loc_31F96					; 2
		ptr loc_31FDC					; 4
		ptr loc_32080					; 6
; ===========================================================================

loc_31F48:
		move.l	#Map_BCNZ,ost_mappings(a0)
		move.w	#tile_Nem_CNZBoss-$60,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#7,ost_priority(a0)
		addq.b	#2,ost_secondary_routine(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addi.w	#$30,ost_y_pos(a0)
		move.b	#8,ost_height(a0)
		move.b	#8,ost_width(a0)
		move.b	#$12,ost_boss_wobble(a0)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a0)
		rts
; ===========================================================================

loc_31F96:
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.w	$28(a0),d0
		add.w	d0,ost_y_pos(a0)
		addi_.w	#1,d0
		cmpi.w	#$2E,d0
		blt.s	loc_31FBC
		move.w	#$2E,d0

loc_31FBC:
		move.w	d0,$28(a0)
		tst.w	(v_boss_timer).w
		bne.w	JmpTo39_DisplaySprite
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_y_vel(a0)

	if RemoveJmpTos&FixBugs
	; This has to be moved so that it doesn't point to 'DisplaySprite3'.
JmpTo39_DisplaySprite:
	endc

		jmpto	DisplaySprite,JmpTo39_DisplaySprite
; ===========================================================================

loc_31FDC:
		bsr.w	loc_31FF8
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.w	JmpTo39_DisplaySprite
		add.w	d1,ost_y_pos(a0)
		bsr.w	loc_32030
		jmpto	DisplaySprite,JmpTo39_DisplaySprite
; ===========================================================================

loc_31FF8:
		moveq	#0,d2
		move.w	ost_x_pos(a0),d2
		swap	d2
		moveq	#0,d3

loc_32002:
		move.w	ost_y_pos(a0),d3
		swap	d3
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		addi.w	#$38,ost_y_vel(a0)
		swap	d2
		move.w	d2,ost_x_pos(a0)
		swap	d3
		move.w	d3,ost_y_pos(a0)
		rts
; ===========================================================================

loc_32030:
		move.b	#-$3C,d0
		jsrto	PlaySound,JmpTo9_PlaySound
		move.w	#tile_Nem_CNZBoss-$60,ost_tile(a0)
		move.b	#7,ost_anim(a0)
		move.w	#-$300,ost_y_vel(a0)
		move.w	#-$100,ost_x_vel(a0)
		move.b	#4,ost_boss_subtype(a0)
		move.b	#6,ost_secondary_routine(a0)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a0)
		jsrto	FindNextFreeObj,JmpTo23_FindNextFreeObj
		bne.s	locret_3207E
		moveq	#0,d0
		move.w	#$F,d1

loc_3206E:
		move.l	(a0,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_3206E
		neg.w	ost_x_vel(a1)

locret_3207E:
		rts
; ===========================================================================

loc_32080:
		bsr.w	loc_31FF8
		lea	(Ani_BCNZ).l,a1
		jsrto	AnimateSprite,JmpTo20_AnimateSprite
		cmpi.w	#$705,ost_y_pos(a0)
		bcs.w	JmpTo39_DisplaySprite
		jmpto	JmpTo59_DeleteObject,JmpTo59_DeleteObject
; ===========================================================================
Ani_BCNZ:	index offset(*)
		ptr byte_320B0					; 0
		ptr byte_320B3					; 1
		ptr byte_320B9					; 2
		ptr byte_320BF					; 3
		ptr byte_320C3					; 4
		ptr byte_320C8					; 5
		ptr byte_320D3					; 6
		ptr byte_320DD					; 7
		ptr byte_320E1					; 8
		ptr byte_320E4					; 9

byte_320B0:
		dc.b  $F,  1,$FF
		rev02even

byte_320B3:
		dc.b  $F,  4,$FF,  5,$FC,  2
		rev02even

byte_320B9:
		dc.b  $F,  2,$FF,  3,$FC,  2
		rev02even

byte_320BF:
		dc.b   7,  6,  7,$FF
		rev02even

byte_320C3:
		dc.b   1, $C, $D, $E,$FF
		rev02even

byte_320C8:
		dc.b   7,  8,  9,  8,  9,  8,  9,  8,  9,$FD,  3
		rev02even

byte_320D3:
		dc.b   7, $A, $A, $A, $A, $A, $A, $A,$FD,  3
		rev02even

byte_320DD:
		dc.b   3,$13,$14,$FF
		rev02even

byte_320E1:
		dc.b   1,  0,$FF
		rev02even

byte_320E4:
		dc.b   1, $F,$10,$11,$FF
		even

; ===========================================================================

		include "mappings/sprite/CNZ Boss.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo39_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo59_DeleteObject:
		jmp	(DeleteObject).l
JmpTo16_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo9_PlaySound:
		jmp	(PlaySound).l
JmpTo23_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo20_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo10_AddPLC:
		jmp	(AddPLC).l
JmpTo7_AddPoints:
		jmp	(AddPoints).l
JmpTo6_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo6_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 54 - MTZ boss
; ----------------------------------------------------------------------------

BossMetropolis:
		moveq	#0,d0
		move.b	ost_boss_subtype(a0),d0
		move.w	BMTZ_Index(pc,d0.w),d1
		jmp	BMTZ_Index(pc,d1.w)
; ===========================================================================
BMTZ_Index:	index offset(*),,2
		ptr loc_3229E					; 0
		ptr loc_323BA					; 2
		ptr loc_32CAE					; 4
		ptr loc_32D48					; 6
; ===========================================================================

loc_3229E:
		move.l	#Map_BMTZ,ost_mappings(a0)
		move.w	#$37C,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.w	#$2B50,ost_x_pos(a0)
		move.w	#$380,ost_y_pos(a0)
		move.b	#2,ost_mainspr_frame(a0)
		addq.b	#2,ost_boss_subtype(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#2,ost_mainspr_childsprites(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_boss_hitcount2(a0)
		move.b	#7,$3E(a0)
		move.w	ost_x_pos(a0),(v_boss_x_pos).w
		move.w	ost_y_pos(a0),(v_boss_y_pos).w
		move.w	#0,(v_boss_x_vel).w
		move.w	#$100,(v_boss_y_vel).w
		move.b	#$20,ost_mainspr_width(a0)
		clr.b	$2B(a0)
		clr.b	$2C(a0)
		move.b	#$40,ost_boss_wobble(a0)
		move.b	#$27,$33(a0)
		move.b	#$27,$39(a0)
		move.w	ost_x_pos(a0),ost_subspr2_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr2_y_pos(a0)
		move.b	#$C,ost_subspr2_frame(a0)
		move.w	ost_x_pos(a0),ost_subspr3_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr3_y_pos(a0)
		move.b	#0,ost_subspr3_frame(a0)
		jsrto	FindFreeObj,JmpTo17_FindFreeObj
		bne.s	loc_3239C
		move.b	#id_BossMetropolis,ost_id(a1)
		move.b	#6,ost_boss_subtype(a1)
		move.b	#$13,ost_frame(a1)
		move.l	#Map_BMTZ,ost_mappings(a1)
		move.w	#tile_Nem_MTZBoss,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#6,ost_priority(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	a0,$34(a1)
		move.b	#$20,ost_displaywidth(a1)
		jsrto	FindFreeObj,JmpTo17_FindFreeObj
		bne.s	loc_3239C
		move.b	#id_BossMetropolisOrb,ost_id(a1)
		move.l	a0,$34(a1)

loc_3239C:
		lea	($FFFFF740).w,a2
		move.b	#$10,(a2)+
		move.b	#0,(a2)+
		move.b	#3,(a2)+
		move.b	#0,(a2)+
		move.b	#1,(a2)+
		move.b	#0,(a2)+
		rts
; ===========================================================================

loc_323BA:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_323C8(pc,d0.w),d1
		jmp	off_323C8(pc,d1.w)
; ===========================================================================
off_323C8:	index offset(*),,2
		ptr loc_323DC					; 0
		ptr loc_32456					; 2
		ptr loc_324DC					; 4
		ptr loc_32524					; 6
		ptr loc_32544					; 8
		ptr loc_32574					; $A
		ptr loc_325BE					; $C
		ptr loc_3262E					; $E
		ptr loc_32802					; $10
		ptr loc_32864					; $12
; ===========================================================================

loc_323DC:
		bsr.w	BossMove
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		cmpi.w	#$4A0,(v_boss_y_pos).w
		bcs.s	loc_32426
		addq.b	#2,ost_boss_routine(a0)
		move.w	#0,(v_boss_y_vel).w
		move.w	#-$100,(v_boss_x_vel).w
		bclr	#7,$2B(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		move.w	($FFFFB008).w,d0
		cmp.w	($FFFFF750).w,d0
		bcs.s	loc_32426
		move.w	#$100,(v_boss_x_vel).w
		bset	#7,$2B(a0)
		bset	#render_xflip_bit,ost_render(a0)

loc_32426:
		bsr.w	loc_3278E
		lea	(Ani_BMTZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_32774
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_3243C:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	(v_boss_y_pos).w,d0
		move.w	d0,ost_y_pos(a0)
		addq.b	#4,ost_boss_wobble(a0)
		rts
; ===========================================================================

loc_32456:
		bsr.w	BossMove
		btst	#7,$2B(a0)
		bne.s	loc_32490
		cmpi.w	#$2AD0,($FFFFF750).w
		bcc.s	loc_324BC
		bchg	#7,$2B(a0)
		move.w	#$100,(v_boss_x_vel).w
		bset	#render_xflip_bit,ost_render(a0)
		bset	#6,$2B(a0)
		beq.s	loc_324BC
		addq.b	#2,ost_boss_routine(a0)
		move.w	#-$100,(v_boss_y_vel).w
		bra.s	loc_324BC
; ===========================================================================

loc_32490:
		cmpi.w	#$2BD0,($FFFFF750).w
		bcs.s	loc_324BC
		bchg	#7,$2B(a0)
		move.w	#-$100,(v_boss_x_vel).w
		bclr	#render_xflip_bit,ost_render(a0)
		bset	#6,$2B(a0)
		beq.s	loc_324BC
		addq.b	#2,ost_boss_routine(a0)
		move.w	#-$100,(v_boss_y_vel).w

loc_324BC:
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_3243C

loc_324C6:
		bsr.w	loc_3278E
		lea	(Ani_BMTZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_32774
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_324DC:
		bsr.w	BossMove
		cmpi.w	#$470,(v_boss_y_pos).w
		bcc.s	loc_324EE
		move.w	#0,(v_boss_y_vel).w

loc_324EE:
		btst	#7,$2B(a0)
		bne.s	loc_32506
		cmpi.w	#$2B50,(v_boss_x_pos).w
		bcc.s	loc_32514
		move.w	#0,(v_boss_x_vel).w
		bra.s	loc_32514
; ===========================================================================

loc_32506:
		cmpi.w	#$2B50,($FFFFF750).w
		bcs.s	loc_32514
		move.w	#0,(v_boss_x_vel).w

loc_32514:
		move.w	(v_boss_x_vel).w,d0
		or.w	(v_boss_y_vel).w,d0
		bne.s	loc_32522
		addq.b	#2,ost_boss_routine(a0)

loc_32522:
		bra.s	loc_324BC
; ===========================================================================

loc_32524:
		cmpi.b	#$68,$33(a0)
		bcc.s	loc_32536
		addq.b	#1,$33(a0)
		addq.b	#1,$39(a0)
		bra.s	loc_32540
; ===========================================================================

loc_32536:
		subq.b	#1,$39(a0)
		bne.s	loc_32540
		addq.b	#2,ost_boss_routine(a0)

loc_32540:
		bra.w	loc_324BC
; ===========================================================================

loc_32544:
		cmpi.b	#$27,$33(a0)
		bcs.s	loc_32552
		subq.b	#1,$33(a0)
		bra.s	loc_32570
; ===========================================================================

loc_32552:
		addq.b	#1,$39(a0)
		cmpi.b	#$27,$39(a0)
		bcs.s	loc_32570
		move.w	#$100,(v_boss_y_vel).w
		move.b	#0,ost_boss_routine(a0)
		bclr	#6,$2B(a0)

loc_32570:
		bra.w	loc_324BC
; ===========================================================================

loc_32574:
		tst.b	$39(a0)
		beq.s	loc_32580
		subq.b	#1,$39(a0)
		bra.s	loc_32586
; ===========================================================================

loc_32580:
		move.b	#-1,$3A(a0)

loc_32586:
		cmpi.b	#$27,$33(a0)
		bcs.s	loc_32592
		subq.b	#1,$33(a0)

loc_32592:
		bsr.w	BossMove
		cmpi.w	#$420,(v_boss_y_pos).w
		bcc.s	loc_325A4
		move.w	#0,(v_boss_y_vel).w

loc_325A4:
		tst.b	$2C(a0)
		bne.s	loc_325BA
		tst.b	$3A(a0)
		beq.s	loc_325B6
		move.b	#-$80,$3A(a0)

loc_325B6:
		addq.b	#2,ost_boss_routine(a0)

loc_325BA:
		bra.w	loc_324BC
; ===========================================================================

loc_325BE:
		tst.b	$3E(a0)
		beq.s	loc_325EC
		tst.b	$3A(a0)
		bne.s	loc_3262A
		cmpi.b	#$27,$39(a0)
		bcc.s	loc_325D8
		addq.b	#1,$39(a0)
		bra.s	loc_3262A
; ===========================================================================

loc_325D8:
		move.w	#$100,(v_boss_y_vel).w
		move.b	#0,ost_boss_routine(a0)
		bclr	#6,$2B(a0)
		bra.s	loc_3262A
; ===========================================================================

loc_325EC:
		move.w	#-$180,(v_boss_y_vel).w
		move.w	#-$100,(v_boss_x_vel).w
		bclr	#render_xflip_bit,ost_render(a0)
		btst	#7,$2B(a0)
		beq.s	loc_32612
		move.w	#$100,(v_boss_x_vel).w
		bset	#render_xflip_bit,ost_render(a0)

loc_32612:
		move.b	#$E,ost_boss_routine(a0)
		move.b	#0,$2E(a0)
		bclr	#6,$2B(a0)
		move.b	#0,$2F(a0)

loc_3262A:
		bra.w	loc_324BC
; ===========================================================================

loc_3262E:
		tst.b	$2F(a0)
		beq.s	loc_3263C
		subq.b	#1,$2F(a0)
		bra.w	loc_324C6
; ===========================================================================

loc_3263C:
		moveq	#0,d0
		move.b	$2E(a0),d0
		move.w	off_3264A(pc,d0.w),d1
		jmp	off_3264A(pc,d1.w)
; ===========================================================================
off_3264A:	index offset(*),,2
		ptr loc_32650					; 0
		ptr loc_326B8					; 2
		ptr loc_32704					; 4
; ===========================================================================

loc_32650:
		bsr.w	BossMove
		cmpi.w	#$420,(v_boss_y_pos).w
		bcc.s	loc_32662
		move.w	#0,(v_boss_y_vel).w

loc_32662:
		btst	#7,$2B(a0)
		bne.s	loc_32690
		cmpi.w	#$2AF0,($FFFFF750).w
		bcc.s	loc_326B4
		addq.b	#2,$2E(a0)
		move.w	#$180,(v_boss_y_vel).w
		move.b	#3,$2D(a0)
		move.w	#$1E,(v_boss_timer).w
		bset	#render_xflip_bit,ost_render(a0)
		bra.s	loc_326B4
; ===========================================================================

loc_32690:
		cmpi.w	#$2BB0,($FFFFF750).w
		bcs.s	loc_326B4
		addq.b	#2,$2E(a0)
		move.w	#$180,(v_boss_y_vel).w
		move.b	#3,$2D(a0)
		move.w	#$1E,(v_boss_timer).w
		bclr	#render_xflip_bit,ost_render(a0)

loc_326B4:
		bra.w	loc_324BC
; ===========================================================================

loc_326B8:
		bsr.w	BossMove
		cmpi.w	#$4A0,(v_boss_y_pos).w
		bcs.s	loc_326D6
		move.w	#-$180,(v_boss_y_vel).w
		addq.b	#2,$2E(a0)
		bchg	#7,$2B(a0)
		bra.s	loc_326FC
; ===========================================================================

loc_326D6:
		btst	#7,$2B(a0)
		bne.s	loc_326EE
		cmpi.w	#$2AD0,($FFFFF750).w
		bcc.s	loc_326FC
		move.w	#0,(v_boss_x_vel).w
		bra.s	loc_326FC
; ===========================================================================

loc_326EE:
		cmpi.w	#$2BD0,($FFFFF750).w
		bcs.s	loc_326FC
		move.w	#0,(v_boss_x_vel).w

loc_326FC:
		bsr.w	loc_32740
		bra.w	loc_324BC
; ===========================================================================

loc_32704:
		bsr.w	BossMove
		cmpi.w	#$470,(v_boss_y_pos).w
		bcc.s	loc_32724
		move.w	#$100,(v_boss_x_vel).w
		btst	#7,$2B(a0)
		bne.s	loc_32724
		move.w	#-$100,(v_boss_x_vel).w

loc_32724:
		cmpi.w	#$420,(v_boss_y_pos).w
		bcc.s	loc_32738
		move.w	#0,(v_boss_y_vel).w
		move.b	#0,$2E(a0)

loc_32738:
		bsr.w	loc_32740
		bra.w	loc_324BC
; ===========================================================================

loc_32740:
		subi_.w	#1,(v_boss_timer).w
		bne.s	locret_32772
		tst.b	$2D(a0)
		beq.s	locret_32772
		subq.b	#1,$2D(a0)
		jsrto	FindFreeObj,JmpTo17_FindFreeObj
		bne.s	locret_32772
		move.b	#id_BossMetropolis,ost_id(a1)
		move.b	#4,ost_boss_subtype(a1)
		move.l	a0,$34(a1)
		move.w	#$1E,(v_boss_timer).w
		move.b	#$10,$2F(a0)

locret_32772:
		rts
; ===========================================================================

loc_32774:
		move.w	ost_x_pos(a0),d0
		move.w	ost_y_pos(a0),d1
		move.w	d0,ost_subspr2_x_pos(a0)
		move.w	d1,ost_subspr2_y_pos(a0)
		move.w	d0,ost_subspr3_x_pos(a0)
		move.w	d1,ost_subspr3_y_pos(a0)
		rts
; ===========================================================================

loc_3278E:
		bsr.w	loc_328DE
		cmpi.b	#64-1,ost_boss_flash_time(a0)
		bne.s	loc_327D2
		st.b	$38(a0)
		lea	($FFFFF740).w,a1
		andi.b	#-$10,2(a1)
		ori.b	#5,2(a1)
		tst.b	$3E(a0)
		beq.s	loc_327CA
		move.b	#$A,ost_boss_routine(a0)
		move.w	#-$180,(v_boss_y_vel).w
		subq.b	#1,$3E(a0)
		move.w	#0,(v_boss_x_vel).w

loc_327CA:
		move.w	#0,(v_boss_x_vel).w
		rts
; ===========================================================================

loc_327D2:
		cmpi.b	#4,($FFFFB024).w
		beq.s	loc_327E2
		cmpi.b	#4,($FFFFB064).w
		bne.s	locret_32800

loc_327E2:
		lea	($FFFFF740).w,a1
		move.b	2(a1),d0
		andi.b	#$F,d0
		cmpi.b	#4,d0
		beq.s	locret_32800
		andi.b	#-$10,2(a1)
		ori.b	#4,2(a1)

locret_32800:
		rts
; ===========================================================================

loc_32802:
		subq.w	#1,(v_boss_timer).w
		cmpi.w	#$3C,(v_boss_timer).w
		bcs.s	loc_32846
		bmi.s	loc_32820
		bsr.w	BossExplode
		lea	($FFFFF740).w,a1
		move.b	#7,2(a1)
		bra.s	loc_32846
; ===========================================================================

loc_32820:
		bset	#render_xflip_bit,ost_render(a0)
		clr.w	(v_boss_x_vel).w
		clr.w	(v_boss_y_vel).w
		addq.b	#2,ost_boss_routine(a0)
		move.w	#-$12,(v_boss_timer).w
		lea	($FFFFF740).w,a1
		move.b	#3,2(a1)
		jsrto	RestoreLevelMusic,JmpTo7_RestoreLevelMusic

loc_32846:
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		lea	(Ani_BMTZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_32774
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_32864:
		move.w	#$400,(v_boss_x_vel).w
		move.w	#-$40,(v_boss_y_vel).w
		cmpi.w	#$2BF0,(v_boundary_right).w
		bcc.s	loc_3287E
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_32884
; ===========================================================================

loc_3287E:
		tst.b	ost_render(a0)
		bpl.s	JmpTo60_DeleteObject

loc_32884:
		tst.b	(v_boss_status).w
		bne.s	loc_32894
		move.b	#1,(v_boss_status).w
		jsrto	LoadAnimalExplosionArt,JmpTo7_LoadAnimalExplosionArt

loc_32894:
		bsr.w	BossMove
		bsr.w	loc_328C0
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		lea	(Ani_BMTZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_32774
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

JmpTo60_DeleteObject:
		jmp	(DeleteObject).l
; ===========================================================================

loc_328C0:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	(v_boss_y_pos).w,d0
		move.w	d0,ost_y_pos(a0)
		move.w	($FFFFF750).w,ost_x_pos(a0)
		addq.b	#2,ost_boss_wobble(a0)

loc_328DE:
		cmpi.b	#$10,ost_boss_routine(a0)
		bcc.s	locret_32924
		tst.b	ost_boss_hitcount2(a0)
		beq.s	loc_32926
		tst.b	ost_col_type(a0)
		bne.s	locret_32924
		tst.b	ost_boss_flash_time(a0)
		bne.s	loc_32908
		move.b	#$40,ost_boss_flash_time(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_32908:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_32916
		move.w	#$EEE,d0

loc_32916:
		move.w	d0,(a1)
		subq.b	#1,ost_boss_flash_time(a0)
		bne.s	locret_32924
		move.b	#id_col_24x24,ost_col_type(a0)

locret_32924:
		rts
; ===========================================================================

loc_32926:
		moveq	#$64,d0
		jsrto	AddPoints,JmpTo8_AddPoints
		move.w	#$EF,(v_boss_timer).w
		move.b	#$10,ost_boss_routine(a0)
		moveq	#$40,d0
		jsrto	AddPLC,JmpTo11_AddPLC
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 53 - MTZ boss' shield orbs
; ----------------------------------------------------------------------------

BossMetropolisOrb:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3294E(pc,d0.w),d1
		jmp	off_3294E(pc,d1.w)
; ===========================================================================
off_3294E:	index offset(*),,2
		ptr loc_32958					; 0
		ptr loc_329DA					; 2
		ptr loc_32B64					; 4
		ptr loc_32BDC					; 6
		ptr loc_32C98					; 8
; ===========================================================================

loc_32958:
		movea.l	a0,a1
		moveq	#6,d3
		moveq	#0,d2
		bra.s	loc_32966
; ===========================================================================

loc_32960:
		jsrto	FindFreeObj,JmpTo17_FindFreeObj
		bne.s	locret_329CA

loc_32966:
		move.b	#$20,ost_displaywidth(a1)
		move.l	$34(a0),$34(a1)
		move.b	#id_BossMetropolisOrb,ost_id(a1)
		move.l	#Map_BMTZ,ost_mappings(a1)
		move.w	#tile_Nem_MTZBoss,ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#3,ost_priority(a1)
		addq.b	#2,ost_primary_routine(a1)
		move.b	#5,ost_frame(a1)
		move.b	byte_329CC(pc,d2.w),$28(a1)
		move.b	byte_329CC(pc,d2.w),$3B(a1)
		move.b	byte_329D3(pc,d2.w),$3A(a1)
		move.b	#$40,$29(a1)
		move.b	#id_col_6x6+id_col_hurt,ost_col_type(a1)
		move.b	#2,ost_col_property(a1)
		move.b	#0,$3C(a1)
		addq.w	#1,d2
		dbf	d3,loc_32960

locret_329CA:
		rts
; ===========================================================================
byte_329CC:
		dc.b $24					; 0
		dc.b $6C					; 1
		dc.b $B4					; 2
		dc.b $FC					; 3
		dc.b $48					; 4
		dc.b $90					; 5
		dc.b $D8					; 6
byte_329D3:
		dc.b   0					; 0
		dc.b   1					; 1
		dc.b   1					; 2
		dc.b   0					; 3
		dc.b   1					; 4
		dc.b   1					; 5
		dc.b   0					; 6
; ===========================================================================

loc_329DA:
		movea.l	$34(a0),a1
		move.w	ost_y_pos(a1),$2A(a0)
		subi_.w	#4,$2A(a0)
		move.w	ost_x_pos(a1),$38(a0)
		tst.b	$38(a1)
		beq.s	loc_32A56
		move.b	#0,$38(a1)
		addi_.b	#1,$2C(a1)
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$3C,$32(a0)
		move.b	#2,ost_anim(a0)
		move.w	#-$400,ost_y_vel(a0)
		move.w	#-$80,d1
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		bpl.s	loc_32A28
		neg.w	d1

loc_32A28:
		cmpi.w	#$2AF0,ost_x_pos(a0)
		bcc.s	loc_32A34
		move.w	#$80,d1

loc_32A34:
		cmpi.w	#$2BB0,ost_x_pos(a0)
		bcs.s	loc_32A40
		move.w	#-$80,d1

loc_32A40:
		bclr	#render_xflip_bit,ost_render(a0)
		tst.w	d1
		bmi.s	loc_32A50
		bset	#render_xflip_bit,ost_render(a0)

loc_32A50:
		move.w	d1,ost_x_vel(a0)
		bra.s	loc_32A64
; ===========================================================================

loc_32A56:
		cmpi.b	#2,ost_col_property(a0)
		beq.s	loc_32A64
		move.b	#0,ost_col_type(a1)

loc_32A64:
		bsr.w	loc_32A70
		bsr.w	loc_32B1A
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_32A70:
		move.b	$29(a0),d0
		jsr	(CalcSine).l
		move.w	d0,d3
		moveq	#0,d1
		move.b	$33(a1),d1
		muls.w	d1,d0
		move.w	d0,d5
		move.w	d0,d4
		move.b	$39(a1),d2
		tst.b	$3A(a1)
		beq.s	loc_32A96
		move.w	#$10,d2

loc_32A96:
		muls.w	d3,d2
		move.w	$38(a0),d6
		move.b	$28(a0),d0
		jsr	(CalcSine).l
		muls.w	d0,d5
		swap	d5
		add.w	d6,d5
		move.w	d5,ost_x_pos(a0)
		muls.w	d1,d4
		swap	d4
		move.w	d4,$30(a0)
		move.w	$2A(a0),d6
		move.b	$3B(a0),d0
		tst.b	$3A(a1)
		beq.s	loc_32ACA
		move.b	$3C(a0),d0

loc_32ACA:
		jsr	(CalcSine).l
		muls.w	d0,d2
		swap	d2
		add.w	d6,d2
		move.w	d2,ost_y_pos(a0)
		addq.b	#4,$28(a0)
		tst.b	$3A(a1)
		bne.s	loc_32AEA
		addq.b	#8,$3B(a0)
		rts
; ===========================================================================

loc_32AEA:
		cmpi.b	#-1,$3A(a1)
		beq.s	loc_32B0C
		cmpi.b	#-$80,$3A(a1)
		bne.s	loc_32B04
		subq.b	#2,$3C(a0)
		bpl.s	locret_32B18
		clr.b	$3C(a0)

loc_32B04:
		move.b	#0,$3A(a1)
		rts
; ===========================================================================

loc_32B0C:
		cmpi.b	#$40,$3C(a0)
		bcc.s	locret_32B18
		addq.b	#2,$3C(a0)

locret_32B18:
		rts
; ===========================================================================

loc_32B1A:
		move.w	$30(a0),d0
		bmi.s	loc_32B42
		cmpi.w	#$C,d0
		blt.s	loc_32B34
		move.b	#3,ost_frame(a0)
		move.b	#1,ost_priority(a0)
		rts
; ===========================================================================

loc_32B34:
		move.b	#4,ost_frame(a0)
		move.b	#2,ost_priority(a0)
		rts
; ===========================================================================

loc_32B42:
		cmpi.w	#-$C,d0
		blt.s	loc_32B56
		move.b	#4,ost_frame(a0)
		move.b	#6,ost_priority(a0)
		rts
; ===========================================================================

loc_32B56:
		move.b	#5,ost_frame(a0)
		move.b	#7,ost_priority(a0)
		rts
; ===========================================================================

loc_32B64:
		tst.b	$32(a0)
		bmi.s	loc_32B76
		subq.b	#1,$32(a0)
		bpl.s	loc_32B76
		move.b	#id_col_12x12+id_col_custom,ost_col_type(a0)

loc_32B76:
		jsrto	ObjectFall,JmpTo6_ObjectFall
		subi.w	#$20,ost_y_vel(a0)
		cmpi.w	#$180,ost_y_vel(a0)
		blt.s	loc_32B8E
		move.w	#$180,ost_y_vel(a0)

loc_32B8E:
		cmpi.w	#$4AC,ost_y_pos(a0)
		bcs.s	loc_32BB0
		move.w	#$4AC,ost_y_pos(a0)
		move.w	#$4AC,$2E(a0)
		move.b	#1,$2C(a0)
		addq.b	#2,ost_primary_routine(a0)
		bsr.w	loc_32C4C

loc_32BB0:
		bsr.w	loc_32BC2
		lea	(Ani_BMTZ).l,a1
		jsrto	AnimateSprite,JmpTo21_AnimateSprite
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_32BC2:
		cmpi.b	#-2,ost_col_property(a0)
		bgt.s	locret_32BDA
		move.b	#$14,ost_frame(a0)
		move.b	#6,ost_anim(a0)
		addq.b	#2,ost_primary_routine(a0)

locret_32BDA:
		rts
; ===========================================================================

loc_32BDC:
		tst.b	$32(a0)
		bmi.s	loc_32BEE
		subq.b	#1,$32(a0)
		bpl.s	loc_32BEE
		move.b	#id_col_12x12+id_col_custom,ost_col_type(a0)

loc_32BEE:
		bsr.w	loc_32C66
		cmpi.b	#$B,ost_frame(a0)
		bne.s	loc_32BB0
		move.b	$2C(a0),d0
		jsr	(CalcSine).l
		neg.w	d0
		asr.w	#2,d0
		add.w	$2E(a0),d0
		cmpi.w	#$4AC,d0
		bcc.s	loc_32C38
		move.w	d0,ost_y_pos(a0)
		addq.b	#1,$2C(a0)
		btst	#0,$2C(a0)
		beq.w	JmpTo40_DisplaySprite
		moveq	#-1,d0
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_32C30
		neg.w	d0

loc_32C30:
		add.w	d0,ost_x_pos(a0)
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_32C38:
		move.w	#$4AC,ost_y_pos(a0)
		bsr.w	loc_32C4C
		move.b	#1,$2C(a0)
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_32C4C:
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		bpl.s	loc_32C5E
		bclr	#render_xflip_bit,ost_render(a0)
		rts
; ===========================================================================

loc_32C5E:
		bset	#render_xflip_bit,ost_render(a0)
		rts
; ===========================================================================

loc_32C66:
		cmpi.b	#4,($FFFFB024).w
		beq.s	loc_32C76
		cmpi.b	#4,($FFFFB064).w
		bne.s	loc_32C82

loc_32C76:
		move.b	#$14,ost_frame(a0)
		move.b	#6,ost_anim(a0)

loc_32C82:
		cmpi.b	#-2,ost_col_property(a0)
		bgt.s	locret_32C96
		move.b	#$14,ost_frame(a0)
		move.b	#6,ost_anim(a0)

locret_32C96:
		rts
; ===========================================================================

loc_32C98:
		move.b	#-$3C,d0
		jsrto	PlaySound,JmpTo10_PlaySound
		movea.l	$34(a0),a1
		subi_.b	#1,$2C(a1)

	if RemoveJmpTos
JmpTo61_DeleteObject:
	endc

		jmpto	DeleteObject,JmpTo61_DeleteObject
; ===========================================================================

loc_32CAE:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_32CBC(pc,d0.w),d0
		jmp	off_32CBC(pc,d0.w)
; ===========================================================================
off_32CBC:	index offset(*),,2
		ptr loc_32CC0					; 0
		ptr loc_32D2C					; 2
; ===========================================================================

loc_32CC0:
		move.l	#Map_BMTZ,ost_mappings(a0)
		move.w	#tile_Nem_MTZBoss,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#5,ost_priority(a0)
		move.b	#$12,ost_frame(a0)
		addq.b	#2,ost_secondary_routine(a0)
		movea.l	$34(a0),a1
		move.b	#$50,ost_displaywidth(a0)
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		addi_.w	#7,ost_y_pos(a0)
		subi_.w	#4,ost_x_pos(a0)
		move.w	#-$400,d0
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_32D1A
		neg.w	d0
		addi_.w	#8,ost_x_pos(a0)

loc_32D1A:
		move.w	d0,ost_x_vel(a0)
		move.b	#id_col_32x8+id_col_hurt,ost_col_type(a0)
		move.b	#sfx_LaserBurst,d0
		jsrto	PlaySound,JmpTo10_PlaySound

loc_32D2C:
		jsrto	SpeedToPos,JmpTo24_SpeedToPos
		cmpi.w	#$2AB0,ost_x_pos(a0)
		bcs.w	JmpTo61_DeleteObject
		cmpi.w	#$2BF0,ost_x_pos(a0)
		bcc.w	JmpTo61_DeleteObject
		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================

loc_32D48:
		movea.l	$34(a0),a1
		cmpi.b	#id_BossMetropolis,ost_id(a1)
		bne.w	JmpTo61_DeleteObject
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		btst	#render_xflip_bit,ost_render(a1)
		beq.w	JmpTo40_DisplaySprite
		bset	#render_xflip_bit,ost_render(a0)

    if RemoveJmpTos
JmpTo40_DisplaySprite:
    endc

		jmpto	DisplaySprite,JmpTo40_DisplaySprite
; ===========================================================================
Ani_BMTZ:	index offset(*)
		ptr byte_32D8A					; 0
		ptr byte_32D8D					; 1
		ptr byte_32D91					; 2
		ptr byte_32DA6					; 3
		ptr byte_32DAA					; 4
		ptr byte_32DB5					; 5
		ptr byte_32DC0					; 6
		ptr byte_32DC3					; 7

byte_32D8A:
		dc.b  $F,  2,$FF				; 0

byte_32D8D:
		dc.b   1,  0,  1,$FF				; 0

byte_32D91:
		dc.b   3,  5,  5,  5,  5,  5,  5,  5,  5,  6,  7,  6,  7,  6,  7,  8 ; 0
		dc.b   9, $A, $B,$FE,  1			; 16

byte_32DA6:
		dc.b   7, $C, $D,$FF				; 0
byte_32DAA:
		dc.b   7, $E, $F, $E, $F, $E, $F, $E, $F,$FD,  3 ; 0

byte_32DB5:
		dc.b   7,$10,$10,$10,$10,$10,$10,$10,$10,$FD,  3 ; 0

byte_32DC0:
		dc.b   1,$14,$FC				; 0

byte_32DC3:
		dc.b   7,$11,$FF				; 0

; ===========================================================================

		include "mappings/sprite/MTZ Boss.asm"

; ===========================================================================

	if RemoveJmpTos=0
		align 4
	endc

; ===========================================================================

	if RemoveJmpTos=0
JmpTo40_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo61_DeleteObject:
		jmp	(DeleteObject).l
JmpTo17_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo10_PlaySound:
		jmp	(PlaySound).l
JmpTo21_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo11_AddPLC:
		jmp	(AddPLC).l
JmpTo8_AddPoints:
		jmp	(AddPoints).l
JmpTo7_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo7_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l
JmpTo6_ObjectFall:
		jmp	(ObjectFall).l
JmpTo24_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 55 - OOZ boss
; ----------------------------------------------------------------------------

BossOilOcean:
		moveq	#0,d0
		move.b	ost_boss_subtype(a0),d0
		move.w	BOOZ_Index(pc,d0.w),d1
		jmp	BOOZ_Index(pc,d1.w)
; ===========================================================================
BOOZ_Index:	index offset(*),,2
		ptr loc_32FA8					; 0
		ptr loc_32FE6					; 2
		ptr loc_3320A					; 4
		ptr loc_33456					; 6
		ptr loc_33570					; 8
; ===========================================================================

loc_32FA8:
		move.l	#Map_BOOZ,ost_mappings(a0)
		move.w	#tile_Nem_OOZBoss,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		bset	#render_subsprites_bit,ost_render(a0)
		move.b	#0,ost_mainspr_childsprites(a0)
		addq.b	#2,ost_boss_subtype(a0)
		move.b	#id_col_24x24,ost_col_type(a0)
		move.b	#8,ost_boss_hitcount2(a0)
		move.b	#$40,ost_mainspr_width(a0)
		rts
; ===========================================================================

loc_32FE6:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_32FF4(pc,d0.w),d1
		jmp	off_32FF4(pc,d1.w)
; ===========================================================================
off_32FF4:	index offset(*),,2
		ptr loc_32FFE					; 0
		ptr loc_33078					; 2
		ptr loc_330BA					; 4
		ptr loc_33104					; 6
		ptr loc_331A6					; 8
; ===========================================================================

loc_32FFE:
		move.w	#$2940,($FFFFF750).w
		bclr	#render_xflip_bit,ost_render(a0)
		move.w	($FFFFB008).w,d1
		cmpi.w	#$293A,d1
		bcc.s	loc_3301A
		bchg	#render_xflip_bit,ost_render(a0)

loc_3301A:
		move.w	#$2D0,ost_y_pos(a0)
		move.w	#$2D0,(v_boss_y_pos).w
		move.b	#8,ost_mainspr_frame(a0)
		move.b	#1,ost_mainspr_childsprites(a0)
		addq.b	#2,ost_boss_routine(a0)
		move.w	#-$80,(v_boss_y_vel).w
		move.b	#id_col_24x24,ost_col_type(a0)
		move.w	ost_x_pos(a0),ost_subspr2_x_pos(a0)
		move.w	ost_y_pos(a0),ost_subspr2_y_pos(a0)
		clr.b	ost_boss_wobble(a0)
		clr.b	$2A(a0)
		move.b	#8,ost_subspr2_frame(a0)
		lea	($FFFFF740).w,a2
		move.b	#5,(a2)+
		move.b	#0,(a2)+
		move.b	#1,(a2)+
		move.b	#0,(a2)
		move.b	#0,(v_boss_collision_routine).w
		rts
; ===========================================================================

loc_33078:
		bsr.w	BossMove
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		bsr.w	loc_330EA
		cmpi.w	#$290,(v_boss_y_pos).w
		bcc.w	loc_3315E
		move.w	#$290,(v_boss_y_pos).w
		addq.b	#2,ost_boss_routine(a0)
		move.w	#$A8,(v_boss_timer).w
		btst	#7,$2A(a0)
		bne.w	loc_3315E
		lea	($FFFFF740).w,a2
		move.b	#$10,(a2)+
		move.b	#0,(a2)
		bra.w	loc_3315E
; ===========================================================================

loc_330BA:
		btst	#7,$2A(a0)
		bne.s	loc_330DC
		bsr.w	loc_330EA
		subi_.w	#1,(v_boss_timer).w
		bpl.w	loc_3315E
		lea	($FFFFF740).w,a2
		move.b	#5,(a2)+
		move.b	#0,(a2)

loc_330DC:
		addq.b	#2,ost_boss_routine(a0)
		move.w	#-$40,(v_boss_y_vel).w
		bra.w	loc_3315E
; ===========================================================================

loc_330EA:
		move.b	ost_boss_wobble(a0),d0
		jsr	(CalcSine).l
		asr.w	#7,d1
		add.w	(v_boss_y_pos).w,d1
		move.w	d1,ost_y_pos(a0)
		addq.b	#4,ost_boss_wobble(a0)
		rts
; ===========================================================================

loc_33104:
		bsr.w	BossMove
		move.w	(v_boss_y_pos).w,ost_y_pos(a0)
		move.w	(v_boss_x_pos).w,ost_x_pos(a0)
		btst	#6,$2A(a0)
		bne.s	loc_3313C
		cmpi.w	#$28C,(v_boss_y_pos).w
		bcc.w	loc_3315E
		move.w	#$28C,(v_boss_y_pos).w
		move.w	#$80,(v_boss_y_vel).w
		ori.b	#$40,$2A(a0)
		bra.w	loc_3315E
; ===========================================================================

loc_3313C:
		cmpi.w	#$2D0,(v_boss_y_pos).w
		bcs.s	loc_3315E
		move.w	#$2D0,(v_boss_y_pos).w
		clr.b	ost_boss_routine(a0)
		addq.b	#2,ost_boss_subtype(a0)
		btst	#7,$2A(a0)
		beq.s	loc_3315E
		addq.b	#2,ost_boss_subtype(a0)

loc_3315E:
		bsr.w	loc_33174
		lea	(Ani_BOOZ).l,a1
		bsr.w	BossAnimate
		bsr.w	loc_33194
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
; ===========================================================================

loc_33174:
		bsr.w	BOOZ_Hit
		cmpi.b	#$1F,ost_boss_flash_time(a0)
		bne.s	locret_33192
		lea	($FFFFF740).w,a1
		andi.b	#-$10,(a1)
		ori.b	#3,(a1)
		ori.b	#-$80,$2A(a0)

locret_33192:
		rts
; ===========================================================================

loc_33194:
		move.w	ost_x_pos(a0),d0
		move.w	ost_y_pos(a0),d1
		move.w	d0,ost_subspr2_x_pos(a0)
		move.w	d1,ost_subspr2_y_pos(a0)
		rts
; ===========================================================================

loc_331A6:
		clr.w	($FFFFFB22).w
		subq.w	#1,(v_boss_timer).w
		bmi.s	loc_331CA
		cmpi.w	#$1E,(v_boss_timer).w
		bcc.s	loc_331C2
		move.b	#$B,ost_mainspr_frame(a0)
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
; ===========================================================================

loc_331C2:
		bsr.w	BossExplode
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
; ===========================================================================

loc_331CA:
		tst.b	(v_boss_status).w
		bne.s	loc_331DE
		jsrto	RestoreLevelMusic,JmpTo8_RestoreLevelMusic
		jsrto	LoadAnimalExplosionArt,JmpTo8_LoadAnimalExplosionArt
		move.b	#1,(v_boss_status).w

loc_331DE:
		cmpi.w	#$2A20,(v_boundary_right).w
		bcc.s	loc_331EC
		addq.w	#2,(v_boundary_right).w
		bra.s	loc_331FA
; ===========================================================================

loc_331EC:
		move.w	#$2A20,(v_boundary_right).w
		cmpi.w	#$2D0,ost_y_pos(a0)
		bcc.s	BranchTo_JmpTo62_DeleteObject

loc_331FA:
		addi_.w	#1,ost_y_pos(a0)
		bsr.s	loc_33194
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
; ===========================================================================

    if RemoveJmpTos
JmpTo62_DeleteObject:
    endc

BranchTo_JmpTo62_DeleteObject:
		jmpto	DeleteObject,JmpTo62_DeleteObject
; ===========================================================================

loc_3320A:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_33218(pc,d0.w),d1
		jmp	off_33218(pc,d1.w)
; ===========================================================================
off_33218:	index offset(*),,2
		ptr loc_33222					; 0
		ptr loc_33296					; 2
		ptr loc_332C6					; 4
		ptr loc_33324					; 6
		ptr loc_33388					; 8
; ===========================================================================

loc_33222:
		clr.w	($FFFFFB22).w
		move.w	#$2940,($FFFFF750).w
		bclr	#render_xflip_bit,ost_render(a0)
		move.w	($FFFFB008).w,d1
		cmpi.w	#$293A,d1
		bcs.s	loc_33242
		bchg	#render_xflip_bit,ost_render(a0)

loc_33242:
		move.w	#$2B0,(v_boss_y_pos).w
		move.w	#$2B0,ost_y_pos(a0)
		move.b	#2,ost_boss_routine(a0)
		move.b	#id_col_16x8+id_col_hurt,ost_col_type(a0)
		move.b	#5,ost_mainspr_frame(a0)
		moveq	#7,d0
		moveq	#7,d2
		moveq	#0,d4
		move.w	(v_boss_y_pos).w,d5

loc_3326A:
		addi.w	#$F,d5
		move.b	d0,ost_subspr2_frame(a0,d4.w)
		move.w	d5,ost_subspr2_y_pos(a0,d4.w)
		addq.w	#6,d4
		dbf	d2,loc_3326A
		move.b	#8,ost_mainspr_childsprites(a0)
		move.w	#-$80,(v_boss_y_vel).w
		move.b	#0,$3E(a0)
		move.b	#1,(v_boss_collision_routine).w
		rts
; ===========================================================================

loc_33296:
		bsr.w	BossMove
		cmpi.w	#$240,(v_boss_y_pos).w
		bcc.w	loc_333BA
		move.w	#$240,(v_boss_y_pos).w
		move.w	#0,(v_boss_y_vel).w
		addi_.b	#2,ost_boss_routine(a0)
		move.w	#$80,(v_boss_timer).w
		move.b	#3,$38(a0)
		bra.w	loc_333BA
; ===========================================================================

loc_332C6:
		subq.b	#1,$2C(a0)
		bne.s	loc_332D2
		move.b	#5,ost_mainspr_frame(a0)

loc_332D2:
		subi_.w	#1,(v_boss_timer).w
		bne.w	loc_333BA
		subi_.b	#1,$38(a0)
		bmi.s	loc_3330C
		jsrto	RandomNumber,JmpTo5_RandomNumber

loc_332E8:
		addq.b	#1,d0
		andi.w	#3,d0
		btst	d0,$3E(a0)
		bne.s	loc_332E8
		bset	d0,$3E(a0)
		add.w	d0,d0
		move.w	word_3331C(pc,d0.w),(v_boss_timer).w
		addq.b	#2,ost_boss_routine(a0)
		bsr.w	loc_333C6
		bra.w	loc_333BA
; ===========================================================================

loc_3330C:
		move.w	#$80,(v_boss_y_vel).w
		move.b	#8,ost_boss_routine(a0)
		bra.w	loc_333BA
; ===========================================================================
word_3331C:
		dc.w  $238					; 0
		dc.w  $230					; 1
		dc.w  $240					; 2
		dc.w  $25F					; 3
; ===========================================================================

loc_33324:
		bsr.w	BossMove
		move.w	(v_boss_timer).w,d0
		tst.w	(v_boss_y_vel).w
		bmi.s	loc_3333C
		cmp.w	(v_boss_y_pos).w,d0
		bcs.s	loc_33342
		bra.w	loc_333BA
; ===========================================================================

loc_3333C:
		cmp.w	(v_boss_y_pos).w,d0
		bcs.s	loc_333BA

loc_33342:
		move.w	#0,(v_boss_y_vel).w
		move.b	#8,$2C(a0)
		move.b	#6,ost_mainspr_frame(a0)
		jsrto	FindFreeObj,JmpTo18_FindFreeObj
		bne.w	loc_333BA
		move.b	#id_BossOilOcean,ost_id(a1)
		move.b	#8,ost_boss_subtype(a1)
		move.l	a0,$34(a1)
		move.b	#-$16,d0
		jsrto	PlaySound,JmpTo11_PlaySound
		move.b	#4,ost_boss_routine(a0)
		move.w	#$28,(v_boss_timer).w
		move.w	#-$80,(v_boss_y_vel).w
		bra.w	loc_333BA
; ===========================================================================

loc_33388:
		subq.b	#1,$2C(a0)
		bne.s	loc_33394
		move.b	#5,ost_mainspr_frame(a0)

loc_33394:
		bsr.w	BossMove
		cmpi.w	#$2B0,(v_boss_y_pos).w
		bcs.s	loc_333BA
		move.w	#$2B0,(v_boss_y_pos).w
		move.w	#0,(v_boss_y_vel).w
		move.b	#0,ost_boss_routine(a0)
		move.b	#2,ost_boss_subtype(a0)
		rts
; ===========================================================================

loc_333BA:
		bsr.w	loc_333E0				; could be bsr.s
		bsr.w	loc_33406				; could be bsr.s

	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		move.w	#sizeof_priority*3,d0
		jmp	(DisplaySprite3).l
	else
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
	endc
; ===========================================================================

loc_333C6:
		move.w	(v_boss_timer).w,d0
		sub.w	(v_boss_y_pos).w,d0
		bpl.s	loc_333D8
		move.w	#-$80,(v_boss_y_vel).w
		rts
; ===========================================================================

loc_333D8:
		move.w	#$80,(v_boss_y_vel).w
		rts
; ===========================================================================

loc_333E0:
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		blt.s	loc_333F8
		subi_.w	#8,d0
		blt.s	locret_333F6
		bset	#render_xflip_bit,ost_render(a0)

locret_333F6:
		rts
; ===========================================================================

loc_333F8:
		addi_.w	#8,d0
		bgt.s	locret_333F6
		bclr	#render_xflip_bit,ost_render(a0)
		rts
; ===========================================================================

loc_33406:
		move.w	($FFFFF750).w,d5
		move.w	(v_boss_y_pos).w,d6
		move.b	ost_boss_wobble(a0),d3
		move.b	d3,d0
		bsr.w	loc_33446
		move.w	d1,ost_x_pos(a0)
		move.w	d0,ost_y_pos(a0)
		addi_.b	#2,ost_boss_wobble(a0)
		moveq	#7,d2
		moveq	#0,d4

loc_3342A:
		addi.w	#$F,d6
		subi.b	#$10,d3
		bsr.w	loc_33446
		move.w	d1,ost_subspr2_x_pos(a0,d4.w)
		move.w	d0,ost_subspr2_y_pos(a0,d4.w)
		addq.w	#6,d4
		dbf	d2,loc_3342A
		rts
; ===========================================================================

loc_33446:
		move.b	d3,d0
		jsrto	Calcsine,JmpTo13_CalcSine
		asr.w	#4,d1
		add.w	d5,d1
		asr.w	#6,d0
		add.w	d6,d0
		rts
; ===========================================================================

loc_33456:
		moveq	#0,d0
		move.b	ost_boss_routine(a0),d0
		move.w	off_33464(pc,d0.w),d1
		jmp	off_33464(pc,d1.w)
; ===========================================================================
off_33464:	index offset(*),,2
		ptr loc_33468					; 0
		ptr loc_334CC					; 2
; ===========================================================================

loc_33468:
		clr.w	($FFFFFB22).w
		move.w	#$28C0,($FFFFF750).w
		bclr	#render_xflip_bit,ost_render(a0)
		move.w	($FFFFB008).w,d1
		cmpi.w	#$293A,d1
		bcs.s	loc_3348E
		move.w	#$29C0,($FFFFF750).w
		bset	#render_xflip_bit,ost_render(a0)

loc_3348E:
		move.w	#$2A0,(v_boss_y_pos).w
		move.b	#2,ost_mainspr_frame(a0)
		move.b	#id_col_16x8+id_col_hurt,ost_col_type(a0)
		addq.b	#2,ost_boss_routine(a0)
		move.b	#$80,ost_mainspr_width(a0)
		clr.b	ost_boss_wobble(a0)
		moveq	#7,d0
		moveq	#7,d1
		moveq	#0,d2

loc_334B4:
		move.b	d1,ost_subspr2_frame(a0,d2.w)
		addq.w	#next_subspr,d2
		dbf	d0,loc_334B4
		move.b	#8,ost_mainspr_childsprites(a0)
		move.b	#2,(v_boss_collision_routine).w
		rts
; ===========================================================================

loc_334CC:
		bsr.w	loc_334EE				; could be bsr.s
		cmpi.b	#$FE,ost_boss_wobble(a0)
		bcs.s	loc_334E6
		move.b	#0,ost_boss_routine(a0)
		move.b	#4,ost_boss_subtype(a0)
		rts
; ===========================================================================

loc_334E6:
		bsr.w	loc_3354C
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
; ===========================================================================

loc_334EE:
		move.b	ost_boss_wobble(a0),d0
		addi.b	#$40,d0
		move.b	d0,d3
		bsr.w	loc_33526
		move.w	d1,ost_x_pos(a0)
		move.w	d0,ost_y_pos(a0)
		addi_.b	#1,ost_boss_wobble(a0)
		moveq	#7,d2
		moveq	#0,d4

loc_3350E:
		subi_.b	#6,d3
		bsr.w	loc_33526
		move.w	d1,ost_subspr2_x_pos(a0,d4.w)
		move.w	d0,ost_subspr2_y_pos(a0,d4.w)
		addq.w	#next_subspr,d4
		dbf	d2,loc_3350E
		rts
; ===========================================================================

loc_33526:
		move.b	d3,d0
		jsrto	Calcsine,JmpTo13_CalcSine
		muls.w	#$68,d1
		asr.l	#8,d1
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_3353C
		neg.w	d1

loc_3353C:
		add.w	($FFFFF750).w,d1
		muls.w	#$68,d0
		asr.l	#8,d0

loc_33546:
		add.w	(v_boss_y_pos).w,d0
		rts
; ===========================================================================

loc_3354C:
		move.b	ost_boss_wobble(a0),d0
		moveq	#$15,d1
		cmpi.b	#$52,d0
		bcs.s	loc_3356A
		moveq	#3,d1
		cmpi.b	#$6B,d0
		bcs.s	loc_3356A
		moveq	#2,d1
		cmpi.b	#-$6E,d0
		bcs.s	loc_3356A
		moveq	#4,d1

loc_3356A:
		move.b	d1,ost_mainspr_frame(a0)
		rts
; ===========================================================================

loc_33570:
		moveq	#0,d0

loc_33572:
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3357E(pc,d0.w),d0
		jmp	off_3357E(pc,d0.w)
; ===========================================================================
off_3357E:	index offset(*),,2
		ptr loc_33586					; 0
		ptr loc_335DE					; 2
		ptr loc_336B2					; 4
		ptr loc_3370E					; 6
; ===========================================================================

loc_33586:
		addq.b	#2,ost_secondary_routine(a0)
		move.l	#Map_BOOZ,ost_mappings(a0)
		move.w	#tile_Nem_OOZBoss,ost_tile(a0)
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		movea.l	$34(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	#$C,ost_frame(a0)
		move.w	#-$20,d0
		move.w	#-$400,ost_x_vel(a0)
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_335D2
		neg.w	d0
		neg.w	ost_x_vel(a0)

loc_335D2:
		add.w	d0,ost_x_pos(a0)
		move.b	#id_col_16x2+id_col_hurt,ost_col_type(a0)
		rts
; ===========================================================================

loc_335DE:
		bsr.w	loc_335FE
		jsrto	SpeedToPos,JmpTo25_SpeedToPos
		cmpi.w	#$2870,ost_x_pos(a0)
		bcs.w	JmpTo62_DeleteObject
		cmpi.w	#$2A10,ost_x_pos(a0)
		bcc.w	JmpTo62_DeleteObject
		jmpto	DisplaySprite,JmpTo41_DisplaySprite
; ===========================================================================

loc_335FE:
		cmpi.w	#$250,ost_y_pos(a0)
		bcs.s	locret_33626
		tst.w	ost_x_vel(a0)
		bmi.w	loc_33628
		move.w	ost_x_pos(a0),d0
		cmpi.w	#$2980,d0
		bcc.s	locret_33626
		cmpi.w	#$297C,d0
		bcs.w	locret_33626
		move.w	#$2988,d1
		bra.s	loc_33640
; ===========================================================================

locret_33626:
		rts
; ===========================================================================

loc_33628:
		move.w	ost_x_pos(a0),d0
		cmpi.w	#$2900,d0
		bcs.s	locret_3363E
		cmpi.w	#$2904,d0
		bcc.s	locret_3363E
		move.w	#$28F8,d1
		bra.s	loc_33640
; ===========================================================================

locret_3363E:
		rts
; ===========================================================================

loc_33640:
		jsrto	FindFreeObj,JmpTo18_FindFreeObj
		bne.s	locret_336B0
		move.b	#id_BossOilOcean,ost_id(a1)
		move.b	#8,ost_boss_subtype(a1)
		move.b	#4,ost_secondary_routine(a1)
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a1)
		move.b	#2,ost_anim(a1)
		move.b	#$D,ost_frame(a1)
		move.w	#0,ost_y_vel(a1)
		move.l	#Map_BOOZ,ost_mappings(a1)
		move.w	#tile_Nem_OOZBoss,ost_tile(a1)
		jsrto	AdjustVRAM2P,JmpTo63_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a1)
		move.b	#2,ost_priority(a1)
		move.w	#5,$32(a1)
		move.b	#7,$36(a1)
		move.w	ost_x_vel(a0),ost_x_vel(a1)
		move.w	d1,ost_x_pos(a1)
		move.w	#$250,ost_y_pos(a1)
		move.b	#-$15,d0
		jsrto	PlaySound,JmpTo11_PlaySound

locret_336B0:
		rts
; ===========================================================================

loc_336B2:
		subq.w	#1,$32(a0)
		bpl.s	loc_33700
		move.w	#$C7,$32(a0)
		subq.b	#1,$36(a0)
		bmi.s	loc_33700
		jsrto	FindNextFreeObj,JmpTo24_FindNextFreeObj
		bne.s	loc_33700
		moveq	#0,d0
		move.w	#$F,d1

loc_336D0:
		move.l	(a0,d0.w),(a1,d0.w)
		addq.w	#4,d0
		dbf	d1,loc_336D0
		move.w	#5,$32(a1)
		move.w	#$200,ost_anim(a1)
		move.w	#$10,d0
		tst.w	ost_x_vel(a1)
		bpl.s	loc_336F4
		neg.w	d0

loc_336F4:
		add.w	d0,ost_x_pos(a1)
		move.b	#-$15,d0
		jsrto	PlaySound,JmpTo11_PlaySound

loc_33700:
		lea	(Ani_BOOZ).l,a1
		jsrto	AnimateSprite,JmpTo22_AnimateSprite
		jmpto	DespawnObject,JmpTo38_DespawnObject
; ===========================================================================

loc_3370E:
		bra.w	JmpTo62_DeleteObject
; ===========================================================================
Ani_BOOZ:	index offset(*)
		ptr byte_3371E					; 0
		ptr byte_33738					; 1
		ptr byte_3373B					; 2
		ptr byte_3374D					; 3
		ptr byte_33750					; 4
		ptr byte_33753					; 5

byte_3371E:
		dc.b   9,  8,  8,  8,  8,  9,  9,  9,  9,  8,  8,  8,  8,  9,  9,  9 ; 0
		dc.b   9,  8,  8,  8,  8,  9,  9,  9,  9,$FF	; 16

byte_33738:
		dc.b  $F,  1,$FF				; 0

byte_3373B:
		dc.b   1, $D,$11, $E,$12, $F,$13,$10,$14,$14,$10,$13, $F,$12, $E,$11 ; 0
		dc.b  $D,$FA					; 16

byte_3374D:
		dc.b  $F, $A,$FF				; 0

byte_33750:
		dc.b  $F, $B,$FF				; 0

byte_33753:
		dc.b  $F,  8,$FF				; 0
; ===========================================================================

		include "mappings/sprite/OOZ Boss.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo41_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo62_DeleteObject:
		jmp	(DeleteObject).l
JmpTo18_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo38_DespawnObject:
		jmp	(DespawnObject).l
JmpTo11_PlaySound:
		jmp	(PlaySound).l
JmpTo24_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo22_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo5_RandomNumber:
		jmp	(RandomNumber).l
JmpTo63_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo13_CalcSine:
		jmp	(CalcSine).l
JmpTo8_RestoreLevelMusic:
		jmp	(RestoreLevelMusic).l
JmpTo8_LoadAnimalExplosionArt:
		jmp	(LoadAnimalExplosionArt).l
JmpTo25_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 09 - Sonic in Special Stage
; ----------------------------------------------------------------------------

SonicSpecial:
		bsr.w	loc_33908				; could be bsr.s
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SSS_Index(pc,d0.w),d1
		jmp	SSS_Index(pc,d1.w)
; ===========================================================================
SSS_Index:	index offset(*),,2
		ptr loc_3391C					; 0
		ptr loc_339D6					; 2
		ptr loc_33BAE					; 4
		ptr SSS_Index					; 6 - invalid
		ptr loc_33BD8					; 8
; ===========================================================================

loc_33908:
		lea	(v_ss_ctrl_record_buffer_end).w,a1
		moveq	#$E,d0

loc_3390E:
		move.w	-4(a1),-(a1)
		dbf	d0,loc_3390E
		move.w	(v_joypad_hold).w,-(a1)
		rts
; ===========================================================================

loc_3391C:
		move.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.l	d0,ost_ss_x_pos(a0)
		move.w	#$80,d1
		move.w	d1,ost_ss_y_pos(a0)
		move.w	d0,ost_ss_y_sub(a0)
		add.w	($FFFFF73E).w,d0
		move.w	d0,ost_x_pos(a0)
		add.w	($FFFFF740).w,d1
		move.w	d1,ost_y_pos(a0)
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.l	#Map_SSS,ost_mappings(a0)
		move.w	#(vram_SpecialSonic/sizeof_cell)+tile_pal2,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.w	#$6E,ost_ss_z_pos(a0)
		clr.b	($FFFFF742).w
		move.w	#$400,ost_ss_init_flip_timer(a0)
		move.b	#$40,ost_angle(a0)
		move.b	#1,(v_sonic_last_frame_id).w
		clr.b	ost_ss_slide_timer(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		clr.b	ost_col_property(a0)
		clr.b	ost_ss_dplc_timer(a0)
		movea.l	#v_ss_shadow_sonic,a1
		move.b	#id_ShadowSpecial,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$18,ost_y_pos(a1)
		move.l	#Map_ShadSpec,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHorizShadow+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.l	a0,ost_shadspec_parent(a1)
		bra.w	SSS_LoadGFX
; ===========================================================================

loc_339D6:
		tst.b	ost_secondary_routine(a0)
		bne.s	loc_33A0E
		lea	(v_joypad_hold).w,a2
		bsr.w	loc_33F8A
		bsr.w	loc_3400A
		bsr.w	loc_33E44
		bsr.w	loc_3404A
		bsr.w	loc_34084
		bsr.w	loc_33B40
		bsr.w	loc_33EA0
		lea	(Ani_SSS).l,a1
		bsr.w	loc_33F00
		bsr.w	loc_33DFC
		bra.w	SSS_LoadGFX
; ===========================================================================

loc_33A0E:
		bsr.w	loc_33A22
		bsr.w	loc_33E44
		bsr.w	loc_3404A
		bsr.w	loc_34084
		bra.w	SSS_LoadGFX
; ===========================================================================

loc_33A22:
		moveq	#0,d0
		move.b	ost_ss_hurt_timer(a0),d0
		addi_.b	#8,d0
		move.b	d0,ost_ss_hurt_timer(a0)
		bne.s	loc_33A3E
		move.b	#0,ost_secondary_routine(a0)
		move.b	#$1E,ost_ss_dplc_timer(a0)

loc_33A3E:
		add.b	ost_angle(a0),d0
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		subi.b	#$10,d0
		lsr.b	#5,d0
		add.w	d0,d0
		move.b	byte_33A92(pc,d0.w),ost_frame(a0)
		move.b	byte_33A92+1(pc,d0.w),d0
		or.b	d0,ost_render(a0)
		move.b	ost_ss_hurt_timer(a0),d0
		subi_.b	#8,d0
		bne.s	locret_33A90
		move.b	d0,ost_col_property(a0)
		cmpa.l	#-$5000,a0
		bne.s	loc_33A7C
		tst.w	(v_rings).w
		beq.s	locret_33A90
		bra.s	loc_33A82
; ===========================================================================

loc_33A7C:
		tst.w	(v_rings_p2).w
		beq.s	locret_33A90

loc_33A82:
		jsrto	FindFreeObjSpecial,JmpTo_FindFreeObjSpecial
		bne.s	locret_33A90
		move.l	a0,ost_ringlossspec_parent(a1)
		move.b	#id_RingLossSpecial,ost_id(a1)

locret_33A90:
		rts
; ===========================================================================
byte_33A92:
		dc.b   4,  1					; 0
		dc.b   0,  0					; 2
		dc.b   4,  0					; 4
		dc.b  $C,  0					; 6
		dc.b   4,  2					; 8
		dc.b   0,  2					; 10
		dc.b   4,  3					; 12
		dc.b  $C,  1					; 14

dword_33AA2:
		dc.l   v_ss_character_art&$FFFFFF		; 0
		dc.l   (v_ss_character_art&$FFFFFF)+($58*sizeof_cell) ; 1
		dc.l   (v_ss_character_art&$FFFFFF)+($124*sizeof_cell) ; 2
		dc.l   (v_ss_character_art&$FFFFFF)+($171*sizeof_cell) ; 3
; ===========================================================================

SSS_LoadGFX:
		move.b	ost_ss_dplc_timer(a0),d0
		beq.s	loc_33AC6
		subq.b	#1,d0
		move.b	d0,ost_ss_dplc_timer(a0)
		andi.b	#1,d0
		beq.s	loc_33AC6
		rts
; ===========================================================================

loc_33AC6:
		jsrto	DisplaySprite,JmpTo42_DisplaySprite
		lea	dword_33AA2(pc),a3
		lea	(v_sonic_last_frame_id).w,a4
		move.w	#$5CA0,d4
		moveq	#0,d1

SpecialPlayer_LoadGFX:
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		cmp.b	(a4),d0
		beq.s	locret_33B3E
		move.b	d0,(a4)
		moveq	#0,d6
		cmpi.b	#4,d0
		blt.s	loc_33AFE
		addq.w	#4,d6
		cmpi.b	#$C,d0
		blt.s	loc_33AFE
		addq.w	#4,d6
		cmpi.b	#$10,d0
		blt.s	loc_33AFE
		addq.b	#4,d6

loc_33AFE:
		move.l	(a3,d6.w),d6
		add.w	d1,d0
		add.w	d0,d0
		lea	(SS_Sonic_Tails_DPLC).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_33B3E

loc_33B16:
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.w	#1,d1
		add.l	d6,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(AddDMA).l
		dbf	d5,loc_33B16

locret_33B3E:
		rts
; ===========================================================================

loc_33B40:
		lea	(v_joypad_press).w,a2

loc_33B44:
		move.b	(a2),d0
		andi.b	#$70,d0
		beq.w	locret_33BAC
		move.w	#$780,d2
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		addi.b	#-$80,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,ost_x_vel(a0)
		muls.w	d2,d0
		asr.l	#7,d0
		add.w	d0,ost_y_vel(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		move.b	#4,ost_primary_routine(a0)
		move.b	#3,ost_anim(a0)
		moveq	#0,d0
		move.b	d0,ost_anim_time(a0)
		move.b	d0,ost_anim_frame(a0)
		move.b	d0,ost_col_property(a0)
		tst.b	(f_ss_2p).w
		bne.s	loc_33B9E
		tst.w	(v_player_mode).w
		bne.s	loc_33BA2

loc_33B9E:
		not.b	(f_ss_swap_positions).w

loc_33BA2:
		move.w	#$A0,d0
		jsr	(PlaySound).l

locret_33BAC:
		rts
; ===========================================================================

loc_33BAE:
		lea	(v_joypad_hold).w,a2
		bsr.w	loc_33C32
		bsr.w	loc_33C06
		bsr.w	loc_33C54
		bsr.w	loc_33DB4
		bsr.w	loc_33E44
		bsr.w	loc_34084
		lea	(Ani_SSS).l,a1
		bsr.w	loc_33F00
		bra.w	SSS_LoadGFX
; ===========================================================================

loc_33BD8:
		lea	(v_joypad_hold).w,a2
		bsr.w	loc_33C32
		bsr.w	loc_33C06
		bsr.w	loc_33C54
		bsr.w	loc_33DB4
		bsr.w	loc_33E44
		bsr.w	loc_34084
		bsr.w	loc_33EA0
		lea	(Ani_SSS).l,a1
		bsr.w	loc_33F00
		bra.w	SSS_LoadGFX
; ===========================================================================

loc_33C06:
		move.l	ost_ss_x_pos(a0),d2
		move.l	ost_ss_y_pos(a0),d3
		move.w	ost_x_vel(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	ost_y_vel(a0),d0
		addi.w	#$A8,ost_y_vel(a0)
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,ost_ss_x_pos(a0)
		move.l	d3,ost_ss_y_pos(a0)
		rts
; ===========================================================================

loc_33C32:
		move.b	(a2),d0
		btst	#2,d0
		bne.s	loc_33C44
		btst	#3,d0
		bne.w	loc_33C4C
		rts
; ===========================================================================

loc_33C44:
		subi.w	#$40,ost_x_vel(a0)
		rts
; ===========================================================================

loc_33C4C:
		addi.w	#$40,ost_x_vel(a0)
		rts
; ===========================================================================

loc_33C54:
		moveq	#0,d2
		moveq	#0,d3
		move.w	ost_ss_y_pos(a0),d2
		bmi.s	loc_33CB4
		move.w	ost_ss_x_pos(a0),d3
		bmi.s	loc_33C90
		cmp.w	d2,d3
		bcs.s	loc_33C80
		bne.s	loc_33C76
		tst.w	d3
		bne.s	loc_33C76
		move.b	#$40,ost_angle(a0)
		rts
; ===========================================================================

loc_33C76:
		lsl.l	#5,d2
		divu.w	d3,d2
		move.b	d2,ost_angle(a0)
		rts
; ===========================================================================

loc_33C80:
		lsl.l	#5,d3
		divu.w	d2,d3
		subi.w	#$40,d3
		neg.w	d3
		move.b	d3,ost_angle(a0)
		rts
; ===========================================================================

loc_33C90:
		neg.w	d3
		cmp.w	d2,d3
		bcc.s	loc_33CA4
		lsl.l	#5,d3
		divu.w	d2,d3
		addi.w	#$40,d3
		move.b	d3,ost_angle(a0)
		rts
; ===========================================================================

loc_33CA4:
		lsl.l	#5,d2
		divu.w	d3,d2
		subi.w	#$80,d2
		neg.w	d2
		move.b	d2,ost_angle(a0)
		rts
; ===========================================================================

loc_33CB4:
		neg.w	d2
		move.w	ost_ss_x_pos(a0),d3
		bpl.s	loc_33CE0
		neg.w	d3
		cmp.w	d2,d3
		bcs.s	loc_33CD0
		lsl.l	#5,d2
		divu.w	d3,d2
		addi.w	#$80,d2
		move.b	d2,ost_angle(a0)
		rts
; ===========================================================================

loc_33CD0:
		lsl.l	#5,d3
		divu.w	d2,d3
		subi.w	#$C0,d3
		neg.w	d3
		move.b	d3,ost_angle(a0)
		rts
; ===========================================================================

loc_33CE0:
		cmp.w	d2,d3
		bcc.s	loc_33CF2
		lsl.l	#5,d3
		divu.w	d2,d3
		addi.w	#$C0,d3
		move.b	d3,ost_angle(a0)
		rts
; ===========================================================================

loc_33CF2:
		lsl.l	#5,d2
		divu.w	d3,d2
		subi.w	#$100,d2
		neg.w	d2
		move.b	d2,ost_angle(a0)
		rts
; ===========================================================================

loc_33D02:
		moveq	#0,d6
		moveq	#0,d0
		move.w	ost_ss_x_pos(a1),d0
		bpl.s	loc_33D10
		st.b	d6
		neg.w	d0

loc_33D10:
		lsl.l	#7,d0
		divu.w	ost_ss_z_pos(a1),d0
		move.b	byte_33D32(pc,d0.w),d0
		tst.b	d6
		bne.s	loc_33D24
		subi.b	#-$80,d0
		neg.b	d0

loc_33D24:
		tst.w	ost_ss_y_pos(a1)
		bpl.s	loc_33D2C
		neg.b	d0

loc_33D2C:
		move.b	d0,ost_angle(a0)
		rts
; ===========================================================================
byte_33D32:
		dc.b $40,$40,$40,$40,$41,$41,$41,$42,$42,$42,$43,$43,$43,$44,$44,$44 ; 0
		dc.b $45,$45,$45,$46,$46,$46,$47,$47,$47,$48,$48,$48,$48,$49,$49,$49 ; 16
		dc.b $4A,$4A,$4A,$4B,$4B,$4B,$4C,$4C,$4C,$4D,$4D,$4D,$4E,$4E,$4E,$4F ; 32
		dc.b $4F,$50,$50,$50,$51,$51,$51,$52,$52,$52,$53,$53,$53,$54,$54,$54 ; 48
		dc.b $55,$55,$56,$56,$56,$57,$57,$57,$58,$58,$59,$59,$59,$5A,$5A,$5B ; 64
		dc.b $5B,$5B,$5C,$5C,$5D,$5D,$5E,$5E,$5E,$5F,$5F,$60,$60,$61,$61,$62 ; 80
		dc.b $62,$63,$63,$64,$64,$65,$65,$66,$66,$67,$67,$68,$68,$69,$6A,$6A ; 96
		dc.b $6B,$6C,$6C,$6D,$6E,$6E,$6F,$70,$71,$72,$73,$74,$75,$77,$78,$7A ; 112
		dc.b $80					; 128
		even
; ===========================================================================

loc_33DB4:
		move.w	ost_ss_y_pos(a0),d0
		ble.s	locret_33DFA
		muls.w	d0,d0
		move.w	ost_ss_x_pos(a0),d1
		muls.w	d1,d1
		add.w	d1,d0
		move.w	ost_ss_z_pos(a0),d1
		mulu.w	d1,d1
		cmp.l	d1,d0
		bcs.s	locret_33DFA
		move.b	#2,ost_primary_routine(a0)
		bclr	#status_jump_bit,ost_primary_status(a0)
		moveq	#0,d0
		move.w	d0,ost_x_vel(a0)
		move.w	d0,ost_y_vel(a0)
		move.w	d0,ost_inertia(a0)
		move.b	d0,ost_ss_slide_timer(a0)
		bset	#status_underwater_bit,ost_primary_status(a0)
		bsr.w	loc_3404A
		bsr.w	loc_34084

locret_33DFA:
		rts
; ===========================================================================

loc_33DFC:
		tst.b	ost_col_property(a0)
		beq.s	locret_33E42
		clr.b	ost_col_property(a0)
		tst.b	ost_ss_dplc_timer(a0)
		bne.s	locret_33E42
		clr.b	ost_inertia(a0)
		cmpa.l	#v_ost_player1,a0
		bne.s	loc_33E24
		st.b	($FFFFF742).w
		tst.w	(v_rings).w
		beq.s	loc_33E38
		bra.s	loc_33E2E
; ===========================================================================

loc_33E24:
		clr.b	($FFFFF742).w
		tst.w	(v_rings_p2).w
		beq.s	loc_33E38

loc_33E2E:
		move.w	#$C6,d0
		jsr	(PlaySound).l

loc_33E38:
		move.b	#2,ost_secondary_routine(a0)
		clr.b	ost_ss_hurt_timer(a0)

locret_33E42:
		rts
; ===========================================================================

loc_33E44:
		tst.w	(v_player_mode).w
		bne.s	locret_33E8E
		move.w	ost_ss_z_pos(a0),d0
		cmpa.l	#v_ost_player1,a0
		bne.s	loc_33E5E
		tst.b	($FFFFF742).w
		beq.s	loc_33E6E
		bra.s	loc_33E64
; ===========================================================================

loc_33E5E:
		tst.b	($FFFFF742).w
		bne.s	loc_33E6E

loc_33E64:
		cmpi.w	#$80,d0
		beq.s	locret_33E8E
		addq.w	#1,d0
		bra.s	loc_33E76
; ===========================================================================

loc_33E6E:
		cmpi.w	#$6E,d0
		beq.s	locret_33E8E
		subq.w	#1,d0

loc_33E76:
		move.w	d0,ost_ss_z_pos(a0)
		cmpi.w	#$77,d0
		bcc.s	loc_33E88
		move.b	#3,ost_priority(a0)
		rts
; ===========================================================================

loc_33E88:
		move.b	#2,ost_priority(a0)

locret_33E8E:
		rts
; ===========================================================================
byte_33E90:
		dc.b   1,  1					; 0
		dc.b   0,  0					; 2
		dc.b   1,  0					; 4
		dc.b   2,  0					; 6
		dc.b   1,  2					; 8
		dc.b   0,  2					; 10
		dc.b   1,  3					; 12
		dc.b   2,  1					; 14
; ===========================================================================

loc_33EA0:
		btst	#status_jump_bit,ost_primary_status(a0)
		beq.s	loc_33EB6
		move.b	#3,ost_anim(a0)
		andi.b	#-4,ost_primary_status(a0)
		rts
; ===========================================================================

loc_33EB6:
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		subi.b	#$10,d0
		lsr.b	#5,d0
		move.b	d0,d1
		add.w	d0,d0
		move.b	byte_33E90(pc,d0.w),d2
		cmp.b	ost_anim(a0),d2
		bne.s	loc_33ED6
		cmp.b	ost_ss_last_angle_index(a0),d1
		beq.s	locret_33EFE

loc_33ED6:
		move.b	d1,ost_ss_last_angle_index(a0)
		move.b	d2,ost_anim(a0)
		move.b	byte_33E90+1(pc,d0.w),d0
		andi.b	#-4,ost_primary_status(a0)
		or.b	d0,ost_primary_status(a0)
		cmpi.b	#1,d1
		beq.s	loc_33EF8
		cmpi.b	#5,d1
		bne.s	locret_33EFE

loc_33EF8:
		move.w	#$400,ost_ss_init_flip_timer(a0)

locret_33EFE:
		rts
; ===========================================================================

loc_33F00:
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		cmp.b	ost_anim_restart(a0),d0
		beq.s	loc_33F1C
		move.b	#0,ost_anim_frame(a0)
		move.b	d0,ost_anim_restart(a0)
		move.b	#0,ost_anim_time(a0)

loc_33F1C:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_33F88
		add.w	d0,d0
		adda.w	(a1,d0.w),a1
		move.b	(v_ss_player_anim_frame_timer).w,d0
		lsr.b	#1,d0
		move.b	d0,ost_anim_time(a0)
		cmpi.b	#0,ost_anim(a0)				; could be optimized to tst.b
		bne.s	loc_33F54
		subi_.b	#1,ost_ss_flip_timer(a0)
		bgt.s	loc_33F54
		bchg	#status_xflip_bit,ost_primary_status(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		move.b	ost_ss_init_flip_timer(a0),ost_ss_flip_timer(a0)

loc_33F54:
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		bpl.s	loc_33F6A
		move.b	#0,ost_anim_frame(a0)
		move.b	1(a1),d0

loc_33F6A:
		andi.b	#$7F,d0
		move.b	d0,ost_frame(a0)
		move.b	ost_primary_status(a0),d1
		andi.b	#3,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		addq.b	#1,ost_anim_frame(a0)

locret_33F88:
		rts
; ===========================================================================

loc_33F8A:
		move.w	ost_inertia(a0),d2
		move.b	(a2),d0
		btst	#2,d0
		bne.s	loc_33FDC
		btst	#3,d0
		bne.w	loc_33FEC
		bset	#status_underwater_bit,ost_primary_status(a0)
		bne.s	loc_33FAC
		move.b	#$1E,ost_ss_slide_timer(a0)

loc_33FAC:
		move.b	ost_angle(a0),d0
		bmi.s	loc_33FC4
		subi.b	#$38,d0
		cmpi.b	#$10,d0
		bcc.s	loc_33FC4
		move.w	d2,d1
		asr.w	#3,d1
		sub.w	d1,d2
		bra.s	loc_33FCA
; ===========================================================================

loc_33FC4:
		move.w	d2,d1
		asr.w	#3,d1
		sub.w	d1,d2

loc_33FCA:
		move.w	d2,ost_inertia(a0)
		move.b	ost_ss_slide_timer(a0),d0
		beq.s	locret_33FDA
		subq.b	#1,d0
		move.b	d0,ost_ss_slide_timer(a0)

locret_33FDA:
		rts
; ===========================================================================

loc_33FDC:
		addi.w	#$60,d2
		cmpi.w	#$600,d2
		ble.s	loc_33FFA
		move.w	#$600,d2
		bra.s	loc_33FFA
; ===========================================================================

loc_33FEC:
		subi.w	#$60,d2
		cmpi.w	#-$600,d2
		bge.s	loc_33FFA
		move.w	#-$600,d2

loc_33FFA:
		move.w	d2,ost_inertia(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		clr.b	ost_ss_slide_timer(a0)
		rts
; ===========================================================================

loc_3400A:
		tst.b	ost_ss_slide_timer(a0)
		bne.s	loc_34024
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d1
		asr.l	#8,d1
		add.w	d1,ost_inertia(a0)

loc_34024:
		move.b	ost_angle(a0),d0
		bpl.s	locret_34048
		addi_.b	#4,d0
		cmpi.b	#-$78,d0
		bcs.s	locret_34048
		move.w	ost_inertia(a0),d0
		bpl.s	loc_3403C
		neg.w	d0

loc_3403C:
		cmpi.w	#$100,d0
		bcc.s	locret_34048
		move.b	#8,ost_primary_routine(a0)

locret_34048:
		rts
; ===========================================================================

loc_3404A:
		moveq	#0,d0
		moveq	#0,d1
		move.w	ost_inertia(a0),d2
		bpl.s	loc_3405E
		neg.w	d2
		lsr.w	#8,d2
		sub.b	d2,ost_angle(a0)
		bra.s	loc_34064
; ===========================================================================

loc_3405E:
		lsr.w	#8,d2
		add.b	d2,ost_angle(a0)

loc_34064:
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	ost_ss_z_pos(a0),d1
		asr.l	#8,d1
		move.w	d1,ost_ss_x_pos(a0)
		muls.w	ost_ss_z_pos(a0),d0
		asr.l	#8,d0
		move.w	d0,ost_ss_y_pos(a0)
		rts
; ===========================================================================

loc_34084:
		move.w	ost_ss_x_pos(a0),d0
		muls.w	#$CC,d0
		asr.l	#8,d0
		add.w	($FFFFF73E).w,d0
		move.w	d0,ost_x_pos(a0)
		move.w	ost_ss_y_pos(a0),d0
		add.w	($FFFFF740).w,d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 63 - Character shadow in Special Stage
; ----------------------------------------------------------------------------

ShadowSpecial:

		rsobj ShadowSpecial,$38
ost_shadspec_parent:	rs.l 1					; $38; parent player of this shadow
		rsobjend

		movea.l	ost_shadspec_parent(a0),a1
		cmpa.l	#-$5000,a1
		bne.s	loc_340BC
		movea.l	#-$5000,a1
		bsr.s	loc_340CC
		jmpto	DisplaySprite,JmpTo42_DisplaySprite

; ===========================================================================

loc_340BC:
		movea.l	#-$4FC0,a1
		bsr.s	loc_340CC
		bsr.w	loc_341BA
		jmpto	DisplaySprite,JmpTo42_DisplaySprite
; ===========================================================================

loc_340CC:
		cmpi.b	#2,ost_primary_routine(a1)
		beq.w	loc_34108
		bsr.w	loc_33D02
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		muls.w	ost_ss_z_pos(a1),d1
		muls.w	#$CC,d1
		swap	d1
		add.w	($FFFFF73E).w,d1
		move.w	d1,ost_x_pos(a0)
		muls.w	ost_ss_z_pos(a1),d0
		asr.l	#8,d0
		add.w	($FFFFF740).w,d0
		move.w	d0,ost_y_pos(a0)
		bra.w	loc_3411A
; ===========================================================================

loc_34108:
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_angle(a1),ost_angle(a0)

loc_3411A:
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		subi.b	#$10,d0
		lsr.b	#5,d0
		move.b	d0,d1
		lsl.w	#3,d0
		lea	word_3417A(pc),a2
		adda.w	d0,a2
		move.w	(a2)+,ost_tile(a0)
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a0)
		move.w	(a2)+,d0
		add.w	d0,ost_y_pos(a0)
		move.b	(a2)+,ost_frame(a0)
		move.b	ost_render(a0),d0
		andi.b	#-4,d0
		or.b	(a2)+,d0
		move.b	d0,ost_render(a0)
		tst.b	ost_angle(a0)
		bpl.s	locret_34178
		cmpi.b	#3,d1
		beq.s	loc_34164
		cmpi.b	#7,d1
		bne.s	loc_3416A

loc_34164:
		addi_.b	#3,ost_frame(a0)

loc_3416A:
		move.w	($FFFFF740).w,d1
		sub.w	ost_y_pos(a0),d1
		add.w	d1,d1
		add.w	d1,ost_y_pos(a0)

locret_34178:
		rts
; ===========================================================================
word_3417A:
		dc.w $6262,  $14,  $14,	$101			; 0
		dc.w $623C,    0,  $18,	   0			; 4
		dc.w $6262,$FFEC,  $14,	$100			; 8
		dc.w $629C,$FFEC,    0,	$200			; 12
		dc.w $6262,$FFEC,$FFEC,	$700			; 16
		dc.w $623C,    0,$FFE8,	$900			; 20
		dc.w $6262,  $14,$FFEC,	$701			; 24
		dc.w $629C,  $14,    0,	$201			; 28
; ===========================================================================

loc_341BA:
		cmpi.b	#1,ost_anim(a1)
		bne.s	locret_341E0
		move.b	ost_primary_status(a1),d1
		andi.w	#3,d1
		cmpi.b	#2,d1
		bcc.s	locret_341E0
		move.b	byte_341E2(pc,d1.w),d0
		ext.w	d0
		add.w	d0,ost_x_pos(a0)
		subi_.w	#4,ost_y_pos(a0)

locret_341E0:
		rts
; ===========================================================================
byte_341E2:
		dc.b   4					; 0
		dc.b $FC					; 1

Ani_SSS:	index offset(*)
		ptr byte_341EE					; 0
		ptr byte_341F4					; 1
		ptr byte_341FE					; 2
		ptr byte_34204					; 3
		ptr byte_34208					; 4

byte_341EE:
		dc.b   3,  0,  1,  2,  3,$FF

byte_341F4:
		dc.b   3,  4,  5,  6,  7,  8,  9, $A, $B,$FF

byte_341FE:
		dc.b   3, $C, $D, $E, $F,$FF

byte_34204:
		dc.b   1,$10,$11,$FF

byte_34208:
		dc.b   3,  0,  4, $C,  4,  0,  4, $C,  4,$FF
; ===========================================================================

		include "mappings/sprite/Special Stage Sonic.asm"
		include "mappings/sprite/Special Stage Shadows.asm"
		include "mappings/spriteDPLC/Special Stage Sonic, Tails, & Tails' Tails.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo42_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo_FindFreeObjSpecial:
		jmp	(FindFreeObjSpecial).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 10 - Tails in Special Stage
; ----------------------------------------------------------------------------

TailsSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TSS_Index(pc,d0.w),d1
		jmp	TSS_Index(pc,d1.w)
; ===========================================================================
TSS_Index:	index offset(*),,2
		ptr loc_34804					; 0
		ptr loc_34908					; 2
		ptr loc_349F2					; 2
		ptr TSS_Index					; 6	- invalid
		ptr loc_34A24					; 8
; ===========================================================================

loc_34804:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.w	d0,ost_ss_x_pos(a0)
		move.w	#$80,d1
		move.w	d1,ost_ss_y_pos(a0)
		add.w	($FFFFF73E).w,d0
		move.w	d0,ost_x_pos(a0)
		add.w	($FFFFF740).w,d1
		move.w	d1,ost_y_pos(a0)
		move.b	#$E,ost_height(a0)
		move.b	#7,ost_width(a0)
		move.l	#Map_TSS,ost_mappings(a0)
		move.w	#(vram_SpecialTails/sizeof_cell)+tile_pal3,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#2,ost_priority(a0)
		move.w	#$80,ost_ss_z_pos(a0)
		tst.w	(v_player_mode).w
		beq.s	loc_34864
		move.b	#3,ost_priority(a0)
		move.w	#$6E,ost_ss_z_pos(a0)

loc_34864:
		move.w	#$400,ost_ss_init_flip_timer(a0)
		move.b	#$40,ost_angle(a0)
		move.b	#1,(v_tails_last_frame_id).w
		clr.b	ost_col_property(a0)
		clr.b	ost_ss_dplc_timer(a0)
		bsr.w	TSS_LoadGFX
		movea.l	#v_ss_shadow_tails,a1
		move.b	#id_ShadowSpecial,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$18,ost_y_pos(a1)
		move.l	#Map_ShadSpec,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHorizShadow+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.l	a0,ost_shadspec_parent(a1)
		movea.l	#v_ss_tails_tails,a1
		move.b	#id_TailsTailsSpecial,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	#Map_TTSpec,ost_mappings(a1)
		move.w	#(vram_SpecialTails_Tails/sizeof_cell)+tile_pal3,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	ost_priority(a0),ost_priority(a1)
		subi_.b	#1,ost_priority(a1)
		move.l	a0,ost_ttspec_parent(a1)
		movea.l	a1,a0
		move.b	#1,(v_tailstails_last_frame_id).w
		clr.b	ost_ss_dplc_timer(a0)
		movea.l	ost_ttspec_parent(a0),a0
		rts
; ===========================================================================

loc_34908:
		tst.b	ost_secondary_routine(a0)
		bne.s	loc_3495E
		bsr.w	loc_34972
		lea	(v_joypad2_hold).w,a2
		tst.w	(v_player_mode).w
		beq.s	loc_34920
		lea	(v_joypad_hold).w,a2

loc_34920:
		bsr.w	loc_33F8A
		bsr.w	loc_3400A
		moveq	#1,d0
		bsr.w	loc_33E44
		bsr.w	loc_3404A
		bsr.w	loc_34084
		lea	(v_joypad2_press).w,a2
		tst.w	(v_player_mode).w
		beq.s	loc_34944
		lea	(v_joypad_press).w,a2

loc_34944:
		bsr.w	loc_33B44
		bsr.w	loc_33EA0
		lea	(Ani_TSS).l,a1
		bsr.w	loc_33F00
		bsr.w	loc_33DFC
		bra.w	TSS_LoadGFX
; ===========================================================================

loc_3495E:
		bsr.w	loc_33A22
		bsr.w	loc_33E44
		bsr.w	loc_3404A
		bsr.w	loc_34084
		bra.w	TSS_LoadGFX
; ===========================================================================

loc_34972:
		tst.b	(f_ss_2p).w
		bne.s	locret_3497E
		tst.w	(v_player_mode).w
		beq.s	loc_34980

locret_3497E:
		rts
; ===========================================================================

loc_34980:
		move.b	(v_joypad2_hold).w,d0
		andi.b	#$7F,d0
		beq.s	loc_349A2
		moveq	#0,d0
		moveq	#3,d1
		lea	(v_ss_ctrl_record_buffer).w,a1

loc_34992:
		move.l	d0,(a1)
		move.l	d0,(a1)
		dbf	d1,loc_34992
		move.w	#$B4,(v_tails_control_counter).w
		rts
; ===========================================================================

loc_349A2:
		tst.w	(v_tails_control_counter).w
		beq.s	loc_349AE
		subq.w	#1,(v_tails_control_counter).w
		rts
; ===========================================================================

loc_349AE:
		lea	(v_ss_last_ctrl_record).w,a1
		move.w	(a1),(v_joypad2_hold).w
		rts
; ===========================================================================
dword_349B8:
		dc.l   (v_ss_character_art&$FFFFFF)+($183*sizeof_cell) ; 0
		dc.l   (v_ss_character_art&$FFFFFF)+($1C0*sizeof_cell) ; 1
		dc.l   (v_ss_character_art&$FFFFFF)+($264*sizeof_cell) ; 2
		dc.l   (v_ss_character_art&$FFFFFF)+($29E*sizeof_cell) ; 3
; ===========================================================================

TSS_LoadGFX:
		move.b	ost_ss_dplc_timer(a0),d0
		beq.s	loc_349DC
		subq.b	#1,d0
		move.b	d0,ost_ss_dplc_timer(a0)
		andi.b	#1,d0
		beq.s	loc_349DC
		rts
; ===========================================================================

loc_349DC:
		jsrto	DisplaySprite,JmpTo43_DisplaySprite
		lea	dword_349B8(pc),a3
		lea	(v_tails_last_frame_id).w,a4
		move.w	#$6000,d4
		moveq	#$12,d1
		bra.w	SpecialPlayer_LoadGFX
; ===========================================================================

loc_349F2:
		lea	(v_joypad2_hold).w,a2
		tst.w	(v_player_mode).w
		beq.s	loc_34A00
		lea	(v_joypad_hold).w,a2

loc_34A00:
		bsr.w	loc_33C32
		bsr.w	loc_33C06
		bsr.w	loc_33DB4
		bsr.w	loc_33E44
		bsr.w	loc_34084
		bsr.w	loc_33C54
		lea	(Ani_TSS).l,a1
		bsr.w	loc_33F00
		bra.s	TSS_LoadGFX
; ===========================================================================

loc_34A24:
		lea	(v_joypad2_hold).w,a2
		tst.w	(v_player_mode).w
		beq.s	loc_34A32
		lea	(v_joypad_hold).w,a2

loc_34A32:
		bsr.w	loc_33C32
		bsr.w	loc_33C06
		bsr.w	loc_33C54
		bsr.w	loc_33DB4
		bsr.w	loc_33E44
		bsr.w	loc_34084
		bsr.w	loc_33EA0
		lea	(Ani_TSS).l,a1
		bsr.w	loc_33F00
		bra.w	TSS_LoadGFX
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 88 - Tails' tails in Special Stage
; ----------------------------------------------------------------------------

TailsTailsSpecial:

		rsobj TailsTailsSpecial,$38
ost_ttspec_parent:	rs.l 1					; $38
		rsobjend

		movea.l	ost_ttspec_parent(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.b	ost_render(a1),ost_render(a0)
		move.b	ost_primary_status(a1),ost_primary_status(a0)
		move.b	ost_anim(a1),ost_anim(a0)
		move.b	ost_priority(a1),d0
		subq.b	#1,d0
		move.b	d0,ost_priority(a0)
		cmpi.b	#3,ost_anim(a0)
		bcc.s	locret_34A9E
		lea	(Ani_TTSpec).l,a1
		jsrto	AnimateSprite,JmpTo23_AnimateSprite
		bra.w	TTSS_LoadGFX
; ===========================================================================

locret_34A9E:
		rts
; ===========================================================================
dword_34AA0:
		dc.l	(v_ss_character_art&$FFFFFF)+($2AE*sizeof_cell)
		dc.l	(v_ss_character_art&$FFFFFF)+($2E3*sizeof_cell)
		dc.l	(v_ss_character_art&$FFFFFF)+($31E*sizeof_cell)
; ===========================================================================

TTSS_LoadGFX:
		movea.l	ost_ttspec_parent(a0),a1
		move.b	ost_ss_dplc_timer(a1),d0
		beq.s	loc_34ABE
		andi.b	#1,d0
		beq.s	loc_34ABE
		rts
; ===========================================================================

loc_34ABE:
		jsrto	DisplaySprite,JmpTo43_DisplaySprite
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		cmp.b	(v_tailstails_last_frame_id).w,d0
		beq.s	locret_34B1A
		move.b	d0,(v_tailstails_last_frame_id).w
		moveq	#0,d6
		cmpi.b	#7,d0
		blt.s	loc_34AE4
		addq.w	#4,d6
		cmpi.b	#$E,d0
		blt.s	loc_34AE4
		addq.w	#4,d6

loc_34AE4:
		move.l	dword_34AA0(pc,d6.w),d6
		addi.w	#$24,d0
		add.w	d0,d0
		lea	(SS_Sonic_Tails_DPLC).l,a2
		adda.w	(a2,d0.w),a2
		move.w	#$62C0,d2
		moveq	#0,d1
		move.w	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.w	#1,d1
		add.l	d6,d1
		jsr	(AddDMA).l

locret_34B1A:
		rts
; ===========================================================================
Ani_TSS:	index offset(*)
		ptr byte_34B24					; 0
		ptr byte_34B2A					; 1
		ptr byte_34B34					; 2
		ptr byte_34B3A					; 3

byte_34B24:
		dc.b   3,  0,  1,  2,  3,$FF

byte_34B2A:
		dc.b   3,  4,  5,  6,  7,  8,  9, $A, $B,$FF

byte_34B34:
		dc.b   3, $C, $D, $E, $F,$FF

byte_34B3A:
		dc.b   1,$10,$11,$FF
; ===========================================================================

		include "mappings/sprite/Special Stage Tails.asm"

; ===========================================================================

Ani_TTSpec:	index offset(*)
		ptr byte_34D8C					; 0
		ptr byte_34D95					; 1
		ptr byte_34D9E					; 2

byte_34D8C:
		dc.b   3,  0,  1,  2,  3,  4,  5,  6,$FF

byte_34D95:
		dc.b   3,  7,  8,  9, $A, $B, $C, $D,$FF

byte_34D9E:
		dc.b   3, $E, $F,$10,$11,$12,$13,$14,$FF,  0
; ===========================================================================

		include "mappings/sprite/Special Stage Tails' Tails.asm"

; ===========================================================================

	if RemoveJmpTos=0
JmpTo43_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo23_AnimateSprite:
		jmp	(AnimateSprite).l

		align 4
	endc
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 61 - Special Stage Bombs
; ----------------------------------------------------------------------------

BombSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_34EBE(pc,d0.w),d1
		jmp	off_34EBE(pc,d1.w)
; ===========================================================================
off_34EBE:	index offset(*),,2
		ptr loc_34EC6					; 0
		ptr loc_34F06					; 1
		ptr loc_3533A					; 2
		ptr loc_34F6A					; 3
; ===========================================================================

loc_34EC6:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$7F,ost_x_pos(a0)
		move.w	#$58,ost_y_pos(a0)
		move.l	#Map_BombSpec,ost_mappings(a0)
		move.w	#tile_Nem_SpecialBomb+tile_pal2,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#id_col_12x20,ost_col_type(a0)
		move.b	#-1,(f_unused_ss_bomb).w		; never used again
		tst.b	ost_angle(a0)
		bmi.s	loc_34F06
		bsr.w	loc_3529C

loc_34F06:
		bsr.w	loc_3512A
		bsr.w	loc_351A0
		lea	(Ani_BombSpec).l,a1
		bsr.w	loc_3539E
		tst.b	ost_render(a0)
		bpl.s	locret_34F26
		bsr.w	loc_34F28
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

locret_34F26:
		rts
; ===========================================================================

loc_34F28:
		move.w	#8,d6
		bsr.w	loc_350A0
		bcc.s	locret_34F68
		move.b	#1,ost_col_property(a1)
		move.w	#$CB,d0
		jsr	(PlaySound2).l
		move.b	#6,ost_primary_routine(a0)
		move.b	#0,ost_anim_frame(a0)
		move.b	#0,ost_anim_time(a0)
		move.l	$34(a0),d0
		beq.s	locret_34F68
		move.l	#0,$34(a0)
		movea.l	d0,a1
		st.b	$2A(a1)

locret_34F68:
		rts
; ===========================================================================

loc_34F6A:
		move.b	#$A,ost_anim(a0)
		move.w	#tile_Nem_SpecialExplosion+tile_pal3,ost_tile(a0)
		bsr.w	loc_34F90
		bsr.w	loc_3512A
		bsr.w	loc_351A0
		lea	(Ani_BombSpec).l,a1
		jsrto	AnimateSprite,JmpTo24_AnimateSprite
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_34F90:
		cmpi.w	#4,$30(a0)
		bcc.s	locret_34F9E
		move.b	#1,ost_priority(a0)

locret_34F9E:
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 60 - Special Stage rings
; ----------------------------------------------------------------------------

RingsSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_34FAE(pc,d0.w),d1
		jmp	off_34FAE(pc,d1.w)
; ===========================================================================
off_34FAE:	index offset(*),,2
		ptr loc_34FB6					; 0
		ptr loc_34FF0					; 2
		ptr loc_3533A					; 4
		ptr loc_35010					; 6
; ===========================================================================

loc_34FB6:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$7F,ost_x_pos(a0)
		move.w	#$58,ost_y_pos(a0)
		move.l	#Map_RingSpec,ost_mappings(a0)
		move.w	#tile_Nem_SpecialRings+tile_pal4,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#3,ost_priority(a0)
		move.b	#id_col_20x20,ost_col_type(a0)
		tst.b	ost_angle(a0)
		bmi.s	loc_34FF0
		bsr.w	loc_3529C

loc_34FF0:
		bsr.w	loc_3512A
		bsr.w	loc_351A0
		bsr.w	loc_35036

loc_34FFC:
		lea	(Ani_RingSpec).l,a1
		bsr.w	loc_3539E
		tst.b	ost_render(a0)
		bmi.w	JmpTo44_DisplaySprite
		rts
; ===========================================================================

loc_35010:
		move.b	#$A,ost_anim(a0)
		move.w	#tile_Nem_SpecialStars+tile_pal3,ost_tile(a0)
		bsr.w	loc_34F90
		bsr.w	loc_3512A
		bsr.w	loc_351A0
		lea	(Ani_RingSpec).l,a1
		jsrto	AnimateSprite,JmpTo24_AnimateSprite
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_35036:
		move.w	#$A,d6
		bsr.w	loc_350A0
		bcc.s	locret_3509E
		cmpa.l	#-$5000,a1
		bne.s	loc_3504E
		addq.w	#1,(v_rings).w
		bra.s	loc_35052
; ===========================================================================

loc_3504E:
		addq.w	#1,(v_rings_p2).w

loc_35052:
		addq.b	#1,ost_ss_rings_units(a1)
		cmpi.b	#$A,ost_ss_rings_units(a1)
		blt.s	loc_3507A
		addq.b	#1,ost_ss_rings_tens(a1)
		move.b	#0,ost_ss_rings_units(a1)
		cmpi.b	#$A,ost_ss_rings_tens(a1)
		blt.s	loc_3507A
		addq.b	#1,ost_ss_rings_hundreds(a1)
		move.b	#0,ost_ss_rings_tens(a1)

loc_3507A:
		move.b	#6,ost_primary_routine(a0)
		move.l	$34(a0),d0
		beq.s	loc_35094

loc_35086:
		move.l	#0,$34(a0)
		movea.l	d0,a1
		st.b	$2A(a1)

loc_35094:
		move.w	#sfx_Ring,d0
		jsr	(PlaySound2).l

locret_3509E:
		rts
; ===========================================================================

loc_350A0:
		cmpi.b	#8,ost_anim(a0)
		bne.s	loc_350DC
		tst.b	ost_col_type(a0)
		beq.s	loc_350DC
		lea	(v_ost_player1).w,a2
		lea	(v_ost_player2).w,a3
		move.w	$34(a2),d0
		cmp.w	$34(a3),d0
		bcs.s	loc_350CE
		movea.l	a3,a1
		bsr.w	loc_350E2
		bcs.s	locret_350E0
		movea.l	a2,a1
		bra.w	loc_350E2
; ===========================================================================

loc_350CE:
		movea.l	a2,a1
		bsr.w	loc_350E2
		bcs.s	locret_350E0
		movea.l	a3,a1
		bra.w	loc_350E2
; ===========================================================================

loc_350DC:
		move	#0,ccr

locret_350E0:
		rts
; ===========================================================================

loc_350E2:
		tst.b	ost_id(a1)
		beq.s	loc_3511A
		cmpi.b	#2,ost_primary_routine(a1)
		bne.s	loc_3511A
		tst.b	ost_secondary_routine(a1)
		bne.s	loc_3511A
		move.b	ost_angle(a1),d0
		move.b	ost_angle(a0),d1
		move.b	d1,d2
		add.b	d6,d1
		bcs.s	loc_35110
		sub.b	d6,d2
		bcs.s	loc_35112
		cmp.b	d1,d0
		bcc.s	loc_3511A
		cmp.b	d2,d0
		bcc.s	loc_35120
		bra.s	loc_3511A
; ===========================================================================

loc_35110:
		sub.b	d6,d2

loc_35112:
		cmp.b	d1,d0
		bcs.s	loc_35120
		cmp.b	d2,d0
		bcc.s	loc_35120

loc_3511A:
		move	#0,ccr
		rts
; ===========================================================================

loc_35120:
		clr.b	ost_col_type(a0)
		move	#1,ccr
		rts
; ===========================================================================

loc_3512A:
		btst	#status_broken_bit,ost_primary_status(a0)
		bne.s	loc_3516C
		cmpi.b	#4,(v_ss_track_drawing_index).w
		bne.s	loc_35146
		subi.l	#$CCCC,$30(a0)
		ble.s	loc_3516C
		bra.s	loc_35150
; ===========================================================================

loc_35146:
		subi.l	#$CCCD,$30(a0)
		ble.s	loc_3516C

loc_35150:
		cmpi.b	#$A,ost_anim(a0)
		beq.s	locret_3516A
		move.w	$30(a0),d0
		cmpi.w	#$1D,d0
		ble.s	loc_35164
		moveq	#$1E,d0

loc_35164:
		move.b	byte_35180(pc,d0.w),ost_anim(a0)

locret_3516A:
		rts
; ===========================================================================

loc_3516C:
		move.l	(sp)+,d0
		move.l	$34(a0),d0
		beq.w	JmpTo63_DeleteObject
		movea.l	d0,a1
		st.b	$2A(a1)

    if RemoveJmpTos
JmpTo63_DeleteObject:
    endc

		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================
byte_35180:
		dc.b   9,  9,  9,  8,  8,  7,  7,  6,  6,  5,  5,  4,  4,  3,  3,  3
		dc.b   2,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0
		even
; ===========================================================================

loc_351A0:
		move.w	d7,-(sp)
		moveq	#0,d2
		moveq	#0,d3
		moveq	#0,d4
		moveq	#0,d5
		moveq	#0,d6
		moveq	#0,d7
		movea.l	(v_ss_ctrl_record_buffer_end).w,a1
		move.w	$30(a0),d0
		beq.w	loc_35258
		cmp.w	(a1)+,d0
		bgt.w	loc_35258
		subq.w	#1,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		tst.b	(v_ss_track_orientation).w
		bne.w	loc_35260
		move.b	4(a1,d0.w),d6
		move.b	5(a1,d0.w),d7
		beq.s	loc_351E8
		move.b	ost_angle(a0),d1
		cmp.b	d6,d1
		bcs.s	loc_351E8
		cmp.b	d7,d1
		bcs.s	loc_35258

loc_351E8:
		move.b	(a1,d0.w),d2
		move.b	2(a1,d0.w),d4
		move.b	3(a1,d0.w),d5
		move.b	1(a1,d0.w),d3

loc_351F8:
		bpl.s	loc_35202
		cmpi.b	#$48,d3
		bcs.s	loc_35202
		ext.w	d3

loc_35202:
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo14_CalcSine
		muls.w	d4,d1
		muls.w	d5,d0
		asr.l	#8,d0
		asr.l	#8,d1
		add.w	d2,d1
		add.w	d3,d0
		move.w	d1,ost_x_pos(a0)
		move.w	d0,ost_y_pos(a0)
		move.l	$34(a0),d0
		beq.s	loc_3524E
		movea.l	d0,a1
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo14_CalcSine
		move.w	d4,d7
		lsr.w	#2,d7
		add.w	d7,d4
		muls.w	d4,d1
		move.w	d5,d7
		asr.w	#2,d7
		add.w	d7,d5
		muls.w	d5,d0
		asr.l	#8,d0
		asr.l	#8,d1
		add.w	d2,d1
		add.w	d3,d0
		move.w	d1,ost_x_pos(a1)
		move.w	d0,ost_y_pos(a1)

loc_3524E:
		ori.b	#render_onscreen,ost_render(a0)

loc_35254:
		move.w	(sp)+,d7
		rts
; ===========================================================================

loc_35258:
		andi.b	#(~render_onscreen)&$FF,ost_render(a0)
		bra.s	loc_35254
; ===========================================================================

loc_35260:
		move.b	#-$80,d1
		move.b	4(a1,d0.w),d6
		move.b	5(a1,d0.w),d7
		beq.s	loc_35282
		sub.w	d1,d6
		sub.w	d1,d7
		neg.w	d6
		neg.w	d7
		move.b	ost_angle(a0),d1
		cmp.b	d7,d1
		bcs.s	loc_35282
		cmp.b	d6,d1
		bcs.s	loc_35258

loc_35282:
		move.b	(a1,d0.w),d2
		move.b	2(a1,d0.w),d4
		move.b	3(a1,d0.w),d5
		subi.w	#$100,d2
		neg.w	d2
		move.b	1(a1,d0.w),d3
		bra.w	loc_351F8
; ===========================================================================

loc_3529C:
		jsrto	FindNextFreeObjSpecial,JmpTo_FindNextFreeObjSpecial
		bne.w	locret_3532C
		move.l	a0,$34(a1)
		move.b	ost_id(a0),ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.l	#Map_ShadSpec,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHorizShadow+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#5,ost_priority(a1)
		move.b	ost_angle(a0),d0
		cmpi.b	#$10,d0
		bgt.s	loc_352E6
		bset	#render_xflip_bit,ost_render(a1)
		move.b	#2,$2B(a1)
		move.l	a1,$34(a0)
		rts
; ===========================================================================

loc_352E6:
		cmpi.b	#$30,d0
		bgt.s	loc_352FE
		bset	#render_xflip_bit,ost_render(a1)

loc_352F2:
		move.b	#1,$2B(a1)
		move.l	a1,$34(a0)
		rts
; ===========================================================================

loc_352FE:
		cmpi.b	#$50,d0
		bgt.s	loc_35310
		move.b	#0,$2B(a1)
		move.l	a1,$34(a0)
		rts
; ===========================================================================

loc_35310:
		cmpi.b	#$70,d0
		bgt.s	loc_35322
		move.b	#1,$2B(a1)
		move.l	a1,$34(a0)
		rts
; ===========================================================================

loc_35322:
		move.b	#2,$2B(a1)
		move.l	a1,$34(a0)

locret_3532C:
		rts
; ===========================================================================
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b   0					; 2
		dc.b $18					; 3
		dc.b   0					; 4
		dc.b $14					; 5
		dc.b   0					; 6
		dc.b $14					; 7
		dc.b   0					; 8
		dc.b $14					; 9
		dc.b   0					; 10
		dc.b   0					; 11
; ===========================================================================

loc_3533A:
		tst.b	$2A(a0)
		bne.w	loc_3539A
		movea.l	$34(a0),a1
		tst.b	ost_render(a1)
		bmi.s	loc_3534E
		rts
; ===========================================================================

loc_3534E:
		moveq	#9,d0
		sub.b	ost_anim(a1),d0
		addi_.b	#1,d0
		cmpi.b	#$A,d0
		bne.s	loc_35362
		move.w	#9,d0

loc_35362:
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		moveq	#0,d1
		move.b	$2B(a0),d1
		beq.s	loc_3538A
		cmpi.b	#1,d1
		beq.s	loc_35380
		add.w	d1,d0
		move.w	#tile_Nem_SpecialVertShadow+tile_pal4,ost_tile(a0)
		bra.s	loc_35392
; ===========================================================================

loc_35380:
		add.w	d1,d0
		move.w	#tile_Nem_SpecialDiagShadow+tile_pal4,ost_tile(a0)
		bra.s	loc_35392
; ===========================================================================

loc_3538A:
		add.w	d1,d0
		move.w	#tile_Nem_SpecialHorizShadow+tile_pal4,ost_tile(a0)

loc_35392:
		move.b	d0,ost_frame(a0)
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_3539A:
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

loc_3539E:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_353E8
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		add.w	d0,d0
		adda.w	(a1,d0.w),a1
		move.b	(a1),ost_anim_time(a0)
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		bpl.s	loc_353CA
		move.b	#0,ost_anim_frame(a0)
		move.b	1(a1),d0

loc_353CA:
		andi.b	#$7F,d0
		move.b	d0,ost_frame(a0)
		move.b	ost_primary_status(a0),d1

loc_353D6:
		andi.b	#3,d1
		andi.b	#~(render_xflip|render_yflip),ost_render(a0)
		or.b	d1,ost_render(a0)
		addq.b	#1,ost_anim_frame(a0)

locret_353E8:
		rts
; ===========================================================================
byte_353EA:
		dc.b $38					; 0
		dc.b $48					; 1
		dc.b $2A					; 2
		dc.b $56					; 3
		dc.b $1C					; 4
		dc.b $64					; 5
		dc.b  $E					; 6
		dc.b $72					; 7
		dc.b   0					; 8
		dc.b $80					; 9

byte_353F4:
		dc.b $40					; 0
		dc.b $30					; 1
		dc.b $50					; 2
		dc.b $20					; 3
		dc.b $60					; 4
		dc.b $10					; 5
		dc.b $70					; 6
		dc.b   0					; 7
		dc.b $80					; 8
		dc.b   0					; 9
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 5B - Ring spray/spill in Special Stage
; ----------------------------------------------------------------------------

RingLossSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	RLS_Index(pc,d0.w),d1
		jmp	RLS_Index(pc,d1.w)
; ===========================================================================
RLS_Index:	index offset(*),,2
		ptr loc_35410					; 0
		ptr loc_354E4					; 2

		rsobj	RingLossSpecial,$38
ost_ringlossspec_parent:	rs.l 1				; $38
		rsobjend
; ===========================================================================

loc_35410:
		movea.l	ost_ringlossspec_parent(a0),a3
		moveq	#0,d1
		move.b	ost_ss_rings_tens(a3),d1
		beq.s	loc_35428
		subi_.b	#1,ost_ss_rings_tens(a3)
		move.w	#$A,d1
		bra.s	loc_35458
; ===========================================================================

loc_35428:
		move.b	ost_ss_rings_hundreds(a3),d1
		beq.s	loc_35440

loc_3542E:
		subi_.b	#1,ost_ss_rings_hundreds(a3)
		move.b	#9,ost_ss_rings_tens(a3)
		move.w	#$A,d1
		bra.s	loc_35458
; ===========================================================================

loc_35440:
		move.b	ost_ss_rings_units(a3),d1
		beq.s	loc_3545C
		move.b	#0,ost_ss_rings_units(a3)
		btst	#0,d1
		beq.s	loc_35458
		lea_	byte_353F4,a2
		bra.s	loc_3545C
; ===========================================================================

loc_35458:
		lea_	byte_353EA,a2

loc_3545C:
		cmpi.b	#9,(a3)
		bne.s	loc_35468
		sub.w	d1,(v_rings).w
		bra.s	loc_3546C
; ===========================================================================

loc_35468:
		sub.w	d1,(v_rings_p2).w

loc_3546C:
		move.w	d1,d2
		subq.w	#1,d2
		bmi.w	JmpTo63_DeleteObject
		movea.l	a0,a1
		bra.s	loc_3547E
; ===========================================================================

loc_35478:
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.s	loc_354DE

loc_3547E:
		move.b	#id_RingLossSpecial,ost_id(a1)
		move.b	#2,ost_primary_routine(a1)
		move.l	#Map_RingSpec,ost_mappings(a1)
		move.w	#tile_Nem_SpecialRings+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#5,ost_priority(a1)
		move.b	#0,ost_col_type(a1)
		move.b	#8,ost_anim(a1)
		move.w	ost_x_pos(a3),ost_x_pos(a1)
		move.w	ost_y_pos(a3),ost_y_pos(a1)
		move.b	ost_angle(a3),d0
		addi.b	#$40,d0
		add.b	(a2)+,d0
		jsr	(CalcSine).l
		muls.w	#$400,d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a1)
		muls.w	#$1000,d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a1)

loc_354DE:
		dbf	d2,loc_35478
		rts
; ===========================================================================

loc_354E4:
		jsrto	ObjectFall,JmpTo7_ObjectFall
		addi.w	#$80,ost_y_vel(a0)
		bsr.w	loc_3551C
		tst.w	ost_x_pos(a0)
		bmi.w	JmpTo63_DeleteObject
		cmpi.w	#$100,ost_x_pos(a0)
		bcc.w	JmpTo63_DeleteObject
		cmpi.w	#$E0,ost_y_pos(a0)
		bgt.w	JmpTo63_DeleteObject
		lea	(Ani_RingSpec).l,a1
		jsrto	AnimateSprite,JmpTo24_AnimateSprite
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_3551C:
		tst.w	ost_y_vel(a0)
		bmi.w	locret_35530
		move.b	#0,ost_priority(a0)
		move.b	#9,ost_anim(a0)

locret_35530:
		rts
; ===========================================================================
		rts						; dead code
; ===========================================================================

loc_35534:
		move.w	Pal_SSCheckpointRainbow(pc,d0.w),($FFFFFB76).w
		move.w	Pal_SSCheckpointRainbow+2(pc,d0.w),($FFFFFB78).w
		move.w	Pal_SSCheckpointRainbow+4(pc,d0.w),($FFFFFB7A).w
		rts
; ===========================================================================
		incfile Pal_SSCheckpointRainbow
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 5A - Special Stage checkpoints, ring requirement messages,
; and progress messages
; ----------------------------------------------------------------------------

MessageSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_35562(pc,d0.w),d1
		jmp	off_35562(pc,d1.w)
; ===========================================================================
off_35562:	index offset(*),,2
		ptr loc_35578					; 0
		ptr loc_357FE					; 2
		ptr loc_35B5A					; 4
		ptr loc_359CE					; 6
		ptr loc_35B96					; 8
		ptr loc_359A6					; $A
		ptr loc_359BC					; $C
		ptr loc_35706					; $E
		ptr loc_357B2					; $10
		ptr loc_357D2					; $12
		ptr loc_357E8					; $14
; ===========================================================================

loc_35578:
		tst.b	(f_ss_no_checkpoint).w
		bne.s	loc_355E0
		movea.l	(v_ss_track_last_mappings_copy).w,a1

loc_35582:
		cmpa.l	#MapSpec_Straight4,a1
		blt.s	locret_355DE
		cmpa.l	#MapSpec_Drop1,a1
		bge.s	locret_355DE
		moveq	#6,d0
		bsr.s	loc_35534
		st.b	(f_ss_checkpoint_rainbow).w
		moveq	#6,d0

loc_3559C:
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.s	loc_355D6
		move.b	#id_MessageSpecial,ost_id(a1)
		move.b	#2,ost_primary_routine(a1)
		move.l	#Map_RingSpec,ost_mappings(a1)
		move.w	#tile_Nem_SpecialRings+tile_pal4,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#5,ost_priority(a1)
		move.b	d0,$2A(a1)
		move.w	#0,$30(a1)
		move.b	#-1,ost_frame(a1)

loc_355D6:
		dbf	d0,loc_3559C
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

locret_355DE:
		rts
; ===========================================================================

loc_355E0:
		sf.b	(f_ss_no_checkpoint).w
		tst.b	(f_ss_2p).w
		bne.w	JmpTo63_DeleteObject
		sf.b	(f_ss_hide_ringstogo).w
		sf.b	(f_ss_trigger_ringstogo).w
		move.w	#0,(v_ss_no_ringstogo_lifetime).w
		move.b	#0,$3A(a0)
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================
byte_35604:
		dc.b   3					; 0
		dc.b   4					; 1
		dc.b   5					; 2
		dc.b   0					; 3
		dc.b $FF					; 4

		dc.b $11					; 5
		dc.b   8					; 6
		dc.b   0					; 7
		dc.b   8					; 8
		dc.b   2					; 9
		dc.b $FF					; 10

		dc.b   6					; 11
		dc.b $FF					; 12

		even

word_35612:
		dc.w   $C0					; 0
		dc.w   $B8					; 1
		dc.w   $B0					; 2
		dc.w   $A0					; 3
		dc.w   $98					; 4
		dc.w   $88					; 5
; ===========================================================================

loc_3561E:
		st.b	(f_ss_trigger_ringstogo).w
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.w	locret_356E4
		move.l	#Map_SpecialNum,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHUD+tile_pal3,ost_tile(a1)
		move.b	#id_MessageSpecial,ost_id(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#1,ost_priority(a1)

loc_35648:
		bset	#render_subsprites_bit,ost_render(a1)
		move.b	#0,ost_mainspr_childsprites(a1)
		move.b	#$E,ost_primary_routine(a1)
		lea	ost_subspr2_x_pos(a1),a2
		move.w	#$5A,d1
		move.w	#$38,d2
		moveq	#0,d0
		moveq	#2,d3

loc_3566A:
		move.w	d1,(a2)+
		move.w	d2,(a2)+
		move.w	d0,(a2)+
		subq.w	#8,d1
		dbf	d3,loc_3566A
		lea	byte_35604(pc),a3
		move.w	#$68,d1
		move.w	#$38,d2

loc_35682:
		move.b	(a3)+,d0
		bmi.s	loc_356A4
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.s	locret_356E4
		bsr.s	loc_356E6
		move.b	#$10,ost_primary_routine(a1)
		move.w	d1,ost_x_pos(a1)
		move.w	d2,ost_y_pos(a1)
		move.b	d0,ost_frame(a1)
		addq.w	#8,d1
		bra.s	loc_35682
; ===========================================================================

loc_356A4:
		lea	word_35612(pc),a2

loc_356A8:
		move.b	(a3)+,d0
		bmi.s	loc_356C8
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.s	locret_356E4
		bsr.s	loc_356E6
		move.b	#$12,ost_primary_routine(a1)
		move.w	(a2)+,$2A(a1)
		move.w	d2,ost_y_pos(a1)
		move.b	d0,ost_frame(a1)
		bra.s	loc_356A8
; ===========================================================================

loc_356C8:
		move.b	(a3)+,d0
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.s	locret_356E4
		bsr.s	loc_356E6
		move.b	#$14,ost_primary_routine(a1)
		move.w	(a2)+,ost_x_pos(a1)
		move.w	d2,ost_y_pos(a1)
		move.b	d0,ost_frame(a1)

locret_356E4:
		rts
; ===========================================================================

loc_356E6:
		move.b	#id_MessageSpecial,ost_id(a1)
		move.l	#Map_SSMessages,ost_mappings(a1)
		move.w	#tile_Nem_SpecialMessages+tile_pal3,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
	if FixBugs=0
		; Multi-sprite objects cannot use ost_priority, as it is
		; overwritten by 'ost_subspr3_y_pos'. This object doesn't use the
		; multi-sprite system, but it does share display code with one, so
		; this might as well be removed since it won't be used.
		move.b	#1,ost_priority(a1)
	endc
		rts
; ===========================================================================

loc_35706:
		move.b	(f_ss_trigger_ringstogo).w,(f_ss_hide_ringstogo).w
		bne.s	locret_35714
		bsr.s	loc_35716
		bra.w	loc_357B2
; ===========================================================================

locret_35714:
		rts
; ===========================================================================

loc_35716:
		move.w	(v_rings).w,d0
		cmpi.w	#sonic_alone,(v_player_mode).w
		blt.s	loc_3572A
		beq.s	loc_3572E
		move.w	(v_rings_p2).w,d0
		bra.s	loc_3572E
; ===========================================================================

loc_3572A:
		add.w	(v_rings_p2).w,d0

loc_3572E:
		sub.w	(v_ss_ring_requirement).w,d0
		neg.w	d0
		bgt.s	loc_3574E
		moveq	#0,d0
		moveq	#1,d2
		addi_.w	#1,(v_ss_no_ringstogo_lifetime).w
		cmpi.w	#$C,(v_ss_no_ringstogo_lifetime).w
		bcs.s	loc_3577A
		st.b	(f_ss_hide_ringstogo).w
		bra.s	loc_3577A
; ===========================================================================

loc_3574E:
		moveq	#0,d1
		move.w	d0,d1
		moveq	#0,d0
		cmpi.w	#$64,d1
		blt.s	loc_35764

loc_3575A:
		addi.w	#$100,d0
		subi.w	#$64,d1
		bgt.s	loc_3575A

loc_35764:
		divu.w	#$A,d1
		lsl.w	#4,d1
		or.b	d1,d0
		swap	d1
		or.b	d1,d0
		move.w	#0,(v_ss_no_ringstogo_lifetime).w
		sf.b	(f_ss_hide_ringstogo).w

loc_3577A:
		moveq	#1,d2
		lea	ost_subspr2_x_pos(a0),a1
		move.w	d0,(v_ss_ringstogo_bcd).w
		move.w	d0,d1
		andi.w	#$F,d1
		move.b	d1,ost_subspr2_frame-ost_subspr2_x_pos(a1)
		lsr.w	#4,d0
		beq.s	loc_357AC
		addq.w	#1,d2
		move.w	d0,d1
		andi.w	#$F,d1
		move.b	d1,ost_subspr3_frame-ost_subspr2_x_pos(a1)
		lsr.w	#4,d0
		beq.s	loc_357AC
		addq.w	#1,d2
		andi.w	#$F,d0
		move.b	d0,ost_subspr4_frame-ost_subspr2_x_pos(a1)

loc_357AC:
		move.b	d2,ost_mainspr_childsprites(a0)
		rts
; ===========================================================================

loc_357B2:
		tst.b	(f_ss_no_checkpoint_msg).w
		bne.w	locret_357D0
		tst.b	(f_ss_hide_ringstogo).w
		bne.s	locret_357D0
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#7,d0
		cmpi.b	#6,d0
	if FixBugs
		; Multi-sprite objects cannot use 'ost_priority', so they
		; must use 'DisplaySprite3' instead of 'DisplaySprite'.
		; This object's 'priority' is overwritten by 'ost_subspr3_y_pos',
		; causing it to display on the wrong layer.
		bcc.s	locret_357D0
		move.w	#sizeof_priority*1,d0
		jmp	(DisplaySprite3).l
	else
		bcs.w	JmpTo44_DisplaySprite
	endc

locret_357D0:
		rts
; ===========================================================================

loc_357D2:
		moveq	#0,d0
		cmpi.w	#2,(v_ss_ringstogo_bcd).w
		bcc.s	loc_357DE
		moveq	#-8,d0

loc_357DE:
		add.w	$2A(a0),d0
		move.w	d0,ost_x_pos(a0)
		bra.s	loc_357B2
; ===========================================================================

loc_357E8:
		moveq	#0,d0
		cmpi.w	#2,(v_ss_ringstogo_bcd).w
		bcc.s	loc_357B2
		rts
; ===========================================================================
byte_357F4:
		dc.b   0					; 0
		dc.b   1					; 1
		dc.b   1					; 2
		dc.b   1					; 3
		dc.b   2					; 4
		dc.b   4					; 5
		dc.b   6					; 6
		dc.b   8					; 7
		dc.b   9					; 8
		dc.b $FF					; 9
; ===========================================================================

loc_357FE:
		cmpi.b	#4,(v_ss_track_drawing_index).w
		bne.s	loc_3583C
		move.w	$2C(a0),d0
		move.b	byte_357F4(pc,d0.w),ost_frame(a0)
		bmi.w	loc_358C4
		addi_.w	#1,$2C(a0)
		moveq	#0,d0
		move.b	$2A(a0),d0
		add.w	d0,d0
		add.w	$30(a0),d0
		move.b	byte_35846(pc,d0.w),9(a0)
		move.b	byte_35846+1(pc,d0.w),$D(a0)
		addi.w	#$E,$30(a0)
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_3583C:
		tst.b	ost_frame(a0)
		bpl.w	JmpTo44_DisplaySprite
		rts
; ===========================================================================
byte_35846:
		dc.b $F6,$F6					; 0
		dc.b $70,$5E					; 2
		dc.b $76,$58					; 4
		dc.b $7E,$56					; 6
		dc.b $88,$58					; 8
		dc.b $8E,$5E					; 10
		dc.b $F6,$F6					; 12
		dc.b $F6,$F6					; 14
		dc.b $6D,$5A					; 16
		dc.b $74,$54					; 18
		dc.b $7E,$50					; 20
		dc.b $8A,$54					; 22
		dc.b $92,$5A					; 24
		dc.b $F6,$F6					; 26
		dc.b $F6,$F6					; 28
		dc.b $6A,$58					; 30
		dc.b $72,$50					; 32
		dc.b $7E,$4C					; 34
		dc.b $8C,$50					; 36
		dc.b $94,$58					; 38
		dc.b $F6,$F6					; 40
		dc.b $F6,$F6					; 42
		dc.b $68,$56					; 44
		dc.b $70,$4C					; 46
		dc.b $7E,$48					; 48
		dc.b $8E,$4C					; 50
		dc.b $96,$56					; 52
		dc.b $F6,$F6					; 54
		dc.b $62,$5E					; 56
		dc.b $66,$50					; 58
		dc.b $70,$46					; 60
		dc.b $7E,$42					; 62
		dc.b $8E,$46					; 64
		dc.b $98,$50					; 66
		dc.b $9C,$5E					; 68
		dc.b $5C,$5A					; 70
		dc.b $62,$4A					; 72
		dc.b $70,$3E					; 74
		dc.b $7E,$38					; 76
		dc.b $8E,$3E					; 78
		dc.b $9C,$4A					; 80
		dc.b $A2,$5A					; 82
		dc.b $54,$54					; 84
		dc.b $5A,$3E					; 86
		dc.b $6A,$30					; 88
		dc.b $7E,$2A					; 90
		dc.b $94,$30					; 92
		dc.b $A4,$3E					; 94
		dc.b $AA,$54					; 96
		dc.b $42,$4A					; 98
		dc.b $4C,$28					; 100
		dc.b $62,$12					; 102
		dc.b $7E, $A					; 104
		dc.b $9C,$12					; 106
		dc.b $B2,$28					; 108
		dc.b $BC,$4A					; 110
		dc.b $16,$26					; 112
		dc.b $28,$FC					; 114
		dc.b $EC,$EC					; 116
		dc.b $EC,$EC					; 118
		dc.b $EC,$EC					; 120
		dc.b $D6,$FC					; 122
		dc.b $E8,$26					; 124
; ===========================================================================

loc_358C4:
		cmpi.w	#$E8,ost_x_pos(a0)
		bne.w	JmpTo63_DeleteObject
		moveq	#0,d0
		bsr.w	loc_35534
		sf.b	(f_ss_checkpoint_rainbow).w
		st.b	(f_ss_no_checkpoint_msg).w
		tst.b	(f_ss_2p).w
		beq.w	loc_35978
		move.w	#$A1,d0
		jsr	(PlaySound).l
		addi.b	#$10,(v_ss_2p_bcd_score).w
		moveq	#0,d6
		addi_.b	#1,(v_special_act).w
		move.w	#$C,d0
		move.w	(v_rings).w,d2
		cmp.w	(v_rings_p2).w,d2
		bgt.s	loc_3592A
		beq.s	loc_35942
		subi.b	#$10,(v_ss_2p_bcd_score).w
		addi_.b	#1,(v_ss_2p_bcd_score).w
		move.w	#$E,d0
		tst.b	(v_console_region).w
		bpl.s	loc_35926
		move.w	#$14,d0

loc_35926:
		move.w	#$2000,d6

loc_3592A:
		move.w	#$80,d3
		bsr.w	loc_35AB6
		add.w	d6,ost_tile(a1)
		add.w	d6,ost_tile(a2)
		bsr.w	loc_35DAA
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

loc_35942:
		subi.b	#$10,(v_ss_2p_bcd_score).w
		move.w	#$10,d0
		bsr.w	loc_35DAA
		cmpi.b	#3,(v_special_act).w
		beq.s	loc_35966
		move.w	#$46,$2A(a0)
		move.b	#$A,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_35966:
		bsr.w	loc_35A7A
		move.w	#$46,$2A(a0)
		move.b	#$C,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_35978:
		move.w	#6,d1
		move.w	#$ED,d0
		move.w	(v_rings).w,d2
		add.w	(v_rings_p2).w,d2
		cmp.w	(v_ss_ring_requirement).w,d2
		blt.s	loc_35996
		move.w	#4,d1
		move.w	#$A1,d0

loc_35996:
		jsr	(PlaySound).l
		move.w	d1,d0
		bsr.w	loc_35D52
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

loc_359A6:
		subi_.w	#1,$2A(a0)
		beq.s	loc_359B0
		rts
; ===========================================================================

loc_359B0:
		move.w	#$A,d0					; MOST RINGS WINS
		bsr.w	loc_35DAA
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

loc_359BC:
		subi_.w	#1,$2A(a0)
		beq.s	loc_359C6
		rts
; ===========================================================================

loc_359C6:
		st.b	(f_ss_chk_rings).w
		bra.w	SS_ClearObjects
; ===========================================================================

loc_359CE:
		cmpi.b	#$15,ost_frame(a0)
		bne.s	loc_35A1A
		move.w	$30(a0),d0
		tst.b	$2E(a0)
		bne.s	loc_359FE
		subi_.w	#1,ost_y_pos(a0)
		subi_.w	#4,d0
		cmp.w	ost_y_pos(a0),d0
		blt.s	loc_35A1A
		addi_.w	#1,d0
		move.w	d0,ost_y_pos(a0)
		st.b	$2E(a0)
		bra.s	loc_35A1A
; ===========================================================================

loc_359FE:
		addi_.w	#1,ost_y_pos(a0)
		addi_.w	#4,d0
		cmp.w	ost_y_pos(a0),d0
		bgt.s	loc_35A1A
		subi_.w	#1,d0
		move.w	d0,ost_y_pos(a0)
		sf.b	$2E(a0)

loc_35A1A:
		subi_.w	#1,$2A(a0)
		bne.w	JmpTo44_DisplaySprite
		tst.b	$2F(a0)
		beq.s	loc_35A42

loc_35A2A:
		move.w	#$F9,d0
		jsr	(PlayMusic).l
		move.w	#$30,$2A(a0)
		move.b	#$C,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_35A42:
		cmpi.b	#$15,ost_frame(a0)
		bne.w	JmpTo63_DeleteObject
		tst.w	$30(a0)
		beq.w	JmpTo63_DeleteObject
		tst.b	(f_ss_2p).w
		beq.s	loc_35A72
		bsr.w	loc_35A7A
		cmpi.b	#3,(v_special_act).w
		beq.s	loc_35A2A
		move.w	#$A,d0
		bsr.w	loc_35DAA
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

loc_35A72:
		bsr.w	loc_35CE2
		jmpto	DeleteObject,JmpTo63_DeleteObject
; ===========================================================================

loc_35A7A:
		lea	(v_ss_2p_ring_buffer).w,a3
		moveq	#0,d0
		move.b	(v_special_act).w,d0
		subq.w	#1,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	(v_rings).w,(a3,d0.w)
		move.w	(v_rings_p2).w,2(a3,d0.w)
		move.w	#0,(v_rings).w
		move.w	#0,(v_rings_p2).w
		moveq	#0,d0
		move.w	d0,(v_ost_player1+ost_ss_rings_base).w
		move.b	d0,(v_ost_player1+ost_ss_rings_units).w
		move.w	d0,(v_ost_player2+ost_ss_rings_base).w
		move.b	d0,(v_ost_player2+ost_ss_rings_units).w
		rts
; ===========================================================================

loc_35AB6:
		move.w	#$48,d4
		tst.b	(f_ss_2p).w
		beq.s	loc_35AC4
		move.w	#$1C,d4

loc_35AC4:
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.w	locret_35B58
		move.b	#id_MessageSpecial,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.l	#Map_SSMessages,ost_mappings(a1)
		move.w	#tile_Nem_SpecialMessages+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#1,ost_priority(a1)
		move.w	d3,ost_x_pos(a1)
		move.w	d4,ost_y_pos(a1)
		move.w	#$46,$2A(a1)
		move.b	#$14,ost_frame(a1)
		movea.l	a1,a2
		jsrto	FindFreeObjSpecial,JmpTo2_FindFreeObjSpecial
		bne.s	locret_35B58
		move.b	#id_MessageSpecial,ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.l	#Map_SSMessages,ost_mappings(a1)
		move.w	#tile_Nem_SpecialMessages+tile_pal2,ost_tile(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#0,ost_priority(a1)
		move.w	d3,ost_x_pos(a1)
		move.w	d4,ost_y_pos(a1)
		move.w	d4,$30(a1)
		move.w	#$46,$2A(a1)
		move.b	#$15,ost_frame(a1)
		cmpi.w	#6,d0
		bne.s	locret_35B58
		st.b	$2F(a1)
		bset	#render_yflip_bit,ost_render(a1)

locret_35B58:
		rts
; ===========================================================================

loc_35B5A:
		subi_.w	#1,$2A(a0)
		bne.w	JmpTo44_DisplaySprite
		cmpi.b	#$13,ost_frame(a0)
		bgt.w	JmpTo63_DeleteObject
		move.b	#8,ost_primary_routine(a0)
		move.w	#8,$14(a0)
		move.w	ost_x_pos(a0),d1
		subi.w	#$80,d1
		move.w	ost_y_pos(a0),d2
		subi.w	#$70,d2
		jsrto	CalcAngle,JmpTo_CalcAngle
		move.b	d0,ost_angle(a0)
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_35B96:
		moveq	#0,d0
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo14_CalcSine
		muls.w	$14(a0),d0
		muls.w	$14(a0),d1
		asr.w	#8,d0
		asr.w	#8,d1
		add.w	d1,ost_x_pos(a0)
		add.w	d0,ost_y_pos(a0)
		cmpi.w	#0,ost_x_pos(a0)
		blt.w	JmpTo63_DeleteObject
		cmpi.w	#$100,ost_x_pos(a0)
		bgt.w	JmpTo63_DeleteObject
		cmpi.w	#0,ost_y_pos(a0)
		blt.w	JmpTo63_DeleteObject
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_35BD6:
		jsrto	FindNextFreeObjSpecial,JmpTo_FindNextFreeObjSpecial
		bne.s	locret_35C12
		move.b	d0,ost_frame(a1)
		move.l	#Map_SpecialNum,ost_mappings(a1)
		move.w	#tile_Nem_SpecialHUD+tile_pal3,ost_tile(a1)
		move.b	#id_MessageSpecial,ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#1,ost_priority(a1)
		move.w	d1,ost_x_pos(a1)
		move.w	d2,ost_y_pos(a1)
		move.w	#$46,$2A(a1)

locret_35C12:
		rts
; ===========================================================================

loc_35C14:
		lea	off_35C62(pc),a3
		adda.w	(a3,d0.w),a3

loc_35C1C:
		move.b	(a3)+,d0
		bmi.s	locret_35C60
		jsrto	FindNextFreeObjSpecial,JmpTo_FindNextFreeObjSpecial
		bne.s	locret_35C60
		move.b	d0,ost_frame(a1)
		move.l	#Map_SSMessages,ost_mappings(a1)
		move.w	#tile_Nem_SpecialMessages+tile_pal3,ost_tile(a1)
		move.b	#id_MessageSpecial,ost_id(a1)
		move.b	#4,ost_primary_routine(a1)
		move.b	#render_rel,ost_render(a1)
		move.b	#1,ost_priority(a1)
		move.w	d1,ost_x_pos(a1)
		move.w	d2,ost_y_pos(a1)
		move.w	#$46,$2A(a1)
		addq.w	#8,d1
		bra.s	loc_35C1C
; ===========================================================================

locret_35C60:
		rts
; ===========================================================================
off_35C62:	index offset(*)
		ptr byte_35C86					; 0
		ptr byte_35C8A					; 2
		ptr byte_35C90					; 4
		ptr byte_35C96					; 6
		ptr byte_35C9A					; 8
		ptr byte_35CA1					; $A
		ptr byte_35CA8					; $C
		ptr byte_35CAD					; $E
		ptr byte_35CB3					; $10
		ptr byte_35CB9					; $12
		ptr byte_35CBF					; $14
		ptr byte_35CC4					; $16
		ptr byte_35CC8					; $18
		ptr byte_35CCE					; $1A
		ptr byte_35CD3					; $1C
		ptr byte_35CD5					; $1E
		ptr byte_35CD9					; $20
		ptr byte_35CDB					; $22

byte_35C86:	dc.b   0,  1,  2,$FF
byte_35C8A:	dc.b   3,  4,  5,  0,  6,$FF
byte_35C90:	dc.b   7,  8,  8,  9,$11,$FF
byte_35C96:	dc.b   5,  8,  2,$FF
byte_35C9A:	dc.b   1,  5,  8, $A,  0, $B,$FF
byte_35CA1:	dc.b  $C,  9, $D, $E,  1,  3,$FF
byte_35CA8:	dc.b  $F,  8,  6,  2,$FF
byte_35CAD:	dc.b $10,  4,  5,  6,$11,$FF
byte_35CB3:	dc.b   6,  8,  5,  4,  7,$FF
byte_35CB9:	dc.b  $F,  4,  9,  1,  6,$FF
byte_35CBF:	dc.b   2,  4,  1,$11,$FF
byte_35CC4:	dc.b $10,  4,  5,$FF
byte_35CC8:	dc.b   2,$10,  4,  7,  1,$FF
byte_35CCE:	dc.b  $D,  9,  9,$11,$FF
byte_35CD3:	dc.b $11,$FF
byte_35CD5:	dc.b $12,$12,$12,$FF
byte_35CD9:	dc.b $13,$FF
byte_35CDB:	dc.b   2, $D,  4,  9,  6,$FF
		even
; ===========================================================================

loc_35CE2:
		moveq	#0,d0
		move.w	#$54,d1
		move.w	#$6C,d2
		bsr.w	loc_35C14
		jsrto	SS_StartNewAct,JmpTo_SS_StartNewAct
		move.w	d1,d4
		move.w	d2,d5
		movea.w	d2,a3
		move.w	#$80,d1
		cmpi.w	#2,d2
		beq.s	loc_35D08
		subi_.w	#8,d1

loc_35D08:
		move.w	#$6C,d2

loc_35D0C:
		move.w	d4,d6
		lsr.w	#4,d4
		andi.w	#$F,d6
		move.b	d6,d0
		swap	d5
		bsr.w	loc_35BD6
		subi_.w	#8,d1
		swap	d5
		dbf	d5,loc_35D0C
		moveq	#2,d0
		lea	(off_35DDE).l,a2
		adda.w	(a2,d0.w),a2
		move.w	#$6C,d2
		move.w	#$84,d1
		cmpa.w	#2,a3
		bne.s	loc_35D44
		addi_.w	#8,d1

loc_35D44:
		moveq	#0,d0
		move.b	(a2)+,d0
		bmi.s	locret_35D50
		bsr.w	loc_35C14
		bra.s	loc_35D44
; ===========================================================================

locret_35D50:
		rts
; ===========================================================================

loc_35D52:
		move.w	#$80,d3
		bsr.w	loc_35AB6
		cmpi.w	#sonic_alone,(v_player_mode).w
		ble.s	loc_35D6E
		addi.w	#tile_pal2,ost_tile(a1)
		addi.w	#tile_pal2,ost_tile(a2)

loc_35D6E:
		move.w	#$74,d1
		move.w	#$68,d2
		lea	(off_35DDE).l,a2
		adda.w	(a2,d0.w),a2
		cmpi.b	#4,d0
		beq.s	loc_35D8A
		move.w	#$5E,d1

loc_35D8A:
		moveq	#0,d0
		move.b	(a2)+,d0
		bmi.s	locret_35DA8
		cmpi.b	#2,d0
		bne.s	loc_35D9E
		move.w	#$5E,d1
		move.w	#$7E,d2

loc_35D9E:
		bsr.w	loc_35C14
		addi_.w	#8,d1
		bra.s	loc_35D8A
; ===========================================================================

locret_35DA8:
		rts
; ===========================================================================

loc_35DAA:
		move.w	d0,d3
		subq.w	#8,d3
		lsr.w	#1,d3
		moveq	#0,d1
		move.b	byte_35DD6(pc,d3.w),d1
		move.w	#$48,d2
		lea	(off_35DDE).l,a2
		adda.w	(a2,d0.w),a2

loc_35DC4:
		moveq	#0,d0
		move.b	(a2)+,d0
		bmi.s	locret_35DD4
		bsr.w	loc_35C14
		addi_.w	#8,d1
		bra.s	loc_35DC4
; ===========================================================================

locret_35DD4:
		rts
; ===========================================================================
byte_35DD6:
		dc.b $48					; 0
		dc.b $44					; 1
		dc.b $58					; 2
		dc.b $58					; 3
		dc.b $74					; 4
		dc.b $3C					; 5
		dc.b $58					; 6
		dc.b   0					; 7
		;even

off_35DDE: index offset(*)
		ptr byte_35DF6					; 0
		ptr byte_35DF7					; 2
		ptr byte_35DFA					; 4
		ptr byte_35DFC					; 6
		ptr byte_35E01					; 8
		ptr byte_35E05					; $A
		ptr byte_35E09					; $C
		ptr byte_35E0C					; $E
		ptr byte_35E0F					; $10
		ptr byte_35E11					; $12
		ptr byte_35E16					; $14
		ptr byte_35E19					; $16

byte_35DF6:	dc.b $FF					; 0
byte_35DF7:	dc.b   2,$1C,$FF				; 0
byte_35DFA:	dc.b   4,$FF					; 0
byte_35DFC:	dc.b   6,  8,  2,$1E,$FF			; 0
byte_35E01:	dc.b  $A,$20, $A,$FF				; 0
byte_35E05:	dc.b  $C,  2, $E,$FF				; 0
byte_35E09:	dc.b $10, $E,$FF				; 0
byte_35E0C:	dc.b $12, $E,$FF				; 0
byte_35E0F:	dc.b $14,$FF					; 0
byte_35E11:	dc.b $16,$18,$16,$1A,$FF			; 0
byte_35E16:	dc.b $22, $E,$FF				; 0
byte_35E19:	dc.b   2,$24,$26,$1C,$FF			; 0
; ===========================================================================

		include "mappings/sprite/Special Stage HUD and Messages.asm"

; ===========================================================================

loc_35F76:
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.w	Pal_SSEmeralds(pc,d0.w),($FFFFFB76).w
		move.w	Pal_SSEmeralds+2(pc,d0.w),($FFFFFB78).w
		move.w	Pal_SSEmeralds+4(pc,d0.w),($FFFFFB7A).w
		rts
; ===========================================================================
		incfile Pal_SSEmeralds
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 59 - Special Stage Chaos Emeralds
; ----------------------------------------------------------------------------

EmeraldSpecial:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	EmeraldSpec_Index(pc,d0.w),d1
		jmp	EmeraldSpec_Index(pc,d1.w)
; ===========================================================================
EmeraldSpec_Index:	index offset(*),,2
		ptr loc_35FD4					; 0
		ptr loc_36022					; 2
		ptr loc_3533A					; 4
		ptr loc_36160					; 6
		ptr loc_36172					; 8
; ===========================================================================

loc_35FD4:
		st.b	(f_ss_no_checkpoint_msg).w
		st.b	(f_ss_pause_only).w
		subi_.w	#1,$2A(a0)
		cmpi.w	#-$3C,$2A(a0)
		beq.s	loc_35FEC
		rts
; ===========================================================================

loc_35FEC:
		moveq	#0,d0
		move.b	(v_special_stage).w,d0
		bsr.s	loc_35F76
		addq.b	#2,ost_primary_routine(a0)
		move.l	#Map_EmeraldSpec,ost_mappings(a0)
		move.w	#tile_Nem_SpecialEmerald+tile_pal4,ost_tile(a0)
		move.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.w	#$36,$30(a0)
		move.b	#$40,ost_angle(a0)
		bsr.w	loc_3529C

loc_36022:
		bsr.w	loc_360F0
		bsr.w	loc_3512A
		bsr.w	loc_3603C
		lea	(Ani_EmeraldSpec).l,a1
		bsr.w	loc_3539E
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================

loc_3603C:
		move.w	d7,-(sp)
		moveq	#0,d2
		moveq	#0,d3
		moveq	#0,d4
		moveq	#0,d5
		moveq	#0,d6
		moveq	#0,d7
		movea.l	(v_ss_ctrl_record_buffer_end).w,a1
		adda_.l	#2,a1
		move.w	$30(a0),d0
		subq.w	#1,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.b	(a1,d0.w),d2
		move.b	1(a1,d0.w),d3
		move.b	2(a1,d0.w),d4
		move.b	3(a1,d0.w),d5
		move.w	d5,d6
		swap	d5
		move.w	d6,d5
		move.w	d4,d6
		swap	d4
		move.w	d6,d4
		bpl.s	loc_36088
		cmpi.b	#$48,d3
		bcs.s	loc_36088
		ext.w	d3

loc_36088:
		move.w	d4,d6
		add.w	d4,d4
		add.w	d6,d4
		lsr.w	#2,d4
		move.w	d5,d6
		add.w	d5,d5
		add.w	d6,d5
		lsr.w	#2,d5
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo14_CalcSine
		muls.w	d4,d1
		muls.w	d5,d0
		asr.l	#8,d0
		asr.l	#8,d1
		add.w	d2,d1
		add.w	d3,d0
		move.w	d1,ost_x_pos(a0)
		move.w	d0,ost_y_pos(a0)
		move.b	d1,$3A(a0)
		move.b	d0,$3B(a0)
		swap	d4
		swap	d5
		movea.l	$34(a0),a1
		move.b	ost_angle(a0),d0
		jsrto	CalcSine,JmpTo14_CalcSine
		move.w	d4,d6
		lsr.w	#2,d6
		add.w	d6,d4
		muls.w	d4,d1
		move.w	d5,d6
		asr.w	#2,d6
		add.w	d6,d5
		muls.w	d5,d0
		asr.l	#8,d0
		asr.l	#8,d1
		add.w	d2,d1
		add.w	d3,d0
		move.w	d1,ost_x_pos(a1)
		move.w	d0,ost_y_pos(a1)
		move.w	(sp)+,d7
		rts
; ===========================================================================

loc_360F0:
		cmpi.b	#3,ost_anim(a0)
		bcs.s	locret_36140
		tst.b	$3E(a0)
		bne.s	loc_3610C
		move.w	#$F9,d0
		jsr	(PlayMusic).l
		st.b	$3E(a0)

loc_3610C:
		cmpi.b	#6,ost_anim(a0)
		bcs.s	locret_36140
		move.w	(v_rings).w,d2
		add.w	(v_rings_p2).w,d2
		cmp.w	(v_ss_ring_requirement).w,d2
		blt.s	loc_36142
		cmpi.b	#9,ost_anim(a0)
		bcs.s	locret_36140
		move.w	#$63,$2A(a0)
		move.b	#8,ost_primary_routine(a0)
		move.w	#$9D,d0
		jsr	(PlayMusic).l

locret_36140:
		rts
; ===========================================================================

loc_36142:
		move.l	#0,(v_ss_new_speed_factor).w
		move.b	#6,ost_primary_routine(a0)
		move.w	#$4F,$2A(a0)
		move.w	#6,d0
		bsr.w	loc_35D6E
		rts
; ===========================================================================

loc_36160:
		subi_.w	#1,$2A(a0)
		bpl.w	JmpTo44_DisplaySprite
		st.b	(f_ss_chk_rings).w
		bra.w	SS_ClearObjects
; ===========================================================================

loc_36172:
		subi_.w	#1,$2A(a0)
		bpl.s	loc_361A4
		moveq	#0,d0
		move.b	(v_special_stage).w,d0
		lea	(v_emerald_list).w,a0
		st.b	(a0,d0.w)
		st.b	(f_got_emerald).w
		addi_.b	#1,(v_special_stage).w
		addi_.b	#1,(v_emeralds).w
		st.b	(f_ss_chk_rings).w
		bsr.w	SS_ClearObjects
		move.l	(sp)+,d0
		rts
; ===========================================================================

loc_361A4:
		addi_.b	#1,$3C(a0)
		moveq	#0,d0
		moveq	#0,d2
		move.b	$3B(a0),d2
		move.b	$3C(a0),d0
		lsr.w	#2,d0
		andi.w	#3,d0
		add.b	byte_361C8(pc,d0.w),d2
		move.w	d2,ost_y_pos(a0)
		bra.w	JmpTo44_DisplaySprite
; ===========================================================================
byte_361C8:
		dc.b $FF					; 0
		dc.b   0					; 1
		dc.b   1					; 2
		dc.b   0					; 3
; ===========================================================================

SS_ClearObjects:
		movea.l	#v_ost_all&$FFFFFF,a1
		move.w	#(sizeof_ost_all/(4*4))-1,d0		; number of loops to clear the OST with $10 bytes per loop
		moveq	#0,d1

	.loop:
		move.l	d1,(a1)+				; clear $10 bytes of the OST
		move.l	d1,(a1)+
		move.l	d1,(a1)+
		move.l	d1,(a1)+
		dbf	d0,.loop

	if FixBugs
		clear_ram	v_sprite_buffer,v_sprite_buffer_end
	else
		; The '+4' shouldn't be here; clear_ram accidentally clears an additional 4 bytes.
		clear_ram	v_sprite_buffer,v_sprite_buffer_end+4
	endc
		rts
; ===========================================================================
		; Unused/dead code; a0 = object
		cmpi.b	#$B,(v_ss_track_drawing_index).w
		bcs.s	loc_36208
		subi.l	#$4445,$30(a0)
		bra.s	loc_36210
; ===========================================================================

loc_36208:
		subi.l	#$4444,$30(a0)

loc_36210:
		move.w	$30(a0),d0
		cmpi.w	#$1D,d0
		ble.s	loc_3621C
		moveq	#$1E,d0

loc_3621C:
		lea_	byte_35180,a1
		move.b	(a1,d0.w),ost_anim(a0)
		rts

; end of unused/dead code
; ===========================================================================
Ani_EmeraldSpec:	index offset(*)
		ptr byte_3623C					; 0
		ptr byte_3623F					; 1
		ptr byte_36242					; 2
		ptr byte_36245					; 3
		ptr byte_36248					; 4
		ptr byte_3624B					; 5
		ptr byte_3624E					; 6
		ptr byte_36251					; 7
		ptr byte_36254					; 8
		ptr byte_36257					; 9

byte_3623C:	dc.b  $B,  0,$FF				; 0
byte_3623F:	dc.b  $B,  1,$FF				; 0
byte_36242:	dc.b  $B,  2,$FF				; 0
byte_36245:	dc.b  $B,  3,$FF				; 0
byte_36248:	dc.b  $B,  4,$FF				; 0
byte_3624B:	dc.b  $B,  5,$FF				; 0
byte_3624E:	dc.b  $B,  6,$FF				; 0
byte_36251:	dc.b  $B,  7,$FF				; 0
byte_36254:	dc.b  $B,  8,$FF				; 0
byte_36257:	dc.b  $B,  9,$FF				; 0
; ===========================================================================

		include "mappings/sprite/Special Stage Chaos Emeralds.asm"

; ===========================================================================
Ani_RingSpec:	index offset(*)
		ptr byte_362E8					; 0
		ptr byte_362EE					; 1
		ptr byte_362F4					; 2
		ptr byte_362FA					; 3
		ptr byte_36300					; 4
		ptr byte_36306					; 5
		ptr byte_3630C					; 6
		ptr byte_36312					; 7
		ptr byte_36318					; 8
		ptr byte_3631E					; 9
		ptr byte_36324					; 10
byte_362E8:	dc.b   5,  0, $A,$14, $A,$FF			; 0
byte_362EE:	dc.b   5,  1, $B,$15, $B,$FF			; 0
byte_362F4:	dc.b   5,  2, $C,$16, $C,$FF			; 0
byte_362FA:	dc.b   5,  3, $D,$17, $D,$FF			; 0
byte_36300:	dc.b   5,  4, $E,$18, $E,$FF			; 0
byte_36306:	dc.b   5,  5, $F,$19, $F,$FF			; 0
byte_3630C:	dc.b   5,  6,$10,$1A,$10,$FF			; 0
byte_36312:	dc.b   5,  7,$11,$1B,$11,$FF			; 0
byte_36318:	dc.b   5,  8,$12,$1C,$12,$FF			; 0
byte_3631E:	dc.b   5,  9,$13,$1D,$13,$FF			; 0
byte_36324:	dc.b   1,$1E,$1F,$20,$FF,  0			; 0
; ===========================================================================

		include "mappings/sprite/Special Stage Rings.asm"

; ===========================================================================
Ani_BombSpec:	index offset(*)
		ptr byte_364E4					; 0
		ptr byte_364E7					; 1
		ptr byte_364EA					; 2
		ptr byte_364ED					; 3
		ptr byte_364F0					; 4
		ptr byte_364F3					; 5
		ptr byte_364F6					; 6
		ptr byte_364F9					; 7
		ptr byte_364FC					; 8
		ptr byte_364FF					; 9
		ptr byte_36502					; 10

byte_364E4:	dc.b  $B,  0,$FF				; 0
byte_364E7:	dc.b  $B,  1,$FF				; 0
byte_364EA:	dc.b  $B,  2,$FF				; 0
byte_364ED:	dc.b  $B,  3,$FF				; 0
byte_364F0:	dc.b  $B,  4,$FF				; 0
byte_364F3:	dc.b  $B,  5,$FF				; 0
byte_364F6:	dc.b  $B,  6,$FF				; 0
byte_364F9:	dc.b  $B,  7,$FF				; 0
byte_364FC:	dc.b  $B,  8,$FF
byte_364FF:	dc.b  $B,  9,$FF				; 0
byte_36502:	dc.b   2, $A, $B, $C,$FF,  0			; 0
; ===========================================================================

		include "mappings/sprite/Special Stage Bombs.asm"

; ===========================================================================

JmpTo44_DisplaySprite:
		jmp	(DisplaySprite).l			; for some reason, this was not changed in Revision 2


	if RemoveJmpTos=0
JmpTo63_DeleteObject:
		jmp	(DeleteObject).l
JmpTo24_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo_SS_StartNewAct:
		jmp	(SS_StartNewAct).l
JmpTo_CalcAngle:
		jmp	(CalcAngle).l
JmpTo14_CalcSine:
		jmp	(CalcSine).l
JmpTo7_ObjectFall:
		jmp	(ObjectFall).l
JmpTo_FindNextFreeObjSpecial:
		jmp	(FindNextFreeObjSpecial).l
JmpTo2_FindFreeObjSpecial:
		jmp	(FindFreeObjSpecial).l

		align 4
	endc

; ---------------------------------------------------------------------------
; Subroutine to	load OST data from a subobjdata declaration.
; Part 2 assumes d0 is already set to index; part 3 assumes a1 already points
; to the data.

; input:
;	a0 = address of OST of object
;	d0 = ID of subobjdata declaration (LoadSubObjData2 only)
;	a1 = pointer to subobjdata declaration (LoadSubObjData3 only)

;	uses d0.l, a0, a1
; ---------------------------------------------------------------------------

LoadSubObjData:
		moveq	#0,d0
		move.b	ost_subdata_ptr(a0),d0			; get subobjdata ID

LoadSubObjData2:
		move.w	SubData_Index(pc,d0.w),d0
		lea	SubData_Index(pc,d0.w),a1		; a1 = subobjdata declaration

LoadSubObjData3:
		move.l	(a1)+,ost_mappings(a0)			; mappings pointer
		move.w	(a1)+,ost_tile(a0)			; tile base
		jsr	(AdjustVRAM2P).l			; adjust for two-player mode if required
		move.b	(a1)+,d0
		or.b	d0,ost_render(a0)			; render flags
		move.b	(a1)+,ost_priority(a0)			; priority
		move.b	(a1)+,ost_displaywidth(a0)		; display width
		move.b	(a1),ost_col_type(a0)			; collision type
		addq.b	#2,ost_primary_routine(a0)		; advance to object's next routine
		rts
; ===========================================================================

SubData_Index:	index offset(*),,2
		ptr SubData_Whisp				; 0
		ptr SubData_Ground				; 2
		ptr SubData_GWall				; 4
		ptr SubData_GRock				; 6
		ptr SubData_Chop				; 8
		ptr SubData_Spiker				; $A
		ptr Rexon					; invalid
		ptr SubData_Rex					; $E
		ptr SubData_RexProj				; $10
		ptr SubData_Neb					; $12
		ptr off_3776E					; $14
		ptr SubData_Turt				; $16
		ptr SubData_TRider				; $18
		ptr SubData_BTJet				; $1A
		ptr SubData_TurtProj				; $1C
		ptr SubData_Coco				; $1E
		ptr off_37782					; $20
		ptr SubData_CrawlT				; 17
		ptr SubData_Shelcrk				; 18
		ptr SubData_ShelcrkClaw				; 19
		ptr SubData_Slice				; 20
		ptr SubData_SlicePinc				; 21
		ptr SubData_Flash				; 22
		ptr SubData_Ast					; 23
		ptr off_3778C					; 24
		ptr off_38CAE					; 25
		ptr off_37796					; 26
		ptr SubData_Grabber				; 27
		ptr SubData_GrabLegs				; 28
		ptr SubData_GrabBox				; 29
		ptr SubData_GrabString				; 30
		ptr off_377A0					; 31
		ptr SubData_Balkiry				; 32
		ptr off_39576					; 33
		ptr off_39580					; 34
		ptr off_377AA					; 35
		ptr off_39DCE					; 36
		ptr off_377B4					; 37
		ptr SubData_SonicSega				; 38
		ptr SubData_SegaHideTM				; 39
		ptr off_3AFC8					; 40
		ptr off_3AFC8					; 41
		ptr off_3AFC8					; 42
		ptr SubData_ShipExh				; 43
		ptr SubData_ShipExh				; 44
		ptr SubData_Cloud				; 45
		ptr off_3AFD2					; 46
		ptr SubData_Cloud				; 47
		ptr SubData_Cloud				; 48
		ptr SubData_Cloud				; 49
		ptr SubData_VertProp				; 50
		ptr SubData_HorizProp,SubData_HorizProp_WFZ	; $66, WFZ subtype
		ptr SubData_HorizProp,SubData_HorizProp_SCZ	; $68, SCZ subtype
		ptr off_3B818					; 53
		ptr off_3B818					; 54
		ptr off_3B818					; 55
		ptr off_3B818					; 56
		ptr off_3B8DA					; 57
		ptr off_3BA36					; 58
		ptr SubData_HorizLaser				; 59
		ptr SubData_ConvPulley				; 60
		ptr SubData_StatHook				; 61
		ptr SubData_ShipExh				; 62
		ptr SubData_ConvPlat				; 63
		ptr SubData_ConvPlat				; 64
		ptr SubData_GunPlat				; 65
		ptr SubData_PropShaft				; 66
		ptr SubData_CPult				; 67
		ptr SubData_BreakPlate				; 68
		ptr SubData_Rivet				; 69
		ptr TornadoSmoke				; invalid
		ptr off_377BE					; 71
		ptr SubData_TorSmoke				; 72
		ptr off_3CC80					; 73
		ptr off_3CC8A					; 74
		ptr off_3CC94					; 75
		ptr off_3CC94					; 76
		ptr off_3CC94					; 77
		ptr off_3CC94					; 78
		ptr off_3CC94					; 79
		ptr off_3CC9E					; 80
		ptr off_3CCA8					; 81
		ptr off_39DD8					; 82
		ptr off_3D0B2					; 83
		ptr off_3D0BC					; 84
		ptr off_3D0C6					; 85
		ptr SubData_Crawl				; 86

; ---------------------------------------------------------------------------
; Subroutine to find the nearest player to an object and their direction and
; distance from it

; input:
;	a0 = object

; output:
;	a1 =address of OST of nearest player
;	d0 = 0 if player is left of object, 2 if right
;	d1 = 0 if player is above object, 2 if below
;	d2 = player's horizontal distance to object
; 	d3 = player's vertical distance to object

;	uses d0.l, d1.l, d2.w, d3.w, d4.w, d5.w, a0, a1, a2
; ---------------------------------------------------------------------------

FindPlayer:
		moveq	#0,d0
		moveq	#0,d1
		lea	(v_ost_player1).w,a1
		move.w	ost_x_pos(a0),d2			; d2 = x pos of player 1
		sub.w	ost_x_pos(a1),d2			; subtract x pos of object
		mvabs.w d2,d4					; d4 = absolute horizontal distance to player 1

		lea	(v_ost_player2).w,a2
		move.w	ost_x_pos(a0),d3			; d3 = x pos of player 2
		sub.w	ost_x_pos(a2),d3			; subtract x pos of object
		mvabs.w	d3,d5					; d5 =  absolute horizontal distance to player 2

	if FixBugs
		; Fix various badniks following or otherwise behaving erratically in debug mode
		tst.w	(v_debug_active).w			; is debug mode active?
		bne.s 	.player2closer				; if so, ignore player 1
	endc

		cmp.w	d5,d4
		bls.s	.chk_horiz				; branch if player 1 is closer

	.player2closer:
		movea.l	a2,a1					; else, player 2 is closer (could be word-length)
		move.w	d3,d2

	.chk_horiz:
		tst.w	d2
		bpl.s	.chk_vert				; branch if player is left of object
		addq.w	#2,d0					; mark player as right of object

	.chk_vert:
		move.w	ost_y_pos(a0),d3			; d3 = y pos of object
		sub.w	ost_y_pos(a1),d3			; subtract player's y pos
		bcc.s	.done					; branch if player is above object
		addq.w	#2,d1					; mark player as below object

	.done:
		rts

; ---------------------------------------------------------------------------
; Subroutine to apply a speed cap to an object
;
; input:
;	d0.w = max x velocity absolute value
;	d1.w = max y velocity absolute value
;
;	uses d0.w, d1.w, d2.w, d3.w
; ---------------------------------------------------------------------------

CapSpeed:
		move.w	ost_x_vel(a0),d2			; d2 = current x vel
		bpl.s	.right					; branch if object is moving right

	;.left:
		neg.w	d0					; negate max x vel for leftward motion
		cmp.w	d0,d2					; is current x vel lower than max?
		bcc.s	.chk_y					; if so, branch
		move.w	d0,d2					; if greater than max, apply cap
		bra.w	.chk_y
; ===========================================================================

	.right:
		cmp.w	d0,d2					; is current x vel lower than max?
		bls.s	.chk_y					; if so, branch
		move.w	d0,d2					; if greater than max, cap speed

.chk_y:
		move.w	ost_y_vel(a0),d3			; d3 = current y vel
		bpl.s	.down					; branch if object is moving down

	;.up:
		neg.w	d1					; negate max y vel for upward motion
		cmp.w	d1,d3					; is current y vel lower than max?
		bcc.s	.update_speed				; if so, branch
		move.w	d1,d3					; if greater than max, apply cap
		bra.w	.update_speed
; ===========================================================================

	.down:
		cmp.w	d1,d3					; is current y vel lower than max?
		bls.s	.update_speed				; if so, branch
		move.w	d1,d3					; if greater than max, apply cap

.update_speed:
		move.w	d2,ost_x_vel(a0)			; set x vel
		move.w	d3,ost_y_vel(a0)			; set x vel
		rts

; ---------------------------------------------------------------------------
; Subroutine to stop all movement of an object
; Would be better to just insert the three instructions directly in object's
; code.
;
;	uses d0.l
; ---------------------------------------------------------------------------

MoveStop:
		moveq	#0,d0
		move.w	d0,ost_x_vel(a0)			; clear x vel
		move.w	d0,ost_y_vel(a0)			; clear y vel
		rts

; ---------------------------------------------------------------------------
; Subroutine to align a child object to its parent with variable x and y
; offset. Used by Grabber and Mecha Sonic.

; input:
;	d0 = x offset
;	d1 = y offset
;	a0 = parent object
;	a1 = child object

; output:
;	d2 = new x position
;	d3 = new y position

;	uses d0.w, d1.w, d2.w, d3.w, a0, a1
; ---------------------------------------------------------------------------

AlignChild:
		move.w	ost_x_pos(a0),d2			; d2 = parent's x pos
		add.w	d0,d2					; add offset to get child's x pos
		move.w	d2,ost_x_pos(a1)			; set child's xpos
		move.w	ost_y_pos(a0),d3			; d3 = parent's y pos
		add.w	d1,d3					; add offset to get child's y pos
		move.w	d3,ost_y_pos(a1)			; set child's y pos
		rts

; ---------------------------------------------------------------------------
; Subroutine to adjust an object's position based on the movement of the
; camera in SCZ.
; Used by the Tornado and SCZ badniks

; input:
;	a0 = object

;	uses d0.w, a0
; ---------------------------------------------------------------------------

AdjustPosSCZ:
		move.w	(v_tornado_x_vel).w,d0
		add.w	d0,ost_x_pos(a0)
		move.w	(v_tornado_y_vel).w,d0
		add.w	d0,ost_y_pos(a0)
		rts

; ---------------------------------------------------------------------------
; Subroutine to delete an object if it goes off the left side of the screen.
; Used by SCZ clouds and badniks.
;
; input:
;	a0 = object
;
;	uses d0.w
; ---------------------------------------------------------------------------

DeleteBehindScreen:
		tst.w	(f_two_player).w			; is it two-player mode? (it never will be in base game)
		beq.s	.chkgone				; if not, branch
		jmp	(DisplaySprite).l

	.chkgone:
		move.w	ost_x_pos(a0),d0
		andi.w	#-$80,d0
		sub.w	(v_camera_x_pos_coarse).w,d0
		bmi.w	JmpTo64_DeleteObject			; if more than 80 pixels to left of screen, delete
		jmp	(DisplaySprite).l			; else, display

; ---------------------------------------------------------------------------
; Subroutine to set a child object's x and y flip based on the parent object.
; Used only by Mecha Sonic and Grabber's legs.

; In the Sonic Classics version of Revision 2, ~(render_xflip|render_yflip)
; and ~(status_xflip|status_yflip) were changed to ~(render_yflip) and
; ~(status_yflip), breaking the x-flipping of the Grabbers' legs and Mecha
; Sonic's sparks.

; input:
;	a0 = parent object
;	a1 = child object

; 	uses d0.b, d1.b d2.b, a0, a1
; ---------------------------------------------------------------------------

InheritParentFlip:
		move.b	ost_render(a0),d0			; get child object's render flags
		andi.b	#~(render_xflip|render_yflip),d0	; clear x and y flip bits
		move.b	ost_primary_status(a0),d2		; do the same with the status flags
		andi.b	#~(status_xflip|status_yflip),d2
		move.b	ost_render(a1),d1			; get parent's render flags
		andi.b	#render_xflip|render_yflip,d1		; only need x and y flip bits
		or.b	d1,d0					; merge parent's x and y flip states with rest of child's render flags
		or.b	d1,d2					; same with status flags
		move.b	d0,ost_render(a0)			; set merged render flags
		move.b	d2,ost_primary_status(a0)		; set merged status flags
		rts

; ---------------------------------------------------------------------------
; Subroutine to spawn a child object using a childobjdata declaration

; input:
;	a0 = address of parent's OST slot
;	a1 = address of child's OST slot (set by call to FindNextFreeObj)
;	a2 = pointer to child object data

;	uses d0.w, a0, a1, a2
; ---------------------------------------------------------------------------

LoadChild:
		jsr	(FindNextFreeObj).l			; find free OST slot after parent
		bne.s	.fail					; branch if not found
		move.w	(a2)+,d0				; offset in parent's OST where pointer to child will be stored
		move.w	a1,(a0,d0.w)				; set pointer to child object
		_move.b	(a2)+,ost_id(a1)			; set child's ID
		move.b	(a2)+,ost_subdata_ptr(a1)		; set child's subobjdata pointer
		move.w	a0,ost_parent2(a1)			; set pointer to parent object
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

	.fail:
		rts

; ---------------------------------------------------------------------------
; Unused subroutine to set an object's x-flip state based on its x pos
; relative to the nearest player. Perhaps would have been used in conjunction
; with object-specific code to make a badnik always face the player?

; input:
;	a0 = object
;	d0 = 0 if player is left from object, 2 if right (set by FindPlayer)
; ---------------------------------------------------------------------------

		bsr.w	FindPlayer				; get nearest player
		bclr	#render_xflip_bit,ost_render(a0)	; clear x-flip bits
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	d0					; is object to right of nearest player?
		beq.s	.isright				; if so, branch
		bset	#render_xflip_bit,ost_render(a0)	; set x-flip bits
		bset	#status_xflip_bit,ost_primary_status(a0)

	.isright:
		rts

; ---------------------------------------------------------------------------
; Subroutine to create a specified number of moving projectiles.
; Used by Asteron and Mecha Sonic.
;
; input:
;	d2 = subtype, used for object initialization (refer to LoadSubObject)
;	d6 = number of projectiles to create-1
;	a0 = address of parent object
;	a2 = pointer to projectile data
;
; format:
;   dc.b x_offset, y_offset, x_vel, y_vel, ost_frame, ost_render

; output:
;	d1 = index in list
;	a1 = address of new projectile
;	a3 = points to end of projectile data

; uses d0.w, d1.w, d2.b, a0, a1, a2, a3
; ---------------------------------------------------------------------------

LoadProjectiles:
		moveq	#0,d1					; first index in projectile list

	.loop:
		jsr	(FindNextFreeObj).l			; find free OST slot after parent
		bne.s	.fail					; branch if not found
		_move.b	#id_Projectile,ost_id(a1)		; load projectile
		move.b	d2,ost_subdata_ptr(a1)			; set subobjdata pointer
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; align to parent object
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		lea	(SpeedToPos).l,a3			; address of movement subroutine to call
		move.l	a3,ost_proj_codeptr(a1)			; set movement type
;		move.l	#SpeedtoPos,ost_proj_codeptr(a1)	; above two instructions could be this
		lea	(a2,d1.w),a3				; get index into projectile data
		move.b	(a3)+,d0				; x offset
		ext.w	d0
		add.w	d0,ost_x_pos(a1)
		move.b	(a3)+,d0				; y offset
		ext.w	d0
		add.w	d0,ost_y_pos(a1)
		move.b	(a3)+,ost_x_vel(a1)			; set movement values
		move.b	(a3)+,ost_y_vel(a1)
		move.b	(a3)+,ost_frame(a1)			; set mapping frame
		move.b	(a3)+,ost_render(a1)			; set render flags
		addq.w	#6,d1					; advance to next index in projectile data
		dbf	d6,.loop				; repeat until all projectiles have been created

	.fail:
		rts
; ===========================================================================
; Custom sprite animation subroutine. Used only by Mecha Sonic.
AnimateSprite2:
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		cmp.b	ost_anim_restart(a0),d0
		beq.s	loc_3688C
		move.b	d0,ost_anim_restart(a0)
		move.b	#0,ost_anim_frame(a0)
		move.b	#0,ost_anim_time(a0)

loc_3688C:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_368B0
		add.w	d0,d0
		adda.w	(a1,d0.w),a1
		move.b	(a1),ost_anim_time(a0)
		moveq	#0,d1
		move.b	ost_anim_frame(a0),d1
		move.b	1(a1,d1.w),d0
		bmi.s	loc_368B4

loc_368A8:
		move.b	d0,ost_frame(a0)
		addq.b	#1,ost_anim_frame(a0)

loc_368B0:
		moveq	#0,d0
		rts
; ===========================================================================

loc_368B4:
		addq.b	#1,d0
		bne.s	loc_368C8
		move.b	#0,ost_anim_frame(a0)
		move.b	1(a1),d0
		bsr.s	loc_368A8
		moveq	#1,d0
		rts
; ===========================================================================

loc_368C8:
		addq.b	#1,d0
		bne.s	loc_368DE
		addq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_anim_time(a0)
		addq.b	#1,ost_anim_frame(a0)
		moveq	#1,d0
		rts
; ===========================================================================

loc_368DE:
		addq.b	#1,d0
		bne.s	loc_368EA
		addq.b	#2,ost_secondary_routine(a0)
		moveq	#1,d0
		rts
; ===========================================================================

loc_368EA:
		addq.b	#1,d0
		bne.s	locret_368F6
		move.b	#1,ost_anim_time(a0)
		moveq	#1,d0

locret_368F6:
		rts
; ===========================================================================
; Delete an object if it goes too far off-screen. Used only by the Tornado.
DeleteOffScreen:
		tst.w	(f_two_player).w
		beq.s	loc_36904
		jmp	(DisplaySprite).l
; ===========================================================================

loc_36904:
	if AllOptimizations
		out_of_range.s JmpTo64_DeleteObject,ost_x_pos(a0)
	else
		out_of_range.w JmpTo64_DeleteObject,ost_x_pos(a0)
	endc
		jmp	(DisplaySprite).l
; ===========================================================================

	if RemoveJmpTos
JmpTo65_DeleteObject:
	endc

JmpTo64_DeleteObject:
		jmp	(DeleteObject).l


; ===========================================================================
; ----------------------------------------------------------------------------
; Object 8C - Whisp
; ----------------------------------------------------------------------------

Whisp:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_36932(pc,d0.w),d1
		jmp	off_36932(pc,d1.w)
; ===========================================================================
off_36932:	index offset(*),,2
		ptr loc_3693C					; 0
		ptr loc_3694E					; 2
		ptr loc_369A8					; 4
		ptr loc_36958					; 6
		ptr loc_36A26					; 8
; ===========================================================================

loc_3693C:
		bsr.w	LoadSubObjData
		move.b	#$10,$2A(a0)
		move.b	#4,$2B(a0)
		rts
; ===========================================================================

loc_3694E:
		tst.b	ost_render(a0)
		bmi.s	loc_36970
		bra.w	loc_3695E
; ===========================================================================

loc_36958:
		subq.b	#1,$2A(a0)
		bmi.s	loc_36970

loc_3695E:
		lea	(Ani_Whisp).l,a1
		jsr	(AnimateSprite).l
		jmp	(DespawnObject).l
; ===========================================================================

loc_36970:
		subq.b	#1,$2B(a0)
		bpl.s	loc_36996
		move.b	#8,ost_primary_routine(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0)
		clr.w	ost_y_vel(a0)
		move.w	#-$200,ost_x_vel(a0)
		move.w	#-$200,ost_y_vel(a0)
		bra.w	loc_36A26
; ===========================================================================

loc_36996:
		move.b	#4,ost_primary_routine(a0)
		move.w	#-$100,ost_y_vel(a0)
		move.b	#$60,$2A(a0)

loc_369A8:
		subq.b	#1,$2A(a0)
		bmi.s	loc_369F8
		bsr.w	FindPlayer
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	d0
		beq.s	loc_369C2
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_369C2:
		move.w	word_369F4(pc,d0.w),d2
		add.w	d2,ost_x_vel(a0)
		move.w	word_369F4(pc,d1.w),d2
		add.w	d2,ost_y_vel(a0)
		move.w	#$200,d0
		move.w	d0,d1
		bsr.w	CapSpeed
		jsr	(SpeedToPos).l
		lea	(Ani_Whisp).l,a1
		jsr	(AnimateSprite).l
		jmp	(DespawnObject).l
; ===========================================================================
word_369F4:
		dc.w  -$10
		dc.w   $10
; ===========================================================================

loc_369F8:
		move.b	#6,ost_primary_routine(a0)
		jsr	(RandomNumber).l
		move.l	(v_random).w,d0
		andi.b	#$1F,d0
		move.b	d0,$2A(a0)
		bsr.w	MoveStop
		lea	(Ani_Whisp).l,a1
		jsr	(AnimateSprite).l
		jmp	(DespawnObject).l
; ===========================================================================

loc_36A26:
		jsr	(SpeedToPos).l
		lea	(Ani_Whisp).l,a1
		jsr	(AnimateSprite).l
		jmp	(DespawnObject).l
; ===========================================================================

SubData_Whisp:
		subobjdata	Map_Whisp,tile_Nem_Whisp+tile_pal2+tile_hi,render_rel,4,$18/2,id_col_8x8

Ani_Whisp:	index offset(*)
		ptr Ani_Whisp_Fly

Ani_Whisp_Fly:
		dc.b 1
		dc.b id_Frame_Whisp_WingUp
		dc.b id_Frame_Whisp_WingDown
		dc.b afEnd
; ===========================================================================

		include "mappings/sprite/Whisp.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Objects 8D and 8E - Grounder

; 8D = hidden behind wall; 8E = roving on ground
; ----------------------------------------------------------------------------
GrounderInWall:
GrounderOnGround:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Ground_Index(pc,d0.w),d1
		jmp	Ground_Index(pc,d1.w)
; ===========================================================================
Ground_Index:	index offset(*),,2
		ptr Ground_Init					; 0
		ptr Ground_Wait					; 2
		ptr Ground_BreakOut				; 4
		ptr Ground_StartRoam				; 6
		ptr Ground_Roaming				; 8
		ptr Ground_Pause				; $A

		rsobj	GrounderInWall,$2A
ost_ground_wait:		rs.b 1				; $2A ; time to wait before turning around
ost_ground_emerge:	rs.b 1					; $2B ; flag that triggers grounder's wall to break when set
		rsobjend
; ===========================================================================

Ground_Init:
		bsr.w	LoadSubObjData				; go to Ground_Wait next

		; It seems this object was at one time going to use the y-flip bit in the objpos data
		; to indicate different priority levels. If y-flip is not set, then high priority is used;
		; otherwise it is cleared. As it stands, all instances of this object have y-flip set,
		; meaning lower priority is always used.
		bclr	#render_yflip_bit,ost_render(a0)	; clear y-flip render bit
		beq.s	.no_yflip				; branch if it was already clear
		bclr	#status_yflip_bit,ost_primary_status(a0) ; clear y-flip status bit
		andi.w	#tile_draw,ost_tile(a0)			; clear priority bit

	.no_yflip:
		move.b	#$14,ost_height(a0)
		move.b	#$10,ost_width(a0)
		jsr	(FindFloorObj).l
		tst.w	d1					; is grounder on the floor?
		bpl.s	.chk_wall				; if not, branch
		add.w	d1,ost_y_pos(a0)			; align to floor
		move.w	#0,ost_y_vel(a0)

.chk_wall:
		_move.b	ost_id(a0),d0				; get ID
		subi.b	#id_GrounderInWall,d0
		beq.w	Ground_LoadWall				; branch if this is a Grounder hiding in a wall
		move.b	#id_Ground_StartRoam,ost_primary_routine(a0) ; if on ground, go to Ground_StartRoam next
		rts
; ===========================================================================

Ground_Wait:
		bsr.w	FindPlayer				; get nearest player
		abs.w d2					; d2 = absolute value of horizontal distance to nearest player
		cmpi.w	#$60,d2					; is a player within $60 pixels horizontally?
		bls.s	.within_60				; branch if so
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

	.within_60:
		addq.b	#2,ost_primary_routine(a0)		; go to Ground_Emerge next
		st.b	ost_ground_emerge(a0)			; signal wall to break apart
		bsr.w	Ground_LoadRocks			; load rocks
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Ground_BreakOut:
		lea	(Ani_Grounder1).l,a1			; go to Ground_StartRoam when animation is complete
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Ground_StartRoam:
		addq.b	#2,ost_primary_routine(a0)		; go to Ground_Roaming next
		bsr.w	FindPlayer
		move.w	Ground_Speeds(pc,d0.w),ost_x_vel(a0)	; set x vel based on direction to nearest player
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	d0
		beq.s	.no_xflip				; branch if player is to the left
		bset	#status_xflip_bit,ost_primary_status(a0) ; else, player is to the right

	.no_xflip:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Ground_Speeds:
		dc.w -$100
		dc.w $100
; ===========================================================================

Ground_Roaming:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos		; update position
		jsr	(FindFloorObj).l
		cmpi.w	#-1,d1
		blt.s	Ground_Stop				; branch if grounder is more than 1 pixel below floor
		cmpi.w	#$C,d1
		bge.s	Ground_Stop				; branch if grounder is more than $C pixels above floor
		add.w	d1,ost_y_pos(a0)			; align to floor
		lea	(Ani_Grounder2).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Ground_Stop:
		addq.b	#2,ost_primary_routine(a0)		; go to Ground_Pause next
		move.b	#60-1,ost_ground_wait(a0)		; wait for 60 frames
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Ground_Pause:
		subq.b	#1,ost_ground_wait(a0)			; decrement timer
		bmi.s	.turn_around				; branch if time has run out
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

	.turn_around:
		move.b	#id_Ground_Roaming,ost_primary_routine(a0) ; go back to Ground_Roaming
		neg.w	ost_x_vel(a0)				; reverse direction
		bchg	#status_xflip_bit,ost_primary_status(a0) ; x-flip
		jmpto	DespawnObject,JmpTo39_DespawnObject

; ----------------------------------------------------------------------------
; Object 8F - Wall behind which Grounder hides
; ----------------------------------------------------------------------------

GrounderWall:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	GWall_Index(pc,d0.w),d1
		jmp	GWall_Index(pc,d1.w)
; ===========================================================================

GWall_Index:	index offset(*),,2
		ptr GWall_Init					; 0
		ptr GWall_Wait					; 2
		ptr GWall_GRock_Fall				; 4

		rsobj GrounderWall,$2C
ost_gwall_parent: 		rs.w 1				; $2C ; parent grounder that spawned this object
ost_gwall_vel_index:	rs.w 1					; $2E ; index into GRock_Vels
		rsobjend
; ===========================================================================

GWall_Init:
	if FixBugs
		bra.w	LoadSubObjData
	else
		bsr.w	LoadSubObjData
		clr.w	ost_tile(a0)				; this is unnecessary, as it is already set to 0 (tile_LevelArt) by the call to LoadSubObjData
		rts
	endc
; ===========================================================================

GWall_Wait:
		movea.w	ost_gwall_parent(a0),a1			; a1 = parent grounder
		tst.b	ost_ground_emerge(a1)			; is grounder about to emerge?
		bne.s	.break_wall				; if so, branch
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

.break_wall:
		addq.b	#2,ost_primary_routine(a0)		; go to GWall_GRock_Fall next
		move.w	ost_gwall_vel_index(a0),d0		; get velocity table index
		move.b	Gwall_FragSpeeds(pc,d0.w),ost_x_vel(a0)	; set x vel
		move.b	Gwall_FragSpeeds+1(pc,d0.w),ost_y_vel(a0) ; set y vel
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Gwall_FragSpeeds:
		;   ost_x_vel, ost_y_vel
		dc.b   1,$FE					; 0
		dc.b   1,$FF					; 2
		dc.b $FF,$FE					; 4
		dc.b $FF,$FF					; 6

; ----------------------------------------------------------------------------
; Object 90 - Rocks thrown by Grounder behind wall
; ----------------------------------------------------------------------------

GrounderRocks:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	GRock_Index(pc,d0.w),d1
		jmp	GRock_Index(pc,d1.w)
; ===========================================================================

GRock_Index:	index offset(*),,2
		ptr GRock_Init					; 0
		ptr GWall_GRock_Fall				; 2

		rsobj GrounderRocks,$2C
ost_grock_parent: 		rs.w 1				; $2C ; parent grounder that spawned this object
ost_grock_vel_index:	rs.w 1					; $2E ; index into velocity and frame tables
		rsobjend
; ===========================================================================

GRock_Init:
		bsr.w	LoadSubObjData				; go to GWall_GRock_Fall next
	if FixBugs=0
		; See SubData_GRock.
		move.w	#tile_Nem_Grounder+tile_pal3,ost_tile(a0) ; why do this when you can put it in the subtype data?
	endc
		move.w	ost_grock_vel_index(a0),d0		; get velocity table index
		move.b	GRock_Vels(pc,d0.w),ost_x_vel(a0)	; set x vel
		move.b	GRock_Vels+1(pc,d0.w),ost_y_vel(a0)	; set y_vel
		lsr.w	#1,d0					; divide by 2 to get frame index
		move.b	GRock_Frames(pc,d0.w),ost_frame(a0)	; set mapping frame
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

GRock_Frames:
		dc.b   id_Frame_GRock_Large			; 0
		dc.b   id_Frame_GRock_Small			; 1
		dc.b   id_Frame_GRock_Large			; 2
		dc.b   id_Frame_GRock_Medium			; 3
		dc.b   id_Frame_GRock_Large			; 4
		dc.b   id_Frame_GRock_Large			; 5

GRock_Vels:
		dc.b  -1, -4
		dc.b   4, -3					; 2
		dc.b   2,  0					; 4
		dc.b  -3, -1					; 6
		dc.b  -3, -3					; 8
; ===========================================================================

GWall_GRock_Fall:
		tst.b	ost_render(a0)				; is object still on-screen?
		bpl.w	JmpTo65_DeleteObject			; if not, delete
		jsrto	ObjectFall,JmpTo8_ObjectFall		; apply gravity
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Ground_LoadRocks:
		moveq	#0,d1					; initial index into GRock_Vels
		moveq	#5-1,d6					; five rocks to load

	.loadloop:
		jsrto	FindFreeObj,JmpTo19_FindFreeObj		; find free OST slot
		bne.s	.fail					; branch if not found
		bsr.w	.loadrock				; load one instance of GrounderRocks object  (could be bsr.s or inlined)
		dbf	d6,.loadloop

	.fail:
		rts
; ===========================================================================

	.loadrock:
		_move.b	#id_GrounderRocks,ost_id(a1)		; load grounder's rock
		move.b	#id_SubData_GRock,ost_subdata_ptr(a1)	; index to ost data
		move.w	a0,ost_grock_parent(a1)			; set pointer to parent
		move.w	d1,ost_grock_vel_index(a1)		; set velocity table index
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; spawn at parent grounder's position
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addq.w	#2,d1					; next velocity table index
		rts
; ===========================================================================

Ground_LoadWall:
		moveq	#0,d1					; initial index into GWall_Offsets
		moveq	#4-1,d6					; four objects to load

	.loadloop:
		jsrto	FindFreeObj,JmpTo19_FindFreeObj		; find free OST slot
		bne.s	.fail					; branch if not found
		bsr.w	.loadwall				; load one instance of GrounderWall object (could be bsr.s or inlined)
		dbf	d6,.loadloop

	.fail:
		rts
; ===========================================================================

	.loadwall:
		_move.b	#id_GrounderWall,ost_id(a1)		; load grounder's Wall
		move.b	#id_SubData_GWall,ost_subdata_ptr(a1)	; index to ost data
		move.w	a0,ost_gwall_parent(a1)			; set pointer to parent
		move.w	d1,ost_gwall_vel_index(a1)		; set velocity table index

		move.l	ost_x_pos(a0),d0			; get parent grounder's x pos
		swap	d0					; offset is added to high word
		moveq	#0,d2
		move.b	GWall_Offsets(pc,d1.w),d2		; get x offset from array
		ext.w	d2
		add.w	d2,d0					; add offset to parent x pos
		swap	d0					; swap words back
		move.l	d0,ost_x_pos(a1)			; store x pos

		move.l	ost_y_pos(a0),d0			; get parent grounder's x pos
		swap	d0					; offset is added to high word
		moveq	#0,d2
		move.b	GWall_Offsets+1(pc,d1.w),d2		; get y offset from array
		ext.w	d2
		add.w	d2,d0					; add offset to parent y pos
		swap	d0					; swap words back
		move.l	d0,ost_y_pos(a1)			; store pos

		addq.w	#2,d1					; next index in GWall_Offsets
		rts

; ----------------------------------------------------------------------------
; Offsets for Grounder's wall relative to parent
; ----------------------------------------------------------------------------

GWall_Offsets:
		dc.b    0,-$14					; 0
		dc.b  $10,  -4					; 2
		dc.b    0,  $C					; 4
		dc.b -$10,  -4					; 6
; ===========================================================================

SubData_Ground:
		subobjdata	Map_Ground,tile_nem_Grounder+tile_pal2+tile_hi,render_rel,5,$20/2,id_col_12x20 ; tile_hi is cleared by init code

SubData_GWall:
		subobjdata	Map_GWall,tile_LevelArt,render_rel|render_onscreen,4,$20/2,id_col_null

SubData_GRock:
	if FixBugs
		; The correct tile setting for this object.
		subobjdata	Map_GRock,tile_Nem_Grounder+tile_pal3,render_rel|render_onscreen,4,$10/2,id_col_null
	else
		; The tile setting here is incorrect, and is corrected with an additional instruction
		; in the object's code. It'd make more sense to put the correct setting here and eliminate
		; the additional instruction.
		subobjdata	Map_GRock,tile_nem_Grounder+tile_pal2+tile_hi,render_rel|render_onscreen,4,$10/2,id_col_null
	endc

; ----------------------------------------------------------------------------
; Animation scripts

; Absolutely no reason for these to be complete separate like this.
; ----------------------------------------------------------------------------

Ani_Grounder2:	index offset(*)
		ptr Ground_Roam

Ground_Roam:
		dc.b id_Frame_Ground_Roam2
		dc.b id_Frame_Ground_Roam1
		dc.b id_Frame_Ground_Roam2
		dc.b id_Frame_Ground_Roam3
		dc.b afEnd
		even

Ani_Grounder1:	index offset(*)
		ptr Ground_Emerge				; 0

Ground_Emerge:
		dc.b 7
		dc.b id_Frame_Ground_Emerge1
		dc.b id_Frame_Ground_Emerge2
		dc.b afRoutine

; ===========================================================================

		include "mappings/sprite/Grounder.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 91 - Chop Chop
; ----------------------------------------------------------------------------

ChopChop:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Chop_Index(pc,d0.w),d1
		jmp	Chop_Index(pc,d1.w)
; ===========================================================================
Chop_Index:	index offset(*),,2
		ptr loc_36DC2					; 0
		ptr loc_36DE4					; 2
		ptr loc_36E32					; 4
		ptr loc_36E66					; 6
; ===========================================================================

loc_36DC2:
		bsr.w	LoadSubObjData
		move.w	#$200,$2A(a0)
		move.w	#$50,$2C(a0)
		moveq	#$40,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_36DDE
		neg.w	d0

loc_36DDE:
		move.w	d0,ost_x_vel(a0)
		rts
; ===========================================================================

loc_36DE4:
		subq.b	#1,$2C(a0)
		bne.s	loc_36DEE
		bsr.w	loc_36E78

loc_36DEE:
		subq.w	#1,$2A(a0)
		bpl.s	loc_36E0A
		move.w	#$200,$2A(a0)
		bchg	#status_xflip_bit,ost_primary_status(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		neg.w	ost_x_vel(a0)

loc_36E0A:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	FindPlayer
		move.w	d2,d4
		move.w	d3,d5
		bsr.w	loc_36EB2
		bne.s	loc_36E20
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36E20:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$10,$2A(a0)
		clr.w	ost_x_vel(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36E32:
		subq.b	#1,$2A(a0)
		bmi.s	loc_36E3C
		bra.w	loc_36E6A
; ===========================================================================

loc_36E3C:
		addq.b	#2,ost_primary_routine(a0)
		bsr.w	FindPlayer
		lsr.w	#1,d0
		move.b	byte_36E62(pc,d0.w),ost_x_vel(a0)
		addi.w	#$10,d3
		cmpi.w	#$20,d3
		bcs.s	loc_36E5E
		lsr.w	#1,d1
		move.b	byte_36E64(pc,d1.w),ost_y_vel+1(a0)

loc_36E5E:
		bra.w	loc_36E6A
; ===========================================================================
byte_36E62:
		dc.b  -2					; 0 - player is left from object -> move left
		dc.b   2					; 1 - player is right from object -> move right
byte_36E64:
		dc.b $80					; 0 - player is above object -> ...move down?
		dc.b $80					; 1 - player is below object -> move down
; ===========================================================================

loc_36E66:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos

loc_36E6A:
		lea	(Ani_Chop).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36E78:
		move.w	#$50,$2C(a0)
		jsrto	FindFreeObj,JmpTo19_FindFreeObj
		bne.s	locret_36EB0
		_move.b	#id_DrownCount,ost_id(a1)		; load DrownCount object
		move.b	#id_Ani_Drown_SmallBubble,ost_subtype(a1) ; small bubble subtype
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		moveq	#$14,d0
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_36EA2
		neg.w	d0

loc_36EA2:
		add.w	d0,ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addq.w	#6,ost_y_pos(a1)

locret_36EB0:
		rts
; ===========================================================================

loc_36EB2:
		addi.w	#$20,d3
		cmpi.w	#$40,d3
		bcc.s	loc_36EDE
		tst.w	d2
		bmi.s	loc_36ECA
		tst.w	ost_x_vel(a0)
		bpl.s	loc_36EDE
		bra.w	loc_36ED2
; ===========================================================================

loc_36ECA:
		tst.w	ost_x_vel(a0)
		bmi.s	loc_36EDE
		neg.w	d2

loc_36ED2:
		cmpi.w	#$20,d2
		bcs.s	loc_36EDE
		cmpi.w	#$A0,d2
		bcs.s	loc_36EE2

loc_36EDE:
		moveq	#0,d2
		rts
; ===========================================================================

loc_36EE2:
		moveq	#1,d2
		rts
; ===========================================================================

SubData_Chop:
		subobjdata	Map_Chop,tile_nem_ChopChop+tile_pal2,render_rel,4,$20/2,id_col_12x20

; ----------------------------------------------------------------------------
; Animation script
; ----------------------------------------------------------------------------

Ani_Chop:	index offset(*)
		ptr Chop_Swim

Chop_Swim:
		dc.b 4
		dc.b id_Frame_Chop_Closed
		dc.b id_Frame_Chop_Open
		dc.b afEnd
; ===========================================================================

		include "mappings/sprite/Chop Chop.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 92 - Spiker
; ----------------------------------------------------------------------------

Spiker:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Spiker_Index(pc,d0.w),d1
		jmp	Spiker_Index(pc,d1.w)
; ===========================================================================
Spiker_Index:	index offset(*),,2
		ptr loc_36F24					; 0
		ptr loc_36F3C					; 2
		ptr loc_36F68					; 4
		ptr loc_36F90					; 6
; ===========================================================================

loc_36F24:
		bsr.w	LoadSubObjData
		move.b	#$40,$2A(a0)
		move.w	#$80,ost_x_vel(a0)
		bchg	#status_xflip_bit,ost_primary_status(a0)
		rts
; ===========================================================================

loc_36F3C:
		bsr.w	loc_3703E
		bne.s	loc_36F48
		subq.b	#1,$2A(a0)
		bmi.s	loc_36F5A

loc_36F48:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(Ani_Spiker).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36F5A:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$10,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36F68:
		bsr.w	loc_3703E
		bne.s	loc_36F74
		subq.b	#1,$2A(a0)
		bmi.s	loc_36F78

loc_36F74:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36F78:
		subq.b	#2,ost_primary_routine(a0)
		move.b	#$40,$2A(a0)
		neg.w	ost_x_vel(a0)
		bchg	#status_xflip_bit,ost_primary_status(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36F90:
		move.b	$2E(a0),d0
		cmpi.b	#8,d0
		beq.s	loc_36FA4
		subq.b	#1,d0
		move.b	d0,$2E(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_36FA4:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	loc_36FDC
		st.b	$2B(a0)
		_move.b	#id_SpikerDrill,ost_id(a1)
		move.b	ost_subdata_ptr(a0),ost_subdata_ptr(a1)
		move.w	a0,$2C(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#4,ost_frame(a1)
		move.b	#2,ost_frame(a0)
		move.b	#1,ost_anim(a0)

loc_36FDC:
		move.b	$2F(a0),ost_primary_routine(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 93 - Spiker's drill
; ----------------------------------------------------------------------------

SpikerDrill:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SpkDrill_Index(pc,d0.w),d1
		jmp	SpkDrill_Index(pc,d1.w)
; ===========================================================================
SpkDrill_Index:	index offset(*),,2
		ptr loc_36FF8					; 0
		ptr loc_37028					; 2
; ===========================================================================

loc_36FF8:
		bsr.w	LoadSubObjData
		ori.b	#render_onscreen,ost_render(a0)
		ori.b	#id_col_hurt,ost_col_type(a0)
		movea.w	$2C(a0),a1
		move.b	ost_render(a1),d0
		andi.b	#3,d0
		or.b	d0,ost_render(a0)
		moveq	#2,d1
		btst	#1,d0
		bne.s	loc_37022
		neg.w	d1

loc_37022:
		move.b	d1,ost_y_vel(a0)
		rts
; ===========================================================================

loc_37028:
		tst.b	ost_render(a0)
		bpl.w	JmpTo65_DeleteObject
		bchg	#render_xflip_bit,ost_render(a0)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3703E:
		tst.b	$2B(a0)
		bne.s	loc_37062
		tst.b	ost_render(a0)
		bpl.s	loc_37062
		bsr.w	FindPlayer
		addi.w	#$20,d2
		cmpi.w	#$40,d2
		bcc.s	loc_37062
		addi.w	#$80,d3
		cmpi.w	#$100,d3
		bcs.s	loc_37066

loc_37062:
		moveq	#0,d0
		rts
; ===========================================================================

loc_37066:
		move.b	ost_primary_routine(a0),$2F(a0)
		move.b	#6,ost_primary_routine(a0)
		move.b	#$10,$2E(a0)
		moveq	#1,d0
		rts
; ===========================================================================

SubData_Spiker:
		subobjdata	Map_Spiker,tile_LevelArt,render_rel,4,$20/2,id_col_8x16

Ani_Spiker:	index offset(*)
		ptr byte_3708A					; 0
		ptr byte_3708E					; 1

byte_3708A:
		dc.b   9,  0,  1,$FF				; 0

byte_3708E:
		dc.b   9,  2,  3,$FF				; 0

; ===========================================================================

		include "mappings/sprite/Spiker.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 95 - Sol
; ----------------------------------------------------------------------------

Sol:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Sol_Index(pc,d0.w),d1
		jmp	Sol_Index(pc,d1.w)
; ===========================================================================
Sol_Index:	index offset(*),,2
		ptr loc_37116					; 0
		ptr loc_371DC					; 1
		ptr loc_37224					; 2
		ptr loc_3723C					; 3
		ptr loc_372B8					; 4
; ===========================================================================

loc_37116:
		move.l	#Map_Sol,ost_mappings(a0)
		move.w	#tile_LevelArt,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo64_AdjustVRAM2P
		ori.b	#render_rel,ost_render(a0)
		move.b	#4,ost_priority(a0)
		move.b	#id_col_8x8,ost_col_type(a0)
		move.b	#$C,ost_displaywidth(a0)
		move.w	#-$40,ost_x_vel(a0)
		moveq	#0,d2
		lea	$37(a0),a2
		movea.l	a2,a3
		addq.w	#1,a2
		moveq	#3,d1

loc_37152:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	loc_371AE
		addq.b	#1,(a3)
		move.w	a1,d5
		subi.w	#-$5000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		_move.b	ost_id(a0),ost_id(a1)
		move.b	#6,ost_primary_routine(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		ori.b	#render_rel,ost_render(a1)
		move.b	#4,ost_priority(a1)
		move.b	#8,ost_displaywidth(a1)
		move.b	#3,ost_frame(a1)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a1)
		move.b	d2,ost_angle(a1)
		addi.b	#$40,d2
		move.l	a0,$3C(a1)
		dbf	d1,loc_37152

loc_371AE:
		moveq	#1,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_371BA
		neg.w	d0

loc_371BA:
		move.b	d0,$36(a0)
		move.b	ost_subtype(a0),ost_primary_routine(a0)
		addq.b	#2,ost_primary_routine(a0)
		move.w	#-$40,ost_x_vel(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	locret_371DA
		neg.w	ost_x_vel(a0)

locret_371DA:
		rts
; ===========================================================================

loc_371DC:
		move.w	($FFFFB008).w,d0
		sub.w	ost_x_pos(a0),d0
		bcc.s	loc_371E8
		neg.w	d0

loc_371E8:
		cmpi.w	#$A0,d0
		bcc.s	loc_3720C
		move.w	($FFFFB00C).w,d0
		sub.w	ost_y_pos(a0),d0
		bcc.s	loc_371FA
		neg.w	d0

loc_371FA:
		cmpi.w	#$50,d0
		bcc.s	loc_3720C
		tst.w	(v_debug_active).w
		bne.s	loc_3720C
		move.b	#1,ost_anim(a0)

loc_3720C:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_372D2).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		andi.b	#3,ost_frame(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37224:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_372E0).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		andi.b	#3,ost_frame(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3723C:
		lea	(off_372E0).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		movea.l	$3C(a0),a1
		_cmpi.b	#id_Sol,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		cmpi.b	#2,ost_frame(a1)
		bne.s	loc_3728E
		cmpi.b	#$40,ost_angle(a0)
		bne.s	loc_3728E
		addq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_anim(a0)
		subq.b	#1,$37(a1)
		bne.s	loc_37278
		addq.b	#2,ost_primary_routine(a1)

loc_37278:
		move.w	#-$200,ost_x_vel(a0)
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_3728A
		neg.w	ost_x_vel(a0)

loc_3728A:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3728E:
		move.b	ost_angle(a0),d0
		jsr	(CalcSine).l
		asr.w	#4,d1
		add.w	ost_x_pos(a1),d1
		move.w	d1,ost_x_pos(a0)
		asr.w	#4,d0
		add.w	ost_y_pos(a1),d0
		move.w	d0,ost_y_pos(a0)
		move.b	$36(a1),d0
		add.b	d0,ost_angle(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_372B8:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		tst.b	ost_render(a0)
		bpl.w	JmpTo65_DeleteObject
		lea	(off_372E0).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_372D2:	index offset(*)
		ptr byte_372D6					; 0
		ptr byte_372DA					; 1

byte_372D6:
		dc.b  $F,  0,$FF,  0				; 0

byte_372DA:
		dc.b  $F,  1,  2,$FE,  1,  0			; 0

off_372E0:	index offset(*)
		ptr byte_372E2

byte_372E2:
		dc.b   5,  3,  4,$FF				; 0
; ===========================================================================

		include "mappings/sprite/Sol.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Objects 94 and 96 - Rexon's body

; All instances in game are object ID 96.
; ----------------------------------------------------------------------------
Rexon_Dup:
Rexon:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Rex_Index(pc,d0.w),d1
		jmp	Rex_Index(pc,d1.w)
; ===========================================================================
Rex_Index:	index offset(*),,2
		ptr Rex_Init					; 0
		ptr Rex_Wait					; 2
		ptr Rex_Wait_Stationary				; 4 ; unused
		ptr Rex_HeadSpawned				; 6

		rsobj Rexon,$2A
ost_rex_turntime:	rs.b 1					; $2A ; time until Rexon turns around
					rs.b 1			; unused
ost_rex_neck1:		rs.w 1					; $2C, pointer to bottommost next segment (does NOT oscillate)
ost_rex_neck2:		rs.w 1					; $2E, pointer to second neck segment
ost_rex_neck3:		rs.w 1					; $30, pointer to third neck segment
ost_rex_neck4:		rs.w 1					; $32, pointer to fourth neck segment
ost_rex_head:		rs.w 1					; $34, pointer to head
		rsobjend
; ==========================================================================

Rex_Init: ; Routine 0
		bsr.w	LoadSubObjData				; go to Rex_Wait next
		move.b	#id_Frame_Rexon_Body,ost_frame(a0)
		move.w	#-$20,ost_x_vel(a0)
		move.b	#$80,ost_rex_turntime(a0)		; move left for 128 frames
		rts
; ===========================================================================

Rex_Wait: ; Routine 2
		bsr.w	FindPlayer				; get nearest player
		addi.w	#$60,d2
		cmpi.w	#$100,d2
		bcc.s	.no_spawn				; branch if they're not close enough yet
		bsr.w	Rex_SpawnHead

	.no_spawn:
		move.w	ost_x_pos(a0),-(sp)			; back up current x pos
		bsr.w	Rex_CheckTurnAround
		move.w	#$36/2,d1				; all of these could be moveq
		move.w	#$10/2,d2
		move.w	#$22/2,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo27_SolidObject
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Rex_CheckTurnAround:
		subq.b	#1,ost_rex_turntime(a0)			; decrement timer
		bpl.s	.no_turn				; branch if time remains
		move.b	#$80,ost_rex_turntime(a0)		; reset timer
		neg.w	ost_x_vel(a0)				; reverse direction
		bchg	#render_xflip_bit,ost_render(a0)	; invert x flip state

	.no_turn:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		rts
; ===========================================================================
; This routine appears to be completely unused. It is identical to Rex_Wait
; except it lacks the code to move the Rexon horizontally while waiting. My
; guess is that object ID 94 would have been used for a Rexon that did not move
; while waiting, with code in Rex_Init to set this routine.

Rex_Wait_Stationary: ; Routine 4 (unused)
		bsr.w	FindPlayer				; find nearest player
		addi.w	#$60,d2
		cmpi.w	#$100,d2
		bcc.s	.no_spawn				; branch if they're not close enough yet
		bsr.w	Rex_SpawnHead

	.no_spawn:
		bsr.w	Rex_Solid				; run solidity checks
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

Rex_Solid:
		move.w	#$36/2,d1				; width
		move.w	#$10/2,d2				; height (jumping)
		move.w	#$10/2,d3				; height (walking)
		move.w	ost_x_pos(a0),d4
		jmpto	SolidObject,JmpTo27_SolidObject
; ===========================================================================

Rex_HeadSpawned: ; Routine 6
		bsr.s	Rex_Solid				; run solidity checks
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 97 - Rexon's head and neck
; ----------------------------------------------------------------------------

RexonHead:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	RexHead_Index(pc,d0.w),d1
		jmp	RexHead_Index(pc,d1.w)
; ===========================================================================
RexHead_Index:	index offset(*),,2
		ptr RexHead_Init				; 0
		ptr RexHead_Wait				; 2
		ptr RexHead_Raise				; 4
		ptr RexHead_Risen				; 6
		ptr RexHead_Defeated				; 8

		rsobj RexonHead,$2A
ost_rexhead_timer:		rs.b 1				; $2A ; multi-use delay timer
ost_rexhead_osc_index:	rs.b 1					; $2B ; current index into oscillating data
ost_rexhead_parent:		rs.w 1				; $2C ; pointer to parent Rexon
ost_rexhead_subid:		rs.w 1				; $2E ; subid of object
ost_rexhead_nextseg:	rs.w 1					; $30 ; pointer to next neck segment above
ost_rexhead_headptr:	rs.w 1					; $32 ; pointer to head
		rsset $38
ost_rexhead_osc_delta:	rs.b 1					; $38 ; current delta for changing the oscillation index
ost_rexhead_framecount:	rs.b 1					; $39 ; counter that increments every frame, used for oscillation timing
		rsobjend

; Sub IDs for the individual instances of this object
		rsreset
id_RexHead_Neck1:	rs.w 1					; 0
id_RexHead_Neck2:	rs.w 1					; 2
id_RexHead_Neck3:	rs.w 1					; 4
id_RexHead_Neck4:	rs.w 1					; 6
id_RexHead_Head:	rs.w 1					; 8

countof_rexnecksegs:	equ 4

; ===========================================================================

RexHead_Init: ; Routine 0
		bsr.w	LoadSubObjData				; go to RexHead_Wait next
		move.b	#8,ost_displaywidth(a0)
		moveq	#$28,d0					; start $28 pixels to right of body if x-flipped
		btst	#render_xflip_bit,ost_render(a0)	; head inherits x flip state of body
		bne.s	.xflip					; branch if x-flipped
		moveq	#-$18,d0				; start $18 pixels to left of body if not x-flipped

	.xflip:
		add.w	d0,ost_x_pos(a0)			; set x pos
		addi.w	#$10,ost_y_pos(a0)			; start $10 pixels below body
		move.b	#1,ost_rexhead_osc_delta(a0)		; initial oscillation movement is to the right
		movea.w	ost_rexhead_parent(a0),a1		; a1 = parent Rexon
		lea	ost_rex_neck2(a1),a1			; a1 = location of parent's pointer to second neck segment from body
		move.b	#id_col_8x8,ost_col_type(a0)		; set proper collision
		moveq	#0,d0
		move.w	ost_rexhead_subid(a0),d0		; get sub ID
		cmpi.w	#id_RexHead_Head,d0
		beq.s	.is_head				; branch if this is the head
		move.b	#id_Frame_Rexon_Neck,ost_frame(a0)
		move.b	#id_col_8x8+id_col_hurt,ost_col_type(a0)
		move.w	(a1,d0.w),ost_rexhead_nextseg(a0)	; set pointer to next neck segment immediately above

	.is_head:
		move.w	ost_rex_head-ost_rex_neck2(a1),ost_rexhead_headptr(a0) ; set pointer to head
		lsr.w	#1,d0
		move.b	RexHead_Delays(pc,d0.w),ost_rexhead_timer(a0) ; time until segment emerges from lava
		move.b	d0,ost_rexhead_framecount(a0)		; initialize frame counter with sub id / 2 to stagger oscillation
		rts
; ===========================================================================
; Time in frames to wait before segment emerges from lava, and time to wait
; before entering RexHead_Risen.
RexHead_Delays:
		dc.b $1E					; id_RexHead_Neck1, id_RexHead_Head
		dc.b $18					; id_RexHead_Neck2, id_RexHead_Neck4
		dc.b $12					; id_RexHead_Neck3
		dc.b  $C					; id_RexHead_Neck4, id_RexHead_Neck2
		dc.b   6					; id_RexHead_Head,	id_RexHead_Neck1
		even
; ===========================================================================

RexHead_Wait: ; Routine 2
	if	(Revision<2)&(FixBugs=0)
		; This call is in the wrong place. If ost_rexhead_timer expires on the same frame
		; as the Rexon is defeated, the routine will be erroneously set back to RexHead_Raise;
		; potentially causing a crash. It should be moved to after the timer check...
		bsr.w	RexHead_CheckAlive
	endc
		subq.b	#1,ost_rexhead_timer(a0)		; decrement delay timer
		bmi.s	RexHead_StartRaise			; branch if expired
	if (Revision=2)|FixBugs
		; ...like so.
		bsr.w	RexHead_CheckAlive
	endc
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

RexHead_StartRaise:
		addq.b	#2,ost_primary_routine(a0)		; go to RexHead_Raise next
		move.w	#-$120,ost_x_vel(a0)
		move.w	#-$200,ost_y_vel(a0)
		move.w	ost_rexhead_subid(a0),d0		; get sub ID
		subi_.w	#id_RexHead_Head,d0			; invert ID
		neg.w	d0
		lsr.w	#1,d0
		move.b	RexHead_Delays(pc,d0.w),ost_rexhead_timer(a0) ; time until segment advances to RexHead_Risen
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

RexHead_Raise: ; Routine 4
	if	(Revision<2)&(FixBugs=0)
		; Same bug as RexHead_Wait.
		bsr.w	RexHead_CheckAlive
	endc
		moveq	#$10,d0
		add.w	d0,ost_x_vel(a0)			; reduce x vel
		subq.b	#1,ost_rexhead_timer(a0)		; decrement timer
		bmi.s	.raisedone				; branch if expired
	if (Revision=2)|FixBugs
		bsr.w	RexHead_CheckAlive
	endc
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

.raisedone:
		addq.b	#2,ost_primary_routine(a0)		; go to RexHead_Risen next
		bsr.w	MoveStop				; stop movement
		move.b	#$20,ost_rexhead_timer(a0)		; time to wait before head fires a projectile
		move.w	ost_rexhead_subid(a0),d0		; get sub ID
		lsr.w	#1,d0
		move.b	RexHead_OscIndicies(pc,d0.w),ost_rexhead_osc_index(a0) ; set initial oscillation index
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

RexHead_OscIndicies:
		dc.b $24					; 0
		dc.b $20					; 1
		dc.b $1C					; 2
		dc.b $1A					; 3
		even
; ===========================================================================

RexHead_Risen: ; Routine 6
		bsr.w	RexHead_CheckAlive
		cmpi.w	#id_RexHead_Head,ost_rexhead_subid(a0)
		bne.s	.nothead				; branch if this not the head
		subq.b	#1,ost_rexhead_timer(a0)		; decrement timer
		bpl.s	.nothead				; branch if time remains
		bsr.w	RexHead_FireProjectile			; fire a projectile

	.nothead:
		move.b	ost_rexhead_framecount(a0),d0
		addq.b	#1,d0					; increment frame counter
		move.b	d0,ost_rexhead_framecount(a0)
		andi.b	#3,d0
		bne.s	.display				; only run oscillation every four frames
		bsr.w	RexHead_UpdateOscIndex
		bsr.w	RexHead_Oscillate

	.display:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

RexHead_Defeated: ; Routine 8
		move.w	(v_boundary_bottom).w,d0
		addi.w	#$E0,d0
		cmp.w	ost_y_pos(a0),d0			; has neck segment passed below bottom boundary?
		bcs.w	JmpTo65_DeleteObject			; if so, delete
		jsrto	ObjectFall,JmpTo8_ObjectFall
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

RexHead_CheckAlive:
		movea.w	ost_rexhead_headptr(a0),a1		; a1 = pointer to head
		cmpi.b	#id_RexonHead,(a1)			; is the head still loaded?
		beq.s	.stillalive				; branch if so
		move.b	#id_RexHead_Defeated,ost_primary_routine(a0) ; go to RexHead_Defeated next
		move.w	ost_rexhead_subid(a0),d0
		move.w	RexHead_DeathVels(pc,d0.w),ost_x_vel(a0) ; set initial x vel for neck segments as they scatter

	.stillalive:
		rts
; ===========================================================================

RexHead_DeathVels:
		dc.w   $80					; id_RexHead_Neck1
		dc.w -$100					; id_RexHead_Neck2
		dc.w  $100					; id_RexHead_Neck3
		dc.w  -$80					; id_RexHead_Neck4
		dc.w   $80					; id_RexHead_Head
; ===========================================================================

RexHead_FireProjectile:
		move.b	#$7F,ost_rexhead_timer(a0)		; wait 127 frames before firing next projectile
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj	; find free OST slot after parent
		bne.s	.fail					; branch if not found
		_move.b	#id_Projectile,ost_id(a1)		; load projectile
		move.b	#id_Frame_Rexon_Proj,ost_frame(a1)
		move.b	#id_SubData_RexProj,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		lea	(SpeedToPos).l,a2			; SpeedToPos is the only code this object runs
		move.l	a2,ost_proj_codeptr(a1)			; (these two instructions could be 'move.l #SpeedToPos,ost_proj_codeptr(a1)')
		moveq	#1,d0					; x vel
		moveq	#$10,d1					; x pos offset from parent
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	.xflip					; branch if Rexon is x-flipped
		neg.w	d0					; invert x vel and initial offset values
		neg.w	d1

	.xflip:
		move.b	d0,ost_x_vel(a1)			; set x vel
		add.w	d1,ost_x_pos(a1)			; apply x pos offset
		addq.w	#4,ost_y_pos(a1)			; apply y pos offset
		move.b	#$80,ost_y_vel+1(a1)			; set y vel

	.fail:
		rts
; ===========================================================================

RexHead_UpdateOscIndex:
		move.b	ost_rexhead_osc_index(a0),d0		; get current index
		move.b	ost_rexhead_osc_delta(a0),d1		; get current delta
		add.b	d1,d0					; apply delta
		move.b	d0,ost_rexhead_osc_index(a0)		; store new index
		subi.b	#$18,d0
		beq.s	.change_direction			; branch if new index is $18 or lower
		bcs.s	.change_direction
		cmpi.b	#$10,d0
		bcs.s	.done					; branch if new index is less than $28

	.change_direction:
		neg.b	ost_rexhead_osc_delta(a0)		; invert delta

	.done:
		rts

; ----------------------------------------------------------------------------
; Subroutine to load the Rexon's head and neck
; ----------------------------------------------------------------------------

Rex_SpawnHead:
		move.b	#id_Rex_HeadSpawned,ost_primary_routine(a0) ; go to Rex_HeadSpawned next
		bclr	#render_xflip_bit,ost_render(a0)	; Rexon faces left
		tst.w	d0					; d0 = direction to nearest player
		beq.s	.no_xflip				; branch if nearest player is to the left
		bset	#render_xflip_bit,ost_render(a0)	; Rexon faces right

	.no_xflip:
		bsr.w	MoveStop				; stop body's movement
		lea	ost_rex_neck1(a0),a2			; a2 = first child pointer
		moveq	#id_RexHead_Neck1,d1			; starting with first neck segment
		moveq	#(countof_rexnecksegs+1)-1,d6		; four neck segments plus the head

	.spawn:
		jsrto	FindFreeObj,JmpTo19_FindFreeObj		; find free OST slot
		bne.s	.fail					; branch if not found
		_move.b	#id_RexonHead,ost_id(a1)		; load Rexon's head
		move.b	ost_render(a0),ost_render(a1)
		move.b	ost_subdata_ptr(a0),ost_subdata_ptr(a1)	; index to subobjdata
		move.w	a0,ost_rexhead_parent(a1)		; set pointer to parent
		move.w	a1,(a2)+				; set parent's child pointer
		move.w	d1,ost_rexhead_subid(a1)		; set sub ID
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; match parent position initially (will be adjusted later)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addq.w	#2,d1					; next sub ID
		dbf	d6,.spawn				; repeat for all segments plus head

	.fail:
		rts

; ----------------------------------------------------------------------------
; Subroutine to oscillate the Rexon's head and neck. Note that it actually
; applies the oscillation to the next segment above, rather than the one
; that called this subroutine.
; ----------------------------------------------------------------------------

RexHead_Oscillate:
		move.w	ost_rexhead_nextseg(a0),d0		; get ID of next segment (0 for head)
		beq.s	.exit					; return if this is the head
		movea.w	d0,a1					; we actually oscillate the next segment above of us
		lea	RexHead_OscData(pc),a2
		moveq	#0,d0
		move.b	ost_rexhead_osc_index(a0),d0		; get index
		andi.b	#$7F,d0					; discard highest bit
		move.w	d0,d1					;
		andi.w	#$1F,d0					; RexHead_OscData array has only 32 entries
		add.w	d0,d0
		move.b	(a2,d0.w),d2				; get first value
		ext.w	d2					; sign extend to word length
		move.b	1(a2,d0.w),d3				; get second value
		ext.w	d3					; sign extend to word length
		lsr.w	#4,d1					; divide index by 4
		andi.w	#6,d1					; only even numbers as it's a word length index
		move.w	.osc_adjustments(pc,d1.w),d1		; perform an adjustment
		jsr	.osc_adjustments(pc,d1.w)
		move.w	ost_x_pos(a0),d4			; get x pos of current segment
		add.w	d2,d4					; add value
		move.w	d4,ost_x_pos(a1)			; this is new x pos of next segment
		move.b	ost_y_pos+1(a0),d5			; same with y pos, but only the low byte
		add.b	d3,d5
		move.b	d5,ost_y_pos+1(a1)

	.exit:
		rts
; ===========================================================================
.osc_adjustments:	index offset(*),,2
		ptr .osc_null					; 0
		ptr .neg_y					; 2
		ptr .neg_both					; 4
		ptr .neg_x					; 6
; ===========================================================================

.osc_null:
		rts
; ===========================================================================

.neg_y:
		exg	d2,d3					; swap values
		neg.w	d3					; flip sign of second value
		rts
; ===========================================================================
; Unused
.neg_both:
		neg.w	d2					; flip signs of both values
		neg.w	d3
		rts
; ===========================================================================
; Unused
.neg_x:
		exg	d2,d3					; swap values
		neg.w	d2					; flip sign of first value
		rts
; ===========================================================================

SubData_Rex:
		subobjdata	Map_Rex,tile_Nem_Rexon+tile_pal4,render_rel,4,$20/2,id_col_null
; ===========================================================================

		include "mappings/sprite/Rexon.asm"

; ----------------------------------------------------------------------------
; Oscillation values for the Rexon's head and neck.
; Only entries $18-$28 are used.
; ----------------------------------------------------------------------------
RexHead_OscData:
		dc.b $F,  0
		dc.b $F,$FF					; 1
		dc.b $F,$FF					; 2
		dc.b $F,$FE					; 3
		dc.b $F,$FD					; 4
		dc.b $F,$FC					; 5
		dc.b $E,$FC					; 6
		dc.b $E,$FB					; 7
		dc.b $E,$FA					; 8
		dc.b $E,$FA					; 9
		dc.b $D,$F9					; 10
		dc.b $D,$F8					; 11
		dc.b $C,$F8					; 12
		dc.b $C,$F7					; 13
		dc.b $C,$F6					; 14
		dc.b $B,$F6					; 15
		dc.b $B,$F5					; 16
		dc.b $A,$F5					; 17
		dc.b $A,$F4					; 18
		dc.b  9,$F4					; 19
		dc.b  8,$F4					; 20
		dc.b  8,$F3					; 21
		dc.b  7,$F3					; 22
		dc.b  6,$F2					; 23
		dc.b  6,$F2					; 24
		dc.b  5,$F2					; 25
		dc.b  4,$F2					; 26
		dc.b  4,$F1					; 27
		dc.b  3,$F1					; 28
		dc.b  2,$F1					; 29
		dc.b  1,$F1					; 30
		dc.b  1,$F1					; 31
		even
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 98 - Projectile with optional gravity
; ----------------------------------------------------------------------------

Projectile:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Proj_Index(pc,d0.w),d1
		jmp	Proj_Index(pc,d1.w)
; ===========================================================================
Proj_Index:	index offset(*),,2
		ptr Proj_Init					; 0
		ptr Proj_Run					; 2

		rsobj Projectile,$2A
ost_proj_codeptr: rs.l 1					; $2A ; address of code to run for the object
		rsobjend
; ===========================================================================

Proj_Init:
		bra.w	LoadSubObjData				; go to Proj_Run next
; ===========================================================================

Proj_Run:
		tst.b	ost_render(a0)				; is projectile onscreen?
		bpl.w	JmpTo65_DeleteObject			; if not, delete
		movea.l	ost_proj_codeptr(a0),a1			; get code pointer
		jsr	(a1)					; run the projectile's code
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37710:
		bchg	#tile_pal12_bit,ost_tile(a0)
		jmpto	ObjectFall, JmpTo8_ObjectFall
; ===========================================================================

TurtProj_Run:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(Ani_TurtProj).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_37728:
		addi.w	#$20,ost_y_vel(a0)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		rts
; ===========================================================================

loc_37734:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_395A8).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_37742:
		addi.w	#$20,ost_y_vel(a0)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_38CC4).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_37756:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_3BA40).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================
SubData_RexProj:
		subobjdata	Map_Rex,tile_nem_Rexon+tile_pal2,render_rel|render_onscreen,4,8/2,id_col_4x4|id_col_hurt

off_3776E:
		dc.l Map_Neb
		dc.w $A36E
		dc.w $8404
		dc.w $88B

SubData_TurtProj:
		subobjdata	Map_Turt,tile_Nem_Turtloid,render_rel|render_onscreen,4,8/2,id_col_4x4|id_col_hurt

off_37782:
		dc.l Map_Coco
		dc.w $3EE
		dc.w $8404
		dc.w $88B
off_3778C:
		dc.l Map_Ast
		dc.w $8368
		dc.w $8405
		dc.w $498
off_37796:
		dc.l Map_Spiny
		dc.w $252D
		dc.w $8405
		dc.w $498
off_377A0:
		dc.l Map_Grab
		dc.w $A500
		dc.w $8404
		dc.w $498
off_377AA:
		dc.l Map_Clucker
		dc.w $379
		dc.w $8405
		dc.w $498
off_377B4:
		dc.l Map_MechSon
		dc.w $2380
		dc.w $8405
		dc.w $498
off_377BE:
		dc.l Map_WallTurr
		dc.w $3AB
		dc.w $8403
		dc.w $498
; ===========================================================================
; ----------------------------------------------------------------------------
; Object 99 - Nebula
; ----------------------------------------------------------------------------

Nebula:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Neb_Index(pc,d0.w),d1
		jmp	Neb_Index(pc,d1.w)
; ===========================================================================
Neb_Index:	index offset(*),,2
		ptr loc_377DC					; 0
		ptr loc_377E8					; 2
		ptr loc_3781C					; 4
; ===========================================================================

loc_377DC:
		bsr.w	LoadSubObjData
		move.w	#-$C0,ost_x_vel(a0)
		rts
; ===========================================================================

loc_377E8:
		bsr.w	FindPlayer
		tst.w	d0
		bne.s	loc_377FA
		cmpi.w	#$80,d2
		bcc.s	loc_377FA
		bsr.w	loc_37810

loc_377FA:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	AdjustPosSCZ
		lea	(Ani_Neb).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		bra.w	DeleteBehindScreen
; ===========================================================================

loc_37810:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#-$A0,ost_y_vel(a0)
		rts
; ===========================================================================

loc_3781C:
		tst.b	$2A(a0)
		bne.s	loc_37834
		bsr.w	FindPlayer
		addi_.w	#8,d2
		cmpi.w	#$10,d2
		bcc.s	loc_37834
		bsr.w	loc_37850

loc_37834:
		addi_.w	#1,ost_y_vel(a0)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	AdjustPosSCZ
		lea	(Ani_Neb).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		bra.w	DeleteBehindScreen
; ===========================================================================

loc_37850:
		st.b	$2A(a0)
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_37886
		_move.b	#id_Projectile,ost_id(a1)
		move.b	#4,ost_frame(a1)
		move.b	#$14,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$18,ost_y_pos(a1)
		lea_	loc_37710,a2
		move.l	a2,ost_proj_codeptr(a1)

locret_37886:
		rts
; ===========================================================================
SubData_Neb:
		dc.l Map_Neb
		dc.w $A36E
		dc.w $404
		dc.w $1006

Ani_Neb:	index offset(*)
		ptr byte_37894

byte_37894:
		dc.b   3,  0,  1,  2,  3,$FF			; 0
; ===========================================================================

		include "mappings/sprite/Nebula.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 9A - Turtloid
; ----------------------------------------------------------------------------

Turtloid:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Turt_Index(pc,d0.w),d1
		jmp	Turt_Index(pc,d1.w)
; ===========================================================================
Turt_Index:	index offset(*),,2
		ptr Turt_Init					; 0
		ptr Turt_Action					; 2

		rsobj	Turtloid,$2A
ost_turt_delay:		rs.b 1					; $2A; time to wait before firing projectile or resuming flight after firing
					rs.b 1			; unused
ost_turt_riderptr:	rs.w 1					; $2C; pointer to this Turtloid's rider
ost_turt_jetani:	rs.l 1					; $2E; pointer to animation script for jet; used when loading jet object
		rsobjend
; ===========================================================================

Turt_Init:	 ; Routine 0
		bsr.w	LoadSubObjData				; go to Turt_Action next
		move.w	#-$80,ost_x_vel(a0)			;
		bsr.w	Turt_LoadRider
		lea	(Ani_TurtJet).l,a1			; set animation script for jet
		move.l	a1,ost_turt_jetani(a0)
	;	move.l	#Ani_TurtJet,ost_turt_jetani(a0) ; above two instructions could be optimized to this
		bra.w	BTJet_Load
; ===========================================================================


	if FixBugs
		; When the Turloid's rider is destroyed, ost_turt_riderptr is never cleared.
		; In the event that a rider is destroyed before its parent Turtloid fires, and
		; another Badnik is defeated after the rider's explosion finishes, there is a chance
		; that the animal spawned by the second badnik will be loaded into the slot
		; still referenced by the Turtloid. If the Turtloid attempts to fire after this,
		; the animal will be treated as the rider and set to an invalid mapping frame (3),
		; causing an address error in BuildSprites.

		; This can be fixed by clearing the pointer as soon as the rider is defeated,
		; and skipping setting the rider's frame if it no longer exists
Turt_Action: ; Routine 2
		movea.w	ost_turt_riderptr(a0),a1		; get pointer to rider
		cmpi.b	#id_TurtloidRider,ost_id(a1)
		beq.s	.notdestroyed				; branch if rider hasn't been destroyed
		clr.w	ost_turt_riderptr			; rider no longer exists; clear the pointer
	.notdestroyed:
	else
Turt_Action: ; Routine 2
	endc
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	Turt_Action_Index(pc,d0.w),d1
		jsr	Turt_Action_Index(pc,d1.w)
		bsr.w	Turt_Platform				; update position and handle platform collision (could be bsr.s or inlined)
		bra.w	DeleteBehindScreen			; delete once off left edge of screen
; ===========================================================================

Turt_Action_Index:	index offset(*),,2
		ptr Turt_ChkDist				; 0
		ptr Turt_Fire					; 2
		ptr Turt_ResumeFlight				; 4
		ptr Turt_Null					; 6
; ===========================================================================

Turt_Platform:
		pushr.w	ost_x_pos(a0)				; back up current x pos for later
		jsrto	SpeedToPos,JmpTo26_SpeedToPos		; update position
		bsr.w	AdjustPosSCZ				; adjust to camera motion
		move.w	#$18,d1
		move.w	#8,d2
		move.w	#$1C/2,d3
		popr.w	d4
		jmpto	DetectPlatform,JmpTo9_DetectPlatform	; handle platform collision
; ===========================================================================

Turt_ChkDist: ; Action 0
		bsr.w	FindPlayer
	if FixBugs
		tst.w	d2					; d2 = horizontal distance to nearest player
	else
		; This will never trigger the branch below, as d0 is only ever 0 or 2 after a call
		; to FindPlayer. My guess is that this was supposed to branch if the player
		; was to the right of the Turtloid, in which case d2 should have been tested, as in
		; above fix. (Changing the branch condition to bne is another way to fix this.)
		tst.w	d0					; d0 = direction to nearest player
	endc
		bmi.w	TRider_SharedRTS			; supposed to branch if player is to right, but never does
		cmpi.w	#$80,d2
		bcc.w	TRider_SharedRTS			; branch if player is more than $80 pixels away
		addq.b	#2,ost_secondary_routine(a0)		; go to Turt_Fire next
		move.w	#0,ost_x_vel(a0)			; stop Turtloid until after projectile is fired
		move.b	#4,ost_turt_delay(a0)			; wait for 4 frames
		move.b	#id_Frame_Turt_FireProj,ost_frame(a0)
		rts
; ===========================================================================

Turt_Fire: ; Action 2
		subq.b	#1,ost_turt_delay(a0)			; decrement timer
		bpl.w	TRider_SharedRTS			; branch if time remains
		addq.b	#2,ost_secondary_routine(a0)		; go to Turt_ResumeFlight next
		move.b	#8,ost_turt_delay(a0)			; wait for 8 frames
	if FixBugs
		move.w	ost_turt_riderptr(a0),d1
		beq.w	Turt_LoadProjectile			; branch if rider has already been destroyed
		movea.w	d1,a1					; a1 = Turtloid's rider
	else
		movea.w	ost_turt_riderptr(a0),a1		; a1 = Turtloid's rider
	endc
		move.b	#id_Frame_TRider_FireProj,ost_frame(a1)	; set rider's fire frame
		bra.w	Turt_LoadProjectile
; ===========================================================================

Turt_ResumeFlight: ; Action 4
		subq.b	#1,ost_turt_delay(a0)			; decrement timer
		bpl.s	.exit					; branch if time remains
		addq.b	#2,ost_secondary_routine(a0)		; go to Turt_Null next
		move.w	#-$80,ost_x_vel(a0)			; resume flight
		clr.b	ost_frame(a0)				; frame = id_Frame_Turt_Normal
		movea.w	ost_turt_riderptr(a0),a1		; pointless

	.exit:
		rts
; ===========================================================================

Turt_Null: ; Action 6
		rts						; after Turtloid has fired shot, do nothing

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 9B - Turtloid rider
; ----------------------------------------------------------------------------

TurtloidRider:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TRider_Index(pc,d0.w),d1
		jmp	TRider_Index(pc,d1.w)
; ===========================================================================
TRider_Index:	index offset(*),,2
		ptr TRider_Init					; 0
		ptr TRider_Display				; 2

		rsobj	TurtloidRider,$2C
ost_trider_turtptr:	rs.w 1					; pointer to parent Turtloid
		rsobjend
; ===========================================================================

TRider_Init: ; Routine 0
		bra.w	LoadSubObjData
; ===========================================================================

TRider_Display: ; Routine 2
		movea.w	ost_trider_turtptr(a0),a1		; a1 = parent turtloid
		lea	TRider_Offsets(pc),a2
		bsr.w	TRider_Align				; could be bsr.s or inlined
		bra.w	DeleteBehindScreen
; ===========================================================================
TRider_Offsets:
		dc.w	4					; x offset
		dc.w	-$18					; y offset
; ===========================================================================

TRider_Align:
		; This subroutine is essentially AlignChild, but with the child object
		; performing the alignment rather than the parent.
		move.l	ost_x_pos(a1),ost_x_pos(a0)		; get parent x pos
		move.l	ost_y_pos(a1),ost_y_pos(a0)		; get parent y pos
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a0)			; apply offset to x pos
		move.w	(a2)+,d0
		add.w	d0,ost_y_pos(a0)			; same with y pos

TRider_SharedRTS:						; oddly, a large number of returns in this file branch here
		rts

; ----------------------------------------------------------------------------
; Subroutine to load the Turtloid's rider
; ----------------------------------------------------------------------------

Turt_LoadRider:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj	; find free OST slot after parent
		bne.s	.fail					; branch if not found
		_move.b	#id_TurtloidRider,ost_id(a1)		; load Turtloid rider
		move.b	#id_Frame_TRider_Normal,ost_frame(a1)
		move.b	#id_SubData_TRider,ost_subdata_ptr(a1)
		move.w	a0,ost_trider_turtptr(a1)		; set rider's pointer to parent...
		move.w	a1,ost_turt_riderptr(a0)		; ... and parent's pointer to child
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		addq.w	#4,ost_x_pos(a1)			; spawn 4 pixels to right of parent
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		subi.w	#$18,ost_y_pos(a1)			; spawn $18 pixels above parent

	.fail:
		rts

; ----------------------------------------------------------------------------
; Object 9C - Balkiry and Turloid jet exhaust
; ----------------------------------------------------------------------------

BalkTurtJet:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	BTJet_Index(pc,d0.w),d1
		jmp	BTJet_Index(pc,d1.w)
; ===========================================================================
BTJet_Index:	index offset(*),,2
		ptr BTJet_Init					; 0
		ptr BTJet_Display				; 2

		rsobj	BalkTurtJet,$2C
ost_btjet_parent:	rs.w 1					; $2C; parent Balkiry or Turtloid
ost_btjet_animptr:	rs.l 1					; $2E; pointer to animation script
ost_btjet_type:		rs.b 1					; $32; id of parent object
		rsobjend
; ===========================================================================

BTJet_Init:	 ; Routine 0
		bra.w	LoadSubObjData
; ===========================================================================

BTJet_Display: ; Routine 2
		movea.w	ost_btjet_parent(a0),a1			; a1 = parent Turtloid or Balkiry
		move.b	ost_btjet_type(a0),d0			; id of parent object
		cmp.b	ost_id(a1),d0
		bne.w	JmpTo65_DeleteObject			; delete if parent has been destroyed
		move.l	ost_x_pos(a1),ost_x_pos(a0)		; update position
		move.l	ost_y_pos(a1),ost_y_pos(a0)
		movea.l	ost_btjet_animptr(a0),a1		; get animation script
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		bra.w	DeleteBehindScreen

; ----------------------------------------------------------------------------
; Subroutine to load Turtloid and Balkirys' jet exhaust
; ----------------------------------------------------------------------------

BTJet_Load:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj	; find free OST slot after parent
		bne.s	.fail					; branch if not found
		_move.b	#id_BalkTurtJet,ost_id(a1)		; load Balkiry and Turtloid jet object
	if FixBugs=0
		; Completely unnecessary due to the use of AnimateSprite by this object.
		move.b	#id_Frame_TurtJet1,ost_frame(a1)
	endc
		move.b	#id_SubData_BTJet,ost_subdata_ptr(a1)
		move.w	a0,ost_btjet_parent(a1)			; set pointer to parent
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.l	ost_turt_jetani(a0),ost_btjet_animptr(a1) ; set animation script pointer
		move.b	ost_id(a0),ost_btjet_type(a1)

	.fail:
		rts

; ----------------------------------------------------------------------------
; Subroutine to load the Turtloid's projectile
; ----------------------------------------------------------------------------

Turt_LoadProjectile:
		jsrto	FindFreeObj,JmpTo19_FindFreeObj		; find free OST slot
		bne.s	.fail					; branch if not found
		_move.b	#id_Projectile,ost_id(a1)		; load projectile
	if FixBugs=0
		; Defintely the wrong frame, and not necessary at all due to the use of AnimateSprite
		; by this instance of the projectile object.
		move.b	#id_Frame_TurtJet1,ost_frame(a1)
	endc
		move.b	#id_SubData_TurtProj,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		subi.w	#$14,ost_x_pos(a1)			; spawn $14 pixels to left of Turtloid
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$A,ost_y_pos(a1)			; spawn $A pixels below Turtloid
		move.w	#-$100,ost_x_vel(a1)			; move to left
		lea_	TurtProj_Run,a2				; set projectile movement routine
		move.l	a2,ost_proj_codeptr(a1)
;		move.l	#TurtProj_Run,ost_proj_codeptr(a1)	; above two instructions could be this

	.fail:
		rts
; ===========================================================================
SubData_Turt:
	if FixBugs
		subobjdata	Map_Turt,tile_Nem_Turtloid,render_rel,5,$38/2,id_col_null
	else
		; This is too narrow, and causes the Turtloid to 'pop in' at the right
		; edge of the screen.
		subobjdata	Map_Turt,tile_Nem_Turtloid,render_rel,5,$30/2,id_col_null
	endc

SubData_TRider:
		subobjdata	Map_Turt,tile_Nem_Turtloid,render_rel,4,$18/2,id_col_12x12

SubData_BTJet:
		subobjdata	Map_Turt,tile_Nem_Turtloid,render_rel,5,$10/2,id_col_null

Ani_TurtProj:	index offset(*)
		ptr TurtProj_Flicker

	TurtProj_Flicker:
		dc.b 1
		dc.b id_Frame_Turt_Proj1
		dc.b id_Frame_Turt_Proj2
		dc.b afEnd

Ani_TurtJet:	index offset(*)
		ptr TurtJet_Flicker

	TurtJet_Flicker:
		dc.b 1
		dc.b id_Frame_TurtJet1
		dc.b id_Frame_TurtJet2
		dc.b afEnd

Ani_BalkJet:	index offset(*)
		ptr BalkJet_Flicker

	BalkJet_Flicker:
		dc.b 1
		dc.b id_Frame_BalkJet1
		dc.b id_Frame_BalkJet2
		dc.b afEnd
; ===========================================================================

		include "mappings/sprite/Turtloid.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 9D - Coconuts
; ----------------------------------------------------------------------------

Coconuts:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Coco_Index(pc,d0.w),d1
		jmp	Coco_Index(pc,d1.w)
; ===========================================================================
Coco_Index:	index offset(*)
		ptr loc_37C10					; 0
		ptr loc_37C1C					; 2
		ptr loc_37CAE					; 4
		ptr loc_37CD4					; 6
;Obj9D_timer		= objoff_2A	; byte
;Obj9D_climb_table_index	= objoff_2C	; word
;Obj9D_attack_timer	= objoff_2E	; byte	; time player needs to spend close to object before it attacks
; ===========================================================================

loc_37C10:
		bsr.w	LoadSubObjData
		move.b	#$10,$2A(a0)
		rts
; ===========================================================================

loc_37C1C:
		bsr.w	FindPlayer
		bclr	#render_xflip_bit,ost_render(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	d0
		beq.s	loc_37C3C
		bset	#render_xflip_bit,ost_render(a0)
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_37C3C:
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcc.s	loc_37C50
		tst.b	$2E(a0)
		beq.s	loc_37C66
		subq.b	#1,$2E(a0)

loc_37C50:
		subq.b	#1,$2A(a0)
		bmi.s	loc_37C5A
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37C5A:
		addq.b	#2,ost_primary_routine(a0)
		bsr.w	loc_37C82
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37C66:
		move.b	#6,ost_primary_routine(a0)
		move.b	#1,ost_frame(a0)
		move.b	#8,$2A(a0)
		move.b	#$20,$2E(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37C82:
		move.w	$2C(a0),d0
		cmpi.w	#$C,d0
		bcs.s	loc_37C8E
		moveq	#0,d0

loc_37C8E:
		lea	byte_37CA2(pc,d0.w),a1
		addq.w	#2,d0
		move.w	d0,$2C(a0)
		move.b	(a1)+,ost_y_vel(a0)
		move.b	(a1)+,$2A(a0)
		rts
; ===========================================================================
byte_37CA2:
		dc.b $FF,$20					; 0
		dc.b   1,$18					; 2
		dc.b $FF,$10					; 4
		dc.b   1,$28					; 6
		dc.b $FF,$20					; 8
		dc.b   1,$10					; 10
; ===========================================================================

loc_37CAE:
		subq.b	#1,$2A(a0)
		beq.s	loc_37CC6
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(Ani_Coco).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37CC6:
		subq.b	#2,ost_primary_routine(a0)
		move.b	#$10,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37CD4:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_37CE6(pc,d0.w),d1
		jsr	off_37CE6(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_37CE6:	index offset(*),,2
		ptr loc_37CEA					; 0
		ptr loc_37D06					; 2
; ===========================================================================

loc_37CEA:
		subq.b	#1,$2A(a0)
		bmi.s	loc_37CF2
		rts
; ===========================================================================

loc_37CF2:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#8,$2A(a0)
		move.b	#2,ost_frame(a0)
		bra.w	loc_37D22
; ===========================================================================

loc_37D06:
		subq.b	#1,$2A(a0)
		bmi.s	loc_37D0E
		rts
; ===========================================================================

loc_37D0E:
		clr.b	ost_secondary_routine(a0)
		move.b	#4,ost_primary_routine(a0)
		move.b	#8,$2A(a0)
		bra.w	loc_37C82
; ===========================================================================

loc_37D22:
		jsrto	FindFreeObj,JmpTo19_FindFreeObj
		bne.s	locret_37D74
		_move.b	#id_Projectile,ost_id(a1)
		move.b	#id_Frame_Coco_Coconut,ost_frame(a1)
		move.b	#$20,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#-$D,ost_y_pos(a1)
		moveq	#0,d0
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_37D58
		moveq	#4,d0

loc_37D58:
		lea	Coco_ThrowData(pc,d0.w),a2
		move.w	(a2)+,d0
		add.w	d0,ost_x_pos(a1)
		move.w	(a2)+,ost_x_vel(a1)
		move.w	#-$100,ost_y_vel(a1)
		lea_	loc_37728,a2
		move.l	a2,ost_proj_codeptr(a1)

locret_37D74:
		rts
; ===========================================================================
Coco_ThrowData:
		dc.w   -$B,  $100				; 0
		dc.w	$B, -$100				; 4

SubData_Coco:
		dc.l Map_Coco
		dc.w $3EE
		dc.w $405
		dc.w $C09

Ani_Coco:	index offset(*)
		ptr byte_37D8C					; 0
		ptr byte_37D90					; 1

byte_37D8C:
		dc.b   5,  0,  1,$FF

byte_37D90:
		dc.b   9,  1,  2,  1,$FF
		even
; ===========================================================================

		include "mappings/sprite/Coconuts.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 9E - Crawlton
; ----------------------------------------------------------------------------

Crawlton:
		moveq	#0,d0
		move.b	$3B(a0),d0
		move.w	Crawlt_Index(pc,d0.w),d1
		jmp	Crawlt_Index(pc,d1.w)
; ===========================================================================
Crawlt_Index:	index offset(*),,2
		ptr loc_37E30					; 0
		ptr loc_37E42					; 2
		ptr loc_37E98					; 4
		ptr loc_37EB6					; 6
		ptr loc_37ED4					; 8
		ptr loc_37EFC					; $A
; ===========================================================================

loc_37E30:
		bsr.w	LoadSubObjData
		move.b	#-$80,ost_height(a0)
		addq.b	#2,$3B(a0)
		bra.w	loc_37F74
; ===========================================================================

loc_37E42:
		bsr.w	FindPlayer
		move.w	d2,d4
		move.w	d3,d5
		addi.w	#$80,d2
		cmpi.w	#$100,d2
		bcc.s	loc_37E5E
		addi.w	#$80,d3
		cmpi.w	#$100,d3
		bcs.s	loc_37E62

loc_37E5E:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37E62:
		addq.b	#2,$3B(a0)
		move.b	#$10,$3A(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		tst.w	d0
		beq.s	loc_37E7C
		bset	#render_xflip_bit,ost_render(a0)

loc_37E7C:
		neg.w	d4
		lsl.w	#3,d4
		andi.w	#-$100,d4
		move.w	d4,ost_x_vel(a0)
		neg.w	d5
		lsl.w	#3,d5
		andi.w	#-$100,d5
		move.w	d5,ost_y_vel(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37E98:
		subq.b	#1,$3A(a0)
		bmi.s	loc_37EA2
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37EA2:
		addq.b	#2,$3B(a0)
		move.b	#8,$39(a0)
		move.b	#$1C,$3A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37EB6:
		subq.b	#1,$3A(a0)
		beq.s	loc_37EC4
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37EC4:
		move.b	$39(a0),$3B(a0)
		move.b	#$20,$3A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37ED4:
		subq.b	#1,$3A(a0)
		beq.s	loc_37EDE
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37EDE:
		move.b	#6,$3B(a0)
		move.b	#2,$39(a0)
		move.b	#$1C,$3A(a0)
		neg.w	ost_x_vel(a0)
		neg.w	ost_y_vel(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_37EFC:
		movea.w	$3E(a0),a1
		cmpi.b	#id_Crawlton,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		bclr	#render_xflip_bit,ost_render(a0)
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_37F1C
		bset	#render_xflip_bit,ost_render(a0)

loc_37F1C:
		move.b	#-$80,$14(a0)
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		cmpi.b	#6,$3B(a1)
		bne.s	loc_37F6C
		move.w	ost_x_vel(a1),d2
		asr.w	#8,d2
		move.w	ost_y_vel(a1),d3
		asr.w	#8,d3
		lea	ost_subspr2_x_pos(a0),a2
		move.b	$3A(a1),d0
		moveq	#$18,d1
		moveq	#6,d6

loc_37F4E:
		move.w	(a2),d4
		move.w	2(a2),d5
		cmp.b	d1,d0
		bcc.s	loc_37F5C
		add.w	d2,d4
		add.w	d3,d5

loc_37F5C:
		move.w	d4,(a2)+
		move.w	d5,(a2)+
		subi_.b	#4,d1
		bcs.s	loc_37F6C
		addq.w	#2,a2
		dbf	d6,loc_37F4E

loc_37F6C:
		move.w	#$280,d0
		jmpto	DisplaySprite3,JmpTo5_DisplaySprite3
; ===========================================================================

loc_37F74:
		jsrto	FindFreeObj,JmpTo19_FindFreeObj
		bne.s	locret_37FE6
		_move.b	#id_Crawlton,ost_id(a1)
		move.b	ost_render(a0),ost_render(a1)
		bset	#render_subsprites_bit,ost_render(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#$A,$3B(a1)
		move.b	#0,ost_mainspr_frame(a1)
		move.b	#$80,ost_mainspr_width(a1)
		move.b	#7,ost_mainspr_childsprites(a1)
		move.w	a0,$3E(a1)
		move.w	ost_x_pos(a0),d2
		move.w	d2,ost_x_pos(a1)
		move.w	ost_y_pos(a0),d3
		move.w	d3,ost_y_pos(a1)
		move.b	#-$80,$14(a1)
		bset	#render_useheight_bit,ost_render(a1)
		lea	ost_subspr2_x_pos(a1),a2
		moveq	#6,d6

loc_37FD6:
		move.w	d2,(a2)+
		move.w	d3,(a2)+
		move.w	#2,(a2)+
		addi.w	#$10,d1
		dbf	d6,loc_37FD6

locret_37FE6:
		rts
; ===========================================================================
SubData_CrawlT:
		dc.l Map_CrawlT
		dc.w $23C0
		dc.w $404
		dc.w $800B
; ===========================================================================

		include "mappings/sprite/Crawlton.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 9F - Shellcracker
; ----------------------------------------------------------------------------

Shellcracker:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Shelcrk_Index(pc,d0.w),d1
		jmp	Shelcrk_Index(pc,d1.w)
; ===========================================================================
Shelcrk_Index:	index offset(*),,2
		ptr loc_38022					; 0
		ptr loc_3804E					; 2
		ptr loc_380C4					; 4
		ptr loc_380FC					; 6
; ===========================================================================

loc_38022:
		bsr.w	LoadSubObjData
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_38034
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_38034:
		move.w	#-$40,ost_x_vel(a0)
		move.b	#$C,ost_height(a0)
		move.b	#$18,ost_width(a0)
		move.w	#$140,$2A(a0)
		rts
; ===========================================================================

loc_3804E:
		bsr.w	FindPlayer
		tst.w	d0
		beq.s	loc_3805E
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_38068

loc_3805E:
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcs.s	loc_380AE

loc_38068:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jsr	(FindFloorObj).l
		cmpi.w	#-8,d1
		blt.s	loc_38096
		cmpi.w	#$C,d1
		bge.s	loc_38096
		add.w	d1,ost_y_pos(a0)
		subq.w	#1,$2A(a0)
		bmi.s	loc_3809A
		lea	(off_38304).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38096:
		neg.w	ost_x_vel(a0)

loc_3809A:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#0,ost_frame(a0)
		move.w	#$3B,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_380AE:
		move.b	#6,ost_primary_routine(a0)
		move.b	#0,ost_frame(a0)
		move.w	#8,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_380C4:
		tst.b	ost_render(a0)
		bpl.s	loc_380E4
		bsr.w	FindPlayer
		tst.w	d0
		beq.s	loc_380DA
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_380E4

loc_380DA:
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcs.s	loc_380AE

loc_380E4:
		subq.w	#1,$2A(a0)
		bmi.s	loc_380EE
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_380EE:
		subq.b	#2,ost_primary_routine(a0)
		move.w	#$140,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_380FC:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3810E(pc,d0.w),d1
		jsr	off_3810E(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3810E:	index offset(*),,2
		ptr loc_38114					; 0
		ptr loc_3812A					; 2
		ptr loc_3813E					; 4
; ===========================================================================

loc_38114:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3811C
		rts
; ===========================================================================

loc_3811C:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_frame(a0)
		bra.w	loc_38292
; ===========================================================================

loc_3812A:
		tst.b	$2C(a0)
		bne.s	loc_38132
		rts
; ===========================================================================

loc_38132:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$20,$2A(a0)
		rts
; ===========================================================================

loc_3813E:
		subq.w	#1,$2A(a0)
		bmi.s	loc_38146
		rts
; ===========================================================================

loc_38146:
		clr.b	ost_secondary_routine(a0)
		clr.b	$2C(a0)
		move.b	#2,ost_primary_routine(a0)
		move.w	#$140,$2A(a0)
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object A0 - Shellcracker's claw
; ----------------------------------------------------------------------------

ShellcrackerClaw:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ShelcrkClaw_Index(pc,d0.w),d1
		jmp	ShelcrkClaw_Index(pc,d1.w)
; ===========================================================================
ShelcrkClaw_Index:	index offset(*),,2
		ptr loc_38170					; 0
		ptr loc_381AC					; 2
		ptr loc_38280					; 4
; ===========================================================================

loc_38170:
		bsr.w	LoadSubObjData
		movea.w	$2C(a0),a1
		move.b	ost_render(a1),d0
		andi.b	#1,d0
		or.b	d0,ost_render(a0)
		move.w	$2E(a0),d0
		beq.s	loc_38198
		move.b	#4,ost_frame(a0)
		addq.w	#6,ost_x_pos(a0)
		addq.w	#6,ost_y_pos(a0)

loc_38198:
		lsr.w	#1,d0
		move.b	byte_381A4(pc,d0.w),$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
byte_381A4:
		dc.b   0					; 0
		dc.b   3					; 1
		dc.b   5					; 2
		dc.b   7					; 3
		dc.b   9					; 4
		dc.b  $B					; 5
		dc.b  $D					; 6
		dc.b  $F					; 7
; ===========================================================================

loc_381AC:
		movea.w	$2C(a0),a1
		cmpi.b	#id_Shellcracker,ost_id(a1)
		bne.s	loc_381D0
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_381C8(pc,d0.w),d1
		jsr	off_381C8(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_381C8:	index offset(*),,2
		ptr loc_381E0					; 0
		ptr loc_3822A					; 2
		ptr loc_38244					; 4
		ptr loc_38258					; 6
; ===========================================================================

loc_381D0:
		move.b	#4,ost_primary_routine(a0)
		move.w	#$40,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_381E0:
		subq.b	#1,$2A(a0)
		beq.s	loc_381EA
		bmi.s	loc_381EA
		rts
; ===========================================================================

loc_381EA:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	$2E(a0),d0
		cmpi.w	#$E,d0
		bcc.s	loc_3821A
		move.w	#-$400,d2
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_38206
		neg.w	d2

loc_38206:
		move.w	d2,ost_x_vel(a0)
		lsr.w	#1,d0
		move.b	byte_38222(pc,d0.w),d1
		move.b	d1,$2A(a0)
		move.b	d1,$2B(a0)
		rts
; ===========================================================================

loc_3821A:
		move.w	#$B,$2A(a0)
		rts
; ===========================================================================
byte_38222:
		dc.b  $D					; 0
		dc.b  $C					; 1
		dc.b  $A					; 2
		dc.b   8					; 3
		dc.b   6					; 4
		dc.b   4					; 5
		dc.b   2					; 6
		dc.b   0					; 7
; ===========================================================================

loc_3822A:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		subq.b	#1,$2A(a0)
		beq.s	loc_38238
		bmi.s	loc_38238
		rts
; ===========================================================================

loc_38238:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#8,$2A(a0)
		rts
; ===========================================================================

loc_38244:
		subq.b	#1,$2A(a0)
		beq.s	loc_3824E
		bmi.s	loc_3824E
		rts
; ===========================================================================

loc_3824E:
		addq.b	#2,ost_secondary_routine(a0)
		neg.w	ost_x_vel(a0)
		rts
; ===========================================================================

loc_38258:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		subq.b	#1,$2B(a0)
		beq.s	loc_38266
		bmi.s	loc_38266
		rts
; ===========================================================================

loc_38266:
		tst.w	$2E(a0)
		bne.s	loc_3827A
		movea.w	$2C(a0),a1
		move.b	#0,ost_frame(a1)
		st.b	$2C(a1)

loc_3827A:
		addq.w	#4,sp
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_38280:
		jsrto	ObjectFall,JmpTo8_ObjectFall
		subi_.w	#1,$2A(a0)
		bmi.w	JmpTo65_DeleteObject
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38292:
		moveq	#0,d1
		moveq	#7,d6

loc_38296:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_382EE
		_move.b	#id_ShellcrackerClaw,ost_id(a1)
		move.b	#$26,ost_subdata_ptr(a1)
		move.b	#5,ost_frame(a1)
		move.b	#4,ost_priority(a1)
		move.w	a0,$2C(a1)
		move.w	d1,$2E(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	#-$14,d2
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_382D8
		neg.w	d2
		tst.w	d1
		beq.s	loc_382D8
		subi.w	#$C,d2

loc_382D8:
		add.w	d2,ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		subi_.w	#8,ost_y_pos(a1)
		addq.w	#2,d1
		dbf	d6,loc_38296

locret_382EE:
		rts
; ===========================================================================
SubData_Shelcrk:
		dc.l Map_Shelcrk
		dc.w $31C
		dc.w $405
		dc.w $180A

SubData_ShelcrkClaw:
		dc.l Map_Shelcrk
		dc.w $31C
		dc.w $404
		dc.w $C9A

off_38304:	index offset(*)
		ptr byte_38308					; 0
		ptr byte_3830E					; 1

byte_38308:
		dc.b  $E,  0,  1,  2,$FF
		even

byte_3830E:
		dc.b  $E,  0,  2,  1,$FF
		even
; ===========================================================================

		include "mappings/sprite/Shellcracker.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object A1 - Slicer
; ----------------------------------------------------------------------------

Slicer:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Slice_Index(pc,d0.w),d1
		jmp	Slice_Index(pc,d1.w)
; ===========================================================================
Slice_Index:	index offset(*),,2
		ptr loc_383CC					; 0
		ptr loc_383F0					; 2
		ptr loc_38466					; 4
		ptr loc_38482					; 6
		ptr loc_3849E					; 8
; ===========================================================================

loc_383CC:
		bsr.w	LoadSubObjData
		move.w	#-$40,d0
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_383DE
		neg.w	d0

loc_383DE:
		move.w	d0,ost_x_vel(a0)
		move.b	#$10,ost_height(a0)
		move.b	#$10,ost_width(a0)
		rts
; ===========================================================================

loc_383F0:
		tst.b	ost_render(a0)
		bpl.s	loc_3841C
		bsr.w	FindPlayer
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_38404
		subq.w	#2,d0

loc_38404:
		tst.w	d0
		bne.s	loc_3841C
		addi.w	#$80,d2
		cmpi.w	#$100,d2
		bcc.s	loc_3841C
		addi.w	#$40,d3
		cmpi.w	#$80,d3
		bcs.s	loc_38452

loc_3841C:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jsr	(FindFloorObj).l
		cmpi.w	#-8,d1
		blt.s	loc_38444
		cmpi.w	#$C,d1
		bge.s	loc_38444
		add.w	d1,ost_y_pos(a0)
		lea	(Ani_Slice).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38444:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$3B,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38452:
		addq.b	#4,ost_primary_routine(a0)
		move.b	#3,ost_frame(a0)
		move.b	#8,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38466:
		subq.b	#1,$2A(a0)
		bmi.s	loc_38470
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38470:
		subq.b	#2,ost_primary_routine(a0)
		neg.w	ost_x_vel(a0)
		bchg	#status_xflip_bit,ost_primary_status(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38482:
		subq.b	#1,$2A(a0)
		bmi.s	loc_3848C
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3848C:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#4,ost_frame(a0)
		bsr.w	loc_3853E
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3849E:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object A2 - Slicer's pincers
; ----------------------------------------------------------------------------

SlicerPincers:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SlicePinc_Index(pc,d0.w),d1
		jmp	SlicePinc_Index(pc,d1.w)
; ===========================================================================
SlicePinc_Index:	index offset(*),,2
		ptr loc_384B6					; 0
		ptr loc_384BE					; 2
		ptr loc_38524					; 4
; ===========================================================================

loc_384B6:
		bsr.w	LoadSubObjData
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_384BE:
		tst.b	ost_render(a0)
		bpl.w	JmpTo65_DeleteObject
		subq.w	#1,$2A(a0)
		bmi.s	loc_3851A
		movea.w	$2C(a0),a1
		cmpi.b	#-$5F,(a1)
		bne.s	loc_3851A
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_384F6(pc,d0.w),d1
		jsr	off_384F6(pc,d1.w)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(Ani_SlicePinc).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_384F6:	index offset(*),,2
		ptr loc_384F8
; ===========================================================================

loc_384F8:
		bsr.w	FindPlayer
		move.w	word_38516(pc,d0.w),d2
		add.w	d2,ost_x_vel(a0)
		move.w	word_38516(pc,d1.w),d2
		add.w	d2,ost_y_vel(a0)
		move.w	#$200,d0
		move.w	d0,d1
		bra.w	CapSpeed
; ===========================================================================
word_38516:
		dc.w -$10, $10
; ===========================================================================

loc_3851A:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$60,$2A(a0)

loc_38524:
		subq.w	#1,$2A(a0)
		bmi.w	JmpTo65_DeleteObject
		jsrto	ObjectFall,JmpTo8_ObjectFall
		lea	(Ani_SlicePinc).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3853E:
		lea	$3C(a0),a2
		moveq	#0,d1
		moveq	#1,d6

loc_38546:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_385BA
		_move.b	#id_SlicerPincers,ost_id(a1)
		move.b	#$2A,ost_subdata_ptr(a1)
		move.b	ost_render(a0),ost_render(a1)
		move.b	#5,ost_frame(a1)
		move.b	#4,ost_priority(a1)
		move.w	#$78,$2A(a1)
		move.w	a0,$2C(a1)
		move.w	a1,(a2)+
		move.w	#-$200,d0
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_3858A
		neg.w	d0
		bset	#status_xflip_bit,ost_primary_status(a1)

loc_3858A:
		move.w	d0,ost_x_vel(a1)
		lea	byte_385BC(pc,d1.w),a3
		move.b	(a3)+,d0
		ext.w	d0
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_385A0
		neg.w	d0

loc_385A0:
		add.w	ost_x_pos(a0),d0
		move.w	d0,ost_x_pos(a1)
		move.b	(a3)+,d0
		ext.w	d0
		add.w	ost_y_pos(a0),d0
		move.w	d0,ost_y_pos(a1)
		addq.w	#2,d1
		dbf	d6,loc_38546

locret_385BA:
		rts
; ===========================================================================
byte_385BC:
		dc.b    6,    0
		dc.b -$10,    0

SubData_Slice:
		dc.l Map_Slice
		dc.w $243C
		dc.w $405
		dc.w $1006

SubData_SlicePinc:
		dc.l Map_Slice
		dc.w $243C
		dc.w $404
		dc.w $109A

Ani_Slice:	index offset(*)
		ptr byte_385D6

byte_385D6:
		dc.b $13,  0,  2,$FF
		even

Ani_SlicePinc:	index offset(*)
		ptr byte_385DC

byte_385DC:
		dc.b   3,  5,  6,  7,  8,$FF
		even
; ===========================================================================

		include "mappings/sprite/Slicer.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object A3 - Flasher
; ----------------------------------------------------------------------------

Flasher:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Flash_Index(pc,d0.w),d1
		jmp	Flash_Index(pc,d1.w)
; ===========================================================================
Flash_Index:	index offset(*),,2
		ptr loc_3875A					; 0
		ptr loc_38766					; 2
		ptr loc_38794					; 4
		ptr loc_38832					; 6
		ptr loc_3885C					; 8
		ptr loc_38880					; $A
		ptr loc_3888E					; $C
; ===========================================================================

loc_3875A:
		bsr.w	LoadSubObjData
		move.w	#$40,$2A(a0)
		rts
; ===========================================================================

loc_38766:
		subq.w	#1,$2A(a0)
		bmi.s	loc_38770
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_38770:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#-$100,ost_x_vel(a0)
		move.w	#$40,ost_y_vel(a0)
		move.w	#2,$2E(a0)
		clr.w	$2A(a0)
		move.w	#$80,$30(a0)
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_38794:
		subq.w	#1,$30(a0)
		bmi.s	loc_387FC
		move.w	$2A(a0),d0
		bmi.w	JmpTo65_DeleteObject
		bclr	#render_xflip_bit,ost_render(a0)
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	ost_x_vel(a0)
		bmi.s	loc_387C0
		bset	#render_xflip_bit,ost_render(a0)
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_387C0:
		addq.w	#1,d0
		move.w	d0,$2A(a0)
		move.w	$2C(a0),d1
		move.w	word_38810(pc,d1.w),d2
		cmp.w	d2,d0
		bcs.s	loc_387EC
		addq.w	#2,d1
		move.w	d1,$2C(a0)
		lea	byte_38820(pc,d1.w),a1
		tst.b	(a1)+
		beq.s	loc_387E4
		neg.w	$2E(a0)

loc_387E4:
		tst.b	(a1)+
		beq.s	loc_387EC
		neg.w	ost_y_vel(a0)

loc_387EC:
		move.w	$2E(a0),d0
		add.w	d0,ost_x_vel(a0)

loc_387F4:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_387FC:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$80,$30(a0)
		ori.b	#id_col_hurt,ost_col_type(a0)
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================
word_38810:
		dc.w  $100					; 0
		dc.w  $1A0					; 1
		dc.w  $208					; 2
		dc.w  $285					; 3
		dc.w  $300					; 4
		dc.w  $340					; 5
		dc.w  $390					; 6
		dc.w  $440					; 7

byte_38820:
		dc.b $F0					; 0
		dc.b   0					; 1
		dc.b   1					; 2
		dc.b   1					; 3
		dc.b   0					; 4
		dc.b   1					; 5
		dc.b   1					; 6
		dc.b   1					; 7
		dc.b   0					; 8
		dc.b   1					; 9
		dc.b   0					; 10
		dc.b   1					; 11
		dc.b   1					; 12
		dc.b   0					; 13
		dc.b   0					; 14
		dc.b   1					; 15
		dc.b   0					; 16
		dc.b   1					; 17
; ===========================================================================

loc_38832:
		move.b	ost_primary_routine(a0),d2
		lea	(Ani_Flash1).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		cmp.b	ost_primary_routine(a0),d2
		bne.s	loc_3884A
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_3884A:
		clr.l	ost_frame(a0)
		clr.w	ost_anim_time(a0)
		move.b	#3,ost_frame(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3885C:
		subq.w	#1,$30(a0)
		bmi.s	loc_38870
		lea	(Ani_Flash2).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_38870:
		addq.b	#2,ost_primary_routine(a0)
		clr.l	ost_frame(a0)
		clr.w	ost_anim_time(a0)
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_38880:
		lea	(Ani_Flash3).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================

loc_3888E:
		move.b	#4,ost_primary_routine(a0)
		move.w	#$80,$30(a0)
		andi.b	#(~id_col_hurt)&$FF,ost_col_type(a0)
		clr.l	ost_frame(a0)
		clr.w	ost_anim_time(a0)
		jmpto	DespawnObject4,JmpTo2_DespawnObject4
; ===========================================================================
SubData_Flash:
		dc.l Map_Flash
		dc.w $83A8
		dc.w $404
		dc.w $1006

Ani_Flash1:	index offset(*)
		ptr byte_388B8

byte_388B8:
		dc.b   0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1
		dc.b   0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  2,  3,  4
		dc.b $FC
		even

Ani_Flash2:	index offset(*)
		ptr byte_388DC

byte_388DC:
		dc.b   0,  2,  0,  3,  0,  4,  0,  3,  0,$FF
		even

Ani_Flash3:	index offset(*)
		ptr Ani_388E8

Ani_388E8:
		dc.b   3,  4,  3,  2,  1,  0,$FC
		even

; ===========================================================================

		include "mappings/sprite/Flasher.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object A4 - Asteron
; ----------------------------------------------------------------------------

Asteron:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Ast_Index(pc,d0.w),d1
		jmp	Ast_Index(pc,d1.w)
; ===========================================================================
Ast_Index:	index offset(*),,2
		ptr loc_389B2					; 0
		ptr loc_389B6					; 2
		ptr loc_389DA					; 4
		ptr loc_38A2C					; 6
; ===========================================================================

loc_389B2:
		bra.w	LoadSubObjData
; ===========================================================================

loc_389B6:
		bsr.w	FindPlayer
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcc.s	loc_389CE
		addi.w	#$40,d3
		cmpi.w	#$80,d3
		bcs.s	loc_389D2

loc_389CE:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_389D2:
		addq.b	#2,ost_primary_routine(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_389DA:
		bsr.w	FindPlayer
		tst.w	d2
		bpl.s	loc_389E4
		neg.w	d2

loc_389E4:
		cmpi.w	#$10,d2
		bcs.s	loc_389FA
		cmpi.w	#$60,d2
		bcc.s	loc_389FA
		move.w	word_38A1A(pc,d0.w),ost_x_vel(a0)
		bsr.w	loc_38A1E

loc_389FA:
		tst.w	d3
		bpl.s	loc_38A00
		neg.w	d3

loc_38A00:
		cmpi.w	#$10,d3
		bcs.s	loc_38A16
		cmpi.w	#$60,d3
		bcc.s	loc_38A16
		move.w	word_38A1A(pc,d1.w),ost_y_vel(a0)
		bsr.w	loc_38A1E

loc_38A16:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
word_38A1A:
		dc.w $FFC0					; 0
		dc.w   $40					; 1
; ===========================================================================

loc_38A1E:
		move.b	#6,ost_primary_routine(a0)
		move.b	#$40,$2A(a0)
		rts
; ===========================================================================

loc_38A2C:
		subq.b	#1,$2A(a0)
		bmi.s	loc_38A44
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(Ani_Ast).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38A44:
		_move.b	#id_ExplosionItem,ost_id(a0)
		move.b	#2,ost_primary_routine(a0)
		bsr.w	loc_38A58
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38A58:
		move.b	#$30,d2
		moveq	#(sizeof_ProjData_Ast/6)-1,d6
		lea	(ProjData_Ast).l,a2
		bra.w	LoadProjectiles
; ===========================================================================
; Data for Asteron's projectiles, clockwise from top
ProjData_Ast:
		projdata  0, -8,  0, -4, id_Frame_Ast_Spike_Up,        0
		projdata  8, -4,  3, -1, id_Frame_Ast_Spike_AngleUp,   render_xflip
		projdata  8,  8,  3,  3, id_Frame_Ast_Spike_AngleDown, render_xflip
		projdata -8,  8, -3,  3, id_Frame_Ast_Spike_AngleDown, 0
		projdata -8, -4, -3, -1, id_Frame_Ast_Spike_AngleUp,   0
		arraysize ProjData_Ast

SubData_Ast:
		subobjdata Map_Ast,tile_Nem_Asteron+tile_hi,render_rel,4,$20/2,id_col_8x8

Ani_Ast:	index offset(*)
		ptr Ani_Ast_Flashing

Ani_Ast_Flashing:
		dc.b 1
		dc.b id_Frame_Ast_EyeRed
		dc.b id_Frame_Ast_EyeYellow
		dc.b afEnd

; ===========================================================================

		include "mappings/sprite/Asteron.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object A5 - Spiny (on floor)
; ----------------------------------------------------------------------------

Spiny:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_38AF8(pc,d0.w),d1
		jmp	off_38AF8(pc,d1.w)
; ===========================================================================
off_38AF8:	index offset(*),,2
		ptr loc_38AFE					; 0
		ptr loc_38B10					; 2
		ptr loc_38B62					; 4
; ===========================================================================

loc_38AFE:
		bsr.w	LoadSubObjData
		move.w	#-$40,ost_x_vel(a0)
		move.w	#$80,$2A(a0)
		rts
; ===========================================================================

loc_38B10:
		tst.b	$2B(a0)
		beq.s	loc_38B1E
		subq.b	#1,$2B(a0)
		bra.w	loc_38B2C
; ===========================================================================

loc_38B1E:
		bsr.w	FindPlayer
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcs.s	loc_38B4E

loc_38B2C:
		subq.b	#1,$2A(a0)
		bne.s	loc_38B3C
		move.w	#$80,$2A(a0)
		neg.w	ost_x_vel(a0)

loc_38B3C:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_38CB8).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38B4E:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$28,$2B(a0)
		move.b	#2,ost_frame(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38B62:
		subq.b	#1,$2B(a0)
		bmi.s	loc_38B78
		cmpi.b	#$14,$2B(a0)
		bne.s	loc_38B74
		bsr.w	loc_38C22

loc_38B74:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38B78:
		subq.b	#2,ost_primary_routine(a0)
		move.b	#$40,$2B(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object A6 - Spiny (on wall)
; ----------------------------------------------------------------------------

SpinyWall:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_38B94(pc,d0.w),d1
		jmp	off_38B94(pc,d1.w)
; ===========================================================================
off_38B94:	index offset(*),,2
		ptr loc_38B9A					; 0
		ptr loc_38BAC					; 2
		ptr loc_38BFE					; 4
; ===========================================================================

loc_38B9A:
		bsr.w	LoadSubObjData
		move.w	#-$40,ost_y_vel(a0)
		move.w	#$80,$2A(a0)
		rts
; ===========================================================================

loc_38BAC:
		tst.b	$2B(a0)
		beq.s	loc_38BBA
		subq.b	#1,$2B(a0)
		bra.w	loc_38BC8
; ===========================================================================

loc_38BBA:
		bsr.w	FindPlayer
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcs.s	loc_38BEA

loc_38BC8:
		subq.b	#1,$2A(a0)
		bne.s	loc_38BD8
		move.w	#$80,$2A(a0)
		neg.w	ost_y_vel(a0)

loc_38BD8:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_38CBE).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38BEA:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#$28,$2B(a0)
		move.b	#5,ost_frame(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38BFE:
		subq.b	#1,$2B(a0)
		bmi.s	loc_38C14
		cmpi.b	#$14,$2B(a0)
		bne.s	loc_38C10
		bsr.w	loc_38C6E

loc_38C10:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38C14:
		subq.b	#2,ost_primary_routine(a0)
		move.b	#$40,$2B(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_38C22:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_38C6C
		_move.b	#id_Projectile,ost_id(a1)
		move.b	#6,ost_frame(a1)
		move.b	#$34,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#-$300,ost_y_vel(a1)
		move.w	#$100,d1
		lea	($FFFFB000).w,a2
		move.w	ost_x_pos(a0),d0
		cmp.w	ost_x_pos(a2),d0
		bcs.s	loc_38C60
		neg.w	d1

loc_38C60:
		move.w	d1,ost_x_vel(a1)
		lea_	loc_37742,a2
		move.l	a2,ost_proj_codeptr(a1)

locret_38C6C:
		rts
; ===========================================================================

loc_38C6E:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_38CAC
		_move.b	#id_Projectile,ost_id(a1)
		move.b	#6,ost_frame(a1)
		move.b	#$34,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	#$300,d1
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_38CA0
		neg.w	d1

loc_38CA0:
		move.w	d1,ost_x_vel(a1)
		lea_	loc_37742,a2
		move.l	a2,ost_proj_codeptr(a1)

locret_38CAC:
		rts
; ===========================================================================
off_38CAE:
		dc.l Map_Spiny
		dc.w $252D
		dc.w $404
		dc.w $80B

off_38CB8:	index offset(*)
		ptr byte_38CBA

byte_38CBA:
		dc.b   9,  0,  1,$FF

off_38CBE:	index offset(*)
		ptr byte_38CC0

byte_38CC0:
		dc.b   9,  3,  4,$FF

off_38CC4:	index offset(*)
		ptr byte_38CC6

byte_38CC6:
		dc.b   3,  6,  7,$FF

; ===========================================================================

		include "mappings/sprite/Spiny.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object A7 - Grabber's head and body
; A complex multi-object item like the bosses, but unlike them, the individual
; components are completely different objects instead of subtypes of the same
; object.
; ----------------------------------------------------------------------------

Grabber:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Grab_Index(pc,d0.w),d1
		jmp	Grab_Index(pc,d1.w)
; ===========================================================================
Grab_Index:	index offset(*),,2
		ptr Grab_Init					; 0
		ptr Grab_Action					; 2

		rsobj Grabber,$2A
ost_grab_timer1: 		rs.w 1				; $2A ; time in frames until an idle grabber reverses their horizontal movement, and time until Grabber changes color while holding player
ost_grab_colorchng_time:	equ __rs-1			; $2B ; value used to reset above timer, decrementing by 1 each time
ost_grab_timer2:		rs.w 1				; $2C ; time in frames to wait until attack animation starts, and duration of attack movement
ost_grab_xvel_backup:	rs.w 1					; $2E ; x vel is stashed here when they are seeking a player
ost_grab_playerheld:	rs.b 1					; $30 ; flag indicating that a player is being held
ost_grab_31:			rs.b 1				; $31 ;
ost_grab_player:		rs.w 1				; $32 ; OST address of the player currently held by the Brabber
ost_grab_34:			rs.w 1				; $34
ost_grab_36:			rs.b 1				; $36
ost_grab_37:			rs.b 1				; $37
ost_grab_38:			rs.b 1				; $38
		rsset $3A
ost_grab_stringptr:	rs.w 1					; $3A ; pointer to string
ost_grab_legsptr:		rs.w 1				; $3C ; pointer to legs
ost_grab_boxptr:		rs.w 1				; $3E ; pointer to box
		rsobjend

grab_attack_duration:		equ 64				; time in frames a Grabber's attack last
; ===========================================================================

Grab_Init:
		bsr.w	LoadSubObjData				; go to Grab_Action next
		move.w	#-$40,d0				; move left
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	.no_xflip				; branch if this Grabber isn't x-flipped
		neg.w	d0					; move right

	.no_xflip:
		move.w	d0,ost_x_vel(a0)
		move.w	#255,ost_grab_timer1(a0)		; move for 255 frames
		move.b	#2,ost_grab_timer2+1(a0)
		lea	(ChildData_GrabBox).l,a2		; load box
		bsr.w	LoadChild
		lea	(ChildData_GrabLegs).l,a2		; load legs
		bsr.w	LoadChild
		lea	(ChildData_GrabString).l,a2		; load string
		bra.w	LoadChild
; ===========================================================================

Grab_Action:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	Grab_Action_Index(pc,d0.w),d1
		jsr	Grab_Action_Index(pc,d1.w)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos		; update position
		moveq	#0,d0
		moveq	#$10,d1					; y-offset of legs
		movea.w	ost_grab_legsptr(a0),a1
		bsr.w	AlignChild				; update position of legs
		movea.w	ost_grab_boxptr(a0),a1
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; update position of box
		movea.w	ost_grab_stringptr(a0),a1
		move.w	ost_x_pos(a0),ost_x_pos(a1)		; update position of string
		lea	ost_grab_stringptr(a0),a2		; this could have been 'movea.w a1,a2'
		bra.w	Grab_Display
; ===========================================================================

Grab_Action_Index:	index offset(*),,2
		ptr Grab_FindPlayer				; 0
		ptr Grab_WaitAttack				; 2
		ptr Grab_Attack					; 4
		ptr Grab_AscendWithPlayer			; 6
		ptr Grab_HoldPlayer				; 8
		ptr BranchTo_Grab_CheckExplode			; $A
; ===========================================================================

Grab_FindPlayer:
		bsr.w	FindPlayer				; get nearest player
		addi.w	#$40,d2
		cmpi.w	#$80,d2					; is player within $80 pixels of Grabber horizontally?
		bcc.s	.notfound				; branch if not
		cmpi.w	#-$80,d3				; is player within $80 pixels of Grabber vertically?
		bhi.s	.playerfound				; branch if so

	.notfound:
		subq.w	#1,ost_grab_timer1(a0)			; decrement timer
		bpl.s	.return					; branch if time remains

	;.turn_around:
		move.w	#255,ost_grab_timer1(a0)		; reset x-timer
		neg.w	ost_x_vel(a0)				; reverse direction
		bchg	#render_xflip_bit,ost_render(a0)	; invert x-flip state
		bchg	#status_xflip_bit,ost_primary_status(a0)

	.return:
		rts
; ===========================================================================

.playerfound:
		addq.b	#2,ost_secondary_routine(a0)		; go to Grab_Attack next
		move.w	ost_x_vel(a0),ost_grab_xvel_backup(a0)	; save current x vel
		clr.w	ost_x_vel(a0)				; stop horizontal movement
		move.b	#16,ost_grab_timer2(a0)			; wait for 16 frames before attacking
		rts
; ===========================================================================

Grab_WaitAttack:
		subq.b	#1,ost_grab_timer2(a0)			; decrement timer
		bmi.s	.begin_attack				; branch if time remains
		rts
; ===========================================================================

.begin_attack:
		addq.b	#2,ost_secondary_routine(a0)		; go to Grab_Attack next
		move.w	#$200,ost_y_vel(a0)
		move.b	#grab_attack_duration,ost_grab_timer2(a0) ; attack lasts 64 frames
		rts
; ===========================================================================

Grab_Attack:
		tst.b	ost_grab_playerheld(a0)			; has a player been grabbed?  (detected by the legs)
		bne.s	Grab_GrabCharacter			; branch if so
		subq.b	#1,ost_grab_timer2(a0)			; decrement timer
		beq.s	.attack_done				; branch if expired
		cmpi.b	#grab_attack_duration/2,ost_grab_timer2(a0) ; is Grabber exactly halfway through the attack?
		bne.s	.animate				; branch if not
		neg.w	ost_y_vel(a0)				; Grabber starts ascending

	.animate:
		lea	(Ani_Grab).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

.attack_done:
		move.b	#id_Grab_FindPlayer,ost_secondary_routine(a0) ; go to Grab_FindPlayer next
		clr.w	ost_y_vel(a0)				; stop vertical motion
		move.w	$2E(a0),ost_x_vel(a0)			; restore previous x_vel
		move.b	#0,ost_frame(a0)
		rts
; ===========================================================================

Grab_GrabCharacter:
		addq.b	#2,ost_secondary_routine(a0)		; go to Grab_AscendWithPlayer next
		movea.w	ost_grab_player(a0),a1			; a1 = ost of held player
		move.b	#$81,ost_obj_control(a1)		; lock their controls
		clr.w	ost_x_vel(a1)				; stop their movement
		clr.w	ost_y_vel(a1)
		move.b	#$E,ost_anim(a1)			; use floating animation
	if FixBugs
		; If the player gets grabbed while charging a spindash, they won't
		; exit their spindash state: the dust graphic will still appear,
		; just floating in the air, and will do a drop dash when release.
		; To fix this, just clear the player's spindash flag, like this:
		clr.b ost_spindash_flag(a1)
	endc
		move.b	#1,ost_frame(a0)
		tst.w	ost_y_vel(a0)				; is Grabber moving up?
		bmi.s	.movingup				; branch if not
		neg.w	ost_y_vel(a0)				; reverse, lifting the player
		move.b	ost_grab_timer2(a0),d0
		subi.b	#$40,d0
		neg.w	d0
		addq.b	#1,d0
		move.b	d0,ost_grab_timer2(a0)			; adjust timer to account for the early reversal in direction

	.movingup:
		move.b	#1,ost_grab_timer1(a0)
		move.b	#$10,ost_grab_colorchng_time(a0)	; time to wait before changing color
		move.b	#$20,ost_grab_37(a0)
		rts
; ===========================================================================

Grab_AscendWithPlayer:
		bsr.w	Grab_SwitchColor
		bsr.w	loc_390BC
		subq.b	#1,ost_grab_timer2(a0)			; decrement timer
		beq.s	.ascent_done				; branch if time remains
		rts
; ===========================================================================

.ascent_done:
		addq.b	#2,ost_secondary_routine(a0)		; go to Grab_HoldPlayer next
		clr.w	ost_y_vel(a0)				; stop vertical movement
		rts
; ===========================================================================

Grab_HoldPlayer:
		bsr.w	Grab_SwitchColor
		bra.w	loc_390BC
; ===========================================================================
		rts						; dead code
; ===========================================================================

BranchTo_Grab_CheckExplode:
		bra.w	Grab_SwitchColor
; ===========================================================================
; ----------------------------------------------------------------------------
; Object A8 - Grabber's legs
; ----------------------------------------------------------------------------

GrabberLegs:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_38F74(pc,d0.w),d1
		jmp	off_38F74(pc,d1.w)
; ===========================================================================
off_38F74:	index offset(*),,2
		ptr loc_38F7C					; 0
		ptr loc_38F88					; 2
		ptr loc_38FE8					; 4
		ptr loc_39022					; 6
; ===========================================================================

loc_38F7C:
		bsr.w	LoadSubObjData
		move.b	#3,ost_frame(a0)
		rts
; ===========================================================================

loc_38F88:
		movea.w	$2C(a0),a1
		cmpi.b	#id_Grabber,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		bsr.w	InheritParentFlip
		movea.w	$2C(a0),a1
		move.b	ost_frame(a1),d0
		addq.b	#3,d0
		move.b	d0,ost_frame(a0)
		move.b	ost_col_property(a0),d0
		beq.s	loc_38FD8
		clr.b	ost_col_property(a0)
		cmpi.b	#4,ost_secondary_routine(a1)
		bne.s	loc_38FD8
		andi.b	#3,d0
		beq.s	loc_38FD8
		clr.b	ost_col_type(a0)
		addq.b	#2,ost_primary_routine(a0)
		add.w	d0,d0
		st.b	$30(a1)
		move.w	word_38FE0-6(pc,d0.w),$32(a1)		; index base is in middle of below jmpto
		move.w	word_38FE0(pc,d0.w),$34(a1)

loc_38FD8:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
		dc.w v_ost_player1&$FFFF			; -2
		dc.w v_ost_player2&$FFFF			; -1

word_38FE0:
		dc.w v_ost_player1&$FFFF			; 0
		dc.w v_joypad_hold_actual&$FFFF			; 1
		dc.w v_joypad2_hold_actual&$FFFF		; 2
		dc.w v_joypad_hold_actual&$FFFF			; 3
; ===========================================================================

loc_38FE8:
		movea.w	$2C(a0),a1
		move.w	$32(a1),d0
		beq.s	loc_3901A
		movea.w	d0,a2
		cmpi.b	#id_Grabber,ost_id(a1)
		bne.s	loc_3900A
		move.w	ost_x_pos(a0),ost_x_pos(a2)
		move.w	ost_y_pos(a0),ost_y_pos(a2)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3900A:
		move.b	#0,$2A(a2)
		bset	#1,ost_primary_status(a2)
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_3901A:
		addq.b	#2,ost_primary_routine(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39022:
		movea.w	$2C(a0),a1
		cmpi.b	#id_Grabber,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object A9 - Grabber's box
; ----------------------------------------------------------------------------

GrabberBox:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_39040(pc,d0.w),d1
		jmp	off_39040(pc,d1.w)
; ===========================================================================
off_39040:	index offset(*),,2
		ptr loc_39044					; 0
		ptr loc_39056					; 2
; ===========================================================================

loc_39044:
		bsr.w	LoadSubObjData
		move.b	#2,ost_frame(a0)
		subi.w	#$C,ost_y_pos(a0)
		rts
; ===========================================================================

loc_39056:
		movea.w	$2C(a0),a1
		cmpi.b	#id_Grabber,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object AA - Grabber's string
; ----------------------------------------------------------------------------

GrabberString:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_39074(pc,d0.w),d1
		jmp	off_39074(pc,d1.w)
; ===========================================================================
off_39074:	index offset(*),,2
		ptr loc_39078					; 0
		ptr loc_39082					; 2
; ===========================================================================

loc_39078:
		bsr.w	LoadSubObjData
		subq.w	#8,ost_y_pos(a0)
		rts
; ===========================================================================

loc_39082:
		movea.w	$2C(a0),a1
		cmpi.b	#id_Grabber,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		move.w	ost_y_pos(a1),d0
		sub.w	ost_y_pos(a0),d0
		bmi.s	loc_3909E
		lsr.w	#4,d0
		move.b	d0,ost_frame(a0)

loc_3909E:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
; ----------------------------------------------------------------------------
; Object AB - Removed object
; ----------------------------------------------------------------------------

Unknown1:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_390B0(pc,d0.w),d1
		jmp	off_390B0(pc,d1.w)
; ===========================================================================
off_390B0:	index offset(*),,2
		ptr loc_390B4					; 0
		ptr loc_390B8					; 2
; ===========================================================================

loc_390B4:
		bra.w	LoadSubObjData
; ===========================================================================

loc_390B8:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_390BC:
		movea.w	ost_grab_34(a0),a1
		move.w	(a1),d0
		tst.b	ost_grab_31(a0)
		beq.s	loc_390E6
		subq.b	#1,ost_grab_37(a0)
		beq.s	loc_390FA
		move.b	ost_grab_36(a0),d1
		andi.b	#$C,d0
		beq.s	locret_390E4
		cmp.b	d1,d0
		beq.s	locret_390E4
		move.b	d0,ost_grab_36(a0)
		addq.b	#1,ost_grab_38(a0)

locret_390E4:
		rts
; ===========================================================================

loc_390E6:
		andi.b	#$C,d0
		beq.s	locret_390E4
		nop
		st.b	ost_grab_31(a0)
		move.b	d0,$36(a0)
		nop
		rts
; ===========================================================================

loc_390FA:
		cmpi.b	#4,$38(a0)
		bcs.s	loc_3912A
		move.b	#$A,ost_secondary_routine(a0)
		clr.w	ost_y_vel(a0)
		clr.b	ost_col_type(a0)
		movea.w	$32(a0),a2
		move.b	#0,$2A(a2)
		bset	#1,ost_primary_status(a2)
		move.b	#0,ost_anim(a2)
		clr.w	$32(a0)

loc_3912A:
		move.b	#$20,$37(a0)
		clr.b	$31(a0)
		clr.b	$38(a0)
		rts
; ===========================================================================

Grab_SwitchColor:
		subq.b	#1,ost_grab_timer1(a0)			; decrement timer
		bne.s	.no_colorchng				; branch if time remains

	;.change_color:
		move.b	ost_grab_colorchng_time(a0),ost_grab_timer1(a0) ; reset timer
		subq.b	#1,ost_grab_colorchng_time(a0)		; decrement the reset value
		beq.s	Grab_SelfDestruct			; branch if it's reached 0
		bchg	#tile_pal12_bit,ost_tile(a0)		; switch Grabber's stripes between yellow and red

	.no_colorchng:
		rts
; ===========================================================================

Grab_SelfDestruct:
		_move.b	#id_ExplosionItem,ost_id(a0)		; transform into an explosion
		move.b	#id_Explosion_Main,ost_primary_routine(a0)
		bset	#tile_pal12_bit,ost_tile(a0)
		move.w	ost_grab_player(a0),d0			; was a player being held by the Grabber?
		beq.s	.done					; branch if not
		movea.w	d0,a2					; a2 = player
		move.b	#0,ost_obj_control(a2)			; release their control
		bset	#status_air_bit,ost_primary_status(a2)	; drop them
		move.b	#id_col_8x8,ost_col_type(a0)		; set collision type so explosion hurts player

	.done:
		rts
; ===========================================================================

Grab_Display:
		tst.w	(f_two_player).w			; is it 2P mode?
		beq.s	.chkdel					; branch if not
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

.chkdel:
	if AllOptimizations
		out_of_range.s .delete,ost_x_pos(a0)		; branch if out of range
	else
		out_of_range.w .delete,ost_x_pos(a0)		; branch if out of range
	endc
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

.delete:
		lea	(v_respawn_list).w,a3
		moveq	#0,d0
		move.b	ost_respawn(a0),d0			; get respawn index
		beq.s	loc_391B6
		bclr	#7,v_respawn_data-v_respawn_list(a3,d0.w)

loc_391B6:
		tst.b	$30(a0)
		beq.s	loc_391CC
		movea.w	$32(a0),a3
		move.b	#0,$2A(a3)
		bset	#1,ost_primary_status(a3)

loc_391CC:
		moveq	#0,d6
		move.b	$2D(a0),d6

loc_391D2:
		movea.w	(a2)+,a1
		jsrto	DeleteChild,JmpTo6_DeleteChild
		dbf	d6,loc_391D2
		bra.w	JmpTo65_DeleteObject
; ===========================================================================
ChildData_GrabBox:
		childobjdata ost_grab_boxptr,id_GrabberBox,id_SubData_GrabBox

ChildData_GrabLegs:
		childobjdata ost_grab_legsptr,id_GrabberLegs,id_SubData_GrabLegs

ChildData_GrabString:
		childobjdata ost_grab_stringptr,id_GrabberString,id_SubData_GrabString

SubData_Grabber:
	if FixBugs
		subobjdata Map_Grab,tile_Nem_Grabber+tile_pal2+tile_hi,render_rel,4,$2C/2,id_col_8x8
	else
		; The Grabber disappears a bit too early off the edges of the screen. This is
		; because the width set here is too narrow.
		subobjdata Map_Grab,tile_Nem_Grabber+tile_pal2+tile_hi,render_rel,4,$20/2,id_col_8x8
	endc

SubData_GrabLegs:
		subobjdata Map_Grab,tile_Nem_Grabber+tile_pal2+tile_hi,render_rel,1,$20/2,id_col_8x8_2|id_col_custom

SubData_GrabBox:
		subobjdata Map_Grab,tile_Nem_Grabber+tile_pal2+tile_hi,render_rel,4,8/2,id_col_null

SubData_GrabString:
		subobjdata Map_GrabString,tile_Nem_Grabber+tile_pal2+tile_hi,render_rel,5,8/2,id_col_null

Ani_Grab:	index offset(*)
		ptr Ani_Grab_Attack

	Ani_Grab_Attack:
		dc.b 7
		dc.b 0
		dc.b 1
		dc.b afEnd
; ===========================================================================

		include "mappings/sprite/Grabber.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object AC - Balkiry
; ----------------------------------------------------------------------------

Balkiry:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_39388(pc,d0.w),d1
		jmp	off_39388(pc,d1.w)
; ===========================================================================
off_39388:	index offset(*),,2
		ptr loc_3938C					; 0
		ptr loc_393B6					; 2
; ===========================================================================

loc_3938C:
		bsr.w	LoadSubObjData
		move.b	#1,ost_frame(a0)
		move.w	#-$300,ost_x_vel(a0)
		bclr	#render_yflip_bit,ost_render(a0)
		beq.s	loc_393AA
		move.w	#-$500,ost_x_vel(a0)

loc_393AA:
		lea_	Ani_BalkJet,a1
		move.l	a1,$2E(a0)
		bra.w	BTJet_Load
; ===========================================================================

loc_393B6:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	AdjustPosSCZ
		bra.w	DeleteBehindScreen
; ===========================================================================
SubData_Balkiry:
		dc.l Map_Balkiry
		dc.w $565
		dc.w $404
		dc.w $2008
; ===========================================================================

		include "mappings/sprite/Balkiry.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object AD - Clucker's base
; ----------------------------------------------------------------------------

CluckerBase:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3942A(pc,d0.w),d1
		jmp	off_3942A(pc,d1.w)
; ===========================================================================
off_3942A:	index offset(*),,2
		ptr loc_3942E					; 0
		ptr loc_3943A					; 2
; ===========================================================================

loc_3942E:
		bsr.w	LoadSubObjData
		move.b	#$C,ost_frame(a0)
		rts
; ===========================================================================

loc_3943A:
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	ost_x_pos(a0),d4
		jsrto	SolidObject,JmpTo27_SolidObject
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
; ----------------------------------------------------------------------------
; Object AE - Clucker
; ----------------------------------------------------------------------------

Clucker:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_39460(pc,d0.w),d1
		jmp	off_39460(pc,d1.w)
; ===========================================================================
off_39460:	index offset(*)
		ptr loc_3946E					; 0
		ptr loc_39488					; 2
		ptr loc_394A2					; 4
		ptr loc_394D2					; 6
		ptr loc_394E0					; 8
		ptr loc_39508					; $A
		ptr loc_39516					; $C
; ===========================================================================

loc_3946E:
		bsr.w	LoadSubObjData
		move.b	#$15,ost_frame(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	locret_39486
		bset	#status_xflip_bit,ost_primary_status(a0)

locret_39486:
		rts
; ===========================================================================

loc_39488:
		bsr.w	FindPlayer
		addi.w	#$80,d2
		cmpi.w	#$100,d2
		bcs.s	loc_3949A
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3949A:
		addq.b	#2,ost_primary_routine(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_394A2:
		move.b	ost_primary_routine(a0),d2
		lea	(off_3958A).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		cmp.b	ost_primary_routine(a0),d2
		bne.s	loc_394BA
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_394BA:
		lea	ost_frame(a0),a1
		clr.l	(a1)
		clr.w	ost_anim_time-ost_frame(a1)
		move.b	#8,(a1)
		move.b	#id_col_16x16,ost_col_type(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_394D2:
		lea	(off_39596).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_394E0:
		tst.b	$2A(a0)
		beq.s	loc_394EE
		subq.b	#1,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_394EE:
		addq.b	#2,ost_primary_routine(a0)
		lea	ost_frame(a0),a1
		clr.l	(a1)
		clr.w	ost_anim_time-ost_frame(a1)
		move.b	#$B,(a1)
		bsr.w	loc_39526
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_39508:
		lea	(off_395A2).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_39516:
		move.b	#8,ost_primary_routine(a0)
		move.b	#$40,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_39526:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_39574
		_move.b	#id_Projectile,ost_id(a1)
		move.b	#$D,ost_frame(a1)
		move.b	#$46,ost_subdata_ptr(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		addi.w	#$B,ost_y_pos(a1)
		move.w	#-$200,d0
		move.w	#-8,d1
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_39564
		neg.w	d0
		neg.w	d1

loc_39564:
		move.w	d0,ost_x_vel(a1)
		add.w	d1,ost_x_pos(a1)
		lea_	loc_37734,a2
		move.l	a2,ost_proj_codeptr(a1)

locret_39574:
		rts
; ===========================================================================
off_39576:
		dc.l Map_Clucker
		dc.w $379
		dc.w $404
		dc.w $1800

off_39580:
		dc.l Map_Clucker
		dc.w $379
		dc.w $405
		dc.w $1000

off_3958A:	index offset(*)
		ptr byte_3958C

byte_3958C:
		dc.b   1,  0,  1,  2,  3,  4,  5,  6,  7,$FC
		even

off_39596:	index offset(*)
		ptr byte_39598

byte_39598:
		dc.b   1,  8,  9, $A, $B, $B, $B, $B,$FC
		even

off_395A2:	index offset(*)
		ptr byte_395A4

byte_395A4:
		dc.b   3, $A, $B,$FC
		even

off_395A8:	index offset(*)
		ptr byte_395AA

byte_395AA:
		dc.b   3, $D, $E, $F,$10,$11,$12,$13,$14,$FF
		even
; ===========================================================================

		include "mappings/sprite/Clucker.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object AF - Mecha Sonic
; ----------------------------------------------------------------------------

MechaSonic:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3973A(pc,d0.w),d1
		jmp	off_3973A(pc,d1.w)
; ===========================================================================
off_3973A:	index offset(*),,2
		ptr loc_3975E					; 0
		ptr loc_397AC					; 2
		ptr loc_397E6					; 4
		ptr loc_397FE					; 6
		ptr loc_3984A					; 8
		ptr loc_398C0					; $A
		ptr loc_39B92					; $C
		ptr loc_39BBA					; $E
		ptr loc_39BCC					; $10
		ptr loc_39BE2					; $12
		ptr loc_39BEA					; $14
		ptr loc_39C02					; $16
		ptr loc_39C0A					; $18
		ptr loc_39C12					; $1A
		ptr loc_39C2A					; $1C
		ptr loc_39C42					; $1E
		ptr loc_39C50					; $20
		ptr loc_39CA0					; $22
; ===========================================================================

loc_3975E:
		bsr.w	LoadSubObjData
		move.b	#$1B,ost_height(a0)
		move.b	#$10,ost_width(a0)
		move.b	#0,ost_col_type(a0)
		move.b	#8,ost_col_property(a0)
		lea	(byte_39DC2).l,a2
		bsr.w	LoadChild
		move.b	#$E,ost_primary_routine(a1)
		lea	(byte_39DC6).l,a2
		bsr.w	LoadChild
		move.b	#$14,ost_primary_routine(a1)
		lea	(byte_39DCA).l,a2
		bsr.w	LoadChild
		move.b	#$1A,ost_primary_routine(a1)
		rts
; ===========================================================================

loc_397AC:
		move.w	(v_camera_x_pos).w,d0
		cmpi.w	#$224,d0
		bcc.s	loc_397BA
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_397BA:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$3C,$2A(a0)
		move.w	#$100,ost_y_vel(a0)
		move.w	#$224,d0
		move.w	d0,(v_boundary_left).w
		move.w	d0,(v_boundary_right).w
		move.b	#9,(v_current_boss).w
		moveq	#-7,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_397E6:
		subq.w	#1,$2A(a0)
		bmi.s	loc_397F0
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_397F0:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#-$6D,d0
		jsrto	PlayMusic,JmpTo5_PlayMusic
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_397FE:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_3980E
		moveq	#-$24,d0
		jsrto	PlaySound,JmpTo12_PlaySound

loc_3980E:
		jsr	(FindFloorObj).l
		tst.w	d1
		bmi.s	loc_39830
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		moveq	#0,d0
		moveq	#0,d1
		movea.w	$3E(a0),a1
		bsr.w	AlignChild
		bsr.w	loc_39D4A
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39830:
		add.w	d1,ost_y_pos(a0)
		move.w	#0,ost_y_vel(a0)
		move.b	#id_col_12x12,ost_col_type(a0)
		bset	#1,ost_primary_status(a0)
		bra.w	loc_399D6
; ===========================================================================

loc_3984A:
		bsr.w	loc_39CAE
		bsr.w	loc_39D1C
		subq.b	#1,$2A(a0)
		beq.s	loc_39886
		cmpi.b	#$32,$2A(a0)
		bne.s	loc_3986A
		moveq	#-$12,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		jsrto	DisplaySprite,JmpTo45_DisplaySprite

loc_3986A:
		jsr	(FindFloorObj).l
		add.w	d1,ost_y_pos(a0)
		lea	(off_39DE2).l,a1
		bsr.w	AnimateSprite2
		bsr.w	loc_39D4A
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39886:
		addq.b	#2,ost_primary_routine(a0)
		moveq	#0,d0
		move.b	$2F(a0),d0
		andi.b	#$F,d0
		move.b	byte_398B0(pc,d0.w),ost_secondary_routine(a0)
		addq.b	#1,$2F(a0)
		clr.b	$2E(a0)
		movea.w	$3C(a0),a1
		move.b	#$16,ost_primary_routine(a1)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
byte_398B0:
		dc.b   6					; 0
		dc.b   0					; 1
		dc.b $10					; 2
		dc.b   6					; 3
		dc.b   6					; 4
		dc.b $1E					; 5
		dc.b   0					; 6
		dc.b $10					; 7
		dc.b   6					; 8
		dc.b   6					; 9
		dc.b $10					; 10
		dc.b   6					; 11
		dc.b   0					; 12
		dc.b   6					; 13
		dc.b $10					; 14
		dc.b $1E					; 15
; ===========================================================================

loc_398C0:
		bsr.w	loc_39CAE
		bsr.w	loc_39D1C
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_398F2(pc,d0.w),d1
		jsr	off_398F2(pc,d1.w)
		moveq	#0,d0
		moveq	#0,d1
		movea.w	$3E(a0),a1
		bsr.w	AlignChild
		bsr.w	loc_39D4A
		bsr.w	AlignChild
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_398F2:	index offset(*),,2
		ptr loc_3991E					; 0
		ptr loc_39946					; 2
		ptr loc_39976					; 4
		ptr loc_39A0A					; 6
		ptr loc_39A1C					; 8
		ptr loc_39A44					; $A
		ptr loc_39A68					; $C
		ptr loc_39A96					; $E
		ptr loc_39A0A					; $10
		ptr loc_39A1C					; $12
		ptr loc_39AAA					; $14
		ptr loc_39ACE					; $16
		ptr loc_39AF4					; $18
		ptr loc_39B28					; $1A
		ptr loc_39A96					; $1C
		ptr loc_39A0A					; $1E
		ptr loc_39A1C					; $20
		ptr loc_39AAA					; $22
		ptr loc_39ACE					; $24
		ptr loc_39B44					; $26
		ptr loc_39B28					; $28
		ptr loc_39A96					; $2A
; ===========================================================================

loc_3991E:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_frame(a0)
		move.b	#2,$2C(a0)

loc_3992E:
		move.b	#$20,$2A(a0)
		movea.w	$3E(a0),a1
		move.b	#$10,ost_primary_routine(a1)
		move.b	#1,ost_anim(a1)
		rts
; ===========================================================================

loc_39946:
		subq.b	#1,$2A(a0)
		bmi.s	loc_3994E
		rts
; ===========================================================================

loc_3994E:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$40,$2A(a0)
		move.b	#1,ost_anim(a0)
		move.w	#$800,d0
		bsr.w	loc_39D60
		movea.w	$3E(a0),a1
		move.b	#2,ost_anim(a1)
		moveq	#-$44,d0
		jmpto	PlaySound,JmpTo12_PlaySound
; ===========================================================================

loc_39976:
		subq.b	#1,$2A(a0)
		bmi.s	loc_399C2
		cmpi.b	#$20,$2A(a0)
		bne.s	loc_39994
		move.b	#2,ost_anim(a0)
		movea.w	$3E(a0),a1
		move.b	#$12,ost_primary_routine(a1)

loc_39994:
		bsr.w	loc_39D72
		lea	(off_39DE2).l,a1
		bsr.w	AnimateSprite2
		cmpi.b	#2,ost_anim(a0)
		bne.s	locret_399C0
		cmpi.b	#2,ost_anim_frame(a0)
		bne.s	locret_399C0
		cmpi.b	#3,ost_anim_time(a0)
		bne.s	locret_399C0
		bchg	#render_xflip_bit,ost_render(a0)

locret_399C0:
		rts
; ===========================================================================

loc_399C2:
		subq.b	#1,$2C(a0)
		beq.s	loc_399D6
		move.b	#2,ost_secondary_routine(a0)
		clr.w	ost_x_vel(a0)
		bra.w	loc_3992E
; ===========================================================================

loc_399D6:
		move.b	#8,ost_primary_routine(a0)
		move.b	#0,ost_anim(a0)
		move.b	#$64,$2A(a0)
		clr.w	ost_x_vel(a0)
		movea.w	$3E(a0),a1
		move.b	#$12,ost_primary_routine(a1)
		movea.w	$3C(a0),a1
		move.b	#$18,ost_primary_routine(a1)
		moveq	#-$12,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39A0A:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_frame(a0)
		move.b	#3,ost_anim(a0)
		rts
; ===========================================================================

loc_39A1C:
		lea	(off_39DE2).l,a1
		bsr.w	AnimateSprite2
		bne.s	loc_39A2A
		rts
; ===========================================================================

loc_39A2A:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$20,$2A(a0)
		move.b	#4,ost_anim(a0)
		moveq	#-$50,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39A44:
		subq.b	#1,$2A(a0)
		bmi.s	loc_39A56
		lea	(off_39DE2).l,a1
		bsr.w	AnimateSprite2
		rts
; ===========================================================================

loc_39A56:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$40,$2A(a0)
		move.w	#$800,d0
		bra.w	loc_39D60
; ===========================================================================

loc_39A68:
		subq.b	#1,$2A(a0)
		bmi.s	loc_39A7C
		bsr.w	loc_39D72
		lea	(off_39DE2).l,a1
		bra.w	AnimateSprite2
; ===========================================================================

loc_39A7C:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#5,ost_anim(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		clr.w	ost_x_vel(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_39A96:
		lea	(off_39DE2).l,a1
		bsr.w	AnimateSprite2
		bne.w	loc_39AA6
		rts
; ===========================================================================

loc_39AA6:
		bra.w	loc_399D6
; ===========================================================================

loc_39AAA:
		subq.b	#1,$2A(a0)
		bmi.s	loc_39ABC
		lea	(off_39DE2).l,a1
		bsr.w	AnimateSprite2
		rts
; ===========================================================================

loc_39ABC:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$40,$2A(a0)
		move.w	#$400,d0
		bra.w	loc_39D60
; ===========================================================================

loc_39ACE:
		subq.b	#1,$2A(a0)
		cmpi.b	#$3C,$2A(a0)
		bne.s	loc_39ADE
		bsr.w	loc_39AE8

loc_39ADE:
		lea	(off_39DE2).l,a1
		bra.w	AnimateSprite2
; ===========================================================================

loc_39AE8:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#-$600,ost_y_vel(a0)
		rts
; ===========================================================================

loc_39AF4:
		subq.b	#1,$2A(a0)
		bmi.w	loc_39A7C
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_39B0A
		bsr.w	loc_39B1A

loc_39B0A:
		addi.w	#$38,ost_y_vel(a0)
		lea	(off_39DE2).l,a1
		bra.w	AnimateSprite2
; ===========================================================================

loc_39B1A:
		addq.b	#2,ost_secondary_routine(a0)
		add.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_39B28:
		subq.b	#1,$2A(a0)
		bmi.w	loc_39A7C
		jsr	(FindFloorObj).l
		add.w	d1,ost_y_pos(a0)
		lea	(off_39DE2).l,a1			; could be PC relative
		bra.w	AnimateSprite2
; ===========================================================================

loc_39B44:
		subq.b	#1,$2A(a0)
		bmi.w	loc_39A7C
		tst.b	$2E(a0)
		bne.s	loc_39B66
		tst.w	ost_y_vel(a0)
		bmi.s	loc_39B66
		st.b	$2E(a0)
		bsr.w	loc_39D82
		moveq	#-$5E,d0
		jsrto	PlaySound,JmpTo12_PlaySound

loc_39B66:
		jsr	(FindFloorObj).l
		tst.w	d1
		bpl.s	loc_39B74
		bsr.w	loc_39B84

loc_39B74:
		addi.w	#$38,ost_y_vel(a0)
		lea	(off_39DE2).l,a1			; could be PC relative
		bra.w	AnimateSprite2
; ===========================================================================

loc_39B84:
		addq.b	#2,ost_secondary_routine(a0)
		add.w	d1,ost_y_pos(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_39B92:
		clr.b	ost_col_type(a0)
		subq.w	#1,$32(a0)
		bmi.s	loc_39BA4
		jsrto	BossExplode,JmpTo_BossExplode
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39BA4:
		move.w	#$1000,(v_boundary_right).w
		addq.b	#2,(v_dle_routine).w
	if FixBugs
		move.w	(v_level_music).w,d0
	else
		; 'v_level_music' is a word long, not a byte.
		; All this does is try to play Sound 0, which doesn't do anything.
		; This causes the Death Egg Music music to not resume after the
		; Mecha Sonic fight.
		move.b	(v_level_music).w,d0
	endc
		jsrto	PlayMusic,JmpTo5_PlayMusic
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_39BBA:
		bsr.w	LoadSubObjData
		move.b	#8,ost_displaywidth(a0)
		move.b	#0,ost_col_type(a0)
		rts
; ===========================================================================

loc_39BCC:
		movea.w	$2C(a0),a1
		bsr.w	InheritParentFlip
		lea	(off_39E30).l,a1
		bsr.w	AnimateSprite2
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39BE2:
		andi.b	#(~render_onscreen)&$FF,ost_render(a0)
		rts
; ===========================================================================

loc_39BEA:
		bsr.w	LoadSubObjData
		move.b	#8,ost_displaywidth(a0)
		move.b	#$B,ost_frame(a0)
		move.b	#3,ost_priority(a0)
		rts
; ===========================================================================

loc_39C02:
		move.b	#0,ost_col_type(a0)
		rts
; ===========================================================================

loc_39C0A:
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a0)
		rts
; ===========================================================================

loc_39C12:
		bsr.w	LoadSubObjData
		move.b	#4,ost_frame(a0)
		move.w	#$2C0,ost_x_pos(a0)
		move.w	#$139,ost_y_pos(a0)
		rts
; ===========================================================================

loc_39C2A:
		movea.w	$2C(a0),a1
		bclr	#1,ost_primary_status(a1)
		bne.s	loc_39C3A
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39C3A:
		addq.b	#2,ost_primary_routine(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39C42:
		lea	(off_39E42).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39C50:
		movea.w	$2C(a0),a1
		lea	($FFFFB000).w,a2
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_39C92
		move.b	#2,ost_anim(a0)
		cmpi.b	#4,ost_primary_routine(a2)
		bne.s	loc_39C78
		move.b	#3,ost_anim(a0)
		bra.w	loc_39C84
; ===========================================================================

loc_39C78:
		tst.b	ost_col_type(a1)
		bne.s	loc_39C84
		move.b	#4,ost_anim(a0)

loc_39C84:
		lea	(off_39E42).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39C92:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#1,ost_anim(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_39CA0:
		lea	(off_39E42).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_39CAE:
		tst.b	ost_col_property(a0)
		beq.s	loc_39CF0
		tst.b	ost_col_type(a0)
		bne.s	locret_39CEE
		tst.b	$30(a0)
		bne.s	loc_39CD0
		move.b	#$20,$30(a0)
		move.w	#sfx_BossHit,d0
		jsr	(PlaySound).l

loc_39CD0:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_39CDE
		move.w	#$EEE,d0

loc_39CDE:
		move.w	d0,(a1)
		subq.b	#1,$30(a0)
		bne.s	locret_39CEE
		clr.w	($FFFFFB22).w
		bsr.w	loc_39D24

locret_39CEE:
		rts
; ===========================================================================

loc_39CF0:
		moveq	#$64,d0
		bsr.w	AddPoints
		move.w	#$FF,$32(a0)
		move.b	#$C,ost_primary_routine(a0)
		clr.b	ost_col_type(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		movea.w	$3C(a0),a1
		jsrto	DeleteChild,JmpTo6_DeleteChild
		movea.w	$3E(a0),a1
		jmpto	DeleteChild,JmpTo6_DeleteChild
; ===========================================================================

loc_39D1C:
		tst.b	ost_col_type(a0)
		beq.w	TRider_SharedRTS

loc_39D24:
		move.b	ost_frame(a0),d0
		cmpi.b	#6,d0
		beq.s	loc_39D42
		cmpi.b	#7,d0
		beq.s	loc_39D42
		cmpi.b	#8,d0
		beq.s	loc_39D42
		move.b	#id_col_12x12,ost_col_type(a0)
		rts
; ===========================================================================

loc_39D42:
		move.b	#id_col_12x12+id_col_hurt,ost_col_type(a0)
		rts
; ===========================================================================

loc_39D4A:
		moveq	#$C,d0
		moveq	#-$C,d1
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_39D58
		neg.w	d0

loc_39D58:
		movea.w	$3C(a0),a1
		bra.w	AlignChild
; ===========================================================================

loc_39D60:
		tst.b	$2D(a0)
		bne.s	loc_39D68
		neg.w	d0

loc_39D68:
		not.b	$2D(a0)
		move.w	d0,ost_x_vel(a0)
		rts
; ===========================================================================

loc_39D72:
		moveq	#$20,d0
		tst.w	ost_x_vel(a0)
		bmi.s	loc_39D7C
		neg.w	d0

loc_39D7C:
		add.w	d0,ost_x_vel(a0)
		rts
; ===========================================================================

loc_39D82:
		move.b	#$4A,d2
		moveq	#7,d6
		lea	(byte_39D92).l,a2
		bra.w	LoadProjectiles
; ===========================================================================
byte_39D92:							; projectile data
		dc.b   0,$E8,  0,$FD, $F,  0,$F0,$F0,$FE,$FE,$10,  0,$E8,  0,$FD,  0 ; 0
		dc.b $11,  0,$F0,$10,$FE,  2,$12,  0,  0,$18,  0,  3,$13,  0,$10,$10 ; 16
		dc.b   2,  2,$14,  0,$18,  0,  3,  0,$15,  0,$10,$F0,  2,$FE,$16,  0 ; 32

byte_39DC2:
		dc.b   0					; 0
		dc.b $3E					; 1
		dc.b $AF					; 2
		dc.b $48					; 3

byte_39DC6:
		dc.b   0					; 0
		dc.b $3C					; 1
		dc.b $AF					; 2
		dc.b $48					; 3

byte_39DCA:
		dc.b   0					; 0
		dc.b $3A					; 1
		dc.b $AF					; 2
		dc.b $A4					; 3

off_39DCE:
		dc.l Map_MechSon
		dc.w $2380
		dc.w $404
		dc.w $101A

off_39DD8:
		dc.l Map_EggmanWindow
		dc.w $378
		dc.w $406
		dc.w $1000

off_39DE2:	index offset(*)
		ptr byte_39DEE					; 0
		ptr byte_39DF4					; 1
		ptr byte_39DF8					; 2
		ptr byte_39DFE					; 3
		ptr byte_39E14					; 4
		ptr byte_39E1A					; 5

byte_39DEE:
		dc.b   2,  0,  1,  2,$FF
		even

byte_39DF4:
		dc.b $45,  3,$FD
		even

byte_39DF8:
		dc.b   3,  4,  5,  4,  3,$FC

byte_39DFE:
		dc.b   3,  3,  3,  6,  6,  6,  7,  7,  7,  8,  8,  8,  6,  6,  7,  7
		dc.b   8,  8,  6,  7,  8,$FC

byte_39E14:
		dc.b   2,  6,  7,  8,$FF
		even

byte_39E1A:
		dc.b   3,  8,  7,  6,  8,  8,  7,  7,  6,  6,  8,  8,  8,  7,  7,  7
		dc.b   6,  6,  6,  3,  3,$FC
		even

off_39E30:	index offset(*)
		ptr byte_39E36					; 0
		ptr byte_39E3A					; 1
		ptr byte_39E3E					; 2

byte_39E36:
		dc.b   1, $B, $C,$FF

byte_39E3A:
		dc.b   1, $D, $E,$FF

byte_39E3E:
		dc.b   1,  9, $A,$FF
		even

off_39E42:	index offset(*)
		ptr byte_39E4C					; 0
		ptr byte_39E54					; 1
		ptr byte_39E5C					; 2
		ptr byte_39E60					; 3
		ptr byte_39E64					; 4

byte_39E4C:
		dc.b   3,  4,  3,  2,  1,  0,$FC
		even

byte_39E54:
		dc.b   3,  0,  1,  2,  3,  4,$FA
		even

byte_39E5C:
		dc.b   3,  5,  5,$FF

byte_39E60:
		dc.b   3,  5,  6,$FF

byte_39E64:
		dc.b   3,  7,  7,$FF
		even

; ===========================================================================

		include "mappings/sprite/Mecha Sonic.asm"
		include "mappings/sprite/DEZ Eggman's Window.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B0 - Sonic on the Sega screen
; ----------------------------------------------------------------------------

SonicSegaScreen:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SonicSegaScreen_Index(pc,d0.w),d1
		jmp	SonicSegaScreen_Index(pc,d1.w)
; ===========================================================================
SonicSegaScreen_Index:	index offset(*),,2
		ptr SonicSegaScreen_Init			; 0
		ptr SonicSegaScreen_RunLeft			; 2
		ptr SonicSegaScreen_MidWipe			; 4
		ptr SonicSegaScreen_RunRight			; 6
		ptr SonicSegaScreen_EndWipe			; 8
		ptr SonicSegaScreen_Done			; $A	; rts

		rsobj	SonicSegaScreen,$2A
ost_sonicsega_frame_counter:		rs.w 1			; number of frames remaining in each stage of the animation
ost_sonicsega_wait_time:			rs.b 1		; number of frames to wait before updating the streak palette
ost_sonicsega_streakcounter:		rs.b 1			; number of times the streak palette has been updated
		rsobjend
; ===========================================================================

SonicSegaScreen_Init: ; Routine 0
		bsr.w	LoadSubObjData				; load mapping and tile data, go to SonicSegaScreen_RunLeft next
		move.w	#screen_right+40,ost_x_screen(a0)
		move.w	#screen_top+112,ost_y_screen(a0)
		move.w	#$B,ost_sonicsega_frame_counter(a0)	; set timer to 11 frames
		move.w	#id_SegaScreen_VBlank_InitLeft,(v_segascr_vblank_sub).w
		bset	#render_xflip_bit,ost_render(a0)	; sonic faces left initially
		bset	#status_xflip_bit,ost_primary_status(a0)

		; Initialize streak horizontal offsets for Sonic going left.
		lea	(v_hscroll_buffer+(2*2*((9*8)+6))).w,a1	; 9 full lines (8 pixels) + 6 pixels, 2-byte interleaved entries for FG and BG
		lea	Streak_Horizontal_Offsets(pc),a2
		moveq	#0,d0
		moveq	#sizeof_Streak_Horizontal_Offsets-1,d6	; number of streaks-1

	.loop_streak:
		move.b	(a2)+,d0
		add.w	d0,(a1)
		addq.w	#2*2*2,a1				; advance to next streak 2 pixels down
		dbf	d6,.loop_streak				; loop for all streak offsets

;SonicSegaScreen_LoadArt:
		lea	SonicSegaScreen_DPLCPointers(pc),a1	; pointers to DPLCs for sprites that we are going to upscale
		lea	(Art_Sonic).l,a3
		lea	(v_128x128_tiles).l,a5
		moveq	#((sizeof_SonicSegaScreen_DPLCPointers)/4)-1,d5 ; 4 mapping frames to loop over

	.loop_frame:
		movea.l	(a1)+,a2				; DPLC of current frame
		move.w	(a2)+,d6				; number of pieces in this frame
		subq.w	#1,d6					; minus 1 for loop counter

	.loop_piece:
		move.w	(a2)+,d0				; offset of art for current frame
		move.w	d0,d1					; d0 will be used to calculate effective address, d1 to calculate number of longwords to copy

	if FixBugs
		; Depending on the exact location (and size) of the art being used,
		; you may encounter an overflow in the original code which garbles
		; the enlarged Sonic. The following code fixes this:
		andi.l	#$FFF,d0
		lsl.l	#5,d0
		lea	(a3,d0.l),a4				; a4 = ROM address of tiles to copy
	else
		andi.w	#$FFF,d0
		lsl.w	#5,d0
		lea	(a3,d0.w),a4				; a4 = ROM address of tiles to copy
	endc
		andi.w	#$F000,d1				; abcd000000000000
		rol.w	#4,d1					; (this calculation can be done smaller and faster
		addq.w	#1,d1					; by doing rol.w #7,d1; addq.w #7,d1
		lsl.w	#3,d1					; instead of these 4 lines)
		subq.w	#1,d1					; 000000000abcd111 ; number of longwords to copy minus 1

	.loop_pixel:
		move.l	(a4)+,(a5)+				; copy a longword of art data to buffer
		dbf	d1,.loop_pixel				; repeat for all pixels in this spritePiece
		dbf	d6,.loop_piece				; repeat for every spritePiece in the frame
		dbf	d5,.loop_frame				; repeat until all frames have been copied

;SonicSegaScreen_UpscaleSprites:
		pushr.w	d7
		moveq	#0,d0
		moveq	#0,d1
		lea	SonicSegaScreen_SpriteScaleData(pc),a6	; load sprite upscale data array
		moveq	#(((sizeof_SonicSegaScreen_DPLCPointers)/4)*2)-1,d7 ; 4 frames, with 2 pieces each

	.loop_upscale:
		movea.l	(a6)+,a1				; source in RAM of tile graphics to enlarge
		movea.l	(a6)+,a2				; destination in RAM of enlarged graphics
		move.b	(a6)+,d0				; width of the sprite spritePiece to enlarge (minus 1)
		move.b	(a6)+,d1				; height of the sprite spritePiece to enlarge (minus 1)
		bsr.w	Scale_2x				; upscale the spritePiece
		dbf	d7,.loop_upscale			; repeat for every spritePiece
		popr.w	d7
		rts
; ===========================================================================
SonicSegaScreen_DPLCPointers:
		dc.l DPLC_Sonic_Run11				; 0
		dc.l DPLC_Sonic_Run12				; 1
		dc.l DPLC_Sonic_Run13				; 2
		dc.l DPLC_Sonic_Run14				; 3
		arraysize	SonicSegaScreen_DPLCPointers

upscaledata: macro width,height

	dc.l copysrc,copydst					; source of data to upscale, destination where upscaled data will be written
	dc.b \width-1,\height-1					; the width and height of the spritePiece to enlarge minus 1

	copysrc: = copysrc+(((\width*\height)&$7FF)<<5)		; increment source
	copydst: = copydst+(((\width*\height)&$7FF)<<5)*2*2	; increment destination
    endm

SonicSegaScreen_SpriteScaleData:
copysrc:	= v_128x128_tiles
copydst:	= v_128x128_tiles+$B00
SonicSegaScreen_ScaledSpriteDataStart = copydst
		rept 4						; repeat 4 times since there are 4 frames to scale up
		upscaledata 3,2					; spritePiece 1 of each frame (the smaller top spritePiece):
		upscaledata 4,4					; spritePiece 2 of each frame (the larger bottom spritePiece):
		endr
SonicSegaScreen_ScaledSpriteDataEnd	= copydst
sizeof_SonicSegaScreen_ScaledSpriteData: equ	SonicSegaScreen_ScaledSpriteDataEnd-SonicSegaScreen_ScaledSpriteDataStart

		if copysrc>SonicSegaScreen_ScaledSpriteDataStart
			inform 3,"The scale copy source overran the allocated size. Try changing the initial value of copydst to v_128x128_tiles+$%h.",copysrc-v_128x128_tiles
		endc
; ===========================================================================

SonicSegaScreen_RunLeft:					; Routine 2
		subi.w	#$20,ost_x_screen(a0)			; move Sonic left 32 pixels
		subq.w	#1,ost_sonicsega_frame_counter(a0)	; decrement frame counter
		bmi.s	.runleft_done				; if we're done, branch
		bsr.w	SonicSegaScreen_MoveStreaksLeft		; move blue streaks to the left
		lea	(Ani_SonicSegaScreen).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
	.runleft_done:
		addq.b	#2,ost_primary_routine(a0)		; go to SonicSegaScreen_MidWipe next
		move.w	#$C,ost_sonicsega_frame_counter(a0)	; continue moving blue streaks left for 12 frames
		move.b	#1,ost_sonicsega_wait_time(a0)
		move.b	#-1,ost_sonicsega_streakcounter(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

SonicSegaScreen_MidWipe:					; Routine 4
		tst.w	ost_sonicsega_frame_counter(a0)		; has frame counter reached 0?
		beq.s	.updatepalette				; if so, branch
		subq.w	#1,ost_sonicsega_frame_counter(a0)	; decrement frame counter
		bsr.w	SonicSegaScreen_MoveStreaksLeft		; move blue streaks to left

	.updatepalette:
		lea	Pal_SegaScreen2(pc),a1
		bsr.w	SonicSegaScreen_UpdateStreakPals
		bne.s	SonicSegaScreen_RunRightInit
		rts
; ===========================================================================

SonicSegaScreen_RunRightInit:
		addq.b	#2,ost_primary_routine(a0)		; go to SonicSegaScreen_RunRight next
	if FixBugs=0
		; This instruction is redundant, as this bit is flipped again below. This doesn't
		; actually have any harmful effects due to the way AnimateSprite works, but it is
		; still a waste of cycles.
		bchg	#render_xflip_bit,ost_render(a0)
	endc
		move.w	#$B,ost_sonicsega_frame_counter(a0)	; set timer to 11 frames
		move.w	#id_SegaScreen_VBlank_InitRight,(v_segascr_vblank_sub).w
		subi.w	#$28,ost_x_screen(a0)			; start at $40 (screen_left-64)
		bchg	#render_xflip_bit,ost_render(a0)	; Sonic faces right now
		bchg	#status_xflip_bit,ost_primary_status(a0)

	if FixBugs
		clear_ram	hscroll,hscroll_end		; clear the HScroll buffer
	else
		; This clears a lot more than the horizontal scroll buffer. This is because the loop
		; counter is erroneously set to the size of the buffer in bytes ($400) rather than
		; the size in longwords-1.
		clear_ram	hscroll,hscroll_end+$C04	; clear the HScroll buffer and then some
	endc

		; Initialize streak horizontal offsets for Sonic going right.
		lea	(v_hscroll_buffer+(2*2*((9*8)+7))).w,a1	; 9 full lines (8 pixels) + 7 pixels, 2-byte interleaved entries for FG and BG
		lea	Streak_Horizontal_Offsets(pc),a2
		moveq	#0,d0
		moveq	#sizeof_Streak_Horizontal_Offsets-1,d6

	.loop_streak:
		move.b	(a2)+,d0
		sub.w	d0,(a1)
		addq.w	#2*2*2,a1				; advance to next streak 2 pixels down
		dbf	d6,.loop_streak				; loop for all streak offsets
		rts
; ===========================================================================

SonicSegaScreen_RunRight:					; Routine 6
		subq.w	#1,ost_sonicsega_frame_counter(a0)	; decrement frame counter
		bmi.s	.runright_done				; if we're done, branch
		addi.w	#$20,ost_x_screen(a0)			; move Sonic 32 pixels right
		bsr.w	SonicSegaScreen_MoveStreaksRight	; move blue streaks to the right
		lea	(Ani_SonicSegaScreen).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

	.runright_done:
		addq.b	#2,ost_primary_routine(a0)		; go to SonicSegaScreen_EndWipe next
		move.w	#$C,ost_sonicsega_frame_counter(a0)	; continue moving blue streaks right for 12 frames
		move.b	#1,ost_sonicsega_wait_time(a0)
		move.b	#-1,ost_sonicsega_streakcounter(a0)
		rts
; ===========================================================================

SonicSegaScreen_EndWipe:					; Routine 8
		tst.w	ost_sonicsega_frame_counter(a0)		; has frame counter reached 0?
		beq.s	.updatepalette				; if so, branch
		subq.w	#1,ost_sonicsega_frame_counter(a0)	; decrement counter
		bsr.w	SonicSegaScreen_MoveStreaksRight	; move blue streaks to the right

	.updatepalette:
		lea	Pal_SegaScreen3(pc),a1
		bsr.w	SonicSegaScreen_UpdateStreakPals
		bne.s	SonicSegaScreen_PlaySegaSound
		rts
; ===========================================================================

SonicSegaScreen_PlaySegaSound:
		addq.b	#2,ost_primary_routine(a0)
		st.b	(f_segascr_paldone).w
		move.b	#cmd_Sega,d0
		jsrto	PlaySound,JmpTo12_PlaySound

SonicSegaScreen_Done:						; Routine $A
		rts
; ===========================================================================
; ----------------------------------------------------------------------------
; Object B1 - Object that hides TM symbol on Japanese and Korean consoles
; ----------------------------------------------------------------------------

SegaHideTM:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	SegaHideTM_Index(pc,d0.w),d1
		jmp	SegaHideTM_Index(pc,d1.w)
; ===========================================================================
SegaHideTM_Index:	index offset(*),,2
		ptr SegaHideTM_Init				; 0
		ptr SegaHideTM_Display				; 2
; ===========================================================================

SegaHideTM_Init: ; Routine 0
		bsr.w	LoadSubObjData
		move.b	#id_Frame_HideTM,ost_frame(a0)
		move.w	#screen_left+244,ost_x_screen(a0)
		move.w	#screen_top+88,ost_y_screen(a0)
		rts
; ===========================================================================

SegaHideTM_Display:						; Routine 2
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================


SonicSegaScreen_MoveStreaksLeft:
		lea	(v_hscroll_buffer+(2*2*((9*8)+6))).w,a1
		move.w	#sizeof_Streak_Horizontal_Offsets-1,d6	; number of streaks-1

	.loop:
		subi.w	#$20,(a1)				; move 32 pixels left
		addq.w	#8,a1					; advance to next offset
		dbf	d6,.loop
		rts
; ===========================================================================

SonicSegaScreen_MoveStreaksRight:
		lea	(v_hscroll_buffer+(2*2*((9*8)+7))).w,a1
		move.w	#sizeof_Streak_Horizontal_Offsets-1,d6	; number of streaks-1

	.loop:
		addi.w	#$20,(a1)				; move 32 pixels right
		addq.w	#8,a1					; advance to next offset
		dbf	d6,.loop
		rts

; ----------------------------------------------------------------------------
; Subroutine to update the palette for the blue streaks.

; input:
;	a1 = start of palette info
;	uses d0.b, d1.b, d2.b, a1, a2, a3
; ----------------------------------------------------------------------------

SonicSegaScreen_UpdateStreakPals:
		subq.b	#1,ost_sonicsega_wait_time(a0)		; decrement frame counter
		bne.s	.do_nothing				; if not zero, branch
		moveq	#0,d0
		move.b	ost_sonicsega_streakcounter(a0),d0	; number of times the palette update has been run
		addq.b	#1,d0					; increment counter
		cmp.b	1(a1),d0				; have we run the number of times specified? (7 by default)
		bcs.s	.updatepalette				; if so, branch
		tst.b	3(a1)					; ...why? this tests a hardcoded $FF to force the below branch to be taken
		bne.s	.palette_done				; these two instructions could simply be a bra.s instead

.updatepalette:
		move.b	d0,ost_sonicsega_streakcounter(a0)	; update counter
		_move.b	0(a1),ost_sonicsega_wait_time(a0)	; reset wait time
		lea	6(a1),a2				; start of the actual palette data
		moveq	#0,d1
		move.b	2(a1),d1				; number of colors to skip
		move.w	d1,d2
		tst.w	d0					; is this the first update?
		beq.s	.set_target				; if so, branch

	.calc_offset:
		subq.b	#1,d0					; decrement
		beq.s	.adjust_source				; if it has reached zero, branch
		add.w	d2,d1					; increase d1 by number of colors to skip
		bra.s	.calc_offset				; loop until d0 reaches zero to get source offset
; ===========================================================================

	.adjust_source:
		adda.w	d1,a2					; adjust start location of palette data to copy

	.set_target:
		movea.w	4(a1),a3				; location to write the palette data

	.loop:
		move.w	(a2)+,(a3)+				; copy new palette data
		subq.w	#2,d2
		bne.s	.loop

	.do_nothing:
		moveq	#0,d0					; set zero flag in CCR
		rts
; ===========================================================================

	.palette_done:
		moveq	#1,d0					; clear the zero flag in the CCR
		rts
; ===========================================================================
Pal_SegaScreen2:
		; some data describing how to use the following palette
		dc.b	4					; 0	; How many frames before each iteration
		dc.b	8-1					; 1	; How many iterations-1
		dc.b	8*2					; 2	; Number of colors * 2 to skip each iteration
		dc.b	$FF					; 3	; Hack to force a branch to .palette_done
		dc.w	v_pal_dry+$10				; 4	; First target palette entry

		incfile Pal_SegaScreen2_Colors

Pal_SegaScreen3:
		; some data describing how to use the following palette
		dc.b	4					; 0	; How many frames before each iteration
		dc.b	8-1					; 1	; How many iterations
		dc.b	8*2					; 2	; Number of colors * 2 to skip each iteration
		dc.b	$FF					; 3	; Hack to force a branch to .palette_done
		dc.w	v_pal_dry				; 4	; First target palette entry

		incfile Pal_SegaScreen3_Colors


SubData_SonicSega:
		subobjdata	Map_SegaScreenSonic,(vram_Giant_Sonic/sizeof_cell)+tile_pal3+tile_hi,0,1,$20/2,id_col_null

SubData_SegaHideTM:
		subobjdata	Map_SegaScreenSonic,(vram_SEGA/sizeof_cell)+2,0,2,$10/2,id_col_null

Ani_SonicSegaScreen:	index offset(*)
		ptr Ani_SonicSega_0

Ani_SonicSega_0:
		dc.b 0
		dc.b id_Frame_Sonic_Run11-id_Frame_Sonic_Run11	; 0
		dc.b id_Frame_Sonic_Run12-id_Frame_Sonic_Run11	; 1
		dc.b id_Frame_Sonic_Run13-id_Frame_Sonic_Run11	; 2
		dc.b id_Frame_Sonic_Run14-id_Frame_Sonic_Run11	; 3
		dc.b afEnd

 		include "mappings/sprite/SegaScreenSonic.asm"
; ===========================================================================

SegaScreen_VBlank:
		move.w	(v_segascr_vblank_sub).w,d0		; get VBlank subroutine
		beq.w	TRider_SharedRTS			; if it's 0, nothing to do
		clr.w	(v_segascr_vblank_sub).w
		move.w	SegaScreen_VBlank_Index-2(pc,d0.w),d0
		jmp	SegaScreen_VBlank_Index(pc,d0.w)
; ===========================================================================
SegaScreen_VBlank_Index:	index offset(*),2,2
		ptr SegaScreen_VBlank_InitLeft			; 2	; DMA the upscaled Sonic sprites and upload the FG table entries for the streaks when Sonic runs left
		ptr	SegaScreen_VBlank_InitRight		; 4	; upload the FG table entries for the streaks when Sonic runs right
; ===========================================================================

SegaScreen_VBlank_InitLeft:
		dma	SonicSegaScreen_ScaledSpriteDataStart,sizeof_SonicSegaScreen_ScaledSpriteData,vram_Giant_Sonic
		lea	SonicSegaScreen_StreakFadeRight(pc),a1
		vdp_comm.l	move,(vram_sega_fg+((sizeof_vram_row_128*9)+(2*$28))),vram,write,d0 ; set VDP to VRAM write starting at $C590 (line 9, column $28)
		bra.w	SegaScreen_VBlank_SetFGTable
; ===========================================================================

SegaScreen_VBlank_InitRight:
		dma_fill	0,sizeof_vram_planetable_128x32,vram_sega_fg
		lea	SonicSegaScreen_StreakFadeLeft(pc),a1
		vdp_comm.l	move,(vram_sega_fg+((sizeof_vram_row_128*9)+(2*$50))),vram,write,d0 ; set VDP to VRAM write starting at $C9A0 (line 9, column $50)
		bra.w	SegaScreen_VBlank_SetFGTable		; pointless (possibly the result of copying and pasting code)

SegaScreen_VBlank_SetFGTable:
		lea	(vdp_data_port).l,a6
		move.l	#sizeof_vram_row_128<<16,d6		; write $30 entries for each line, leaving $50 untouched.
		moveq	#8-1,d1					; run inner loop 8 tines
		moveq	#10-1,d2				; run outer loop 10 times

	.outerloop:
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; set write address (this could have just used (a5), as that still has the control port in it from the dma_fill)
		move.w	d1,d3					; reset inner loop counter
		movea.l	a1,a2					; reset data pointer

	.innerloop:
		move.w	(a2)+,d4				; get one name table entry
		bclr	#$A,d4					; is this the end of the line?
		beq.s	.write_entry				; branch if not
		bsr.w	.write_end_of_line			; fill rest of line with this set of pixels (could be bsr.s)

	.write_entry:
		move.w	d4,(a6)					; write nametable entry
		dbf	d3,.innerloop				; repeat 7 times
		add.l	d6,d0					; set next VRAM address
		dbf	d2,.outerloop				; repeat 10 times
		rts
; ===========================================================================

.write_end_of_line:
		moveq	#$2A-1-1,d5				; minus 1 for loop counter, minus 1 for write in .write_entry

	.loop:
		move.w	d4,(a6)					; write this entry $29 times
		dbf	d5,.loop
		rts

; ----------------------------------------------------------------------------
; FG nametable entries for the blue streaks
; ----------------------------------------------------------------------------

SonicSegaScreen_StreakFadeRight:
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi	; 0
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+1	; 2
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+2	; 4
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+3	; 6
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+4	; 8
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+5	; 10
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+6	; 12
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+7+(1<<$A) ; 14 ; bit $A is a flag to use this entry $29 times

SonicSegaScreen_StreakFadeLeft:
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+7+(1<<$A) ; 0  ; same deal with bit $A
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+6	; 2
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+5	; 4
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+4	; 6
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+3	; 8
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+2	; 10
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi+1	; 12
		dc.w tile_Nem_IntroTrails+tile_pal2+tile_hi	; 14

Streak_Horizontal_Offsets:
		dc.b $12					; 0
		dc.b   4					; 1
		dc.b   4					; 2
		dc.b   2					; 3
		dc.b   2					; 4
		dc.b   2					; 5
		dc.b   2					; 6
		dc.b   0					; 7
		dc.b   0					; 8
		dc.b   0					; 9
		dc.b   0					; 10
		dc.b   0					; 11
		dc.b   0					; 12
		dc.b   0					; 13
		dc.b   0					; 14
		dc.b   4					; 15
		dc.b   4					; 16
		dc.b   6					; 17
		dc.b  $A					; 18
		dc.b   8					; 19
		dc.b   6					; 20
		dc.b   4					; 21
		dc.b   4					; 22
		dc.b   4					; 23
		dc.b   4					; 24
		dc.b   6					; 25
		dc.b   6					; 26
		dc.b   8					; 27
		dc.b   8					; 28
		dc.b  $A					; 29
		dc.b  $A					; 30
		dc.b  $C					; 31
		dc.b  $E					; 32
		dc.b $10					; 33
		dc.b $16					; 34
		arraysize	Streak_Horizontal_Offsets
		even

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B2 - The Tornado (Tails' plane)
; ----------------------------------------------------------------------------

Tornado:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3A79E(pc,d0.w),d1
		jmp	off_3A79E(pc,d1.w)
; ===========================================================================
off_3A79E:	index offset(*),,2
		ptr loc_3A7AE					; 0
		ptr loc_3A7DE					; 2
		ptr loc_3A89A					; 4
		ptr loc_3A954					; 6
		ptr loc_3AC6A					; 8
		ptr loc_3AD0C					; $A
		ptr loc_3AD2A					; $C
		ptr loc_3AD42					; $E
; ===========================================================================

loc_3A7AE:
		bsr.w	LoadSubObjData
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		subi.b	#$4E,d0
		move.b	d0,ost_primary_routine(a0)
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_3A7DA
		cmpi.b	#8,d0
		bcc.s	loc_3A7DA
		move.b	#4,ost_frame(a0)
		move.b	#1,ost_anim(a0)

loc_3A7DA:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3A7DE:
		bsr.w	loc_3AF58
		tst.w	(v_debug_active).w
		bne.w	loc_3A880
		lea	($FFFFB000).w,a1
		move.w	ost_tile(a1),d0
		andi.w	#-$8000,d0
		move.w	ost_tile(a0),d1
		andi.w	#$7FFF,d1
		or.w	d0,d1
		move.w	d1,ost_tile(a0)
		move.w	ost_x_pos(a0),-(sp)
		bsr.w	loc_3ADAA
		move.b	ost_primary_status(a0),$2E(a0)
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo27_SolidObject
		bsr.w	loc_3AE3A
		move.b	$2E(a0),d0
		move.b	ost_primary_status(a0),d1
		andi.b	#8,d0
		andi.b	#8,d1
		eor.b	d0,d1
		move.b	d1,$2E(a0)
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a1),d1
		move.w	(v_camera_x_pos).w,d0
		move.w	d0,(v_boundary_left).w
		move.w	d0,d2
		addi.w	#$11,d2
		cmp.w	d2,d1
		bhi.s	loc_3A85E
		addq.w	#1,d1
		move.w	d1,ost_x_pos(a1)

loc_3A85E:
		cmpi.w	#$1400,d0
		bcs.s	loc_3A878
		cmpi.w	#$1568,d1
		bcc.s	loc_3A88E
		st.b	(f_lock_controls).w
		move.w	#$808,(v_joypad_hold).w
		bra.w	loc_3A87C
; ===========================================================================

loc_3A878:
		subi.w	#$40,d0

loc_3A87C:
		move.w	d0,(v_boundary_right).w

loc_3A880:
		lea	(Ani_3AFDC).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3A88E:
		bsr.w	loc_3AC46
		move.w	#id_WFZ_act1,(v_zone).w
		bra.s	loc_3A880
; ===========================================================================

loc_3A89A:
		bsr.w	loc_3AF58
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3A8BA(pc,d0.w),d1
		jsr	off_3A8BA(pc,d1.w)
		lea	(Ani_3AFDC).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		bra.w	DeleteOffScreen
; ===========================================================================
off_3A8BA:	index offset(*),,2
		ptr loc_3A8C2					; 0
		ptr loc_3A8D4					; 2
		ptr loc_3A91A					; 4
		ptr loc_3A94E					; 6
; ===========================================================================

loc_3A8C2:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$C0,$32(a0)
		move.w	#$100,ost_x_vel(a0)
		rts
; ===========================================================================

loc_3A8D4:
		subq.w	#1,$32(a0)
		bmi.s	loc_3A8FC
		move.w	ost_x_pos(a0),-(sp)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	AdjustPosSCZ
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	(sp)+,d4
		jsrto	SolidObject,JmpTo27_SolidObject
		bra.w	loc_3AEEC
; ===========================================================================

loc_3A8FC:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$60,$2A(a0)
		move.w	#1,$32(a0)
		move.w	#$100,ost_x_vel(a0)
		move.w	#$100,ost_y_vel(a0)
		rts
; ===========================================================================

loc_3A91A:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_3A92A
		moveq_	sfx_Scatter,d0
		jsrto	PlaySound,JmpTo12_PlaySound

loc_3A92A:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3A946

loc_3A930:
		bsr.w	loc_3AD8C
		subq.w	#1,$32(a0)
		bne.w	TRider_SharedRTS
		move.w	#$E,$32(a0)
		bra.w	loc_3AF34
; ===========================================================================

loc_3A946:
		addq.b	#2,ost_secondary_routine(a0)
		bra.w	loc_3B7BC
; ===========================================================================

loc_3A94E:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bra.s	loc_3A930
; ===========================================================================

loc_3A954:
		bsr.w	loc_3AF58
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3A970(pc,d0.w),d1
		jsr	off_3A970(pc,d1.w)
		lea	(Ani_3AFDC).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================
off_3A970:	index offset(*),,2
		ptr loc_3A982					; 0
		ptr loc_3AA0E					; 2
		ptr loc_3AA4C					; 4
		ptr loc_3AA74					; 6
		ptr loc_3AAA8					; 8
		ptr loc_3AAFE					; $A
		ptr loc_3AB68					; $C
		ptr loc_3AB7C					; $E
		ptr loc_3ABDE					; $10
; ===========================================================================

loc_3A982:
		lea	($FFFFB000).w,a1
		cmpi.w	#$5EC,ost_y_pos(a1)
		bcs.s	locret_3A99E
		clr.w	(v_joypad_hold).w
		addq.w	#1,$2E(a0)
		cmpi.w	#$40,$2E(a0)
		bcc.s	loc_3A9A0

locret_3A99E:
		rts
; ===========================================================================

loc_3A9A0:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$2E58,ost_x_pos(a0)
		move.w	#$66C,ost_y_pos(a0)
		lea	($FFFFB000).w,a1
		bsr.w	loc_3AC56
		lea	(word_3AFBC).l,a2
		bsr.w	LoadChild
		move.w	#$3118,ost_x_pos(a1)
		move.w	#$3F0,ost_y_pos(a1)
		lea	(word_3AFB8).l,a2
		bsr.w	LoadChild
		move.w	#$3070,ost_x_pos(a1)
		move.w	#$3B0,ost_y_pos(a1)
		lea	(word_3AFB8).l,a2
		bsr.w	LoadChild
		move.w	#$3070,ost_x_pos(a1)
		move.w	#$430,ost_y_pos(a1)
		lea	(word_3AFC0).l,a2
		bsr.w	LoadChild
		clr.w	ost_x_pos(a1)
		clr.w	ost_y_pos(a1)
		rts
; ===========================================================================

loc_3AA0E:
		lea	($FFFFB000).w,a1
		cmpi.w	#$2E30,ost_x_pos(a1)
		bcc.s	loc_3AA22
		move.w	#$808,(v_joypad_hold).w
		rts
; ===========================================================================

loc_3AA22:
		addq.b	#2,ost_secondary_routine(a0)
		clr.w	(v_joypad_hold).w
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		clr.w	ost_inertia(a1)
		move.w	#$600,(v_sonic_max_speed).w
		move.w	#$C,(v_sonic_acceleration).w
		move.w	#$80,(v_sonic_deceleration).w
		bra.w	loc_3AC56
; ===========================================================================

loc_3AA4C:
		cmpi.w	#$380,(v_camera_x_pos_offset).w
		bcc.s	loc_3AA5C
		clr.w	(v_joypad_hold).w
		bra.w	loc_3AC56
; ===========================================================================

loc_3AA5C:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$100,ost_x_vel(a0)
		move.w	#-$100,ost_y_vel(a0)
		clr.w	$2A(a0)
		bra.w	loc_3AC56
; ===========================================================================

loc_3AA74:
		bsr.w	loc_3AC56
		addq.w	#1,$2A(a0)
		cmpi.w	#$30,$2A(a0)
		bne.s	loc_3AAA0
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$4040,(v_joypad_hold).w
		move.w	#$38,$2E(a0)
		tst.b	(f_super).w
		beq.s	loc_3AAA0
		move.w	#$28,$2E(a0)

loc_3AAA0:
		bsr.w	loc_3AD8C
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3AAA8:
		clr.w	(v_joypad_hold).w
		addq.w	#1,$2A(a0)
		subq.w	#1,$2E(a0)
		bmi.s	loc_3AABC
		move.w	#$4848,(v_joypad_hold).w

loc_3AABC:
		bsr.w	loc_3AD8C
		btst	#3,ost_primary_status(a0)
		beq.s	loc_3AAFA
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$20,$2E(a0)
		lea	($FFFF80D2).w,a1
		move.l	#$501F0025,(a1)+
		lea	($FFFF81D2).w,a1
		move.l	#$25001F50,(a1)+
		lea	($FFFF8BD6).w,a1
		move.l	#$501F0025,(a1)+
		lea	($FFFF8CD6).w,a1
		move.l	#$25001F50,(a1)+

loc_3AAFA:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3AAFE:
		addq.w	#1,$2A(a0)
		cmpi.w	#$100,$2A(a0)
		bcs.s	loc_3AB18
		addq.b	#2,ost_secondary_routine(a0)
		movea.w	$3A(a0),a1
		move.b	#2,ost_secondary_routine(a1)

loc_3AB18:
		clr.w	(v_joypad_hold).w
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		clr.w	ost_inertia(a1)
		bclr	#1,ost_primary_status(a1)
		bclr	#status_jump_bit,ost_primary_status(a1)
		move.l	#$1000505,ost_frame(a1)
		move.w	#$100,ost_anim_time(a1)
		move.b	#$13,ost_height(a1)
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_3AB60
		move.b	#$F,ost_height(a1)

loc_3AB60:
		bsr.w	loc_3AD8C
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3AB68:
		clr.w	(v_joypad_hold).w
		bsr.w	loc_3AC56
		cmpi.w	#$437,$2A(a0)
		bcs.s	loc_3AB8A
		addq.b	#2,ost_secondary_routine(a0)

loc_3AB7C:
		cmpi.w	#$447,$2A(a0)
		bcc.s	loc_3AB8A
		move.w	#$4040,(v_joypad_hold).w

loc_3AB8A:
		cmpi.w	#$460,$2A(a0)
		bcs.s	loc_3ABDE
		move.b	#6,(v_dle_routine).w
		addq.b	#2,ost_secondary_routine(a0)
		lea	(word_3AFB8).l,a2
		bsr.w	LoadChild
		move.w	#$3090,ost_x_pos(a1)
		move.w	#$3D0,ost_y_pos(a1)
		lea	(word_3AFB8).l,a2
		bsr.w	LoadChild
		move.w	#$30C0,ost_x_pos(a1)
		move.w	#$3F0,ost_y_pos(a1)
		lea	(word_3AFB8).l,a2
		bsr.w	LoadChild
		move.w	#$3090,ost_x_pos(a1)
		move.w	#$410,ost_y_pos(a1)

loc_3ABDE:
		cmpi.w	#$9C0,$2A(a0)
		bcc.s	loc_3AC40
		move.w	$2A(a0),d0
		addq.w	#1,d0
		move.w	d0,$2A(a0)
		move.w	$34(a0),d1
		move.w	word_3AC16(pc,d1.w),d2
		cmp.w	d2,d0
		bcs.s	loc_3AC0E
		addq.w	#2,d1
		move.w	d1,$34(a0)
		lea	byte_3AC2A(pc,d1.w),a1
		move.b	(a1)+,ost_x_vel(a0)
		move.b	(a1)+,ost_y_vel(a0)

loc_3AC0E:
		bsr.w	loc_3AD8C
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
word_3AC16:
		dc.w  $1E0					; 0
		dc.w  $260					; 1
		dc.w  $2A0					; 2
		dc.w  $2C0					; 3
		dc.w  $300					; 4
		dc.w  $3A0					; 5
		dc.w  $3F0					; 6
		dc.w  $460					; 7
		dc.w  $4A0					; 8
		dc.w  $580					; 9

byte_3AC2A:
		dc.b $FF					; 0
		dc.b $FF					; 1
		dc.b   1					; 2
		dc.b   0					; 3
		dc.b   0					; 4
		dc.b   1					; 5
		dc.b   1					; 6
		dc.b $FF					; 7
		dc.b   1					; 8
		dc.b   1					; 9
		dc.b   1					; 10
		dc.b $FF					; 11
		dc.b $FF					; 12
		dc.b   1					; 13
		dc.b $FF					; 14
		dc.b $FF					; 15
		dc.b $FF					; 16
		dc.b   1					; 17
		dc.b $FE					; 18
		dc.b   0					; 19
		dc.b   0					; 20
		dc.b   0					; 21
; ===========================================================================

loc_3AC40:
		move.w	#id_DEZ_act1,(v_zone).w

loc_3AC46:
		move.w	#1,(f_restart).w
		clr.b	(v_last_lamppost).w
		clr.b	(v_last_lamppost_p2).w
		rts
; ===========================================================================

loc_3AC56:
		lea	($FFFFB000).w,a1
		move.l	#$1000505,ost_frame(a1)
		move.w	#$100,ost_anim_time(a1)
		rts
; ===========================================================================

loc_3AC6A:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3AC78(pc,d0.w),d1
		jmp	off_3AC78(pc,d1.w)
; ===========================================================================
off_3AC78	index offset(*),,2
		ptr loc_3AC7E					; 0
		ptr loc_3AC84					; 2
		ptr loc_3ACF2					; 4
; ===========================================================================

loc_3AC7E:
		move.b	#id_col_6x6+id_col_custom,ost_col_type(a0)

loc_3AC84:
		tst.b	ost_col_property(a0)
		beq.s	locret_3ACF0
		addq.b	#2,ost_secondary_routine(a0)
		clr.b	ost_col_type(a0)
		move.w	#$78,(v_camera_y_shift).w
		movea.w	$2C(a0),a1
		bset	#status_underwater_bit,ost_primary_status(a1)
		lea	($FFFFB000).w,a1
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		move.w	ost_x_pos(a0),d0
		subi.w	#$10,d0
		move.w	d0,ost_x_pos(a1)
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_3ACC8
		subi.w	#$10,ost_y_pos(a1)

loc_3ACC8:
		bset	#status_xflip_bit,ost_primary_status(a1)
		bclr	#1,ost_primary_status(a1)
		bclr	#status_jump_bit,ost_primary_status(a1)
		move.b	#$11,ost_anim(a1)
		move.b	#1,($FFFFB02A).w
		move.b	#1,(f_wind_tunnel_disable).w
		clr.w	(v_joypad_hold).w

locret_3ACF0:
		rts
; ===========================================================================

loc_3ACF2:
		lea	($FFFFB000).w,a1
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		move.w	ost_x_pos(a0),d0
		subi.w	#$10,d0
		move.w	d0,ost_x_pos(a1)
		rts
; ===========================================================================

loc_3AD0C:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3AD1A(pc,d0.w),d1
		jmp	off_3AD1A(pc,d1.w)
; ===========================================================================
off_3AD1A:	index offset(*),,2
		ptr loc_3AD1C					; 0
; ===========================================================================

loc_3AD1C:
		bchg	#status_jump_bit,ost_primary_status(a0)
		bne.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3AD2A:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3AD38(pc,d0.w),d1
		jmp	off_3AD38(pc,d1.w)
; ===========================================================================
off_3AD38:	index offset(*),,2
		ptr loc_3AD3A
; ===========================================================================

loc_3AD3A:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3AD42:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3AD50(pc,d0.w),d1
		jmp	off_3AD50(pc,d1.w)
; ===========================================================================
off_3AD50:	index offset(*),,2
		ptr loc_3AD54					; 0
		ptr loc_3AD5C					; 2
; ===========================================================================

loc_3AD54:
		bsr.w	loc_3AD6E
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3AD5C:
		bsr.w	loc_3AD6E
		lea	(Ani_3AFEC).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3AD6E:
		movea.w	$2C(a0),a1
		move.w	ost_x_pos(a1),d0
		subi.w	#$C,d0
		move.w	d0,ost_x_pos(a0)
		move.w	ost_y_pos(a1),d0
		addi.w	#$28,d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================

loc_3AD8C:
		move.w	ost_x_pos(a0),-(sp)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	AdjustPosSCZ
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#9,d3
		move.w	(sp)+,d4
		jmpto	SolidObject,JmpTo27_SolidObject
; ===========================================================================

loc_3ADAA:
		lea	($FFFFB000).w,a1
		btst	#3,ost_primary_status(a1)
		beq.s	loc_3ADC6
		bsr.w	loc_3ADF6
		bsr.w	loc_3AF0C
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bra.w	AdjustPosSCZ
; ===========================================================================

loc_3ADC6:
		tst.b	$2E(a0)
		beq.s	loc_3ADD4
		bsr.w	FindPlayer
		move.w	d2,$38(a0)

loc_3ADD4:
		move.w	#1,d0
		move.w	$38(a0),d3
		beq.s	loc_3ADE8
		bmi.s	loc_3ADE2
		neg.w	d0

loc_3ADE2:
		add.w	d0,d3
		move.w	d3,$38(a0)

loc_3ADE8:
		move.w	ost_x_pos(a1),d1
		add.w	d3,d1
		move.w	d1,ost_x_pos(a0)
		bra.w	AdjustPosSCZ
; ===========================================================================

loc_3ADF6:
		tst.b	$2F(a0)
		bne.s	loc_3AE16
		tst.b	$2E(a0)
		beq.s	locret_3AE38
		st.b	$2F(a0)
		clr.b	$30(a0)
		move.w	#$200,ost_y_vel(a0)
		move.b	#$14,$31(a0)

loc_3AE16:
		subq.b	#1,$31(a0)
		bpl.s	loc_3AE26
		clr.b	$2F(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_3AE26:
		move.w	ost_y_vel(a0),d0
		cmpi.w	#-$100,d0
		ble.s	loc_3AE34
		addi.w	#-$20,d0

loc_3AE34:
		move.w	d0,ost_y_vel(a0)

locret_3AE38:
		rts
; ===========================================================================

loc_3AE3A:
		lea	($FFFFB000).w,a1
		btst	#3,ost_primary_status(a1)
		beq.s	loc_3AEA0
		tst.b	$2F(a0)
		bne.s	loc_3AE72
		clr.w	ost_y_vel(a0)
		move.w	(v_joypad_hold_actual).w,d2
		move.w	#$80,d3
		andi.w	#$300,d2
		beq.s	loc_3AE72
		andi.w	#$200,d2
		bne.s	loc_3AE66
		neg.w	d3

loc_3AE66:
		move.w	d3,ost_y_vel(a0)
		bsr.w	loc_3AF0C
		jsrto	SpeedToPos,JmpTo26_SpeedToPos

loc_3AE72:
		bsr.w	FindPlayer
		moveq	#$10,d3
		add.w	d3,d2
		cmpi.w	#$20,d2
		bcs.s	locret_3AE9E
		move.w	ost_inertia(a1),d2
		bpl.s	loc_3AE88
		neg.w	d2

loc_3AE88:
		cmpi.w	#$900,d2
		bcc.s	locret_3AE9E
		tst.w	d0
		beq.s	loc_3AE94
		neg.w	d3

loc_3AE94:
		move.w	ost_x_pos(a1),d1
		add.w	d3,d1
		move.w	d1,ost_x_pos(a0)

locret_3AE9E:
		rts
; ===========================================================================

loc_3AEA0:
		tst.b	$30(a0)
		bne.s	loc_3AEC0
		tst.b	$2E(a0)
		beq.s	locret_3AE9E
		st.b	$30(a0)
		clr.b	$2F(a0)
		move.w	#$200,ost_y_vel(a0)
		move.b	#$2B,$31(a0)

loc_3AEC0:
		subq.b	#1,$31(a0)
		bpl.s	loc_3AED0
		clr.b	$30(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_3AED0:
		move.w	ost_y_vel(a0),d0
		cmpi.w	#-$100,d0
		ble.s	loc_3AEDE
		addi.w	#-$20,d0

loc_3AEDE:
		move.w	d0,ost_y_vel(a0)
		bsr.w	loc_3AF0C
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		rts
; ===========================================================================

loc_3AEEC:
		bsr.w	FindPlayer
		moveq	#$10,d3
		add.w	d3,d2
		cmpi.w	#$20,d2
		bcs.s	locret_3AF0A
		tst.w	d0
		beq.s	loc_3AF00
		neg.w	d3

loc_3AF00:
		move.w	ost_x_pos(a0),d1
		sub.w	d3,d1
		move.w	d1,ost_x_pos(a1)

locret_3AF0A:
		rts
; ===========================================================================

loc_3AF0C:
		move.w	(v_camera_y_pos).w,d0
		move.w	ost_y_pos(a0),d1
		move.w	ost_y_vel(a0),d2
		beq.s	locret_3AF32
		bpl.s	loc_3AF26
		addi.w	#$34,d0
		cmp.w	d0,d1
		bcs.s	loc_3AF2E
		rts
; ===========================================================================

loc_3AF26:
		addi.w	#$A8,d0
		cmp.w	d0,d1
		bcs.s	locret_3AF32

loc_3AF2E:
		clr.w	ost_y_vel(a0)

locret_3AF32:
		rts
; ===========================================================================

loc_3AF34:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_3AF56
		_move.b	#id_TornadoSmoke_C4,ost_id(a1)		; load with duplicate pointer
		move.b	#$90,ost_subtype(a1)
		move.w	a0,$2C(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

locret_3AF56:
		rts
; ===========================================================================

loc_3AF58:
		subq.b	#1,$37(a0)
		bmi.s	loc_3AF60
		rts
; ===========================================================================

loc_3AF60:
		move.b	#8,$37(a0)
		moveq	#0,d0
		move.b	$36(a0),d0
		moveq	#$18,d1
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_3AF78
		moveq	#4,d1

loc_3AF78:
		addq.b	#1,d0
		cmp.w	d1,d0
		bcs.s	loc_3AF80
		moveq	#0,d0

loc_3AF80:
		move.b	d0,$36(a0)
		cmpi.w	#tails_alone,(v_player_mode).w
		bne.s	loc_3AF94
		move.b	byte_3AF9C(pc,d0.w),d0
		jmpto	Sonic_LoadGFX_2,JmpTo_Sonic_LoadGFX_2
; ===========================================================================

loc_3AF94:
		move.b	byte_3AFA0(pc,d0.w),d0
		jmpto	Tails_LoadGFX_2,JmpTo_Tails_LoadGFX_2
; ===========================================================================
byte_3AF9C:
		dc.b $2D					; 0
		dc.b $2E					; 1
		dc.b $2F					; 2
		dc.b $30					; 3

byte_3AFA0:
		dc.b $10					; 0
		dc.b $10					; 1
		dc.b $10					; 2
		dc.b $10					; 3
		dc.b   1					; 4
		dc.b   2					; 5
		dc.b   3					; 6
		dc.b   2					; 7
		dc.b   1					; 8
		dc.b   1					; 9
		dc.b $10					; 10
		dc.b $10					; 11
		dc.b $10					; 12
		dc.b $10					; 13
		dc.b   1					; 14
		dc.b   2					; 15
		dc.b   3					; 16
		dc.b   2					; 17
		dc.b   1					; 18
		dc.b   1					; 19
		dc.b   4					; 20
		dc.b   4					; 21
		dc.b   1					; 22
		dc.b   1					; 23

word_3AFB8:
		dc.w $3E
		dc.b id_Tornado
		dc.b $58

word_3AFBC:
		dc.w $3C
		dc.b id_Tornado
		dc.b $56

word_3AFC0:
		dc.w $3A
		dc.b id_Tornado
		dc.b $5C

		; Unused
		dc.w $3E
		dc.b id_Tornado
		dc.b $5A

off_3AFC8:
		dc.l Map_Tornado
		dc.w $8500
		dc.w $404
		dc.w $6000

off_3AFD2:
		dc.l Map_TornadoBooster
		dc.w $561
		dc.w $403
		dc.w $4000

Ani_3AFDC:	index offset(*)
		ptr Ani_3AFE0					; 0
		ptr Ani_3AFE6					; 1

Ani_3AFE0:
		dc.b   0,  0,  1,  2,  3,$FF
		even

Ani_3AFE6:
		dc.b   0,  4,  5,  6,  7,$FF
		even

Ani_3AFEC:	index offset(*)
		ptr byte_3AFEE

byte_3AFEE:
		dc.b   0,  1,  2,$FF
		even

; ===========================================================================

		include "mappings/sprite/Tornado.asm"
		include "mappings/sprite/Tornado Booster.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B3 - Clouds (placeable object) in SCZ
; ----------------------------------------------------------------------------

Cloud:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Cloud_Index(pc,d0.w),d1
		jmp	Cloud_Index(pc,d1.w)
; ===========================================================================
Cloud_Index:	index offset(*),,2
		ptr loc_3B2F0					; 0
		ptr loc_3B312					; 2
; ===========================================================================

loc_3B2F0:
		bsr.w	LoadSubObjData
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		subi.b	#$5E,d0

loc_3B2FE:
		move.w	word_3B30C(pc,d0.w),ost_x_vel(a0)
		lsr.w	#1,d0
		move.b	d0,ost_frame(a0)
		rts
; ===========================================================================
word_3B30C:
		dc.w  -$80
		dc.w  -$40
		dc.w  -$20
; ===========================================================================

loc_3B312:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		move.w	(v_tornado_x_vel).w,d0
		add.w	d0,ost_x_pos(a0)
		bra.w	DeleteBehindScreen
; ===========================================================================

SubData_Cloud:
		dc.l Map_Cloud
		dc.w $454F
		dc.w $406
		dc.w $3000
; ===========================================================================

		include "mappings/sprite/SCZ Clouds.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B4 - WFZ vertical propeller
; ----------------------------------------------------------------------------

VerticalPropeller:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	VertProp_Index(pc,d0.w),d1
		jmp	VertProp_Index(pc,d1.w)
; ===========================================================================
VertProp_Index:	index offset(*),,2
		ptr VertProp_Init				; 0
		ptr VertProp_Main				; 2
; ===========================================================================

VertProp_Init: ; Routine 0
		bsr.w	LoadSubObjData				; go to VertProp_Main next
		bclr	#render_yflip_bit,ost_render(a0)	; y-flip bit indicates whether or not collision should be enabled
		beq.s	.collision_enabled			; branch if y-flip bit is not set
		clr.b	ost_col_type(a0)			; clear collision

	.collision_enabled:
		rts
; ===========================================================================

VertProp_Main: ; Routine 2
		lea	(Ani_VertProp).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		move.b	(v_vblank_counter_byte).w,d0		; get byte that increments every frame
		andi.b	#$1F,d0
		bne.s	.skip_sound				; branch if current frame is not multiple of 32
		moveq_	sfx_Helicopter,d0			; play helicopter SFX every 32nd frame
		jsrto	PlaySoundLocal,JmpTo_PlaySoundLocal

	.skip_sound:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

SubData_VertProp:
		subobjdata	Map_VertProp,tile_Nem_VertProp+tile_pal2+tile_hi,render_rel,4,8/2,id_col_4x64|id_col_hurt

Ani_VertProp:	index offset(*)
		ptr Ani_VertProp_Spin

Ani_VertProp_Spin:
		dc.b 1
		dc.b id_Frame_VertProp1
		dc.b id_Frame_VertProp2
		dc.b id_Frame_VertProp3
		dc.b afEnd
		even
; ===========================================================================

		include "mappings/sprite/SCZ & WFZ Vertical Propellers.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B5 - WFZ horizontal propeller
; ----------------------------------------------------------------------------

HorizontalPropeller:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	HorizProp_Index(pc,d0.w),d1
		jmp	HorizProp_Index(pc,d1.w)
; ===========================================================================
HorizProp_Index:	index offset(*),,2
		ptr HorizProp_Init				; 0
		ptr HorizProp_WFZ				; 2
		ptr HorizProp_SCZ				; 4
; ===========================================================================

HorizProp_Init:
		bsr.w	LoadSubObjData
		move.b	#4,ost_anim(a0)
		move.b	ost_subdata_ptr(a0),d0			; subdata pointer indicates subtype
		subi.b	#id_SubData_HorizProp_WFZ-2,d0		; minus $64 to get routine for subtype
		move.b	d0,ost_primary_routine(a0)		; set routine
		rts
; ===========================================================================

HorizProp_WFZ:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0		; this is always 0
		move.w	.index(pc,d0.w),d1
		jsr	.index(pc,d1.w)
		lea	(Ani_HorizProp).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

.index:	index offset(*),,2
		ptr loc_3B444
; ===========================================================================

loc_3B444:
		bra.w	loc_3B456
; ===========================================================================

HorizProp_SCZ:
		lea	(Ani_HorizProp).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3B456:
		cmpi.b	#4,ost_anim(a0)
		bne.s	locret_3B4DC
		lea	(v_ost_player1).w,a1
		bsr.w	loc_3B46A
		lea	(v_ost_player2).w,a1

loc_3B46A:
		move.w	ost_x_pos(a1),d0
		sub.w	ost_x_pos(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$80,d0
		bcc.s	locret_3B4DC
		moveq	#0,d1
		move.b	(v_oscillating_0_to_10).w,d1
		add.w	ost_y_pos(a1),d1
		addi.w	#$60,d1
		sub.w	ost_y_pos(a0),d1
		bcs.s	locret_3B4DC
		cmpi.w	#$90,d1
		bcc.s	locret_3B4DC
		subi.w	#$60,d1
		bcs.s	loc_3B4A0
		not.w	d1
		add.w	d1,d1

loc_3B4A0:
		addi.w	#$60,d1
		neg.w	d1
		asr.w	#4,d1
		add.w	d1,ost_y_pos(a1)
		bset	#1,ost_primary_status(a1)
		move.w	#0,ost_y_vel(a1)
		move.w	#1,ost_inertia(a1)
		tst.b	ost_flip_angle(a1)
		bne.s	locret_3B4DC
		move.b	#1,ost_flip_angle(a1)
		move.b	#$F,ost_anim(a1)
		move.b	#$7F,$2C(a1)
		move.b	#8,$2D(a1)

locret_3B4DC:
		rts
; ===========================================================================
SubData_HorizProp:
		dc.l Map_HorizProp
		dc.w $A3CD
		dc.w $404
		dc.w $4000

Ani_HorizProp:	index offset(*)
		ptr byte_3B4FC					; 0
		ptr byte_3B506					; 1
		ptr byte_3B50E					; 2
		ptr byte_3B516					; 3
		ptr byte_3B51C					; 4
		ptr byte_3B524					; 5
		ptr byte_3B52A					; 6
		ptr byte_3B532					; 7
		ptr byte_3B53A					; 8
		ptr byte_3B544					; 9

byte_3B4FC:	dc.b   7,  0,  1,  2,  3,  4,  5,$FD,  1,  0	; 0
byte_3B506:	dc.b   4,  0,  1,  2,  3,  4,$FD,  2		; 0
byte_3B50E:	dc.b   3,  5,  0,  1,  2,$FD,  3,  0		; 0
byte_3B516:	dc.b   2,  3,  4,  5,$FD,  4			; 0
byte_3B51C:	dc.b   1,  0,  1,  2,  3,  4,  5,$FF		; 0
byte_3B524:	dc.b   2,  5,  4,  3,$FD,  6			; 0
byte_3B52A:	dc.b   3,  2,  1,  0,  5,$FD,  7,  0		; 0
byte_3B532:	dc.b   4,  4,  3,  2,  1,  0,$FD,  8		; 0
byte_3B53A:	dc.b   7,  5,  4,  3,  2,  1,  0,$FD,  9,  0	; 0
byte_3B544:	dc.b $7E,  0,$FF,  0				; 0
; ===========================================================================

		include	"mappings/sprite/SCZ & WFZ Horizontal Propellers.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B6 - WFZ tilting platform
; ----------------------------------------------------------------------------

TiltingPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TiltPlat_Index(pc,d0.w),d1
		jmp	TiltPlat_Index(pc,d1.w)
; ===========================================================================
TiltPlat_Index:	index offset(*),,2
		ptr loc_3B5E8					; 0
		ptr loc_3B602					; 2
		ptr loc_3B65C					; 4
		ptr loc_3B6C8					; 6
		ptr loc_3B73C					; *
; ===========================================================================

loc_3B5E8:
		moveq	#0,d0
		move.b	#$6A,d0
		bsr.w	LoadSubObjData2
		move.b	ost_subtype(a0),d0
		andi.b	#6,d0
		addq.b	#2,d0
		move.b	d0,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_3B602:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3B614(pc,d0.w),d1
		jsr	off_3B614(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3B614:	index offset(*),,2
		ptr loc_3B61C					; 0
		ptr loc_3B624					; 2
		ptr loc_3B644					; 4
		ptr loc_3B64E					; 6
; ===========================================================================

loc_3B61C:
		addq.b	#2,ost_secondary_routine(a0)
		bra.w	loc_3B77E
; ===========================================================================

loc_3B624:
		bsr.w	loc_3B790
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#-$10,d0
		cmp.b	ost_subtype(a0),d0
		beq.s	loc_3B638
		rts
; ===========================================================================

loc_3B638:
		addq.b	#2,ost_secondary_routine(a0)
		clr.b	ost_anim(a0)
		bra.w	loc_3B7BC
; ===========================================================================

loc_3B644:
		lea	(off_3B822).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_3B64E:
		move.b	#2,ost_secondary_routine(a0)
		move.w	#$C0,$2A(a0)
		rts
; ===========================================================================

loc_3B65C:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	word_3B66E(pc,d0.w),d1
		jsr	word_3B66E(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
word_3B66E:	index offset(*),,2
		ptr loc_3B61C
		ptr loc_3B674
		ptr loc_3B6A6
; ===========================================================================

loc_3B674:
		bsr.w	loc_3B790
		subq.w	#1,$2A(a0)
		bmi.s	loc_3B680
		rts
; ===========================================================================

loc_3B680:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$20,$2A(a0)
		move.b	#3,ost_anim(a0)
		clr.b	ost_anim_frame(a0)
		clr.b	ost_anim_time(a0)
		bsr.w	loc_3B7BC
		bsr.w	loc_3B7F8
		moveq	#-$24,d0
		jmpto	PlaySound,JmpTo12_PlaySound
; ===========================================================================

loc_3B6A6:
		subq.b	#1,$2A(a0)
		bmi.s	loc_3B6B6
		lea	(off_3B822).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_3B6B6:
		move.b	#2,ost_secondary_routine(a0)
		clr.b	ost_frame(a0)
		move.w	#$C0,$2A(a0)
		rts
; ===========================================================================

loc_3B6C8:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3B6DA(pc,d0.w),d1

loc_3B6D2:
		jsr	off_3B6DA(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3B6DA:	index offset(*),,2
		ptr loc_3B6E2					; 0
		ptr loc_3B6FE					; 2
		ptr loc_3B72C					; 4
		ptr loc_3B736					; 6
; ===========================================================================

loc_3B6E2:
		bsr.w	loc_3B790
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		bne.s	loc_3B6F2
		rts
; ===========================================================================

loc_3B6F2:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$10,$2A(a0)
		rts
; ===========================================================================

loc_3B6FE:
		bsr.w	loc_3B790
		subq.w	#1,$2A(a0)
		bmi.s	loc_3B70A
		rts
; ===========================================================================

loc_3B70A:
		addq.b	#2,ost_secondary_routine(a0)

loc_3B70E:
		move.b	#0,ost_anim(a0)
		bsr.w	FindPlayer

loc_3B718:
		bclr	#status_xflip_bit,ost_primary_status(a0)
		tst.w	d0
		bne.s	loc_3B728
		bset	#status_xflip_bit,ost_primary_status(a0)

loc_3B728:
		bra.w	loc_3B7BC
; ===========================================================================

loc_3B72C:
		lea	(off_3B822).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_3B736:
		clr.b	ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_3B73C:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3B74E(pc,d0.w),d1
		jsr	off_3B74E(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3B74E:	index offset(*),,2
		ptr loc_3B756
		ptr loc_3B764
		ptr loc_3B644
		ptr loc_3B64E
; ===========================================================================

loc_3B756:
		addq.b	#2,ost_secondary_routine(a0)

loc_3B75A:
		move.b	#2,ost_frame(a0)
		bra.w	loc_3B77E
; ===========================================================================

loc_3B764:
		bsr.w	loc_3B7A6
		subq.w	#1,$2A(a0)
		bmi.s	loc_3B770
		rts
; ===========================================================================

loc_3B770:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#4,ost_anim(a0)
		bra.w	loc_3B7BC
; ===========================================================================

loc_3B77E:
		move.b	ost_subtype(a0),d0
		andi.w	#$F0,d0
		move.b	d0,ost_subtype(a0)
		move.w	d0,$2A(a0)
		rts
; ===========================================================================

loc_3B790:
		move.w	ost_x_pos(a0),-(sp)
		move.w	#$23,d1
		move.w	#4,d2
		move.w	#4,d3
		move.w	(sp)+,d4
		jmpto	SolidObject,JmpTo27_SolidObject
; ===========================================================================

loc_3B7A6:
		move.w	ost_x_pos(a0),-(sp)
		move.w	#$F,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	(sp)+,d4
		jmpto	SolidObject,JmpTo27_SolidObject
; ===========================================================================

loc_3B7BC:
		move.b	ost_primary_status(a0),d0
	if (Revision<2)|FixBugs
		andi.b	#status_platform_both,d0
	else
		; I don't know what this change was meant to do, but it causes
		; Sonic/Tails to not fall off WFZ's ascending platforms when they retract,
		; making him hover.
		andi.b	#status_air,d0
	endc
		beq.s	locret_3B7F6
		bclr	#3,ost_primary_status(a0)
		beq.s	loc_3B7DE
		lea	(v_ost_player1).w,a1
		bclr	#3,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)

loc_3B7DE:
		bclr	#4,ost_primary_status(a0)
		beq.s	locret_3B7F6
		lea	(v_ost_player2).w,a1
		bclr	#4,ost_primary_status(a1)
		bset	#1,ost_primary_status(a1)

locret_3B7F6:
		rts
; ===========================================================================

loc_3B7F8:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_3B816
		_move.b	#id_VerticalLaser,ost_id(a1)
		move.b	#$72,ost_subtype(a1)

loc_3B80A:
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)

locret_3B816:
		rts
; ===========================================================================
off_3B818:
		dc.l Map_TiltPlat
		dc.w $A393
		dc.w $404
		dc.w $1000

off_3B822:	index offset(*)
		ptr byte_3B830					; 0
		ptr byte_3B836					; 1
		ptr byte_3B83A					; 2
		ptr byte_3B840					; 3
		ptr byte_3B846					; 4
		ptr byte_3B84C					; 5
		ptr byte_3B850					; 6

byte_3B830:
		dc.b 3
		dc.b id_Frame_TlitPlat_RightDown
		dc.b id_Frame_TlitPlat_Vert
		dc.b afChange,1
		even

byte_3B836:
		dc.b $3F
		dc.b id_Frame_TlitPlat_Vert
		dc.b afChange,2
		even

byte_3B83A:
		dc.b 3
		dc.b id_Frame_TlitPlat_Vert
		dc.b id_Frame_TlitPlat_RightDown
		dc.b id_Frame_TlitPlat_Horiz
		dc.b af2ndRoutine
		even

byte_3B840:
		dc.b 1
		dc.b id_Frame_TlitPlat_Horiz
		dc.b id_Frame_TlitPlat_RightDown
		dc.b id_Frame_TlitPlat_Vert
		dc.b id_Frame_TlitPlat_LeftDown
		dc.b afEnd

byte_3B846:
		dc.b 3
		dc.b id_Frame_TlitPlat_RightDown
		dc.b id_Frame_TlitPlat_Horiz
		dc.b afChange,5
		even

byte_3B84C:
		dc.b $3F
		dc.b id_Frame_TlitPlat_Horiz
		dc.b afchange,6

byte_3B850:
		dc.b 3
		dc.b id_Frame_TlitPlat_Horiz
		dc.b id_Frame_TlitPlat_RightDown
		dc.b id_Frame_TlitPlat_Vert
		dc.b af2ndRoutine
		even
; ===========================================================================

		include "mappings/sprite/WFZ Tilting Platform.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B7 - WFZ giant vertical laser  (unused)
; ----------------------------------------------------------------------------

VerticalLaser:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3B8B4(pc,d0.w),d1
		jmp	off_3B8B4(pc,d1.w)
; ===========================================================================
off_3B8B4:	index offset(*),,2
		ptr loc_3B8B8					; 0
		ptr loc_3B8C4					; 2
; ===========================================================================

loc_3B8B8:
		bsr.w	LoadSubObjData
		move.b	#$20,$2A(a0)
		rts
; ===========================================================================

loc_3B8C4:
		subq.b	#1,$2A(a0)
		beq.w	JmpTo65_DeleteObject
		bchg	#0,$2B(a0)
		beq.w	TRider_SharedRTS
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3B8DA:
		dc.l Map_VertLaser
		dc.w $C39F
		dc.w $404
		dc.w $18A9

; ===========================================================================

		include "mappings/sprite/WFZ Giant Vertical Laser (unused).asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B8 - WFZ wall turret
; ----------------------------------------------------------------------------

WallTurret:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	WallTurr_Index(pc,d0.w),d1
		jmp	WallTurr_Index(pc,d1.w)
; ===========================================================================
WallTurr_Index:	index offset(*),,2
		ptr loc_3B97C					; 0
		ptr loc_3B980					; 2
		ptr loc_3B9AA					; 4
; ===========================================================================

loc_3B97C:
		bra.w	LoadSubObjData
; ===========================================================================

loc_3B980:
		tst.b	ost_render(a0)
		bpl.s	loc_3B998
		bsr.w	FindPlayer
		tst.w	d1
		beq.s	loc_3B998
		addi.w	#$60,d2
		cmpi.w	#$C0,d2
		bcs.s	loc_3B99C

loc_3B998:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3B99C:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#2,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3B9AA:
		bsr.w	FindPlayer
		moveq	#0,d6
		addi.w	#$20,d2
		cmpi.w	#$40,d2
		bcs.s	loc_3B9C0
		move.w	d0,d6
		lsr.w	#1,d6
		addq.w	#1,d6

loc_3B9C0:
		move.b	d6,ost_frame(a0)
		subq.w	#1,$2A(a0)
		bne.s	loc_3B9D4
		move.w	#$60,$2A(a0)
		bsr.w	loc_3B9D8				; could be optimized to bsr.s

loc_3B9D4:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3B9D8:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_3BA28
		_move.b	#id_Projectile,ost_id(a1)
		move.b	#3,ost_frame(a1)
		move.b	#-$72,ost_subtype(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		lea_	loc_37756,a2
		move.l	a2,ost_proj_codeptr(a1)
		moveq	#0,d0
		move.b	ost_frame(a0),d0
		lsl.w	#2,d0
		lea	byte_3BA2A(pc,d0.w),a2
		move.b	(a2)+,d0
		ext.w	d0
		add.w	d0,ost_x_pos(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	d0,ost_y_pos(a1)
		move.b	(a2)+,ost_x_vel(a1)
		move.b	(a2)+,ost_y_vel(a1)

locret_3BA28:
		rts
; ===========================================================================

byte_3BA2A:
		dc.b   0					; 0
		dc.b $18					; 1
		dc.b   0					; 2
		dc.b   1					; 3
		dc.b $EF					; 4
		dc.b $10					; 5
		dc.b $FF					; 6
		dc.b   1					; 7
		dc.b $11					; 8
		dc.b $10					; 9
		dc.b   1					; 10
		dc.b   1					; 11

off_3BA36:
		dc.l Map_WallTurr
		dc.w $3AB
		dc.w $404
		dc.w $1000

off_3BA40:	index offset(*)
		ptr byte_3BA42

byte_3BA42:
		dc.b   2,  3,  4,$FF
		even
; ===========================================================================

		include "mappings/sprite/WFZ Wall Turret.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object B9 - Horizontal laser that shoots down the Tornado in WFZ
; ----------------------------------------------------------------------------

HorizontalLaser:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	HorizLaser_Index(pc,d0.w),d1
		jmp	HorizLaser_Index(pc,d1.w)
; ===========================================================================
HorizLaser_Index:	index offset(*),,2
		ptr loc_3BACE					; 0
		ptr loc_3BAD2					; 2
		ptr loc_3BAF0					; 4
; ===========================================================================

loc_3BACE:
		bra.w	LoadSubObjData
; ===========================================================================

loc_3BAD2:
		tst.b	ost_render(a0)
		bmi.s	loc_3BADC
		bra.w	loc_3BAF8
; ===========================================================================

loc_3BADC:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#-$1000,ost_x_vel(a0)
		moveq	#-$11,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		bra.w	loc_3BAF8
; ===========================================================================

loc_3BAF0:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bra.w	loc_3BAF8				; pointless

loc_3BAF8:
		move.w	ost_x_pos(a0),d0
		move.w	(v_camera_x_pos).w,d1
		subi.w	#$40,d1
		cmp.w	d1,d0
		blt.w	JmpTo65_DeleteObject
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
SubData_HorizLaser:
		dc.l Map_HorizLaser
		dc.w $C3C3
		dc.w $401
		dc.w $6000
; ===========================================================================

		include "mappings/sprite/WFZ Giant Horizontal Laser.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object BA - WFZ conveyer belt pulley
; ----------------------------------------------------------------------------

ConveyerPulley:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ConvPulley_Index(pc,d0.w),d1
		jmp	ConvPulley_Index(pc,d1.w)
; ===========================================================================
ConvPulley_Index:	index offset(*),,2
		ptr loc_3BB5E					; 0
		ptr loc_3BB62					; 2
; ===========================================================================

loc_3BB5E:
		bra.w	LoadSubObjData
; ===========================================================================

loc_3BB62:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

SubData_ConvPulley:
		dc.l Map_ConvPulley
		dc.w $C3EA
		dc.w $404
		dc.w $1000
; ===========================================================================

		include "mappings/sprite/WFZ Conveyer Belt Pulley.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object BB - WFZ stationary hook (unused)
; ----------------------------------------------------------------------------

StaticHook:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	StatHook_Index(pc,d0.w),d1
		jmp	StatHook_Index(pc,d1.w)
; ===========================================================================
StatHook_Index:	index offset(*),,2
		ptr StatHook_Init				; 0
		ptr StatHook_Display				; 2
; ===========================================================================

StatHook_Init:
		bra.w	LoadSubObjData				; goto StatHook_Display next
; ===========================================================================

StatHook_Display:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

SubData_StatHook:
		subobjdata	Map_StatHook,tile_Nem_Hook+tile_pal2,render_rel,4,$18/2,id_col_12x16
; ===========================================================================

		include "mappings/sprite/WFZ Stationary Hook (unused).asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object BC - Exhaust from Robotnik's getaway ship in WFZ
; ----------------------------------------------------------------------------

ShipExhaust:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ShipExh_Index(pc,d0.w),d1
		jmp	ShipExh_Index(pc,d1.w)
; ===========================================================================
ShipExh_Index:	index offset(*),,2
		ptr ShipExh_Init				; 0
		ptr ShipExh_Main				; 2
; ===========================================================================

ShipExh_Init:
		bsr.w	LoadSubObjData
		move.w	ost_x_pos(a0),$2C(a0)
		rts
; ===========================================================================

ShipExh_Main:
		move.w	$2C(a0),d0
		move.w	(v_camera_x_pos_offset).w,d1
		cmpi.w	#$380,d1
		bcc.w	JmpTo65_DeleteObject
		add.w	d1,d0
		move.w	d0,ost_x_pos(a0)
		bchg	#0,$2A(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
SubData_ShipExh:
		dc.l Map_ShipExh
		dc.w $4465
		dc.w $404
		dc.w $1000
; ===========================================================================

		include "mappings/sprite/WFZ Ship Exhaust.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object BD - WFZ ascending/descending metal platforms
; ----------------------------------------------------------------------------

ConveyerPlatforms:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	ConvPlat_Index(pc,d0.w),d1
		jmp	ConvPlat_Index(pc,d1.w)
; ===========================================================================
ConvPlat_Index:	index offset(*),,2
		ptr loc_3BC30					; 0
		ptr loc_3BC3C					; 2
		ptr loc_3BC50					; 4
; ===========================================================================

loc_3BC30:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#1,$2A(a0)
		rts
; ===========================================================================

loc_3BC3C:
		subq.w	#1,$2A(a0)
		bne.s	loc_3BC4C
		move.w	#$40,$2A(a0)
		bsr.w	loc_3BCF8

loc_3BC4C:
		jmpto	DespawnObject3,JmpTo8_DespawnObject3
; ===========================================================================

loc_3BC50:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3BC62(pc,d0.w),d1
		jsr	off_3BC62(pc,d1.w)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3BC62:	index offset(*),,2
		ptr loc_3BC6C					; 0
		ptr loc_3BCAC					; 2
		ptr loc_3BCB6					; 4
		ptr loc_3BCCC					; 6
		ptr loc_3BCD6					; 8
; ===========================================================================

loc_3BC6C:
		bsr.w	LoadSubObjData
		move.b	#2,ost_frame(a0)
		subq.b	#2,ost_primary_routine(a0)
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$C7,$2A(a0)
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3BC92
		move.w	#$1C7,$2A(a0)

loc_3BC92:
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		subi.b	#$7E,d0
		move.b	d0,ost_subtype(a0)
		move.w	word_3BCA8(pc,d0.w),ost_y_vel(a0)
		rts
; ===========================================================================
word_3BCA8:
		dc.w $FF00					; 0
		dc.w  $100					; 1
; ===========================================================================

loc_3BCAC:
		lea	(Ani_ConvPlat).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_3BCB6:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3BCC0
		bra.w	loc_3BCDE
; ===========================================================================

loc_3BCC0:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#1,ost_anim(a0)
		rts
; ===========================================================================

loc_3BCCC:
		lea	(Ani_ConvPlat).l,a1
		jmpto	AnimateSprite,JmpTo25_AnimateSprite
; ===========================================================================

loc_3BCD6:
		bsr.w	loc_3B7BC
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_3BCDE:
		move.w	ost_x_pos(a0),-(sp)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		move.w	#$23,d1
		move.w	#4,d2
		move.w	#5,d3
		move.w	(sp)+,d4
		jmpto	DetectPlatform,JmpTo9_DetectPlatform
; ===========================================================================

loc_3BCF8:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	locret_3BD22
		_move.b	#id_ConveyerPlatforms,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.b	#4,ost_primary_routine(a1)
		move.b	ost_subtype(a0),ost_subtype(a1)
		move.b	ost_render(a0),ost_render(a1)

locret_3BD22:
		rts
; ===========================================================================
SubData_ConvPlat:
		dc.l Map_ConvPlat
		dc.w $E40E
		dc.w $404
		dc.w $1800

Ani_ConvPlat:	index offset(*)
		ptr byte_3BD32					; 0
		ptr byte_3BD38					; 1

byte_3BD32:
		dc.b   3,  2,  1,  0,$FA
		even

byte_3BD38:
		dc.b   1,  0,  1,  2,$FA
		even
; ===========================================================================

		include "mappings/sprite/WFZ Conveyer Platforms.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object BE - WFZ lateral cannon (temporary platform that pops in/out)
; ----------------------------------------------------------------------------

GunPlatform:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	GunPlat_Index(pc,d0.w),d1
		jmp	GunPlat_Index(pc,d1.w)
; ===========================================================================
GunPlat_Index:	index offset(*),,2
		ptr loc_3BD94					; 0
		ptr loc_3BDA2					; 2
		ptr loc_3BDC6					; 4
		ptr loc_3BDD4					; 6
		ptr loc_3BDC6					; 8
		ptr loc_3BDF4					; $A
; ===========================================================================

loc_3BD94:
		moveq	#0,d0
		move.b	#-$7E,d0
		bsr.w	LoadSubObjData2
		bra.w	loc_3B77E
; ===========================================================================

loc_3BDA2:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#-$10,d0
		cmp.b	ost_subtype(a0),d0
		beq.s	loc_3BDB4
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3BDB4:
		addq.b	#2,ost_primary_routine(a0)
		clr.b	ost_anim(a0)
		move.w	#$A0,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3BDC6:
		lea	(Ani_GunPlat).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3BDD4:
		subq.w	#1,$2A(a0)
		beq.s	loc_3BDE2
		bsr.w	loc_3BE04
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3BDE2:
		addq.b	#2,ost_primary_routine(a0)
		move.b	#1,ost_anim(a0)
		bsr.w	loc_3B7BC
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3BDF4:
		move.b	#2,ost_primary_routine(a0)
		move.w	#$40,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3BE04:
		move.b	ost_frame(a0),d0
		cmpi.b	#3,d0
		beq.s	loc_3BE16
		cmpi.b	#4,d0
		bne.w	loc_3B7BC

loc_3BE16:
		move.w	ost_x_pos(a0),-(sp)
		move.w	#$23,d1
		move.w	#$18,d2
		move.w	#$19,d3
		move.w	(sp)+,d4
		jmpto	DetectPlatform,JmpTo9_DetectPlatform
; ===========================================================================
SubData_GunPlat:
		dc.l Map_GunPlat
		dc.w $E41A
		dc.w $404
		dc.w $1800

Ani_GunPlat:	index offset(*)
		ptr byte_3BE3A					; 0
		ptr byte_3BE40					; 1
byte_3BE3A:
		dc.b   5,  0,  1,  2,  3,$FC

byte_3BE40:
		dc.b   5,  3,  2,  1,  0,$FC
; ===========================================================================

		include "mappings/sprite/WFZ Gun Platform.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object BF - WFZ propeller shaft (unused)
; ----------------------------------------------------------------------------

PropellerShaft:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	PropShaft_Index(pc,d0.w),d1
		jmp	PropShaft_Index(pc,d1.w)
; ===========================================================================
PropShaft_Index:	index offset(*),,2
		ptr loc_3BEBC					; 0
		ptr loc_3BEC0					; 2
; ===========================================================================

loc_3BEBC:
		bra.w	LoadSubObjData
; ===========================================================================

loc_3BEC0:
		lea	(Ani_PropShaft).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
SubData_PropShaft:
		dc.l Map_PropShaft
		dc.w $E450
		dc.w $404
		dc.w $404

Ani_PropShaft:	index offset(*)
		ptr byte_3BEDA
byte_3BEDA:
		dc.b   1,  0,  1,  2,$FF
		even

; ===========================================================================

		include "mappings/sprite/WFZ Vertical Propeller Shaft (unused).asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C0 - WFZ catapult
; ----------------------------------------------------------------------------

Catapult:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	CPult_Index(pc,d0.w),d1
		jmp	CPult_Index(pc,d1.w)
; ===========================================================================
CPult_Index:	index offset(*),,2
		ptr loc_3BF16					; 0
		ptr loc_3BF3E					; 2
; ===========================================================================

loc_3BF16:
		move.w	#$86,d0
		bsr.w	LoadSubObjData2
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		lsl.w	#4,d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_3BF30
		neg.w	d0

loc_3BF30:
		move.w	ost_x_pos(a0),d1
		move.w	d1,$34(a0)
		add.w	d1,d0
		move.w	d0,$32(a0)

loc_3BF3E:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3BF60(pc,d0.w),d1
		jsr	off_3BF60(pc,d1.w)
		move.w	#$10,d1
		move.w	#$11,d3
		move.w	ost_x_pos(a0),d4
		jsrto	DetectPlatform,JmpTo9_DetectPlatform
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3BF60:	index offset(*),,2
		ptr loc_3BF66					; 0
		ptr loc_3BFD8					; 2
		ptr loc_3C062					; 4
; ===========================================================================

loc_3BF66:
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_3BFB2
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$C00,ost_x_vel(a0)
		move.w	#$80,$30(a0)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	loc_3BF90
		neg.w	ost_x_vel(a0)
		neg.w	$30(a0)

loc_3BF90:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		move.b	ost_primary_status(a0),d0
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_3BFA6
		lea	($FFFFB000).w,a1
		bsr.s	loc_3BFB4

loc_3BFA6:
		andi.b	#$10,d0
		beq.s	locret_3BFB2
		lea	($FFFFB040).w,a1
		bsr.s	loc_3BFB4

locret_3BFB2:
		rts
; ===========================================================================

loc_3BFB4:
		clr.w	ost_inertia(a1)
		clr.w	ost_x_vel(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		bclr	#status_xflip_bit,ost_primary_status(a1)
		btst	#status_xflip_bit,ost_primary_status(a0)
		bne.s	locret_3BFD6
		bset	#status_xflip_bit,ost_primary_status(a1)

locret_3BFD6:
		rts
; ===========================================================================

loc_3BFD8:
		move.w	$30(a0),d0
		add.w	d0,ost_x_vel(a0)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		move.w	$32(a0),d0
		sub.w	ost_x_pos(a0),d0
		btst	#status_xflip_bit,ost_primary_status(a0)
		beq.s	loc_3BFF6
		neg.w	d0

loc_3BFF6:
		tst.w	d0
		bpl.s	loc_3C034
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	locret_3C01E

loc_3C004:
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_3C012
		lea	($FFFFB000).w,a1
		bsr.s	loc_3BFB4

loc_3C012:
		andi.b	#$10,d0
		beq.s	locret_3C01E
		lea	($FFFFB040).w,a1
		bsr.s	loc_3BFB4

locret_3C01E:
		rts
; ===========================================================================

loc_3C020:
		move.w	ost_x_vel(a0),ost_x_vel(a1)
		move.w	#-$400,ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		rts
; ===========================================================================

loc_3C034:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	$32(a0),ost_x_pos(a0)
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	loc_3C062
		move.b	d0,d1
		andi.b	#8,d1
		beq.s	loc_3C056
		lea	($FFFFB000).w,a1
		bsr.s	loc_3C020

loc_3C056:
		andi.b	#$10,d0
		beq.s	loc_3C062
		lea	($FFFFB040).w,a1
		bsr.s	loc_3C020

loc_3C062:

		move.w	ost_x_pos(a0),d0
		moveq	#4,d1
		tst.w	$30(a0)
		spl	d2
		bmi.s	loc_3C072
		neg.w	d1

loc_3C072:
		add.w	d1,d0
		cmp.w	$34(a0),d0
		bcc.s	loc_3C07C
		not.b	d2

loc_3C07C:
		tst.b	d2
		bne.s	loc_3C088
		clr.b	ost_secondary_routine(a0)
		move.w	$34(a0),d0

loc_3C088:
		move.w	d0,ost_x_pos(a0)
		rts
; ===========================================================================
SubData_CPult:
		dc.l Map_CPult
		dc.w $245C
		dc.w $404
		dc.w $1000
; ===========================================================================

		include "mappings/sprite/WFZ Catapult.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C1 - WFZ breakable plating
; (and what Sonic hangs onto on the back of Robotnik's getaway ship)
; ----------------------------------------------------------------------------

BreakablePlating:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	BreakPlate_Index(pc,d0.w),d1
		jmp	BreakPlate_Index(pc,d1.w)
; ===========================================================================
BreakPlate_Index:	index offset(*),,2
		ptr loc_3C0C0					; 0
		ptr loc_3C0D6					; 2
		ptr loc_3C1AA					; 4
; ===========================================================================

loc_3C0C0:
		move.w	#id_SubData_BreakPlate,d0
		bsr.w	LoadSubObjData2
		moveq	#0,d0
		move.b	ost_subtype(a0),d0
		mulu.w	#$3C,d0
		move.w	d0,$30(a0)

loc_3C0D6:
		tst.b	$32(a0)
		beq.s	loc_3C140
		tst.w	$30(a0)
		beq.s	loc_3C0E8
		subq.w	#1,$30(a0)
		beq.s	loc_3C12E

loc_3C0E8:
		lea	(v_ost_player1).w,a1
		move.w	ost_y_pos(a0),d0
		subi.w	#$18,d0
		btst	#0,(v_joypad_hold_actual).w
		beq.s	loc_3C10A
		subq.w	#1,ost_y_pos(a1)
		cmp.w	ost_y_pos(a1),d0
		bcs.s	loc_3C10A
		move.w	d0,ost_y_pos(a1)

loc_3C10A:
		addi.w	#$30,d0
		btst	#1,(v_joypad_hold_actual).w
		beq.s	loc_3C124
		addq.w	#1,ost_y_pos(a1)
		cmp.w	ost_y_pos(a1),d0
		bcc.s	loc_3C124
		move.w	d0,ost_y_pos(a1)

loc_3C124:
		move.b	(v_joypad_press).w,d0
		andi.w	#$70,d0
		beq.s	loc_3C196

loc_3C12E:
		clr.b	ost_col_type(a0)
		clr.b	($FFFFB02A).w
		clr.b	(f_wind_tunnel_disable).w
		clr.b	$32(a0)
		bra.s	loc_3C19A
; ===========================================================================

loc_3C140:
		tst.b	ost_col_property(a0)
		beq.s	loc_3C196
		lea	(v_ost_player1).w,a1
		move.w	ost_x_pos(a0),d0
		subi.w	#$14,d0
		cmp.w	ost_x_pos(a1),d0
		bcc.s	loc_3C196
		clr.b	ost_col_property(a0)
		cmpi.b	#4,ost_primary_routine(a1)
		bcc.s	loc_3C196
		clr.w	ost_x_vel(a1)
		clr.w	ost_y_vel(a1)
		move.w	ost_x_pos(a0),d0
		subi.w	#$14,d0
		move.w	d0,ost_x_pos(a1)
		bset	#status_xflip_bit,ost_primary_status(a1)
		move.b	#$11,ost_anim(a1)
		move.b	#1,($FFFFB02A).w
		move.b	#1,(f_wind_tunnel_disable).w
		move.b	#1,$32(a0)

loc_3C196:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3C19A:
		lea	(byte_3C1E4).l,a4
		lea	(byte_3C1E0).l,a2
		bsr.w	loc_3C1F4

loc_3C1AA:
		tst.b	$3F(a0)
		beq.s	loc_3C1B6
		subq.b	#1,$3F(a0)
		bra.s	loc_3C1CA
; ===========================================================================

loc_3C1B6:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		addi_.w	#8,ost_y_vel(a0)
		lea	(off_3C1D6).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite

loc_3C1CA:
		tst.b	ost_render(a0)
		bpl.w	JmpTo65_DeleteObject
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3C1D6:	index offset(*)
		ptr byte_3C1D8

byte_3C1D8:
		dc.b   3,  2,  3,  4,  5,  1,$FF
		even

byte_3C1E0:
		dc.b   0					; 0
		dc.b   4					; 1
		dc.b $18					; 2
		dc.b $20
								; 3
byte_3C1E4:
		dc.w  -$10					; 0
		dc.w  -$10					; 2
		dc.w  -$10					; 4
		dc.w   $10					; 6
		dc.w  -$30					; 8
		dc.w  -$10					; 10
		dc.w  -$30					; 12
		dc.w   $10					; 14
; ===========================================================================

loc_3C1F4:
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		move.b	ost_priority(a0),d4
		subq.b	#1,d4
		moveq	#3,d1
		movea.l	a0,a1
		bra.s	loc_3C20E
; ===========================================================================

loc_3C208:
		jsrto	FindNextFreeObj,JmpTo25_FindNextFreeObj
		bne.s	loc_3C26C

loc_3C20E:
		move.b	#4,ost_primary_routine(a1)
		_move.b	ost_id(a0),ost_id(a1)
		move.l	ost_mappings(a0),ost_mappings(a1)
		move.w	ost_tile(a0),ost_tile(a1)
		move.b	#render_rel|render_onscreen,ost_render(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	(a4)+,d0
		add.w	d2,d0
		move.w	d0,ost_x_pos(a1)
		move.w	(a4)+,d0
		add.w	d3,d0
		move.w	d0,ost_y_pos(a1)
		move.b	d4,ost_priority(a1)
		move.b	#$10,ost_displaywidth(a1)
		move.b	#1,ost_frame(a1)
		move.w	#-$400,ost_x_vel(a1)
		move.w	#0,ost_y_vel(a1)
		move.b	(a2)+,$3F(a1)
		dbf	d1,loc_3C208

loc_3C26C:
		move.w	#$CB,d0
		jmp	(PlaySound).l
; ===========================================================================
SubData_BreakPlate:
		dc.l Map_BreakPlate
		dc.w $E48C
		dc.w $404
		dc.w $40E1
; ===========================================================================

		include "mappings/sprite/WFZ Breakable Plating.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C2 - Rivet (the thing player destroys to access the boss chamber in WFZ)
; ----------------------------------------------------------------------------

Rivet:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Rivet_Index(pc,d0.w),d1
		jmp	Rivet_Index(pc,d1.w)
; ===========================================================================
Rivet_Index:	index offset(*),,2
		ptr loc_3C33A					; 0
		ptr loc_3C33E					; 2
; ===========================================================================

loc_3C33A:
		bra.w	LoadSubObjData
; ===========================================================================

loc_3C33E:
		move.b	($FFFFB01C).w,$30(a0)
		pushr.w	ost_x_pos(a0)
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#9,d3
		popr.w	d4					; why not 'move.w	ost_x_pos(a0),d4'?
		jsrto	SolidObject,JmpTo27_SolidObject
		btst	#3,ost_primary_status(a0)
		bne.s	loc_3C366
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3C366:
		cmpi.b	#2,$30(a0)
		bne.s	loc_3C3B4
		move.w	#$2880,(v_boundary_left).w
		bclr	#3,ost_primary_status(a0)
		_move.b	#id_ExplosionItem,ost_id(a0)
		move.b	#2,ost_primary_routine(a0)
		bset	#1,(v_ost_player1+ost_primary_status).w
		bclr	#3,(v_ost_player1+ost_primary_status).w
		lea	(v_level_layout+(sizeof_levelrow*8)+80).w,a1 ; modify level layout (Row 8, Column 80)
		move.l	#($8A70<<16)|$7172,(a1)+		; new 128x128 tile IDs
		move.w	#$7374,(a1)+
		lea	(v_level_layout+(sizeof_levelrow*9)+80).w,a1 ; modify level layout (Row 9, Column 80)
		move.l	#($6E78<<16)|$7978,(a1)+		; new 128x128 tile IDs
		move.w	#$787A,(a1)+
		move.b	#1,(f_screen_redraw).w

loc_3C3B4:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
SubData_Rivet:
		dc.l Map_Rivet
		dc.w $A461
		dc.w $404
		dc.w $1000
; ===========================================================================

		include "mappings/sprite/WFZ Rivet.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C3,C4 - Tornado's smoke at start of WFZ
; ----------------------------------------------------------------------------

TornadoSmoke:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	TorSmoke_Index(pc,d0.w),d1
		jmp	TorSmoke_Index(pc,d1.w)
; ===========================================================================
TorSmoke_Index:	index offset(*),,2
		ptr loc_3C3E8					; 0
		ptr loc_3C416					; 2
; ===========================================================================

loc_3C3E8:
		bsr.w	LoadSubObjData
		move.b	#7,ost_anim_time(a0)
		jsrto	RandomNumber,JmpTo6_RandomNumber
		move.w	(v_random).w,d0
		andi.w	#$1C,d0
		sub.w	d0,ost_x_pos(a0)
		addi.w	#$10,ost_y_pos(a0)
		move.w	#-$100,ost_y_vel(a0)
		move.w	#-$100,ost_x_vel(a0)
		rts
; ===========================================================================

loc_3C416:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_3C434
		move.b	#7,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#5,ost_frame(a0)
		beq.w	JmpTo65_DeleteObject

loc_3C434:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
SubData_TorSmoke:
		dc.l Map_ExplodeItem
		dc.w $5A4
		dc.w $405
		dc.w $C00
; ===========================================================================
; ----------------------------------------------------------------------------
; Object C5 - WFZ boss
; the laser case is the parent object
; ----------------------------------------------------------------------------

BossWingFortress:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3C450(pc,d0.w),d1
		jmp	off_3C450(pc,d1.w)
; ===========================================================================
off_3C450:	index offset(*),,2
		ptr loc_3C464					; 0
		ptr loc_3C476					; 2
		ptr loc_3C748					; 4
		ptr loc_3C7EE					; 6
		ptr loc_3C8C8					; 8
		ptr loc_3C9AA					; $A
		ptr loc_3C9EA					; $C
		ptr loc_3CA3C					; $E
		ptr loc_3CB3E					; $10
		ptr loc_3CBBE					; $12
; ===========================================================================

loc_3C464:
		bsr.w	LoadSubObjData
		move.b	ost_subtype(a0),d0
		subi.b	#-$70,d0
		move.b	d0,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_3C476:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3C488(pc,d0.w),d1
		jsr	off_3C488(pc,d1.w)
		bra.w	loc_3CBEC
; ===========================================================================
off_3C488:	index offset(*),,2
		ptr loc_3C4A8					; 0
		ptr loc_3C4DC					; 2
		ptr loc_3C552					; 4
		ptr loc_3C570					; 6
		ptr loc_3C58A					; 8
		ptr loc_3C5B0					; $A
		ptr loc_3C5E8					; $C
		ptr loc_3C5F6					; $E
		ptr loc_3C60E					; $10
		ptr loc_3C640					; $12
		ptr loc_3C65C					; $14
		ptr loc_3C68C					; $16
		ptr loc_3C6E4					; $18
		ptr loc_3C5E8					; $1A
		ptr loc_3C704					; $1C
		ptr loc_3C712					; $1E
; ===========================================================================

loc_3C4A8:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#0,ost_col_type(a0)
		move.b	#8,ost_col_property(a0)
		move.w	#$442,d0
		move.w	d0,(v_boundary_bottom).w
		move.w	d0,(v_boundary_bottom_next).w
		move.w	ost_x_pos(a0),d0
		subi.w	#$60,d0
		move.w	d0,$34(a0)
		addi.w	#$C0,d0
		move.w	d0,$36(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C4DC:
		bsr.w	FindPlayer
		addi.w	#$20,d2
		cmpi.w	#$40,d2
		bcs.s	loc_3C4EE
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C4EE:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$40,ost_y_vel(a0)
		lea	(byte_3CC60).l,a2
		bsr.w	LoadChild
		subi.w	#$88,ost_x_pos(a1)
		addi.w	#$60,ost_y_pos(a1)
		lea	(byte_3CC60).l,a2
		bsr.w	LoadChild
		addi.w	#$88,ost_x_pos(a1)
		addi.w	#$60,ost_y_pos(a1)
		lea	(byte_3CC6C).l,a2
		bsr.w	LoadChild
		lea	(byte_3CC70).l,a2
		bsr.w	LoadChild
		lea	(byte_3CC78).l,a2
		bsr.w	LoadChild
		move.w	#$5A,$2A(a0)
		moveq	#-7,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C552:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3C55C
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C55C:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$60,$2A(a0)
		moveq	#-$6D,d0
		jsrto	PlayMusic,JmpTo5_PlayMusic
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C570:
		subq.w	#1,$2A(a0)
		beq.s	loc_3C57E
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C57E:
		addq.b	#2,ost_secondary_routine(a0)
		clr.w	ost_y_vel(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C58A:
		addq.b	#2,ost_secondary_routine(a0)
		bsr.w	FindPlayer
		move.w	#$100,d1
		tst.w	d0
		bne.s	loc_3C59C
		neg.w	d1

loc_3C59C:
		move.w	d1,ost_x_vel(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		move.w	#$70,$2A(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C5B0:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3C5DC
		move.w	ost_x_pos(a0),d0
		tst.w	ost_x_vel(a0)
		bmi.s	loc_3C5CA
		cmp.w	$36(a0),d0
		bcc.s	loc_3C5D0
		bra.w	loc_3C5D4
; ===========================================================================

loc_3C5CA:
		cmp.w	$34(a0),d0
		bcc.s	loc_3C5D4

loc_3C5D0:
		neg.w	ost_x_vel(a0)

loc_3C5D4:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C5DC:
		addq.b	#2,ost_secondary_routine(a0)
		clr.b	ost_anim(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C5E8:
		lea	(off_3CCB2).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C5F6:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$E,$2A(a0)
		movea.w	$3C(a0),a1
		move.b	#4,ost_secondary_routine(a1)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C60E:
		subq.w	#1,$2A(a0)
		beq.s	loc_3C620
		movea.w	$3C(a0),a1
		addq.w	#1,ost_y_pos(a1)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C620:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$40,$2A(a0)
		bset	#4,ost_primary_status(a0)
		bset	#status_underwater_bit,ost_primary_status(a0)
		move.b	#id_col_16x16,ost_col_type(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C640:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3C64A
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C64A:
		addq.b	#2,ost_secondary_routine(a0)
		lea	(byte_3CC74).l,a2
		bsr.w	LoadChild
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C65C:
		movea.w	$3E(a0),a1
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_3C66C
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C66C:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$80,$2A(a0)
		bsr.w	FindPlayer
		move.w	#$80,d1
		tst.w	d0
		bne.s	loc_3C684
		neg.w	d1

loc_3C684:
		move.w	d1,ost_x_vel(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C68C:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3C6B8
		move.w	ost_x_pos(a0),d0
		tst.w	ost_x_vel(a0)
		bmi.s	loc_3C6A6
		cmp.w	$36(a0),d0
		bcc.s	loc_3C6AC
		bra.w	loc_3C6B0
; ===========================================================================

loc_3C6A6:
		cmp.w	$34(a0),d0
		bcc.s	loc_3C6B0

loc_3C6AC:
		clr.w	ost_x_vel(a0)

loc_3C6B0:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C6B8:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$E,$2A(a0)
		bclr	#3,ost_primary_status(a0)
		bclr	#4,ost_primary_status(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		clr.b	ost_col_type(a0)
		movea.w	$3E(a0),a1
		jsrto	DeleteChild,JmpTo6_DeleteChild
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C6E4:
		subq.w	#1,$2A(a0)
		beq.s	loc_3C6F6
		movea.w	$3C(a0),a1
		subq.w	#1,ost_y_pos(a1)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C6F6:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#1,ost_anim(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C704:
		move.b	#8,ost_secondary_routine(a0)
		bsr.w	loc_3C58A
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C712:
		clr.b	ost_col_type(a0)
		st.b	ost_col_property(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		subq.w	#1,$30(a0)
		bmi.s	loc_3C72E
		jsrto	BossExplode,JmpTo_BossExplode
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C72E:
		moveq	#-$71,d0
		jsrto	PlayMusic,JmpTo5_PlayMusic
		move.w	#$720,d0
		move.w	d0,(v_boundary_bottom).w
		move.w	d0,(v_boundary_bottom_next).w
		bsr.w	JmpTo65_DeleteObject
		addq.w	#4,sp
		rts
; ===========================================================================

loc_3C748:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3C772(pc,d0.w),d1
		jsr	off_3C772(pc,d1.w)
		tst.b	(a0)
		beq.w	TRider_SharedRTS
		move.w	ost_x_pos(a0),-(sp)
		move.w	#$13,d1
		move.w	#$40,d2
		move.w	#$80,d3
		move.w	(sp)+,d4
		jmpto	SolidObject,JmpTo27_SolidObject
; ===========================================================================
off_3C772:	index offset(*),,2
		ptr loc_3C778					; 0
		ptr loc_3C786					; 2
		ptr loc_3C7AE					; 4
; ===========================================================================

loc_3C778:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$C,ost_frame(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C786:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.s	loc_3C7A0
		bchg	#0,$2F(a0)
		bne.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C7A0:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#4,$30(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C7AE:
		subq.b	#1,ost_anim_time(a0)
		bpl.w	TRider_SharedRTS
		move.b	ost_anim_time(a0),d0
		move.b	ost_anim_frame(a0),d1
		addq.b	#2,d0
		bpl.s	loc_3C7E4
		move.b	d1,ost_anim_time(a0)
		subq.b	#1,$30(a0)
		bpl.s	loc_3C7E4
		move.b	#$10,$30(a0)
		addq.b	#1,d1
		cmpi.b	#5,d1
		bcc.w	JmpTo65_DeleteObject
		move.b	d1,ost_anim_frame(a0)
		move.b	d1,ost_anim_time(a0)

loc_3C7E4:
		bclr	#0,$2F(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C7EE:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3C7FC(pc,d0.w),d1
		jmp	off_3C7FC(pc,d1.w)
; ===========================================================================
off_3C7FC:	index offset(*),,2
		ptr loc_3C806					; 0
		ptr loc_3C818					; 2
		ptr loc_3C83C					; 4
		ptr loc_3C85C					; 6
		ptr loc_3C8B4					; 8
; ===========================================================================

loc_3C806:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#5,ost_frame(a0)
		addq.w	#8,ost_y_pos(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C818:
		movea.w	$2C(a0),a1
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_3C828
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C828:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$40,$2A(a0)
		move.w	#$40,ost_y_vel(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C83C:
		subq.w	#1,$2A(a0)
		beq.s	loc_3C84A
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C84A:
		addq.b	#2,ost_secondary_routine(a0)
		clr.w	ost_y_vel(a0)
		move.w	#$10,$2A(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C85C:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.s	loc_3C8A6
		subq.w	#1,$2A(a0)
		bne.s	loc_3C8A2
		move.w	#$80,$2A(a0)
		moveq	#0,d0
		move.b	$2E(a0),d0
		addq.b	#1,d0
		cmpi.b	#3,d0
		bcs.s	loc_3C884
		moveq	#0,d0

loc_3C884:
		move.b	d0,$2E(a0)
		tst.b	$30(a0,d0.w)
		bne.s	loc_3C8A2
		st.b	$30(a0,d0.w)
		lea	(byte_3CC64).l,a2
		bsr.w	LoadChild
		move.b	$2E(a0),$2E(a1)

loc_3C8A2:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C8A6:
		addq.b	#2,ost_secondary_routine(a0)
		bset	#5,ost_primary_status(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C8B4:
		movea.w	$2C(a0),a1
		cmpi.b	#id_BossWingFortress,ost_id(a1)
		bne.w	JmpTo65_DeleteObject
		jsrto	BossExplode,JmpTo_BossExplode
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3C8C8:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3C8EA(pc,d0.w),d1
		jsr	off_3C8EA(pc,d1.w)
		lea	(off_3CCB2).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		tst.b	(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3C8EA:	index offset(*),,2
		ptr loc_3C8F0					; 0
		ptr loc_3C916					; 2
		ptr loc_3C93E					; 4
; ===========================================================================

loc_3C8F0:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_anim(a0)
		move.b	#7,ost_frame(a0)
		move.w	#$100,ost_y_vel(a0)
		move.w	#$60,$2A(a0)
		lea	(byte_3CC68).l,a2
		bra.w	LoadChild
; ===========================================================================

loc_3C916:
		bsr.w	loc_3C982
		subq.w	#1,$2A(a0)
		beq.s	loc_3C924
		bra.w	loc_3C968
; ===========================================================================

loc_3C924:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$60,$2A(a0)
		move.w	#-$100,ost_x_vel(a0)
		move.w	ost_y_pos(a0),$34(a0)
		bra.w	loc_3C968
; ===========================================================================

loc_3C93E:
		bsr.w	loc_3C982
		subq.w	#1,$2A(a0)
		bne.s	loc_3C952
		move.w	#$C0,$2A(a0)
		neg.w	ost_x_vel(a0)

loc_3C952:
		moveq	#4,d0
		move.w	ost_y_pos(a0),d1
		cmp.w	$34(a0),d1
		bcs.s	loc_3C960
		neg.w	d0

loc_3C960:
		add.w	d0,ost_y_vel(a0)
		bra.w	*+4

loc_3C968:
		move.w	ost_x_pos(a0),-(sp)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		move.w	#$10,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	(sp)+,d4
		jmpto	DetectPlatform,JmpTo9_DetectPlatform
; ===========================================================================

loc_3C982:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.w	loc_3C992
		rts
; ===========================================================================

loc_3C992:
		bsr.w	loc_3B7BC
		move.b	#id_ExplosionBomb,ost_id(a0)
		clr.b	ost_primary_routine(a0)
		movea.w	$3C(a0),a1
		jsrto	DeleteChild,JmpTo6_DeleteChild
		addq.w	#4,sp
		rts
; ===========================================================================

loc_3C9AA:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3C9B8(pc,d0.w),d1
		jmp	off_3C9B8(pc,d1.w)
; ===========================================================================
off_3C9B8:	index offset(*),,2
		ptr loc_3C9BC					; 0
		ptr loc_3C9C8					; 2
; ===========================================================================

loc_3C9BC:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#id_col_4x4+id_col_hurt,ost_col_type(a0)
		rts
; ===========================================================================

loc_3C9C8:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.w	JmpTo65_DeleteObject
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),d0
		addi.w	#$C,d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================

loc_3C9EA:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.w	JmpTo65_DeleteObject
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3CA06(pc,d0.w),d1
		jmp	off_3CA06(pc,d1.w)
; ===========================================================================
off_3CA06:	index offset(*),,2
		ptr loc_3CA0C					; 0
		ptr loc_3CA1A					; 2
		ptr loc_3CA2E					; 4
; ===========================================================================

loc_3CA0C:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#4,ost_frame(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CA1A:
		movea.w	$2C(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CA2E:
		movea.w	$2C(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CA3C:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.w	JmpTo65_DeleteObject
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3CA66(pc,d0.w),d1
		jsr	off_3CA66(pc,d1.w)
		bchg	#0,$2F(a0)
		bne.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3CA66:	index offset(*),,2
		ptr loc_3CA70					; 0
		ptr loc_3CA98					; 2
		ptr loc_3CAD0					; 4
		ptr loc_3CAE4					; 6
		ptr loc_3CB32					; 8
; ===========================================================================

loc_3CA70:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$D,ost_frame(a0)
		move.b	#4,ost_priority(a0)
		move.b	#0,ost_col_type(a0)
		addi.w	#$10,ost_y_pos(a0)
		move.b	#$C,ost_anim_frame(a0)
		subq.w	#3,ost_y_pos(a0)
		rts
; ===========================================================================

loc_3CA98:
		bset	#0,$2F(a0)
		subq.b	#1,ost_anim_time(a0)
		bpl.s	locret_3CAC2
		move.b	ost_anim_time(a0),d0
		addq.b	#2,d0
		bpl.s	loc_3CABC
		move.b	ost_anim_frame(a0),d0
		subq.b	#1,d0
		beq.s	loc_3CAC4
		move.b	d0,ost_anim_frame(a0)
		move.b	d0,ost_anim_time(a0)

loc_3CABC:
		bclr	#0,$2F(a0)

locret_3CAC2:
		rts
; ===========================================================================

loc_3CAC4:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$40,$2A(a0)
		rts
; ===========================================================================

loc_3CAD0:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3CAD8
		rts
; ===========================================================================

loc_3CAD8:
		addq.b	#2,ost_secondary_routine(a0)
		addi.w	#$10,ost_y_pos(a0)
		rts
; ===========================================================================

loc_3CAE4:
		moveq	#0,d0
		move.b	$2E(a0),d0
		addq.b	#1,d0
		cmpi.b	#5,d0
		bcc.s	loc_3CB0A
		addi.w	#$10,ost_y_pos(a0)
		move.b	d0,$2E(a0)
		move.b	byte_3CB26(pc,d0.w),ost_frame(a0)
		move.b	byte_3CB2C(pc,d0.w),ost_col_type(a0)
		rts
; ===========================================================================

loc_3CB0A:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$80,$2A(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		movea.w	$2C(a0),a1
		bset	#3,ost_primary_status(a1)
		rts
; ===========================================================================
byte_3CB26:
		dc.b  $E					; 0
		dc.b  $F					; 1
		dc.b $10					; 2
		dc.b $11					; 3
		dc.b $12					; 4
		even

byte_3CB2C:
		dc.b id_col_16x16+id_col_hurt			; 0
		dc.b id_col_16x32+id_col_hurt			; 1
		dc.b id_col_16x48+id_col_hurt			; 2
		dc.b id_col_16x64+id_col_hurt			; 3
		dc.b id_col_16x80+id_col_hurt			; 4
		even
; ===========================================================================

loc_3CB32:
		movea.w	$2C(a0),a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		rts
; ===========================================================================

loc_3CB3E:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3CB4C(pc,d0.w),d1
		jmp	off_3CB4C(pc,d1.w)
; ===========================================================================
off_3CB4C:	index offset(*),,2
		ptr loc_3CB52					; 0
		ptr loc_3CB7C					; 2
		ptr loc_3CBA4					; 4
; ===========================================================================

loc_3CB52:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#0,ost_frame(a0)
		move.b	#1,ost_anim(a0)
		move.w	#$2C60,ost_x_pos(a0)
		move.w	#$4E6,ost_y_pos(a0)
		lea	(byte_3CC7C).l,a2
		bsr.w	LoadChild
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CB7C:
		movea.w	$2C(a0),a1
		btst	#5,ost_primary_status(a1)
		bne.s	loc_3CB96
		lea	(off_3D0D8).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CB96:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$C0,$2A(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CBA4:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3CBB2
		addq.w	#1,ost_y_pos(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CBB2:
		movea.w	$3E(a0),a1
		jsrto	DeleteChild,JmpTo6_DeleteChild
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_3CBBE:
		movea.w	$2C(a0),a1
		move.w	ost_y_pos(a1),d0
		addi.w	#$26,d0
		move.w	d0,ost_y_pos(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
		; a bit of unused/dead code
		move.w	ost_x_pos(a0),-(sp)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		move.w	#$F,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	(sp)+,d4
		jmpto	DetectPlatform,JmpTo9_DetectPlatform
; ===========================================================================

loc_3CBEC:
		tst.b	ost_col_property(a0)
		beq.s	loc_3CC3C
		tst.b	ost_col_type(a0)
		bne.s	locret_3CC3A
		tst.b	$30(a0)
		bne.s	loc_3CC16
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	locret_3CC3A
		move.b	#$20,$30(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_3CC16:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_3CC24
		move.w	#$EEE,d0

loc_3CC24:
		move.w	d0,(a1)
		subq.b	#1,$30(a0)
		bne.s	locret_3CC3A
		btst	#4,ost_primary_status(a0)
		beq.s	locret_3CC3A
		move.b	#id_col_16x16,ost_col_type(a0)

locret_3CC3A:
		rts
; ===========================================================================

loc_3CC3C:
		moveq	#$64,d0
		bsr.w	AddPoints
		clr.b	ost_col_type(a0)
		move.w	#$EF,$30(a0)
		move.b	#$1E,ost_secondary_routine(a0)
		bset	#5,ost_primary_status(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		rts
; ===========================================================================
byte_3CC60:
		dc.w $2A
		dc.b id_BossWingFortress
		dc.b $94
byte_3CC64:
		dc.w $3E
		dc.b id_BossWingFortress
		dc.b $98
byte_3CC68:
		dc.w $3C
		dc.b id_BossWingFortress
		dc.b $9A
byte_3CC6C:
		dc.w $3C
		dc.b id_BossWingFortress
		dc.b $9C
byte_3CC70:
		dc.w $3A
		dc.b id_BossWingFortress
		dc.b $96
byte_3CC74:
		dc.w $3E
		dc.b id_BossWingFortress
		dc.b $9E
byte_3CC78:
		dc.w $38
		dc.b id_BossWingFortress
		dc.b $A0
byte_3CC7C:
		dc.w $3E
		dc.b id_BossWingFortress
		dc.b $A2

off_3CC80:
		dc.l Map_BWFZ
		dc.w $379
		dc.w $404
		dc.w $2000
off_3CC8A:
		dc.l Map_BWFZ
		dc.w $379
		dc.w $401
		dc.w $800
off_3CC94:
		dc.l Map_BWFZ
		dc.w $379
		dc.w $405
		dc.w $1000
off_3CC9E:
		dc.l Map_Eggman
		dc.w 0
		dc.w $405
		dc.w $2000
off_3CCA8:
		dc.l Map_BWFZ_EggPlat
		dc.w $A46D
		dc.w $405
		dc.w $2000

off_3CCB2:	index offset(*)
		ptr byte_3CCBA					; 0
		ptr byte_3CCC4					; 1
		ptr byte_3CCCC					; 2
		ptr byte_3CCD0					; 3

byte_3CCBA:
		dc.b   5,  0,  1,  2,  3,  3,  3,  3,$FA
		even

byte_3CCC4:
		dc.b   3,  3,  2,  1,  0,  0,$FA
		even

byte_3CCCC:
		dc.b   3,  5,  6,$FF

byte_3CCD0:
		dc.b   3,  7,  8,  9, $A, $B,$FF
		even
; ===========================================================================

		include "mappings/sprite/WFZ Boss.asm"
		include "mappings/sprite/WFZ Eggman's Platform.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C6 - Eggman
; ----------------------------------------------------------------------------

Eggman:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3CEDE(pc,d0.w),d1
		jmp	off_3CEDE(pc,d1.w)
; ===========================================================================
off_3CEDE:	index offset(*),,2
		ptr loc_3CEE6					; 0
		ptr loc_3CEF8					; 2
		ptr loc_3D036					; 4
		ptr loc_3D09C					; 6
; ===========================================================================

loc_3CEE6:
		bsr.w	LoadSubObjData
		move.b	ost_subtype(a0),d0
		subi.b	#-$5C,d0
		move.b	d0,ost_primary_routine(a0)
		rts
; ===========================================================================

loc_3CEF8:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3CF06(pc,d0.w),d1
		jmp	off_3CF06(pc,d1.w)
; ===========================================================================
off_3CF06:	index offset(*),,2
		ptr loc_3CF10					; 0
		ptr loc_3CF32					; 2
		ptr loc_3CF58					; 4
		ptr loc_3CF7C					; 6
		ptr loc_3CFF6					; 8
; ===========================================================================

loc_3CF10:
		addq.b	#2,ost_secondary_routine(a0)
		lea	(byte_3D0D0).l,a2
		bsr.w	LoadChild
		move.w	#$3F8,ost_x_pos(a1)
		move.w	#$160,ost_y_pos(a1)
		move.w	a0,($FFFFF660).w
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CF32:
		bsr.w	FindPlayer
		addi.w	#$5C,d2
		cmpi.w	#$B8,d2
		bcs.s	loc_3CF44
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CF44:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$18,$2A(a0)
		move.b	#1,ost_frame(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CF58:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3CF62
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CF62:
		addq.b	#2,ost_secondary_routine(a0)
		bset	#status_jump_bit,ost_primary_status(a0)
		move.w	#$200,ost_x_vel(a0)
		move.w	#$10,$2A(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CF7C:
		cmpi.w	#$810,ost_x_pos(a0)
		bcc.s	loc_3CFC0
		bsr.w	FindPlayer
		addi.w	#$50,d2
		cmpi.w	#$A0,d2
		bcc.s	loc_3CF9E
		move.w	ost_x_pos(a1),d0
		addi.w	#$50,d0
		move.w	d0,ost_x_pos(a0)

loc_3CF9E:
		subq.w	#1,$2A(a0)
		bpl.s	loc_3CFAE
		move.w	#$20,$2A(a0)
		bsr.w	loc_3D00C

loc_3CFAE:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_3D0D8).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CFC0:
		move.b	#2,ost_frame(a0)
		clr.w	ost_x_vel(a0)
		tst.b	ost_render(a0)
		bpl.s	loc_3CFF2
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$80,ost_x_vel(a0)
		move.w	#-$200,ost_y_vel(a0)
		move.b	#2,ost_frame(a0)
		move.w	#$50,$2A(a0)
		bset	#3,ost_primary_status(a0)

loc_3CFF2:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3CFF6:
		subq.w	#1,$2A(a0)
		bmi.w	JmpTo65_DeleteObject

loc_3CFFE:
		addi.w	#$10,ost_y_vel(a0)

loc_3D004:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos

loc_3D008:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3D00C:
		lea	(byte_3D0D4).l,a2
		bsr.w	LoadChild
		move.b	#$AA,ost_subtype(a1)
		move.b	#5,ost_frame(a1)
		move.w	#-$100,ost_x_vel(a1)
		subi.w	#$18,ost_y_pos(a1)
		move.w	#8,$2A(a1)
		rts
; ===========================================================================

loc_3D036:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3D044(pc,d0.w),d1
		jmp	off_3D044(pc,d1.w)
; ===========================================================================
off_3D044:	index offset(*),,2
		ptr loc_3D04A					; 0
		ptr loc_3D066					; 2
		ptr loc_3D078					; 4
; ===========================================================================

loc_3D04A:
		movea.w	$2C(a0),a1
		btst	#status_jump_bit,ost_primary_status(a1)
		bne.s	loc_3D05E
		bsr.w	loc_3D086
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3D05E:
		addq.b	#2,ost_secondary_routine(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3D066:
		bsr.w	loc_3D086
		lea	(off_3D0E6).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3D078:
		lea	($FFFFB000).w,a1
		bclr	#5,ost_primary_status(a1)
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_3D086:
		move.w	ost_x_pos(a0),-(sp)
		move.w	#$13,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	(sp)+,d4
		jmpto	SolidObject,JmpTo27_SolidObject
; ===========================================================================

loc_3D09C:
		subq.w	#1,$2A(a0)
		bmi.w	JmpTo65_DeleteObject
		addi.w	#$10,ost_y_vel(a0)
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================
off_3D0B2:
		dc.l Map_Eggman
		dc.w 0
		dc.w $405
		dc.w $1800
off_3D0BC:
		dc.l Map_DEZBarrier
		dc.w $2328
		dc.w $401
		dc.w $800
off_3D0C6:
		dc.l Map_Eggman
		dc.w 0
		dc.w $405
		dc.w $400

byte_3D0D0:
		dc.w $3E
		dc.b id_Eggman
		dc.b $A8

byte_3D0D4:
		dc.w $3C
		dc.b id_Eggman
		dc.b $AA

off_3D0D8:	index offset(*)
		ptr byte_3D0DC					; 0
		ptr byte_3D0E2					; 1

byte_3D0DC:
		dc.b   5,  2,  3,  4,$FF
		even

byte_3D0E2:
		dc.b   5,  6,  7,$FF
		even

off_3D0E6:	index offset(*)
		ptr byte_3D0E8

byte_3D0E8:
		dc.b   1,  0,  1,  2,  3,$FA
; ===========================================================================

		include "mappings/sprite/DEZ Eggman.asm"
		include "mappings/sprite/DEZ One-Way Door.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C8 - Crawl (CNZ shield badnik)
; ----------------------------------------------------------------------------

Crawl:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3D24C(pc,d0.w),d1
		jmp	off_3D24C(pc,d1.w)
; ===========================================================================
off_3D24C:	index offset(*),,2
		ptr loc_3D254					; 0
		ptr loc_3D27C					; 2
		ptr loc_3D2A6					; 4
		ptr loc_3D2D4					; 6
; ===========================================================================

loc_3D254:
		bsr.w	LoadSubObjData
		move.w	#$200,$2A(a0)
		moveq	#$20,d0
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_3D26A
		neg.w	d0

loc_3D26A:
		move.w	d0,ost_x_vel(a0)
		move.b	#$F,ost_height(a0)
		move.b	#$10,ost_width(a0)
		rts
; ===========================================================================

loc_3D27C:
		subq.w	#1,$2A(a0)
		beq.s	loc_3D298
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		bsr.w	loc_3D416
		lea	(Ani_Crawl).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D298:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#$3B,$2A(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D2A6:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3D2B4
		bsr.w	loc_3D416
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D2B4:
		move.b	#2,ost_primary_routine(a0)
		move.w	#$200,$2A(a0)
		neg.w	ost_x_vel(a0)
		bchg	#render_xflip_bit,ost_render(a0)
		bchg	#status_xflip_bit,ost_primary_status(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D2D4:
		move.b	#id_col_8x8_2+id_col_custom,ost_col_type(a0)
		bsr.w	FindPlayer
		move.w	d2,d4
		addi.w	#$40,d2
		cmpi.w	#$80,d2
		bcc.w	loc_3D39A
		addi.w	#$40,d3
		cmpi.w	#$80,d3
		bcc.w	loc_3D39A
		bclr	#3,ost_primary_status(a0)
		bne.w	loc_3D386
		move.b	ost_col_property(a0),d0
		beq.s	loc_3D368
		bclr	#0,ost_col_property(a0)
		beq.s	loc_3D334
		cmpi.b	#2,ost_anim(a1)
		bne.s	loc_3D36C
		btst	#1,ost_primary_status(a1)
		bne.s	loc_3D332
		bsr.w	FindPlayer
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3D32E
		subq.w	#2,d0

loc_3D32E:
		tst.w	d0
		bne.s	loc_3D390

loc_3D332:
		bsr.s	loc_3D3A4

loc_3D334:
		lea	($FFFFB040).w,a1
		bclr	#1,ost_col_property(a0)
		beq.s	loc_3D364
		cmpi.b	#2,ost_anim(a1)
		bne.s	loc_3D36C
		btst	#1,ost_primary_status(a1)
		bne.s	loc_3D362
		bsr.w	FindPlayer
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3D35E
		subq.w	#2,d0

loc_3D35E:
		tst.w	d0
		bne.s	loc_3D390

loc_3D362:
		bsr.s	loc_3D3A4

loc_3D364:
		clr.b	ost_col_property(a0)

loc_3D368:
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D36C:
		move.b	#id_col_8x8_2+id_col_hurt,ost_col_type(a0)
		btst	#1,$2B(a1)
		beq.s	loc_3D380
		move.b	#id_col_8x8_2,ost_col_type(a0)

loc_3D380:
		bset	#3,ost_primary_status(a0)

loc_3D386:
		move.b	#1,ost_frame(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D390:
		move.b	#id_col_8x8_2,ost_col_type(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D39A:
		move.b	$2C(a0),ost_primary_routine(a0)
		jmpto	DespawnObject,JmpTo39_DespawnObject
; ===========================================================================

loc_3D3A4:
		move.b	#2,ost_frame(a0)
		btst	#1,ost_primary_status(a1)
		beq.s	loc_3D3B8
		move.b	#3,ost_frame(a0)

loc_3D3B8:
		move.w	ost_x_pos(a0),d1
		move.w	ost_y_pos(a0),d2
		sub.w	ost_x_pos(a1),d1
		sub.w	ost_y_pos(a1),d2
		jsr	(CalcAngle).l
		move.b	(v_frame_counter).w,d1
		andi.w	#3,d1
		add.w	d1,d0
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,ost_x_vel(a1)
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,ost_y_vel(a1)
		bset	#1,ost_primary_status(a1)
		bclr	#4,ost_primary_status(a1)
		bclr	#5,ost_primary_status(a1)

loc_3D404:
		clr.b	$3C(a1)
		move.w	#$B4,d0
		jsr	(PlaySound).l
		rts
; ===========================================================================
		rts						; dead
; ===========================================================================

loc_3D416:
		bsr.w	FindPlayer
		addi.w	#$40,d2
		cmpi.w	#$80,d2
		bcc.s	locret_3D43E
		addi.w	#$40,d3
		cmpi.w	#$80,d3
		bcc.s	locret_3D43E
		move.b	ost_primary_routine(a0),$2C(a0)
		move.b	#6,ost_primary_routine(a0)
		clr.b	ost_frame(a0)

locret_3D43E:
		rts
; ===========================================================================
SubData_Crawl:
		dc.l Map_Crawl
		dc.w $8340
		dc.w $403
		dc.w $10D7

Ani_Crawl:	index offset(*)
		ptr byte_3D44C

byte_3D44C:
		dc.b $13,  0,  1,$FF
		even
; ===========================================================================

		include "mappings/sprite/Crawl.asm"

; ===========================================================================
; ----------------------------------------------------------------------------
; Object C7 - Eggrobo (final boss)
; ----------------------------------------------------------------------------

EggRobo:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	off_3D4D6(pc,d0.w),d1
		jmp	off_3D4D6(pc,d1.w)
; ===========================================================================
off_3D4D6:	index offset(*),,2
		ptr loc_3D4F8					; 0
		ptr loc_3D508					; 2
		ptr loc_3DA14					; 4
		ptr loc_3DA4A					; 6
		ptr loc_3DA74					; 8
		ptr loc_3DB74					; $A
		ptr loc_3DB9E					; $C
		ptr loc_3DBC8					; $E
		ptr loc_3DC50					; $10
		ptr loc_3DC9C					; $12
		ptr loc_3DCCC					; $14
		ptr loc_3DD20					; $16
		ptr loc_3DD50					; $18
		ptr loc_3DE70					; $1A
		ptr loc_3DEC2					; $1C
		ptr loc_3DFAA					; $1E
		ptr loc_3D970					; $20
; ===========================================================================

loc_3D4F8:
		lea	off_3E590(pc),a1
		bsr.w	LoadSubObjData3
		move.b	ost_subtype(a0),ost_primary_routine(a0)
		rts
; ===========================================================================

loc_3D508:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3D51A(pc,d0.w),d1
		jsr	off_3D51A(pc,d1.w)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3D51A:	index offset(*),,2
		ptr loc_3D52A					; 0
		ptr loc_3D5A8					; 2
		ptr loc_3D5C2					; 4
		ptr loc_3D5EA					; 6
		ptr loc_3D62E					; 8
		ptr loc_3D640					; $A
		ptr loc_3D684					; $C
		ptr loc_3D8D2					; $E
; ===========================================================================

loc_3D52A:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#3,ost_frame(a0)
		move.b	#5,ost_priority(a0)
		lea	(byte_3E55C).l,a2
		bsr.w	LoadChild
		lea	(byte_3E564).l,a2
		bsr.w	LoadChild
		lea	(byte_3E560).l,a2
		bsr.w	LoadChild
		lea	(byte_3E568).l,a2
		bsr.w	LoadChild
		lea	(byte_3E56C).l,a2
		bsr.w	LoadChild
		lea	(byte_3E570).l,a2
		bsr.w	LoadChild
		lea	(byte_3E574).l,a2
		bsr.w	LoadChild
		lea	(byte_3E578).l,a2
		bsr.w	LoadChild
		lea	(byte_3E57C).l,a2
		bsr.w	LoadChild
		lea	(byte_3E580).l,a2
		bsr.w	LoadChild
		lea	(byte_3E2E0).l,a1
		bra.w	loc_3E2A8
; ===========================================================================

loc_3D5A8:
		btst	#status_jump_bit,ost_primary_status(a0)
		bne.s	loc_3D5B2
		rts
; ===========================================================================

loc_3D5B2:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$3C,ost_anim_time(a0)
		moveq	#-7,d0
		jmpto	PlaySound,JmpTo12_PlaySound
; ===========================================================================

loc_3D5C2:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D5CA
		rts
; ===========================================================================

loc_3D5CA:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$79,ost_anim_time(a0)
		move.w	#-$100,ost_y_vel(a0)
		movea.w	$38(a0),a1
		move.b	#4,ost_secondary_routine(a1)
		moveq	#-$6C,d0
		jmpto	PlayMusic,JmpTo5_PlayMusic
; ===========================================================================

loc_3D5EA:
		subq.b	#1,ost_anim_time(a0)
		beq.s	loc_3D604
		moveq	#-$49,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(byte_3E2E0).l,a1
		bra.w	loc_3E2A8
; ===========================================================================

loc_3D604:
		addq.b	#2,ost_secondary_routine(a0)
		clr.w	ost_y_vel(a0)
		move.b	#$1F,ost_anim_time(a0)
		move.b	#id_col_32x32,ost_col_type(a0)
		move.b	#$C,ost_col_property(a0)
		bsr.w	loc_3E0EE
		movea.w	$38(a0),a1
		move.b	#6,ost_secondary_routine(a1)
		rts
; ===========================================================================

loc_3D62E:
		bsr.w	loc_3DFF8
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D63A
		rts
; ===========================================================================

loc_3D63A:
		addq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_3D640:
		bsr.w	loc_3DFF8
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$20,ost_anim_time(a0)
		move.b	ost_angle(a0),d0
		addq.b	#1,d0
		move.b	d0,ost_angle(a0)
		andi.w	#3,d0
		move.b	byte_3D680(pc,d0.w),d0
		move.b	d0,ost_anim(a0)
		clr.b	ost_anim_restart(a0)
		cmpi.b	#2,d0
		bne.s	locret_3D67E
		movea.w	$38(a0),a1
		move.b	#4,ost_secondary_routine(a1)
		move.b	#2,ost_anim(a1)

locret_3D67E:
		rts
; ===========================================================================
byte_3D680:
		dc.b   2					; 0
		dc.b   0					; 1
		dc.b   2					; 2
		dc.b   4					; 3
		even
; ===========================================================================

loc_3D684:
		bsr.w	loc_3DFF8
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		move.w	off_3D696(pc,d0.w),d1
		jmp	off_3D696(pc,d1.w)
; ===========================================================================
off_3D696:	index offset(*),,2
		ptr loc_3D6AA					; 0
		ptr loc_3D702					; 2
		ptr loc_3D83C					; 4
; ===========================================================================
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D6A4
		rts
; ===========================================================================

loc_3D6A4:
		addq.b	#2,ost_anim(a0)
		rts
; ===========================================================================

loc_3D6AA:
		moveq	#0,d0
		move.b	ost_anim_restart(a0),d0
		move.w	off_3D6B8(pc,d0.w),d1
		jmp	off_3D6B8(pc,d1.w)
; ===========================================================================
off_3D6B8:	index offset(*),,2
		ptr loc_3D6C0					; 0
		ptr loc_3D6CE					; 2
		ptr loc_3D6C0					; 4
		ptr loc_3D6E8					; 6
; ===========================================================================

loc_3D6C0:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D6C8
		rts
; ===========================================================================

loc_3D6C8:
		addq.b	#2,ost_anim_restart(a0)
		rts
; ===========================================================================

loc_3D6CE:
		lea	(off_3E40C).l,a1
		bsr.w	loc_3E1AA
		bne.s	loc_3D6DC
		rts
; ===========================================================================

loc_3D6DC:
		addq.b	#2,ost_anim_restart(a0)
		move.b	#$40,ost_anim_time(a0)
		rts
; ===========================================================================

loc_3D6E8:
		lea	(off_3E42C).l,a1
		bsr.w	loc_3E1AA
		bne.s	loc_3D6F6
		rts
; ===========================================================================

loc_3D6F6:
		subq.b	#2,ost_secondary_routine(a0)
		move.b	#$40,ost_anim_time(a0)
		rts
; ===========================================================================

loc_3D702:
		moveq	#0,d0
		move.b	ost_anim_restart(a0),d0
		move.w	word_3D710(pc,d0.w),d1
		jmp	word_3D710(pc,d1.w)
; ===========================================================================
word_3D710:	index offset(*),,2
		ptr loc_3D6C0
		ptr loc_3D720
		ptr loc_3D744
		ptr loc_3D6C0
		ptr loc_3D784
		ptr loc_3D7B8
		ptr loc_3D7F0
		ptr loc_3D82E
; ===========================================================================

loc_3D720:
		lea	(off_3E3D0).l,a1
		bsr.w	loc_3E1AA
		bne.s	loc_3D72E
		rts
; ===========================================================================

loc_3D72E:
		addq.b	#2,ost_anim_restart(a0)
		move.b	#$80,ost_anim_time(a0)
		clr.w	ost_x_vel(a0)
		move.w	#-$200,ost_y_vel(a0)
		rts
; ===========================================================================

loc_3D744:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D768
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_3D75A
		moveq	#-$24,d0
		jsrto	PlaySoundLocal,JmpTo_PlaySoundLocal

loc_3D75A:
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(byte_3E2E0).l,a1
		bra.w	loc_3E2A8
; ===========================================================================

loc_3D768:
		addq.b	#2,ost_anim_restart(a0)
		clr.w	ost_y_vel(a0)
		lea	(byte_3E584).l,a2
		bsr.w	LoadChild
		clr.w	ost_x_vel(a0)
		clr.w	$28(a0)
		rts
; ===========================================================================

loc_3D784:
		move.w	$28(a0),d0
		bne.s	loc_3D78C
		rts
; ===========================================================================

loc_3D78C:
		addq.b	#2,ost_anim_restart(a0)
		move.w	d0,ost_x_pos(a0)
		bclr	#render_xflip_bit,ost_render(a0)
		cmpi.w	#$780,d0
		bcc.s	loc_3D7A6
		bset	#render_xflip_bit,ost_render(a0)

loc_3D7A6:
		bsr.w	loc_3E168
		move.w	#$800,ost_y_vel(a0)
		move.b	#$20,ost_anim_time(a0)
		rts
; ===========================================================================

loc_3D7B8:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D7CC
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(byte_3E2E0).l,a1
		bra.w	loc_3E2A8
; ===========================================================================

loc_3D7CC:
		addq.b	#2,ost_anim_restart(a0)
		clr.w	ost_y_vel(a0)
		move.b	#1,(f_screen_shake).w
		move.w	#$40,($FFFFF660).w
		movea.w	$38(a0),a1
		move.b	#6,ost_secondary_routine(a1)
		moveq	#-$47,d0
		jmpto	PlaySound,JmpTo12_PlaySound
; ===========================================================================

loc_3D7F0:
		lea	(off_3E30A).l,a1
		bsr.w	loc_3E1AA
		bne.s	loc_3D7FE
		rts
; ===========================================================================

loc_3D7FE:
		lea	(byte_3E2E0).l,a1

loc_3D804:
		bsr.w	loc_3E2A8
		bsr.w	FindPlayer
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3D816
		subq.w	#2,d0

loc_3D816:
		tst.w	d0
		bne.s	loc_3D820
		subq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_3D820:
		addq.b	#2,ost_anim_restart(a0)
		move.b	#$60,ost_anim_time(a0)
		bra.w	loc_3E136
; ===========================================================================

loc_3D82E:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D836
		rts
; ===========================================================================

loc_3D836:
		subq.b	#2,ost_secondary_routine(a0)
		rts
; ===========================================================================

loc_3D83C:
		moveq	#0,d0
		move.b	ost_anim_restart(a0),d0
		move.w	word_3D84A(pc,d0.w),d1
		jmp	word_3D84A(pc,d1.w)
; ===========================================================================
word_3D84A:	index offset(*),,2
		ptr loc_3D6C0
		ptr loc_3D856
		ptr loc_3D6C0
		ptr loc_3D89E
		ptr loc_3D6C0
		ptr loc_3D8B8
; ===========================================================================

loc_3D856:
		bset	#status_underwater_bit,ost_primary_status(a0)
		lea	(off_3E2F6).l,a1
		bsr.w	loc_3E1AA
		bne.s	loc_3D86A
		rts
; ===========================================================================

loc_3D86A:
		bsr.w	FindPlayer
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3D878
		subq.w	#2,d0

loc_3D878:
		tst.w	d0
		bne.s	loc_3D88E
		addq.b	#2,ost_anim_restart(a0)
		move.b	#$40,ost_anim_time(a0)
		bset	#4,ost_primary_status(a0)
		rts
; ===========================================================================

loc_3D88E:
		move.b	#8,ost_anim_restart(a0)
		move.b	#$20,ost_anim_time(a0)
		bra.w	loc_3E136
; ===========================================================================

loc_3D89E:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D8A6
		rts
; ===========================================================================

loc_3D8A6:
		addq.b	#2,ost_anim_restart(a0)
		bset	#5,ost_primary_status(a0)
		move.b	#$40,ost_anim_time(a0)
		rts
; ===========================================================================

loc_3D8B8:
		lea	(off_3E300).l,a1
		bsr.w	loc_3E1AA
		bne.s	loc_3D8C6
		rts
; ===========================================================================

loc_3D8C6:
		subq.b	#2,ost_secondary_routine(a0)
		bclr	#status_underwater_bit,ost_primary_status(a0)
		rts
; ===========================================================================

loc_3D8D2:
		moveq	#0,d0
		move.b	ost_anim(a0),d0
		move.w	off_3D8E0(pc,d0.w),d1
		jmp	off_3D8E0(pc,d1.w)
; ===========================================================================
off_3D8E0:	index offset(*),,2
		ptr loc_3D8E6					; 0
		ptr loc_3D922					; 2
		ptr loc_3D93C					; 4
; ===========================================================================

loc_3D8E6:
		jsrto	BossExplode,JmpTo_BossExplode
		jsrto	ObjectFall,JmpTo8_ObjectFall
		move.w	ost_y_pos(a0),d0
		cmpi.w	#$15C,d0
		bcc.s	loc_3D8FA
		rts
; ===========================================================================

loc_3D8FA:
		move.w	#$15C,ost_y_pos(a0)
		move.w	ost_y_vel(a0),d0
		bmi.s	loc_3D916
		lsr.w	#2,d0
		cmpi.w	#$100,d0
		bcs.s	loc_3D916
		neg.w	d0
		move.w	d0,ost_y_vel(a0)
		rts
; ===========================================================================

loc_3D916:
		addq.b	#2,ost_anim(a0)
		move.b	#$40,ost_anim_time(a0)
		rts
; ===========================================================================

loc_3D922:
		subq.b	#1,ost_anim_time(a0)
		bmi.s	loc_3D92C
		jmpto	BossExplode,JmpTo_BossExplode
; ===========================================================================

loc_3D92C:
		addq.b	#2,ost_anim(a0)
		st.b	(f_lock_controls).w
		move.w	#$1000,(v_boundary_right).w
		rts
; ===========================================================================

loc_3D93C:
		move.w	#$808,(v_joypad_hold).w
		cmpi.w	#$840,(v_camera_x_pos).w
		bcc.s	loc_3D94C
		rts
; ===========================================================================

loc_3D94C:
		move.b	#$20,ost_primary_routine(a0)
		clr.b	ost_secondary_routine(a0)
		move.w	#$20,$2A(a0)
		move.b	#1,(f_screen_shake).w
		move.w	#$1000,($FFFFF660).w
		movea.w	$36(a0),a1
		jmpto	DeleteChild,JmpTo6_DeleteChild
; ===========================================================================

loc_3D970:
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#$1F,d0
		bne.s	loc_3D984
		moveq	#-$1F,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		subq.w	#1,$2A(a0)

loc_3D984:
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a1),d0
		sub.w	$2A(a0),d0
		move.w	d0,ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		bsr.w	loc_3DFBA
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3D9AC(pc,d0.w),d1
		jmp	off_3D9AC(pc,d1.w)
; ===========================================================================
off_3D9AC:	index offset(*),,2
		ptr loc_3D9B0					; 0
		ptr loc_3D9D6					; 2
; ===========================================================================

loc_3D9B0:
		lea	($FFFFB000).w,a1
		cmpi.w	#$EC0,ost_x_pos(a1)
		bcc.s	loc_3D9BE
		rts
; ===========================================================================

loc_3D9BE:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$3F,(v_palfade_start).w
		move.b	#$16,ost_anim_time(a0)
		move.w	#$7FFF,(v_palcycle_time).w
		rts
; ===========================================================================

loc_3D9D6:
		subq.b	#1,ost_anim_time(a0)
		beq.w	loc_3D9F2
		movea.l	a0,a1
		lea	($FFFFFB00).w,a0
		moveq	#$3F,d0

loc_3D9E6:
		jsrto	WhiteOut_AddColor,JmpTo_WhiteOut_AddColor
		dbf	d0,loc_3D9E6
		movea.l	a1,a0
		rts
; ===========================================================================

loc_3D9F2:
		move.l	#$EEE0EEE,d0
		lea	($FFFFFB00).w,a1
		moveq	#$1F,d6

loc_3D9FE:
		move.l	d0,(a1)+
		dbf	d6,loc_3D9FE
		moveq	#-7,d0
		jsrto	PlaySound,JmpTo12_PlaySound
		move.b	#$20,(v_gamemode).w
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_3DA14:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DA34(pc,d0.w),d1
		jsr	off_3DA34(pc,d1.w)
		lea	byte_3DA38(pc),a1
		bsr.w	loc_3E282
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DA34:	index offset(*),,2
		ptr loc_3DA3C					; 0
		ptr locret_3DA48				; 2

byte_3DA38:
		dc.b   0					; 0
		dc.b  $C					; 1
		dc.b $FF					; 2
		dc.b $EC					; 3
		even
; ===========================================================================

loc_3DA3C:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#4,ost_frame(a0)
		rts
; ===========================================================================

locret_3DA48:
		rts
; ===========================================================================

loc_3DA4A:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DA62(pc,d0.w),d1
		jsr	off_3DA62(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DA62:	index offset(*),,2
		ptr loc_3DA66					; 0
		ptr locret_3DA72				; 2
; ===========================================================================

loc_3DA66:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$B,ost_frame(a0)
		rts
; ===========================================================================

locret_3DA72:
		rts
; ===========================================================================

loc_3DA74:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DA96(pc,d0.w),d1
		jsr	off_3DA96(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		btst	#status_underwater_bit,ost_primary_status(a0)
		bne.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DA96:	index offset(*),,2
		ptr loc_3DAA0					; 0
		ptr loc_3DAAC					; 2
		ptr loc_3DACC					; 4
		ptr loc_3DB32					; 6
		ptr loc_3DB5A					; 8
; ===========================================================================

loc_3DAA0:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#6,ost_frame(a0)
		rts
; ===========================================================================

loc_3DAAC:
		movea.w	$2C(a0),a1
		bclr	#4,ost_primary_status(a1)
		bne.s	loc_3DABA
		rts
; ===========================================================================

loc_3DABA:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$10,$2A(a0)
		move.w	ost_y_pos(a0),$2E(a0)
		rts
; ===========================================================================

loc_3DACC:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DADC
		addi.w	#$20,ost_y_vel(a0)
		bra.w	JmpTo26_SpeedToPos
; ===========================================================================

loc_3DADC:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$20,$2A(a0)
		bsr.w	FindPlayer
		tst.w	d2
		bpl.s	loc_3DAF0
		neg.w	d2

loc_3DAF0:
		cmpi.w	#$100,d2
		bcs.s	loc_3DAFA
		move.w	#$FF,d2

loc_3DAFA:
		andi.w	#$C0,d2
		lsr.w	#5,d2
		move.w	word_3DB2A(pc,d2.w),d2
		tst.w	d1
		bne.s	loc_3DB0A
		neg.w	d2

loc_3DB0A:
		move.w	d2,ost_y_vel(a0)
		move.w	#$800,d2
		movea.w	$2C(a0),a1
		btst	#render_xflip_bit,ost_render(a0)
		bne.s	loc_3DB20
		neg.w	d2

loc_3DB20:
		move.w	d2,ost_x_vel(a0)
		moveq	#-$44,d0
		jmpto	PlaySound,JmpTo12_PlaySound
; ===========================================================================
word_3DB2A:
		dc.w  $200					; 0
		dc.w  $100					; 1
		dc.w   $80					; 2
		dc.w	 0					; 3
; ===========================================================================

loc_3DB32:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DB3C
		bra.w	JmpTo26_SpeedToPos
; ===========================================================================

loc_3DB3C:
		addq.b	#2,ost_secondary_routine(a0)
		neg.w	ost_x_vel(a0)
		move.w	#$20,$2A(a0)
		move.w	$2E(a0),d0
		sub.w	ost_y_pos(a0),d0
		asl.w	#3,d0
		move.w	d0,ost_y_vel(a0)
		rts
; ===========================================================================

loc_3DB5A:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DB64
		bra.w	JmpTo26_SpeedToPos
; ===========================================================================

loc_3DB64:
		move.b	#2,ost_secondary_routine(a0)
		clr.w	ost_x_vel(a0)
		clr.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_3DB74:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DB8C(pc,d0.w),d1
		jsr	off_3DB8C(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DB8C:	index offset(*),,2
		ptr loc_3DB90					; 0
		ptr locret_3DB9C				; 2
; ===========================================================================

loc_3DB90:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#5,ost_frame(a0)
		rts
; ===========================================================================

locret_3DB9C:
		rts
; ===========================================================================

loc_3DB9E:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DBB6(pc,d0.w),d1
		jsr	off_3DBB6(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DBB6:	index offset(*),,2
		ptr loc_3DBBA					; 0
		ptr locret_3DBC6				; 1
; ===========================================================================

loc_3DBBA:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$A,ost_frame(a0)
		rts
; ===========================================================================

locret_3DBC6:
		rts
; ===========================================================================

loc_3DBC8:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DBE8(pc,d0.w),d1
		jsr	off_3DBE8(pc,d1.w)
		lea	byte_3DBF2(pc),a1
		bsr.w	loc_3E282
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DBE8:	index offset(*),,2
		ptr loc_3DBF6					; 0
		ptr loc_3DC02					; 2
		ptr loc_3DC1C					; 4
		ptr loc_3DC2A					; 6
		ptr loc_3DC46					; 8

byte_3DBF2:
		dc.b   0					; 0
		dc.b   0					; 1
		dc.b $FF					; 2
		dc.b $CC					; 3
; ===========================================================================

loc_3DBF6:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$15,ost_frame(a0)
		rts
; ===========================================================================

loc_3DC02:
		movea.w	($FFFFF660).w,a1
		btst	#3,ost_primary_status(a1)
		bne.s	loc_3DC10
		rts
; ===========================================================================

loc_3DC10:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$40,$2A(a0)
		rts
; ===========================================================================

loc_3DC1C:
		lea	(off_3E59A).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DC2A:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DC34
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DC34:
		addq.b	#2,ost_secondary_routine(a0)
		movea.w	$2C(a0),a1
		bset	#status_jump_bit,ost_primary_status(a1)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DC46:
		move.b	#-1,ost_col_property(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DC50:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DC66(pc,d0.w),d1
		jsr	off_3DC66(pc,d1.w)
		lea	byte_3DC70(pc),a1
		bra.w	loc_3E282
; ===========================================================================
off_3DC66:	index offset(*),,2
		ptr loc_3DC74					; 0
		ptr loc_3DC80					; 2
		ptr loc_3DC86					; 4
		ptr loc_3DC94					; 6
		ptr loc_3DC80					; 8

byte_3DC70:
		dc.b   0					; 0
		dc.b $38					; 1
		dc.b   0					; 2
		dc.b $18					; 3
; ===========================================================================

loc_3DC74:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$C,ost_frame(a0)
		rts
; ===========================================================================

loc_3DC80:
		move.b	#3,ost_anim(a0)

loc_3DC86:
		lea	(off_3E5AA).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DC94:
		move.b	#1,ost_anim(a0)
		bra.s	loc_3DC86
; ===========================================================================

loc_3DC9C:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DCB4(pc,d0.w),d1
		jsr	off_3DCB4(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DCB4:	index offset(*),,2
		ptr loc_3DCB8					; 0
		ptr locret_3DCCA				; 2
; ===========================================================================

loc_3DCB8:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$B,ost_frame(a0)
		move.b	#5,ost_priority(a0)
		rts
; ===========================================================================

locret_3DCCA:
		rts
; ===========================================================================

loc_3DCCC:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DCE4(pc,d0.w),d1
		jsr	off_3DCE4(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DCE4:	index offset(*),,2
		ptr loc_3DCEE					; 0
		ptr loc_3DD00
		ptr loc_3DACC
		ptr loc_3DB32
		ptr loc_3DB5A
; ===========================================================================

loc_3DCEE:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#6,ost_frame(a0)
		move.b	#5,ost_priority(a0)
		rts
; ===========================================================================

loc_3DD00:
		movea.w	$2C(a0),a1
		bclr	#5,ost_primary_status(a1)
		bne.s	loc_3DD0E
		rts
; ===========================================================================

loc_3DD0E:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$10,$2A(a0)
		move.w	ost_y_pos(a0),$2E(a0)
		rts
; ===========================================================================

loc_3DD20:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DD38(pc,d0.w),d1
		jsr	off_3DD38(pc,d1.w)
		tst.b	ost_id(a0)
		beq.w	TRider_SharedRTS
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
off_3DD38:	index offset(*),,2
		ptr loc_3DD3C					; 0
		ptr locret_3DD4E				; 2
; ===========================================================================

loc_3DD3C:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$A,ost_frame(a0)
		move.b	#5,ost_priority(a0)
		rts
; ===========================================================================

locret_3DD4E:
		rts
; ===========================================================================

loc_3DD50:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DD5E(pc,d0.w),d1
		jmp	off_3DD5E(pc,d1.w)
; ===========================================================================
off_3DD5E:	index offset(*),,2
		ptr loc_3DD64					; 0
		ptr loc_3DDA6					; 2
		ptr loc_3DE3C					; 4
; ===========================================================================

loc_3DD64:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$10,ost_frame(a0)
		ori.w	#tile_hi,ost_tile(a0)
		move.b	#1,ost_priority(a0)
		move.w	#$A0,$2A(a0)
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		move.w	ost_x_vel(a1),$30(a0)
		move.w	ost_y_vel(a1),$32(a0)
		move.w	#$18,ost_angle(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DDA6:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DE0A
		lea	$40(a0),a1
		movea.l	a1,a2
		move.w	-(a1),ost_y_vel(a0)
		move.w	-(a1),ost_x_vel(a0)
		moveq	#2,d6

loc_3DDBC:
		move.l	-(a1),-(a2)
		dbf	d6,loc_3DDBC
		lea	($FFFFB000).w,a2
		move.w	ost_x_vel(a2),d0
		bne.s	loc_3DDD2
		move.w	ost_x_pos(a2),ost_x_pos(a0)

loc_3DDD2:
		move.w	d0,(a1)+
		move.w	ost_y_vel(a2),d0
		bne.s	loc_3DDE0
		move.w	ost_y_pos(a2),ost_y_pos(a0)

loc_3DDE0:
		move.w	d0,(a1)+
		jsrto	SpeedToPos,JmpTo26_SpeedToPos
		lea	(off_3E5EE).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		subq.b	#1,ost_angle(a0)
		bpl.s	loc_3DE06
		subq.b	#1,$27(a0)
		move.b	$27(a0),ost_angle(a0)
		moveq	#-$58,d0
		jsrto	PlaySound,JmpTo12_PlaySound

loc_3DE06:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DE0A:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$40,$2A(a0)
		move.b	#4,ost_angle(a0)
		lea	($FFFFB000).w,a1
		move.w	ost_x_pos(a1),ost_x_pos(a0)
		move.w	ost_y_pos(a1),ost_y_pos(a0)
		lea	(byte_3E588).l,a2
		bsr.w	LoadChild
		clr.w	ost_x_vel(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DE3C:
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DE62
		lea	(off_3E5EE).l,a1
		jsrto	AnimateSprite,JmpTo25_AnimateSprite
		subq.b	#1,ost_angle(a0)
		bpl.s	loc_3DE5E
		move.b	#4,ost_angle(a0)
		moveq	#-$58,d0
		jsrto	PlaySound,JmpTo12_PlaySound

loc_3DE5E:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DE62:
		movea.w	$2C(a0),a1
		move.w	ost_x_pos(a0),$28(a1)
		bra.w	JmpTo65_DeleteObject
; ===========================================================================

loc_3DE70:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DE7E(pc,d0.w),d1
		jmp	off_3DE7E(pc,d1.w)
; ===========================================================================
off_3DE7E:	index offset(*),,2
		ptr loc_3DE82					; 0
		ptr loc_3DEA2					; 2
; ===========================================================================

loc_3DE82:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$14,ost_frame(a0)
		move.b	#1,ost_priority(a0)
		ori.w	#tile_hi,ost_tile(a0)
		move.w	#4,$2A(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DEA2:
		movea.w	$2C(a0),a1
		tst.b	(a1)
		beq.w	JmpTo65_DeleteObject
		subq.w	#1,$2A(a0)
		bne.s	loc_3DEBE
		move.w	#4,$2A(a0)
		bchg	#tile_pal12_bit,ost_tile(a0)

loc_3DEBE:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DEC2:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3DED0(pc,d0.w),d1
		jmp	off_3DED0(pc,d1.w)
; ===========================================================================
off_3DED0:	index offset(*),,2
		ptr loc_3DED8					; 0
		ptr loc_3DF04					; 2
		ptr loc_3DF36					; 4
		ptr loc_3DF80					; 6
; ===========================================================================

loc_3DED8:
		addq.b	#2,ost_secondary_routine(a0)
		move.b	#$E,ost_frame(a0)
		move.b	#id_col_12x16+id_col_hurt,ost_col_type(a0)
		move.b	#5,ost_priority(a0)
		move.b	#$C,ost_displaywidth(a0)
		lea	byte_3DF00(pc),a1
		bsr.w	loc_3E282
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================
byte_3DF00:
		dc.b   0					; 0
		dc.b $38					; 1
		dc.b $FF					; 2
		dc.b $EC					; 3
; ===========================================================================

loc_3DF04:
		movea.w	$2C(a0),a1

loc_3DF08:
		btst	#status_broken_bit,ost_primary_status(a1)
		bne.s	loc_3DF4C
		jsrto	ObjectFall,JmpTo8_ObjectFall
		move.w	ost_y_pos(a0),d0
		cmpi.w	#$170,d0
		bcc.s	loc_3DF22
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DF22:
		addq.b	#2,ost_secondary_routine(a0)
		move.w	#$170,ost_y_pos(a0)
		move.w	#$40,$2A(a0)
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DF36:
		movea.w	$2C(a0),a1
		btst	#status_broken_bit,ost_primary_status(a1)
		bne.s	loc_3DF4C
		subq.w	#1,$2A(a0)
		bmi.s	loc_3DF4C
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DF4C:
		move.b	#6,ost_secondary_routine(a0)
		move.l	#Map_ExplodeBomb,ost_mappings(a0)
		move.w	#tile_Nem_FieryExplosion,ost_tile(a0)
		move.b	#1,ost_priority(a0)
		move.b	#7,ost_anim_time(a0)
		move.b	#0,ost_frame(a0)
		move.w	#$C4,d0
		jsr	(PlaySound).l
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DF80:
		subq.b	#1,ost_anim_time(a0)
		bpl.s	loc_3DFA6
		move.b	#7,ost_anim_time(a0)
		addq.b	#1,ost_frame(a0)
		cmpi.b	#5,ost_frame(a0)
		bcs.s	loc_3DFA6
		clr.b	ost_col_type(a0)
		cmpi.b	#7,ost_frame(a0)
		beq.w	JmpTo65_DeleteObject

loc_3DFA6:
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DFAA:
		subq.w	#1,$2A(a0)
		bmi.w	JmpTo65_DeleteObject
		jsrto	ObjectFall,JmpTo8_ObjectFall
		jmpto	DisplaySprite,JmpTo45_DisplaySprite
; ===========================================================================

loc_3DFBA:
		jsr	(FindFreeObj).l
		bne.s	locret_3DFF6
		_move.b	#id_ExplosionBomb,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$30,d1
		add.w	d1,ost_x_pos(a1)
		lsr.w	#8,d0
		lsr.b	#2,d0
		subi.w	#$30,d0
		add.w	d0,ost_y_pos(a1)

locret_3DFF6:
		rts
; ===========================================================================

loc_3DFF8:
		tst.b	ost_col_property(a0)
		beq.s	loc_3E05A
		tst.b	$2A(a0)
		bne.s	loc_3E02E

loc_3E004:
		tst.b	ost_col_type(a0)
		beq.s	loc_3E01E
		movea.w	$36(a0),a1

loc_3E00E:
		tst.b	ost_col_type(a1)
		bne.s	locret_3E058
		clr.b	ost_col_type(a0)
		subq.b	#1,ost_col_property(a0)
		beq.s	loc_3E05A

loc_3E01E:
		move.b	#$3C,$2A(a0)
		move.w	#$AC,d0
		jsr	(PlaySound).l

loc_3E02E:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_3E03C
		move.w	#$EEE,d0

loc_3E03C:
		move.w	d0,(a1)
		subq.b	#1,$2A(a0)
		bne.s	locret_3E058
		clr.w	($FFFFFB22).w
		move.b	#id_col_32x32,ost_col_type(a0)
		movea.w	$36(a0),a1
		move.b	#id_col_32x16,ost_col_type(a1)

locret_3E058:
		rts
; ===========================================================================

loc_3E05A:
		moveq	#$64,d0
		bsr.w	AddPoints
		clr.b	ost_anim_time(a0)
		move.b	#$E,ost_secondary_routine(a0)
		bset	#status_broken_bit,ost_primary_status(a0)
		clr.b	ost_anim(a0)
		clr.b	ost_col_type(a0)
		clr.w	ost_x_vel(a0)
		clr.w	ost_y_vel(a0)
		bsr.w	loc_3E11E
		bsr.w	loc_3E094
		movea.w	$38(a0),a1
		jsrto	DeleteChild,JmpTo6_DeleteChild
		addq.w	#4,sp
		rts
; ===========================================================================

loc_3E094:
		lea	(byte_3E0E6).l,a1			; could be PC-relative
		lea	word_3E0C6(pc),a2
		moveq	#0,d0
		moveq	#7,d6

loc_3E0A2:
		move.b	(a1)+,d0
		movea.w	(a0,d0.w),a3
		move.b	#$1E,ost_primary_routine(a3)
		clr.b	ost_secondary_routine(a3)
		move.w	#$80,$2A(a3)
		move.w	(a2)+,ost_x_vel(a3)
		move.w	(a2)+,ost_y_vel(a3)
		dbf	d6,loc_3E0A2
		rts
; ===========================================================================
word_3E0C6:
		dc.w  $200,-$400
		dc.w -$100,-$100				; 2
		dc.w  $300,-$300				; 4
		dc.w -$100,-$400				; 6
		dc.w  $180,-$200				; 8
		dc.w -$200,-$300				; 10
		dc.w	 0,-$400				; 12
		dc.w  $100,-$300				; 14

byte_3E0E6:
		dc.b $2C					; 0
		dc.b $2E					; 1
		dc.b $30					; 2
		dc.b $32					; 3
		dc.b $34					; 4
		dc.b $3A					; 5
		dc.b $3C					; 6
		dc.b $3E					; 7
; ===========================================================================

loc_3E0EE:
		lea	EggRobo_ChildPtrs(pc),a1
		lea	EggRobo_ColTypes(pc),a2
		moveq	#0,d0
		moveq	#9,d6

loc_3E0FA:
		move.b	(a1)+,d0
		movea.w	(a0,d0.w),a3
		move.b	(a2)+,ost_col_type(a3)

loc_3E104:
		dbf	d6,loc_3E0FA
		rts
; ===========================================================================
EggRobo_ColTypes:
		dc.b 0						; 0
		dc.b id_col_24x24+id_col_hurt			; 1
		dc.b id_col_24x4+id_col_hurt			; 2
		dc.b 0						; 3
		dc.b id_col_16x16+id_col_hurt			; 4
		dc.b id_col_32x16				; 5
		dc.b id_col_8x8+id_col_hurt			; 6
		dc.b id_col_24x24+id_col_hurt			; 7
		dc.b id_col_24x4+id_col_hurt			; 8
		dc.b id_col_8x8+id_col_hurt			; 9

EggRobo_ChildPtrs:
		dc.b $2C					; 0
		dc.b $2E					; 1
		dc.b $30					; 2
		dc.b $32					; 3
		dc.b $34					; 4
		dc.b $36					; 5
		dc.b $38					; 6
		dc.b $3A					; 7
		dc.b $3C					; 8
		dc.b $3E					; 9
; ===========================================================================

loc_3E11E:
		lea	EggRobo_ChildPtrs(pc),a1
		moveq	#0,d0
		moveq	#9,d6

loc_3E126:
		move.b	(a1)+,d0
		movea.w	(a0,d0.w),a3
		clr.b	ost_col_type(a3)
		dbf	d6,loc_3E126
		rts
; ===========================================================================

loc_3E136:
		lea	EggmanBomb_InitSpeeds(pc),a3
		moveq	#1,d6

loc_3E13C:
		lea	(byte_3E58C).l,a2			; could be PC-relative
		bsr.w	LoadChild
		move.w	(a3)+,d0
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3E152
		neg.w	d0

loc_3E152:
		move.w	d0,ost_x_vel(a1)
		move.w	(a3)+,ost_y_vel(a1)
		dbf	d6,loc_3E13C
		rts
; ===========================================================================
EggmanBomb_InitSpeeds:
		dc.w   $60,-$800
		dc.w   $C0,-$A00
; ===========================================================================

loc_3E168:
		move.b	ost_render(a0),d0
		andi.b	#1,d0
		moveq	#0,d1
		lea	byte_3E19E(pc),a1

loc_3E176:
		move.b	(a1)+,d1
		beq.w	TRider_SharedRTS
		movea.w	(a0,d1.w),a2
		move.b	ost_render(a2),d2
		andi.b	#-2,d2
		or.b	d0,d2
		move.b	d2,ost_render(a2)
		move.b	ost_primary_status(a2),d2
		andi.b	#-2,d2
		or.b	d0,d2
		move.b	d2,ost_primary_status(a2)
		bra.s	loc_3E176
; ===========================================================================
byte_3E19E:
		dc.b $2C					; 0
		dc.b $2E					; 1
		dc.b $30					; 2
		dc.b $32					; 3
		dc.b $34					; 4
		dc.b $36					; 5
		dc.b $38					; 6
		dc.b $3A					; 7
		dc.b $3C					; 8
		dc.b $3E					; 9
		dc.b   0					; 10
		even
; ===========================================================================

loc_3E1AA:
		movea.l	(a1)+,a2
		moveq	#0,d0
		move.b	ost_anim_frame(a0),d0
		move.b	(a1,d0.w),d0
		move.b	d0,d1
		moveq	#0,d4
		andi.w	#$C0,d1
		beq.s	loc_3E1C4
		bsr.w	loc_3E23E

loc_3E1C4:
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.b	(a2)+,d0
		move.b	(a2)+,d3
		move.b	$1F(a0),d2
		addq.b	#1,d2
		cmp.b	d3,d2
		bcs.s	loc_3E1DE
		addq.b	#1,ost_anim_frame(a0)
		moveq	#0,d2

loc_3E1DE:
		move.b	d2,$1F(a0)
		moveq	#0,d5

loc_3E1E4:
		move.b	(a2)+,d5
		movea.w	(a0,d5.w),a3
		tst.w	d5
		bne.s	loc_3E1F0
		movea.l	a0,a3

loc_3E1F0:
		move.l	ost_x_pos(a3),d2
		move.b	(a2)+,d1
		ext.w	d1
		asl.w	#4,d1
		btst	#render_xflip_bit,ost_render(a0)

loc_3E200:
		beq.s	loc_3E204
		neg.w	d1

loc_3E204:
		tst.w	d4
		beq.s	loc_3E20A

loc_3E208:
		neg.w	d1

loc_3E20A:
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		move.l	d2,ost_x_pos(a3)
		move.l	ost_y_pos(a3),d3
		move.b	(a2)+,d1
		ext.w	d1
		asl.w	#4,d1
		tst.w	d4
		beq.s	loc_3E224
		neg.w	d1

loc_3E224:
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.l	d3,ost_y_pos(a3)
		dbf	d0,loc_3E1E4
		moveq	#0,d1
		rts
; ===========================================================================

loc_3E236:
		clr.b	ost_anim_frame(a0)
		moveq	#1,d1

locret_3E23C:
		rts
; ===========================================================================

loc_3E23E:
		andi.b	#$3F,d0
		rol.b	#3,d1
		move.w	loc_3E248+2(pc,d1.w),d1

loc_3E248:
		jmp	off_3E24C(pc,d1.w)
; ===========================================================================
off_3E24C:	index offset(*),,2
		ptr loc_3E252					; 0
		ptr loc_3E27A					; 2
		ptr loc_3E27E					; 4
; ===========================================================================

loc_3E252:
		tst.b	$1F(a0)
		bne.s	locret_3E23C
		move.b	ost_anim_frame(a0),d1
		addq.b	#1,d1
		move.b	(a1,d1.w),d0
		jsrto	PlaySound,JmpTo12_PlaySound
		addq.b	#1,d1
		move.b	d1,ost_anim_frame(a0)
		move.b	(a1,d1.w),d0
		move.b	d0,d1
		andi.b	#-$40,d1
		bne.s	loc_3E23E
		rts
; ===========================================================================

loc_3E27A:
		moveq	#1,d4
		rts
; ===========================================================================

loc_3E27E:
		addq.w	#4,sp
		bra.s	loc_3E236
; ===========================================================================

loc_3E282:
		movea.w	$2C(a0),a2
		move.w	ost_x_pos(a2),d0
		move.w	(a1)+,d1
		btst	#render_xflip_bit,ost_render(a2)
		beq.s	loc_3E296
		neg.w	d1

loc_3E296:
		add.w	d1,d0
		move.w	d0,ost_x_pos(a0)
		move.w	ost_y_pos(a2),d0
		add.w	(a1)+,d0
		move.w	d0,ost_y_pos(a0)
		rts
; ===========================================================================

loc_3E2A8:
		moveq	#0,d0
		moveq	#0,d6
		move.b	(a1)+,d6

loc_3E2AE:
		move.b	(a1)+,d0
		movea.w	(a0,d0.w),a2
		move.w	ost_x_pos(a0),d1
		move.b	(a1)+,d2
		ext.w	d2
		btst	#render_xflip_bit,ost_render(a0)
		beq.s	loc_3E2C6
		neg.w	d2

loc_3E2C6:
		add.w	d2,d1
		move.w	d1,ost_x_pos(a2)
		move.w	ost_y_pos(a0),d1
		move.b	(a1)+,d2
		ext.w	d2
		add.w	d2,d1
		move.w	d1,ost_y_pos(a2)
		dbf	d6,loc_3E2AE
		rts
; ===========================================================================
byte_3E2E0:
		dc.b   6					; 0
		dc.b $2E					; 1
		dc.b $FC					; 2
		dc.b $3C					; 3
		dc.b $30					; 4
		dc.b $F4					; 5
		dc.b   8					; 6
		dc.b $32					; 7
		dc.b  $C					; 8
		dc.b $F8					; 9
		dc.b $34					; 10
		dc.b   4					; 11
		dc.b $24					; 12
		dc.b $3A					; 13
		dc.b $FC					; 14
		dc.b $3C					; 15
		dc.b $3C					; 16
		dc.b $F4					; 17
		dc.b   8					; 18
		dc.b $3E					; 19
		dc.b   4					; 20
		dc.b $24					; 21

off_3E2F6:
		dc.l Ani_3E318
		dc.w 1
		dc.w $203
		dc.w $FF00

off_3E300:
		dc.l Ani_3E318
		dc.w $506
		dc.w $708
		dc.w $FF00

off_3E30A:
		dc.l Ani_3E318
		dc.w 1
		dc.w $203
		dc.w $405
		dc.w $607
		dc.w $8C0

; -----------------------------------------------------------------------------
; Custom animation scripts
; -----------------------------------------------------------------------------
Ani_3E318:	index offset(*)
		ptr byte_3E32A					; 0
		ptr byte_3E33E					; 1
		ptr byte_3E352					; 2
		ptr byte_3E366					; 3
		ptr byte_3E37A					; 4
		ptr byte_3E380					; 5
		ptr byte_3E394					; 6
		ptr byte_3E3A8					; 7
		ptr byte_3E3BC					; 8

byte_3E32A:
		dc.b   5,  8,  0,$E0, $C,$30,$E0, $C,$32,$E0, $C,$3C,$E0, $C,$34,$F8 ; 0
		dc.b   4,$3E,$F8,  4				; 16

byte_3E33E:
		dc.b   5,  8,  0,$EC,$14,$30,$EC,$14,$32,$EC,$14,$3C,$EC,$14,$34,$FA ; 0
		dc.b   6,$3E,$FA,  6
								; 16
byte_3E352:
		dc.b   5,  8,  0,$F8,$14,$30,$F8,$14,$32,$F8,$14,$3C,$F8,$14,$34,$FE ; 0
		dc.b   4,$3E,$FE,  4				; 16

byte_3E366:
		dc.b   5,  8,  0,$FC, $C,$30,$FC, $C,$32,$FC, $C,$3C,$FC, $C,$34,  0 ; 0
		dc.b   2,$3E,  0,  2				; 16

byte_3E37A:
		dc.b   0,  8,  0,  0,  0,  0			; 0

byte_3E380:
		dc.b   5,  8,  0,  4,$E8,$30,  4,$E8,$32,  4,$E8,$3C,  4,$E8,$34,  2 ; 0
		dc.b $FA,$3E,  2,$FA				; 16

byte_3E394:
		dc.b   5,  8,  0, $C,$E8,$30, $C,$E8,$32, $C,$E8,$3C, $C,$E8,$34,  4 ; 0
		dc.b $FC,$3E,  4,$FC				; 16

byte_3E3A8:
		dc.b   5,  8,  0,$18,$F4,$30,$18,$F4,$32,$18,$F4,$3C,$18,$F4,$34,  4 ; 0
		dc.b $FC,$3E,  4,$FC				; 16

byte_3E3BC:
		dc.b   5,  8,  0,$18,$FC,$30,$18,$FC,$32,$18,$FC,$3C,$18,$FC,$34,  6 ; 0
		dc.b $FE,$3E,  6,$FE				; 16

off_3E3D0:
		dc.l Ani_3E3D8					; 0
		dc.b 0, 1, 2, $C0
		even

; -----------------------------------------------------------------------------
; Custom animation scripts
; -----------------------------------------------------------------------------
Ani_3E3D8:	index offset(*)
		ptr byte_3E3DE					; 0
		ptr byte_3E3F2					; 1
		ptr byte_3E3F8					; 2
byte_3E3DE:
		dc.b   5,$10,  0,  0,  4,$30,  0,  4,$32,  0,  4,$3C,  0,  4,$34,  0 ; 0
		dc.b   4,$3E,  0,  4				; 16

byte_3E3F2:
		dc.b   0,$10,  0,  0,  0,  0			; 0

byte_3E3F8:
		dc.b   5,  8,  0,  0,$F8,$30,  0,$F8,$32,  0,$F8,$3C,  0,$F8,$34,  0 ; 0
		dc.b $F8,$3E,  0,$F8				; 16

off_3E40C:
		dc.l Ani_3E438					; 0
		dc.b   0,  1,  2,  3,$40,$BD,  4,  5,  6,  7,  8,$40,$BD,  9, $A,  1 ; 0
		dc.b   2,  3,$40,$BD,  4,  5,  6,  7,  8,$40,$BD,$C0 ; 16

off_3E42C:
		dc.l Ani_3E438					; 0
		dc.w $8887
		dc.w $8685
		dc.w $B40
		dc.w $BDC0
; -----------------------------------------------------------------------------
; Custom animation scripts
; -----------------------------------------------------------------------------
Ani_3E438:	index offset(*)
		ptr byte_3E450					; 0
		ptr byte_3E468					; 1
		ptr byte_3E480					; 2
		ptr byte_3E494					; 3
		ptr byte_3E4AC					; 4
		ptr byte_3E4C4					; 5
		ptr byte_3E4D6					; 6
		ptr byte_3E4EE					; 7
		ptr byte_3E502					; 8
		ptr byte_3E51A					; 9
		ptr byte_3E532					; 10
		ptr byte_3E544					; 11

byte_3E450:
		dc.b   6,$20,$34,$F8,$F8,$2E,$F8,$F8,  0,  0,$FC,$30,  4,$FB,$32,  3 ; 0
		dc.b $FB,$3C,$FC,$FB,$3E,  0,$FE,  0		; 16

byte_3E468:
		dc.b   6,$10,$34,$F0,$FC,$2E,$F0,$FC,  0,$F0,$FC,$30,$F4,$FB,$32,$F3 ; 0
		dc.b $FB,$3C,$EC,$FB,$3E,$F8,  0,  0		; 16

byte_3E480:
		dc.b   5,$10,$34,$F8,  4,$2E,$F8,  4,  0,$F8,  4,$30,$FC,  3,$32,$FB ; 0
		dc.b   3,$3C,$F4,  3				; 16

byte_3E494:
		dc.b   6,$10,$34,$FC,$10,$2E,$F8,$10,  0,  0,  8,$30,$F8, $A,$32,$FA ; 0
		dc.b  $A,$3C,  8, $A,$3E,  0,  8,  0		; 16

byte_3E4AC:
		dc.b   6,$20,$34,$FE,$FE,  0,$F4,$FC,$30,$F0,$FD,$32,$F1,$FD,$3C,$F8 ; 0
		dc.b $FD,$3E,$EC,$FA,$3A,$E8,$FC,  0		; 16

byte_3E4C4:
		dc.b   4,$20,$3E,$F8,$FC,$3A,$F8,$FC,$30,$FC,$FF,$32,$FD,$FF,$3C,  4 ; 0
		dc.b $FF,  0					; 16

byte_3E4D6:
		dc.b   6,$10,$3E,$F0,$FC,$3A,$F0,$FC,  0,$F0,$FC,$30,$EC,$FB,$32,$ED ; 0
		dc.b $FB,$3C,$F4,$FB,$34,$F8,  0,  0		; 16

byte_3E4EE:
		dc.b   5,$10,$3E,$F8,  4,$3A,$F8,  4,  0,$F8,  4,$30,$F4,  3,$32,$F5 ; 0
		dc.b   3,$3C,$FC,  3				; 16

byte_3E502:
		dc.b   6,$10,$3E,$FC,$10,$3A,$F8,$10,  0,  0,  8,$30,  8, $A,$32,  6 ; 0
		dc.b  $A,$3C,$F8, $A,$34,  0,  8,  0		; 16

byte_3E51A:
		dc.b   6,$20,$3E,$FE,$FE,  0,$F4,$FC,$30,$F8,$FD,$32,$F7,$FD,$3C,$F1 ; 0
		dc.b $FD,$34,$EC,$FA,$2E,$E8,$FC,  0		; 16

byte_3E532:
		dc.b   4,$20,$34,$F8,$FC,$2E,$F8,$FC,$30,  4,$FF,$32,  3,$FF,$3C,$FC ; 0
		dc.b $FF,  0					; 16

byte_3E544:
		dc.b   6,$10,$3E,  0,  8,$3A,  0,  8,  0,  0,  8,$30,  0,  8,$32,  0 ; 0
		dc.b   8,$3C,  0,  8,$34,  0,  8,  0		; 16

byte_3E55C:
		dc.w $2C					; 1
		dc.b id_EggRobo					; 2
		dc.b   4					; 3

byte_3E560:
		dc.w $2E					; 1
		dc.b id_EggRobo					; 2
		dc.b   6					; 3

byte_3E564:
		dc.w $30					; 1
		dc.b id_EggRobo					; 2
		dc.b   8					; 3

byte_3E568:
		dc.w $32					; 1
		dc.b id_EggRobo					; 2
		dc.b  $A					; 3

byte_3E56C:
		dc.w $34					; 1
		dc.b id_EggRobo					; 2
		dc.b  $C					; 3

byte_3E570:
		dc.w $36					; 1
		dc.b id_EggRobo					; 2
		dc.b  $E					; 3

byte_3E574:
		dc.w $38					; 1
		dc.b id_EggRobo					; 2
		dc.b $10					; 3

byte_3E578:
		dc.w $3A					; 1
		dc.b id_EggRobo					; 2
		dc.b $12					; 3

byte_3E57C:
		dc.w $3C					; 1
		dc.b id_EggRobo					; 2
		dc.b $14					; 3

byte_3E580:
		dc.w $3E					; 1
		dc.b id_EggRobo					; 2
		dc.b $16					; 3


byte_3E584:
		dc.w $10					; 1
		dc.b id_EggRobo					; 2
		dc.b $18					; 3

byte_3E588:
		dc.w $10					; 1
		dc.b id_EggRobo					; 2
		dc.b $1A					; 3

byte_3E58C:
		dc.w $10					; 1
		dc.b id_EggRobo					; 2
		dc.b $1C					; 3

off_3E590:
		dc.l Map_EggRobo				; 0
		dc.w $330
		dc.w $404
		dc.w $3800

off_3E59A:	index offset(*)
		ptr byte_3E59C

byte_3E59C:
		dc.b   7,$15,$15,$15,$15,$15,$15,$15,$15,  0,  1,  2,$FA
		even

off_3E5AA:	index offset(*)
		ptr byte_3E5B2					; 0
		ptr byte_3E5B6					; 1
		ptr byte_3E5D0					; 2
		ptr byte_3E5EA					; 3

byte_3E5B2:
		dc.b   1, $C, $D,$FF
		even

byte_3E5B6:
		dc.b   1, $C, $D, $C, $C, $D, $D, $C, $C, $C, $D, $D, $D, $C, $C, $C
		dc.b  $C, $C, $D, $D, $D, $D, $D, $D,$FA
		even

byte_3E5D0:
		dc.b   1, $D, $D, $D, $D, $D, $D, $C, $C, $C, $C, $C, $D, $D, $D, $C
		dc.b  $C, $C, $D, $D, $C, $C, $D, $C,$FD
		even

byte_3E5EA:
		dc.b   0, $D,$15,$FF
		even

off_3E5EE:	index offset(*)
		ptr byte_3E5F0

byte_3E5F0:
		dc.b   3,$13,$12,$11,$10,$16,$FF
		even

		include "mappings/sprite/EggRobo.asm"

; ---------------------------------------------------------------------------
; Subroutine to upscale graphics by a factor of 2x, based on given mappings
; data for correct positioning of tiles.

; This code is awfully structured and planned: whenever a 3-column sprite spritePiece
; is scaled, it scales the next tiles that were copied to RAM as if the spritePiece
; had 4 columns; this will then be promptly overwritten by the next spritePiece. If
; this happens near the end of the buffer, you will get a buffer overrun.
; Moreover, when the number of rows in the sprite spritePiece is also 3 or 4, the code
; will make an incorrect computation for the output of the next subpiece, which
; causes the output to overwrite art from the previous subpiece. Thus, this code
; fails if there is a 3x3 or a 3x4 sprite spritePiece in the source mappings. Sadly,
; this issue is basically unfixable without rewriting the code entirely.

; input:
; 	a1 = location of tiles to be enlarged
; 	a2 = destination buffer for enlarged tiles
; 	d0 = width-1 of sprite spritePiece
; 	d1 = height-1 of sprite spritePiece

;	uses d0.w, d1.w, d2.w, d3.w, d4.w, d5.w, a1, a2, a3, a4, a5
; ---------------------------------------------------------------------------

Scale_2x:
		move.w	d1,d2
		andi.w	#1,d2
		addq.w	#1,d2
		lsl.w	#6,d2
		swap	d2
		move.w	d1,d3
		lsr.w	#1,d3
		addq.w	#1,d3
		lsl.w	#6,d3
		swap	d3
		bsr.w	loc_3E8CA
		btst	#1,d0
		beq.w	TRider_SharedRTS
		btst	#1,d1
		bne.s	loc_3E8C8
		movea.l	a3,a5

loc_3E8C8:
		movea.l	a5,a2

loc_3E8CA:
		movea.l	a2,a4
		swap	d2
		lea	(a2,d2.w),a3
		swap	d2
		move.w	d1,d5
		andi.w	#1,d5
		bsr.w	loc_3E944
		btst	#1,d1
		beq.s	loc_3E906
		swap	d2
		move.w	d2,d4
		swap	d2
		add.w	d4,d4
		move.w	d0,d3
		andi.w	#1,d3
		lsl.w	d3,d4
		adda.w	d4,a4
		move.w	d1,d5
		lsr.w	#1,d5
		swap	d3
		lea	(a4,d3.w),a5

loc_3E900:
		swap	d3
		bsr.w	loc_3E95C

loc_3E906:
		btst	#0,d0

loc_3E90A:
		bne.s	loc_3E912
		btst	#1,d0
		beq.s	locret_3E942

loc_3E912:
		swap	d2
		lea	(a2,d2.w),a2
		lea	(a2,d2.w),a3
		swap	d2
		move.w	d1,d5
		andi.w	#1,d5
		bsr.w	loc_3E944
		btst	#1,d1
		beq.s	locret_3E942
		move.w	d1,d5
		lsr.w	#1,d5
		swap	d3
		lea	(a4,d3.w),a4
		lea	(a4,d3.w),a5
		swap	d3
		bsr.w	loc_3E95C

locret_3E942:
		rts
; ===========================================================================

loc_3E944:
		moveq	#7,d6

loc_3E946:
		bsr.w	loc_3E974
		addq.w	#4,a2
		bsr.w	loc_3E99E
		addq.w	#4,a3
		dbf	d6,loc_3E946
		dbf	d5,loc_3E944
		rts
; ===========================================================================

loc_3E95C:
		moveq	#7,d6

loc_3E95E:
		bsr.w	loc_3E9C8
		addq.w	#4,a4
		bsr.w	loc_3E9F2
		addq.w	#4,a5
		dbf	d6,loc_3E95E
		dbf	d5,loc_3E95C
		rts
; ===========================================================================

loc_3E974:
		bsr.w	*+4
		move.b	(a1)+,d2
		move.b	d2,d3
		andi.b	#-$10,d2
		move.b	d2,d4
		lsr.b	#4,d4
		or.b	d2,d4
		move.b	d4,(a2)+
		move.b	d4,3(a2)
		andi.b	#$F,d3
		move.b	d3,d4
		lsl.b	#4,d4
		or.b	d3,d4
		move.b	d4,(a2)+
		move.b	d4,3(a2)
		rts
; ===========================================================================

loc_3E99E:
		bsr.w	*+4
		move.b	(a1)+,d2
		move.b	d2,d3
		andi.b	#-$10,d2
		move.b	d2,d4
		lsr.b	#4,d4
		or.b	d2,d4
		move.b	d4,(a3)+
		move.b	d4,3(a3)
		andi.b	#$F,d3
		move.b	d3,d4
		lsl.b	#4,d4
		or.b	d3,d4
		move.b	d4,(a3)+
		move.b	d4,3(a3)
		rts
; ===========================================================================

loc_3E9C8:
		bsr.w	*+4
		move.b	(a1)+,d2
		move.b	d2,d3
		andi.b	#-$10,d2
		move.b	d2,d4
		lsr.b	#4,d4
		or.b	d2,d4
		move.b	d4,(a4)+
		move.b	d4,3(a4)
		andi.b	#$F,d3
		move.b	d3,d4
		lsl.b	#4,d4
		or.b	d3,d4
		move.b	d4,(a4)+
		move.b	d4,3(a4)
		rts
; ===========================================================================

loc_3E9F2:
		bsr.w	*+4

		move.b	(a1)+,d2
		move.b	d2,d3
		andi.b	#-$10,d2
		move.b	d2,d4
		lsr.b	#4,d4
		or.b	d2,d4
		move.b	d4,(a5)+
		move.b	d4,3(a5)
		andi.b	#$F,d3
		move.b	d3,d4
		lsl.b	#4,d4
		or.b	d3,d4
		move.b	d4,(a5)+
		move.b	d4,3(a5)
		rts
; ===========================================================================
		; unused data for something...
		dc.b $12,$34,$56,$78				; 0
		dc.b $12,$34,$56,$78				; 4
		dc.b $12,$34,$56,$78				; 8
		dc.b $12,$34,$56,$78				; 12
		dc.b $12,$34,$56,$78				; 16
		dc.b $12,$34,$56,$78				; 20
		dc.b $12,$34,$56,$78				; 24
		dc.b $12,$34,$56,$78				; 28
; ===========================================================================

	if RemoveJmpTos=0
JmpTo5_DisplaySprite3:
		jmp	(DisplaySprite3).l
JmpTo45_DisplaySprite:
		jmp	(DisplaySprite).l
JmpTo65_DeleteObject:
		jmp	(DeleteObject).l
JmpTo19_FindFreeObj:
		jmp	(FindFreeObj).l
JmpTo39_DespawnObject:
		jmp	(DespawnObject).l
JmpTo6_DeleteChild:
		jmp	(DeleteChild).l
JmpTo12_PlaySound:
		jmp	(PlaySound).l
JmpTo25_FindNextFreeObj:
		jmp	(FindNextFreeObj).l
JmpTo25_AnimateSprite:
		jmp	(AnimateSprite).l
JmpTo_PlaySoundLocal:
		jmp	(PlaySoundLocal).l
JmpTo6_RandomNumber:
		jmp	(RandomNumber).l
JmpTo2_DespawnObject4:
		jmp	(DespawnObject4).l
JmpTo_WhiteOut_AddColor:
		jmp	(WhiteOut_AddColor).l
JmpTo_Tails_LoadGFX_2:
		jmp	(Tails_LoadGFX_2).l
JmpTo_Sonic_LoadGFX_2:
		jmp	(Sonic_LoadGFX_2).l
JmpTo8_DespawnObject3:
		jmp	(DespawnObject3).l
JmpTo64_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l
JmpTo5_PlayMusic:
		jmp	(PlayMusic).l
JmpTo_BossExplode:
		jmp	(BossExplode).l
JmpTo9_DetectPlatform:
		jmp	(DetectPlatform).l
JmpTo27_SolidObject:
		jmp	(SolidObject).l
JmpTo8_ObjectFall:
		jmp	(ObjectFall).l
JmpTo26_SpeedToPos:
		jmp	(SpeedToPos).l

		align 4
	endc


; ===========================================================================
; ----------------------------------------------------------------------------
; Object 8A - Sonic Team Presents/Credits (unused leftover from S1)
; ----------------------------------------------------------------------------

S1_STP_Credits:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	S1Cred_Index(pc,d0.w),d1
		jmp	S1Cred_Index(pc,d1.w)
; ===========================================================================
S1Cred_Index:index offset(*),,2
		ptr loc_3EADA					; 0
		ptr loc_3EB48					; 2
; ===========================================================================

loc_3EADA:
		addq.b	#2,ost_primary_routine(a0)
		move.w	#screen_left+160,ost_x_screen(a0)
		move.w	#screen_top+112,ost_y_screen(a0)
		move.l	#Map_S1Cred,ost_mappings(a0)
		move.w	#vram_S1Credits/sizeof_cell,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo65_AdjustVRAM2P
		move.w	(v_s1_ending_demo_num).w,d0
		move.b	d0,ost_frame(a0)
		move.b	#render_abs,ost_render(a0)
		move.b	#0,ost_priority(a0)
		cmpi.b	#4,(v_gamemode).w
		bne.s	loc_3EB48
		move.w	#vram_S1Title_Credits/sizeof_cell,ost_tile(a0)
		jsrto	AdjustVRAM2P,JmpTo65_AdjustVRAM2P
		move.b	#$A,ost_frame(a0)
		tst.b	(f_s1_credits_cheat).w
		beq.s	loc_3EB48
		cmpi.b	#$72,(v_joypad_hold_actual).w
		bne.s	loc_3EB48
		move.w	#cWhite,($FFFFFBC0).w
		move.w	#$880,($FFFFFBC2).w
		jmp	(DeleteObject).l
; ===========================================================================

loc_3EB48:
		jmp	(DisplaySprite).l
; ===========================================================================

		include "mappings/sprite/S1 Credits & Sonic Team Presents (unused).asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo65_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ----------------------------------------------------------------------------
; Object 3E - Egg prison
; ----------------------------------------------------------------------------

Prison:
		moveq	#0,d0
		move.b	ost_primary_routine(a0),d0
		move.w	Pri_Index(pc,d0.w),d1
		jmp	Pri_Index(pc,d1.w)
; ===========================================================================
Pri_Index:	index offset(*),,2
		ptr loc_3F212					; 0
		ptr loc_3F278					; 2
		ptr loc_3F354					; 4
		ptr loc_3F38E					; 6
		ptr loc_3F3A8					; 8
		ptr loc_3F406					; $A

byte_3F1FE:
		dc.b   0,  2,$20,  4,  0
		dc.b $28,  4,$10,  5,  4			; 5
		dc.b $18,  6,  8,  3,  5			; 10
		dc.b   0,  8,$20,  4,  0			; 15
		even
; ===========================================================================

loc_3F212:
		movea.l	a0,a1
		lea	$38(a0),a3
		lea	byte_3F1FE(pc),a2
		moveq	#3,d1
		bra.s	loc_3F228
; ===========================================================================

loc_3F220:
		jsrto	FindFreeObj,JmpTo20_FindFreeObj
		bne.s	loc_3F272
		move.w	a1,(a3)+

loc_3F228:
		_move.b	ost_id(a0),ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	ost_y_pos(a0),$30(a1)
		move.l	#Map_Pri,ost_mappings(a1)
		move.w	#tile_Nem_Capsule+tile_pal2,ost_tile(a1)
		move.b	#render_rel|render_onscreen,ost_render(a1)
		moveq	#0,d0
		move.b	(a2)+,d0
		sub.w	d0,ost_y_pos(a1)
		move.w	ost_y_pos(a1),$30(a1)
		move.b	(a2)+,ost_primary_routine(a1)
		move.b	(a2)+,ost_displaywidth(a1)
		move.b	(a2)+,ost_priority(a1)
		move.b	(a2)+,ost_frame(a1)

loc_3F272:
		dbf	d1,loc_3F220
		rts
; ===========================================================================

loc_3F278:
		moveq	#0,d0
		move.b	ost_secondary_routine(a0),d0
		move.w	off_3F2AE(pc,d0.w),d1
		jsr	off_3F2AE(pc,d1.w)
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	#$18,d3
		move.w	ost_x_pos(a0),d4
		jsr	(SolidObject).l
		lea	(off_3F428).l,a1
		jsr	(AnimateSprite).l
		jmp	(DespawnObject).l
; ===========================================================================
off_3F2AE:	index offset(*),,2
		ptr loc_3F2B4					; 0
		ptr loc_3F2FC					; 2
		ptr locret_3F352				; 4
; ===========================================================================

loc_3F2B4:
		movea.w	$38(a0),a1
		tst.w	$32(a1)
		beq.s	locret_3F2FA
		movea.w	$3A(a0),a2
		jsr	(FindFreeObj).l
		bne.s	loc_3F2E0
		_move.b	#id_ExplosionItem,ost_id(a1)
		addq.b	#2,ost_primary_routine(a1)
		move.w	ost_x_pos(a2),ost_x_pos(a1)
		move.w	ost_y_pos(a2),ost_y_pos(a1)

loc_3F2E0:
		move.w	#-$400,ost_y_vel(a2)
		move.w	#$800,ost_x_vel(a2)
		addq.b	#2,ost_secondary_routine(a2)
		move.w	#$1D,$34(a0)
		addq.b	#2,ost_secondary_routine(a0)

locret_3F2FA:
		rts
; ===========================================================================

loc_3F2FC:
		subq.w	#1,$34(a0)
		bpl.s	locret_3F352

loc_3F302:
		move.b	#1,ost_anim(a0)
		moveq	#7,d6

loc_3F30A:
		move.w	#$9A,d5
		moveq	#-$1C,d4

loc_3F310:
		jsr	(FindFreeObj).l
		bne.s	loc_3F340
		_move.b	#id_Animals,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		add.w	d4,ost_x_pos(a1)
		move.b	#1,$38(a1)
		addq.w	#7,d4
		move.w	d5,$36(a1)
		subq.w	#8,d5
		dbf	d6,loc_3F310

loc_3F340:
		movea.w	$3C(a0),a2
		move.w	#$B4,ost_anim_time(a2)
		addq.b	#2,ost_secondary_routine(a2)
		addq.b	#2,ost_secondary_routine(a0)

locret_3F352:
		rts
; ===========================================================================

loc_3F354:
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	ost_x_pos(a0),d4
		jsr	(SolidObject).l
		move.w	$30(a0),ost_y_pos(a0)
		move.b	ost_primary_status(a0),d0
		andi.b	#$18,d0
		beq.s	loc_3F388
		addq.w	#8,ost_y_pos(a0)
		clr.b	(f_hud_time_update).w
		move.w	#1,$32(a0)

loc_3F388:
		jmp	(DespawnObject).l

    if RemoveJmpTos
JmpTo66_DeleteObject:
		jmp	(DeleteObject).l
    endc
; ===========================================================================

loc_3F38E:
		tst.b	ost_secondary_routine(a0)
		beq.s	loc_3F3A2
		tst.b	ost_render(a0)
		bpl.w	JmpTo66_DeleteObject
		jsr	(ObjectFall).l

loc_3F3A2:
		jmp	(DespawnObject).l
; ===========================================================================

loc_3F3A8:
		tst.b	ost_secondary_routine(a0)
		beq.s	locret_3F404
		move.b	(v_vblank_counter_byte).w,d0
		andi.b	#7,d0
		bne.s	loc_3F3F4
		jsr	(FindFreeObj).l
		bne.s	loc_3F3F4
		_move.b	#id_Animals,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		subq.w	#6,d0
		tst.w	d1
		bpl.s	loc_3F3E4
		neg.w	d0

loc_3F3E4:
		add.w	d0,ost_x_pos(a1)
		move.b	#1,$38(a1)
		move.w	#$C,$36(a1)

loc_3F3F4:
		subq.w	#1,ost_anim_time(a0)
		bne.s	locret_3F404
		addq.b	#2,ost_primary_routine(a0)

loc_3F3FE:
		move.w	#$B4,ost_anim_time(a0)

locret_3F404:
		rts
; ===========================================================================

loc_3F406:
		moveq	#$6F,d0
		moveq	#id_Animals,d1
		lea	(v_ost_dynamic).w,a1

loc_3F40E:
		cmp.b	ost_id(a1),d1
		beq.s	locret_3F426
		lea	$40(a1),a1
		dbf	d0,loc_3F40E
		jsr	(loc_19452).l
		jmp	(DeleteObject).l
; ===========================================================================

locret_3F426:
		rts
; ===========================================================================
off_3F428:	index offset(*)
		ptr byte_3F42C					; 0
		ptr byte_3F42F					; 1

byte_3F42C:
		dc.b  $F,  0,$FF
		rev02even

byte_3F42F:
		dc.b   3,  0,  1,  2,  3,$FE,  1
		even
; ===========================================================================

		include "mappings/sprite/Prison Capsule.asm"

; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo66_DeleteObject:
		jmp	(DeleteObject).l
JmpTo20_FindFreeObj:
		jmp	(FindFreeObj).l

		align 4
	endc

; ===========================================================================

ReactToItem:
		nop
		jsrto	Touch_Rings,JmpTo_Touch_Rings
		cmpi.b	#id_CNZ,(v_zone).w
		bne.s	.notCNZ
		jsrto	React_CNZBumpers,JmpTo_React_CNZBumpers

	.notCNZ:
		tst.b	(v_current_boss).w
		bne.w	loc_3F666
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		subi_.w	#8,d2
		moveq	#0,d5
		move.b	ost_height(a0),d5
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$4D,ost_frame(a0)
		bne.s	loc_3F592
		addi.w	#$C,d3
		moveq	#$A,d5

loc_3F592:
		move.w	#$10,d4
		add.w	d5,d5
		lea	($FFFFB400).w,a1
		move.w	#$6F,d6

loc_3F5A0:
		move.b	ost_col_type(a1),d0
		bne.w	loc_3F5B4

loc_3F5A8:
		lea	$40(a1),a1
		dbf	d6,loc_3F5A0
		moveq	#0,d0
		rts
; ===========================================================================

loc_3F5B4:
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	React_Sizes(pc,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	ost_x_pos(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_3F5D6
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_3F5DC
		bra.w	loc_3F5A8
; ===========================================================================

loc_3F5D6:
		cmp.w	d4,d0
		bhi.w	loc_3F5A8

loc_3F5DC:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	ost_y_pos(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_3F5F6
		add.w	d1,d1
		add.w	d1,d0
		bcs.w	loc_3F6F2
		bra.w	loc_3F5A8
; ===========================================================================

loc_3F5F6:
		cmp.w	d5,d0
		bhi.w	loc_3F5A8
		bra.w	loc_3F6F2
; ===========================================================================
colid:		macro *
		id_\*: equ ((*-React_Sizes)/2)
		dc.b \1,\2
		endm

;id_col_enemy:	equ 0						; enemies
id_col_item:	equ $40						; monitors, rings, giant rings
id_col_hurt:	equ $80						; non-enemy object that hurts Sonic/Tails when touched
id_col_custom:	equ $C0						;

React_Sizes:
col_null:		colid    4,    4			; 0 ; unused
col_20x20:		colid  $14,  $14			; 1
col_12x20:		colid   $C,  $14			; 2
col_20x12:		colid  $14,   $C			; 3
col_4x16:		colid    4,  $10			; 4
col_12x18:		colid   $C,  $12			; 5
col_16x16:		colid  $10,  $10			; 6
col_6x6:		colid    6,    6			; 7
col_24x12:		colid  $18,   $C			; 8
col_12x16:		colid   $C,  $10			; 9
col_16x8:		colid  $10,    8			; $A
col_8x8:		colid    8,    8			; $B
col_20x16:		colid  $14,  $10			; $C
col_20x8		colid  $14,    8			; $D
col_14x14:		colid   $E,   $E			; $E
col_24x24:		colid  $18,  $18			; $F
col_40x16:		colid  $28,  $10			; $10
col_16x24:		colid  $10,  $18			; $11
col_8x16:		colid    8,  $10			; $12
col_32x112:		colid  $20,  $70			; $13
col_64x32:		colid  $40,  $20			; $14
col_128x32:		colid  $80,  $20			; $15
col_32x32:		colid  $20,  $20			; $16
col_8x8_2:		colid    8,    8			; $17
col_4x4:		colid    4,    4			; $18
col_32x8:		colid  $20,    8			; $19
col_12x12:		colid   $C,   $C			; $1A
col_8x4:		colid    8,    4			; $1B
col_24x4:		colid  $18,    4			; $1C
col_40x4:		colid  $28,    4			; $1D
col_4x8:		colid    4,    8			; $1E
col_4x24:		colid    4,  $18			; $1F
col_4x40:		colid    4,  $28			; $20
col_4x32:		colid    4,  $10			; $21
col_24x24_2:	colid  $18,  $18				; $22
col_12x24:		colid   $C,  $18			; $23
col_72x8:		colid  $48,    8			; $24
col_24x40:		colid  $18,  $28			; $25
col_16x4:		colid  $10,    4			; $26
col_32x2:		colid  $20,   $2			; $27
col_4x64:		colid    4,  $40			; $28
col_24x128:		colid  $18,  $80			; $29
col_32x16:		colid  $20,  $10			; $2A
col_16x32:		colid  $10,  $20			; $2B
col_16x48:		colid  $10,  $30			; $2C
col_16x64:		colid  $10,  $40			; $2D
col_16x80:		colid  $10,  $50			; $2E
col_16x2:		colid  $10,    2			; $2F
col_16x1:		colid  $10,    1			; $30
col_2x8:		colid    2,    8			; $31
col_32x28:		colid  $20,  $1C			; $32

; ===========================================================================

loc_3F666:
		lea	React_Sizes(pc),a3
		move.w	ost_x_pos(a0),d2
		move.w	ost_y_pos(a0),d3
		subi_.w	#8,d2
		moveq	#0,d5
		move.b	ost_height(a0),d5
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$4D,ost_frame(a0)
		bne.s	loc_3F68E
		addi.w	#$C,d3
		moveq	#$A,d5

loc_3F68E:
		move.w	#$10,d4
		add.w	d5,d5
		lea	($FFFFB400).w,a1
		move.w	#$6F,d6

loc_3F69C:
		move.b	ost_col_type(a1),d0
		bne.s	loc_3F6AE

loc_3F6A2:
		lea	$40(a1),a1
		dbf	d6,loc_3F69C
		moveq	#0,d0
		rts
; ===========================================================================

loc_3F6AE:
		bsr.w	loc_3FA2C
		andi.w	#$3F,d0
		beq.s	loc_3F6A2
		add.w	d0,d0
		lea	(a3,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	ost_x_pos(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_3F6D4
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_3F6D8
		bra.s	loc_3F6A2
; ===========================================================================

loc_3F6D4:
		cmp.w	d4,d0
		bhi.s	loc_3F6A2

loc_3F6D8:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	ost_y_pos(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_3F6EE
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_3F6F2
		bra.s	loc_3F6A2
; ===========================================================================

loc_3F6EE:
		cmp.w	d5,d0
		bhi.s	loc_3F6A2

loc_3F6F2:
		move.b	ost_col_type(a1),d1
		andi.b	#-$40,d1
		beq.w	loc_3F78C
		cmpi.b	#-$40,d1
		beq.w	React_Special
		tst.b	d1

loc_3F708:
		bmi.w	React_ChkHurt
		move.b	ost_col_type(a1),d0
		andi.b	#$3F,d0
		cmpi.b	#6,d0
		beq.s	React_Monitor
		move.w	($FFFFB030).w,d0
		tst.w	(f_two_player).w
		beq.s	loc_3F728
		move.w	$30(a0),d0

loc_3F728:
		cmpi.w	#$5A,d0
		bcc.w	locret_3F73A
		move.b	#4,ost_primary_routine(a1)
		move.w	a0,$3E(a1)

locret_3F73A:
		rts
; ===========================================================================

React_Monitor:
		tst.w	ost_y_vel(a0)				; is character moving upwards?
		bpl.s	.chkcharacter				; if not, branch
		move.w	ost_y_pos(a0),d0
		subi.w	#$10,d0					; d0 = y pos above character
		cmp.w	ost_y_pos(a1),d0			; is center of character above the monitor?
		bcs.s	.donothing				; if not, branch (they will phase through the side instead of breaking it)

	;.knock_down
	; knock down the monitor if they jumped into the bottom of it
		neg.w	ost_y_vel(a0)				; reverse the character's y vel
		move.w	#-$180,ost_y_vel(a1)			; set monitor's y vel
		tst.b	ost_secondary_routine(a1)
		bne.s	.donothing
		move.b	#4,ost_secondary_routine(a1)
		rts
; ===========================================================================

	.chkcharacter:
		cmpa.w	#v_ost_player1,a0
		beq.s	.break_monitor
		tst.w	(f_two_player).w
		beq.s	.donothing

	.break_monitor:
		cmpi.b	#2,ost_anim(a0)
		bne.s	.donothing
		neg.w	ost_y_vel(a0)
		move.b	#4,ost_primary_routine(a1)
		move.w	a0,$3E(a1)

	.donothing:
		rts
; ===========================================================================

loc_3F78C:
		btst	#1,$2B(a0)
		bne.s	loc_3F7A6
		cmpi.b	#9,ost_anim(a0)
		beq.s	loc_3F7A6
		cmpi.b	#2,ost_anim(a0)
		bne.w	React_ChkHurt

loc_3F7A6:
		btst	#render_subsprites_bit,ost_render(a1)
		beq.s	loc_3F7C8
		tst.b	ost_boss_hitcount2(a1)
		beq.s	locret_3F7C6
		neg.w	ost_x_vel(a0)
		neg.w	ost_y_vel(a0)
		move.b	#0,ost_col_type(a1)
		subq.b	#1,ost_boss_hitcount2(a1)

locret_3F7C6:
		rts
; ===========================================================================

loc_3F7C8:
		tst.b	ost_col_property(a1)
		beq.s	loc_3F7EA
		neg.w	ost_x_vel(a0)
		neg.w	ost_y_vel(a0)
		move.b	#0,ost_col_type(a1)
		subq.b	#1,ost_col_property(a1)
		bne.s	locret_3F7E8
		bset	#status_broken_bit,ost_primary_status(a1)

locret_3F7E8:
		rts
; ===========================================================================

loc_3F7EA:
		bset	#status_broken_bit,ost_primary_status(a1)
		moveq	#0,d0
		move.w	(v_enemy_combo).w,d0
		addq.w	#2,(v_enemy_combo).w
		cmpi.w	#6,d0
		bcs.s	loc_3F802

loc_3F800:
		moveq	#6,d0

loc_3F802:
		move.w	d0,$3E(a1)

loc_3F806:
		move.w	off_3F854(pc,d0.w),d0

loc_3F80A:
		cmpi.w	#$20,(v_enemy_combo).w
		bcs.s	loc_3F81C
		move.w	#$3E8,d0
		move.w	#$A,$3E(a1)

loc_3F81C:
		movea.w	a0,a3
		bsr.w	AddPoints2
		_move.b	#id_ExplosionItem,ost_id(a1)
		move.b	#0,ost_primary_routine(a1)
		tst.w	ost_y_vel(a0)
		bmi.s	loc_3F844
		move.w	ost_y_pos(a0),d0
		cmp.w	ost_y_pos(a1),d0
		bcc.s	loc_3F84C
		neg.w	ost_y_vel(a0)
		rts
; ===========================================================================

loc_3F844:
		addi.w	#$100,ost_y_vel(a0)
		rts
; ===========================================================================

loc_3F84C:
		subi.w	#$100,ost_y_vel(a0)
		rts
; ===========================================================================
off_3F854:
		dc.w 10, 20, 50, 100
; ===========================================================================

loc_3F85C:
		bset	#status_broken_bit,ost_primary_status(a1)

React_ChkHurt:
		btst	#1,$2B(a0)

loc_3F868:
		beq.s	loc_3F86E

loc_3F86A:
		moveq	#-1,d0
		rts
; ===========================================================================

loc_3F86E:
		nop
		tst.w	$30(a0)
		bne.s	loc_3F86A
		movea.l	a1,a2



HurtCharacter:
		move.w	(v_rings).w,d0
		cmpa.w	#-$5000,a0
		beq.s	loc_3F88C
		tst.w	(f_two_player).w

loc_3F886:
		beq.s	loc_3F8BE
		move.w	(v_rings_p2).w,d0

loc_3F88C:
		btst	#0,$2B(a0)
		bne.s	loc_3F8B8
		tst.w	d0
		beq.w	KillCharacter
		jsr	(FindFreeObj).l
		bne.s	loc_3F8B8
		_move.b	#id_RingLoss,ost_id(a1)
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		move.w	a0,$3E(a1)

loc_3F8B8:
		bclr	#0,$2B(a0)

loc_3F8BE:
		move.b	#4,ost_primary_routine(a0)
		jsrto	Sonic_ResetOnFloor_2,JmpTo_Sonic_ResetOnFloor_2
		bset	#1,ost_primary_status(a0)
		move.w	#-$400,ost_y_vel(a0)
		move.w	#-$200,ost_x_vel(a0)
		btst	#status_underwater_bit,ost_primary_status(a0)
		beq.s	loc_3F8EE
		move.w	#-$200,ost_y_vel(a0)
		move.w	#-$100,ost_x_vel(a0)

loc_3F8EE:
		move.w	ost_x_pos(a0),d0
		cmp.w	ost_x_pos(a2),d0
		bcs.s	loc_3F8FC
		neg.w	ost_x_vel(a0)

loc_3F8FC:
		move.w	#0,ost_inertia(a0)
		move.b	#$1A,ost_anim(a0)
		move.w	#$78,$30(a0)
		move.w	#$A3,d0
		cmpi.b	#$36,(a2)
		bne.s	loc_3F91C
		move.w	#$A6,d0

loc_3F91C:
		jsr	(PlaySound).l
		moveq	#-1,d0
		rts
; ===========================================================================
; loc_3F926:
KillCharacter:
		tst.w	(v_debug_active).w
		bne.s	loc_3F972
		clr.b	$2B(a0)
		move.b	#6,ost_primary_routine(a0)
		jsrto	Sonic_ResetOnFloor_2,JmpTo_Sonic_ResetOnFloor_2
		bset	#1,ost_primary_status(a0)
		move.w	#-$700,ost_y_vel(a0)
		move.w	#0,ost_x_vel(a0)
		move.w	#0,ost_inertia(a0)
		move.b	#$18,ost_anim(a0)
		bset	#tile_hi_bit,ost_tile(a0)
		move.w	#$A3,d0
		cmpi.b	#id_Spikes,ost_id(a2)
		bne.s	loc_3F96C
		move.w	#$A6,d0

loc_3F96C:
		jsr	(PlaySound).l

loc_3F972:
		moveq	#-1,d0
		rts
; ===========================================================================

React_Special:
		move.b	ost_col_type(a1),d1
		andi.b	#$3F,d1
		cmpi.b	#6,d1
		beq.s	loc_3FA00
		cmpi.b	#7,d1
		beq.w	loc_3FA18
		cmpi.b	#$B,d1
		beq.s	loc_3F9CA
		cmpi.b	#$A,d1
		beq.s	loc_3FA00
		cmpi.b	#$C,d1
		beq.s	loc_3F9CE
		cmpi.b	#$14,d1
		beq.s	loc_3FA00
		cmpi.b	#$15,d1
		beq.s	loc_3FA00
		cmpi.b	#$16,d1
		beq.s	loc_3FA00
		cmpi.b	#$17,d1
		beq.s	loc_3FA00
		cmpi.b	#$18,d1
		beq.s	loc_3FA00
		cmpi.b	#$1A,d1
		beq.s	loc_3FA22
		cmpi.b	#$21,d1
		beq.s	loc_3FA12
		rts
; ===========================================================================

loc_3F9CA:
		bra.w	loc_3F85C
; ===========================================================================

loc_3F9CE:
		sub.w	d0,d5
		cmpi.w	#8,d5
		bcc.s	loc_3F9FC
		move.w	ost_x_pos(a1),d0
		subq.w	#4,d0
		btst	#status_xflip_bit,ost_primary_status(a1)
		beq.s	loc_3F9E8
		subi.w	#$10,d0

loc_3F9E8:
		sub.w	d2,d0
		bcc.s	loc_3F9F4
		addi.w	#$18,d0
		bcs.s	loc_3F9F8
		bra.s	loc_3F9FC
; ===========================================================================

loc_3F9F4:
		cmp.w	d4,d0
		bhi.s	loc_3F9FC

loc_3F9F8:
		bra.w	React_ChkHurt
; ===========================================================================

loc_3F9FC:
		bra.w	loc_3F78C
; ===========================================================================

loc_3FA00:
		move.w	a0,d1
		subi.w	#-$5000,d1
		beq.s	loc_3FA0C
		addq.b	#1,ost_col_property(a1)

loc_3FA0C:
		addq.b	#1,ost_col_property(a1)
		rts
; ===========================================================================

loc_3FA12:
		addq.b	#1,ost_col_property(a1)
		rts
; ===========================================================================

loc_3FA18:
		move.b	#2,ost_col_property(a1)
		bra.w	loc_3F78C
; ===========================================================================

loc_3FA22:
		move.b	#-1,ost_col_property(a1)
		bra.w	loc_3F78C
; ===========================================================================

loc_3FA2C:
		cmpi.b	#$F,d0
		bne.s	locret_3FA46
		moveq	#0,d0
		move.b	(v_current_boss).w,d0
		beq.s	locret_3FA46
		subq.w	#1,d0
		add.w	d0,d0
		move.w	off_3FA48(pc,d0.w),d0
		jmp	off_3FA48(pc,d0.w)
; ===========================================================================

locret_3FA46:
		rts
; ===========================================================================
off_3FA48:	index offset(*),1,1
		ptr loc_3FA5A					; 1
		ptr loc_3FA5A					; 2
		ptr loc_3FA60					; 3
		ptr loc_3FAC8					; 4
		ptr loc_3FAFE					; 5
		ptr loc_3FB8A					; 6
		ptr loc_3FBC4					; 7
		ptr loc_3FBCA					; 8
		ptr locret_3FA5E				; 9
; ===========================================================================

loc_3FA5A:
		move.b	ost_col_type(a1),d0

locret_3FA5E:
		rts
; ===========================================================================

loc_3FA60:
		tst.b	(v_boss_collision_routine).w
		bne.s	loc_3FA68
		rts
; ===========================================================================

loc_3FA68:
		move.w	d7,-(sp)
		moveq	#0,d1
		move.b	$15(a1),d1
		subq.b	#2,d1
		cmpi.b	#7,d1
		bgt.s	loc_3FAA8
		move.w	d1,d7
		add.w	d7,d7
		move.w	ost_x_pos(a1),d0
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_3FA8E
		add.w	word_3FAB0(pc,d7.w),d0
		bra.s	loc_3FA92
; ===========================================================================

loc_3FA8E:
		sub.w	word_3FAB0(pc,d7.w),d0

loc_3FA92:
		move.b	byte_3FAC0(pc,d1.w),d1
		ori.l	#262144,d1
		move.w	ost_y_pos(a1),d7
		subi.w	#$1C,d7
		bsr.w	loc_3FC4C

loc_3FAA8:
		move.w	(sp)+,d7
		move.b	ost_col_type(a1),d0
		rts
; ===========================================================================
word_3FAB0:
		dc.w   $1C					; 0
		dc.w   $20					; 1
		dc.w   $28					; 2
		dc.w   $34					; 3
		dc.w   $3C					; 4
		dc.w   $44					; 5
		dc.w   $60					; 6
		dc.w   $70					; 7

byte_3FAC0:
		dc.b   4					; 0
		dc.b   4					; 1
		dc.b   8					; 2
		dc.b  $C					; 3
		dc.b $14					; 4
		dc.b $1C					; 5
		dc.b $24					; 6
		dc.b   8					; 7
; ===========================================================================

loc_3FAC8:
		move.w	d7,-(sp)
		move.w	ost_x_pos(a1),d0
		move.w	ost_y_pos(a1),d7
		tst.b	(v_boss_collision_routine).w
		beq.s	loc_3FAF6
		addi_.w	#4,d7
		subi.w	#$50,d0
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_3FAEC
		addi.w	#$A0,d0

loc_3FAEC:
		move.l	#$140010,d1
		bsr.w	loc_3FC4C

loc_3FAF6:
		move.w	(sp)+,d7
		move.b	ost_col_type(a1),d0
		rts
; ===========================================================================

loc_3FAFE:
		sf.b	ost_boss_hurtplayer(a1)
		cmpi.b	#1,(v_boss_collision_routine).w
		blt.s	loc_3FB46
	if FixBugs
		; The below call to 'Boss_DoCollision' clobbers a1, so back it up
		; here. This fixes Eggman not laughing when he hurts Sonic/Tails AND causes them
		; to drop rings.
		pushr.w	d7/a1
	else
		pushr.w	d7
	endc

		move.w	ost_x_pos(a1),d0
		move.w	ost_y_pos(a1),d7
		addi_.w	#4,d7
		subi.w	#$30,d0
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_3FB28
		addi.w	#$60,d0

loc_3FB28:
		move.l	#262148,d1
		bsr.w	loc_3FC4C
		move.w	(sp)+,d7
		move.b	ost_col_type(a1),d0
		cmpi.w	#$78,$30(a0)
		bne.s	locret_3FB44
		st.b	ost_boss_hurtplayer(a1)

locret_3FB44:
		rts
; ===========================================================================

loc_3FB46:
		move.w	d7,-(sp)
		movea.w	#$14,a5
		movea.w	#0,a4

loc_3FB50:
		move.w	ost_x_pos(a1),d0
		move.w	ost_y_pos(a1),d7
		subi.w	#$20,d7
		add.w	a5,d0
		move.l	#$100004,d1
		bsr.w	loc_3FC4C
		movea.w	#-$14,a5
		adda_.w	#1,a4
		cmpa.w	#1,a4
		beq.s	loc_3FB50
		move.w	(sp)+,d7
		move.b	ost_col_type(a1),d0
		cmpi.w	#$78,$30(a0)
		bne.s	locret_3FB88
		st.b	ost_boss_hurtplayer(a1)

locret_3FB88:
		rts
; ===========================================================================

loc_3FB8A:
		tst.b	(v_boss_collision_routine).w
		beq.s	loc_3FBBE
		move.w	d7,-(sp)
		move.w	ost_x_pos(a1),d0
		move.w	ost_y_pos(a1),d7
		addi.w	#$28,d7
		move.l	#$80010,d1
		cmpi.b	#1,(v_boss_collision_routine).w
		beq.s	loc_3FBB8
		move.w	#$20,d1
		subi_.w	#8,d7
		addi_.w	#4,d0

loc_3FBB8:
		bsr.w	loc_3FC4C
		move.w	(sp)+,d7

loc_3FBBE:
		move.b	ost_col_type(a1),d0
		rts
; ===========================================================================

loc_3FBC4:
		move.b	ost_col_type(a1),d0
		rts
; ===========================================================================

loc_3FBCA:
		cmpi.b	#1,(v_boss_collision_routine).w
		blt.s	loc_3FC46
		beq.s	loc_3FC1C
		move.w	d7,-(sp)
		move.w	ost_x_pos(a1),d0
		move.w	ost_y_pos(a1),d7
		moveq	#0,d1
		move.b	ost_mainspr_frame(a1),d1
		subq.b	#2,d1
		add.w	d1,d1
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_3FBF6
		add.w	word_3FC10(pc,d1.w),d0
		bra.s	loc_3FBFA
; ===========================================================================

loc_3FBF6:
		sub.w	word_3FC10(pc,d1.w),d0

loc_3FBFA:
		sub.w	word_3FC10+2(pc,d1.w),d7

loc_3FBFE:
		move.l	#$60008,d1

.init_water4:
		bsr.w	loc_3FC4C
		move.w	(sp)+,d7

.init_waterA:
		move.w	#0,d0
		rts
; ===========================================================================
word_3FC10:
		dc.w   $14,    0				; 0
		dc.w   $10,  $10				; 2
		dc.w   $10, -$10				; 4
; ===========================================================================

loc_3FC1C:
		move.w	d7,-(sp)
		move.w	ost_x_pos(a1),d0
		move.w	ost_y_pos(a1),d7
		moveq	#$10,d1
		btst	#render_xflip_bit,ost_render(a1)
		beq.s	loc_3FC32
		neg.w	d1

loc_3FC32:
		sub.w	d1,d0
		move.l	#$8000C,d1
		bsr.w	loc_3FC7A
		move.w	(sp)+,d7
		move.b	#0,d0
		rts
; ===========================================================================

loc_3FC46:
		move.b	ost_col_type(a1),d0
		rts
; ===========================================================================

loc_3FC4C:
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_3FC5A
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_3FC5E

locret_3FC58:
		rts
; ===========================================================================

loc_3FC5A:
		cmp.w	d4,d0
		bhi.s	locret_3FC58

loc_3FC5E:
		swap	d1
		sub.w	d1,d7
		sub.w	d3,d7
		bcc.s	loc_3FC70
		add.w	d1,d1
		add.w	d1,d7
		bcs.w	React_ChkHurt
		bra.s	locret_3FC58
; ===========================================================================

loc_3FC70:
		cmp.w	d5,d7
		bhi.w	locret_3FC58
		bra.w	React_ChkHurt
; ===========================================================================

loc_3FC7A:
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_3FC88
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_3FC8C

locret_3FC86:
		rts
; ===========================================================================

loc_3FC88:
		cmp.w	d4,d0
		bhi.s	locret_3FC86

loc_3FC8C:
		swap	d1
		sub.w	d1,d7
		sub.w	d3,d7
		bcc.s	loc_3FC9E
		add.w	d1,d1
		add.w	d1,d7
		bcs.w	loc_3FCA4
		bra.s	locret_3FC86
; ===========================================================================

loc_3FC9E:
		cmp.w	d5,d7
		bhi.w	locret_3FC86

loc_3FCA4:
		neg.w	ost_x_vel(a0)
		neg.w	ost_y_vel(a0)
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo_Sonic_ResetOnFloor_2:
		jmp	(Sonic_ResetOnFloor_2).l
JmpTo_React_CNZBumpers:
		jmp	(React_CNZBumpers).l
JmpTo_Touch_Rings:
		jmp	(Touch_Rings).l

		align 4
	endc

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed gfx for and animate level animations
; (e.g., EHZ flowers, HTZ lava)
; ---------------------------------------------------------------------------
; loc_3FCC4: AniArt_Load:
AnimateLevelGFX:
		moveq	#0,d0
		move.b	(v_zone).w,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	AniArt_Index+2(pc,d0.w),d1
		lea	AniArt_Index(pc,d1.w),a2		; a2 = pointer to dynamic reload script
		move.w	AniArt_Index(pc,d0.w),d0
		jmp	AniArt_Index(pc,d0.w)
; ===========================================================================

		rts						; dead code

; ---------------------------------------------------------------------------
; Dynamic and Animated pattern load cue
;
; Two offsets per level. First points to the Animated pattern load cue to
; use for the level. Second points to the Dynamic reload script.
; ---------------------------------------------------------------------------
AniArt_Index:	index offset(*),,2
		ptr Dynamic_Normal				; EHZ
		ptr Animated_EHZ

		ptr Dynamic_Null				; unused
		ptr Animated_Null

		ptr Dynamic_Null				; unused
		ptr Animated_Null

		ptr Dynamic_Null				; unused
		ptr Animated_Null

		ptr Dynamic_Normal				; MTZ 1 & 2
		ptr Animated_MTZ

		ptr Dynamic_Normal				; MTZ 3
		ptr Animated_MTZ

		ptr Dynamic_Null				; WFZ; unused
		ptr Animated_Null

		ptr Dynamic_HTZ					; HTZ
		ptr Animated_HTZ				; custom animation routines for distant blue background mountains and clouds

		ptr Dynamic_Normal				; HPZ; unused beta leftover
		ptr Animated_HPZ

		ptr Dynamic_Null				; unused
		ptr Animated_Null

		ptr Dynamic_Normal				; OOZ
		ptr Animated_OOZ

		ptr Dynamic_Null				; MCZ; unused
		ptr Animated_Null

		ptr Dynamic_CNZ					; CNZ
		ptr Animated_CNZ				; skip if in boss fight; use different scripts for 2P mode

		ptr Dynamic_Normal				; CPZ
		ptr Animated_CPZ

		ptr Dynamic_Normal				; DEZ
		ptr Animated_DEZ

		ptr Dynamic_ARZ					; ARZ
		ptr Animated_ARZ				; skip if in boss fight

		ptr Dynamic_Null				; SCZ; unused
		ptr Animated_Null
		zonewarning	AniArt_Index,4
; ===========================================================================

Dynamic_Null:
		rts

; ---------------------------------------------------------------------------
; Update the distant blue mountains in HTZ's background.
; The graphics are stashed in main RAM within the 128x128 maps, replacing
; various unused tiles.
; ---------------------------------------------------------------------------

Dynamic_HTZ:
		tst.w	(f_two_player).w
		bne.w	Dynamic_Normal				; branch if we're in two-player mode
		lea	(v_anim_counters).w,a3
		moveq	#0,d0
		move.w	(v_camera_x_pos).w,d1
		neg.w	d1
		asr.w	#3,d1					; d1 = negated camera x pos / 8
		move.w	(v_camera_x_pos).w,d0

	if FixBugs
		move.w	d0,d2
		andi.w	#$F,d2					; is the lower nibble zero?
		seq.b	d2					; if so, set low byte of d2 to $FF
		ext.w	d2					; low word of d2 = -1
		lsr.w	#4,d0					; d0 = camera x pos / 16
		add.w	d1,d0
		add.w	d2,d0					; add $FFFF to correct the value
	else
		; This produces the wrong result if the camera x pos is a multiple of $10, specifically,
		; producing a value 1 higher than intended. This off-by-one causes the mountains to
		; occasionally scroll one pixel in the wrong direction, before jumping two pixels
		; back to "catch up."
		lsr.w	#4,d0					; d0 = camera x pos / 16
		add.w	d1,d0
	endc
		subi.w	#$10,d0					; minus 16
		divu.w	#$30,d0					; divide by 48
		swap	d0					; swap remainder into lower word
		cmp.b	1(a3),d0
		beq.s	.skip_mountains				; branch if second counter is same as remainder

		move.b	d0,1(a3)				; store new remainder
		move.w	d0,d2
		andi.w	#7,d0					; only lowest three bits
		add.w	d0,d0
		add.w	d0,d0
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0					; multiply by 24
		andi.w	#$38,d2					; only bits 3-5
		lsr.w	#2,d2					; divide by 4
		add.w	d2,d0					; d0 = index
		lea	HTZ_CliffTiles(pc,d0.w),a4		; a4 = address of first set of tiles in RAM
		moveq	#6-1,d5					; six DMAs to perform
		move.w	#vram_HTZMountains,d4			; destination in VRAM

	.loop:
		moveq	#-1,d1
		move.w	(a4)+,d1				; get offset of tiles
		andi.l	#$FFFFFF,d1				; source address
		move.w	d4,d2					; set destination
		moveq	#(sizeof_cell*4)/2,d3			; 4 tiles to copy
		jsr	(AddDMA).l				; queue the DMA
		addi.w	#sizeof_cell*4,d4			; next destination address
		dbf	d5,.loop

	.skip_mountains:
		bra.w	Dynamic_HTZ_Clouds

; ---------------------------------------------------------------------------
; Offsets to locations within v_128x128_tiles where HTZ's distant background
; cliff art is stored.

; Expressed in terms of size of 128x128 tiles to show which tile IDs are
; replaced with graphics.
; ---------------------------------------------------------------------------

HTZ_CliffTiles:
		dc.w sizeof_128x128*1,		sizeof_128x128*3, 	sizeof_128x128*5,	sizeof_128x128*$B, 	sizeof_128x128*$C, 	sizeof_128x128*$E
		dc.w sizeof_128x128*1, 		sizeof_128x128*3, 	sizeof_128x128*5, 	sizeof_128x128*$B, 	sizeof_128x128*$C, 	sizeof_128x128*$E
		dc.w sizeof_128x128*$13,	sizeof_128x128*$15, sizeof_128x128*$17, sizeof_128x128*$19, sizeof_128x128*$1A, sizeof_128x128*$1B
		dc.w sizeof_128x128*$13,	sizeof_128x128*$15, sizeof_128x128*$17, sizeof_128x128*$19, sizeof_128x128*$1A, sizeof_128x128*$1B
		dc.w sizeof_128x128*$1D,	sizeof_128x128*$23,	sizeof_128x128*$24,	sizeof_128x128*$25,	sizeof_128x128*$26,	sizeof_128x128*$27
		dc.w sizeof_128x128*$1D,	sizeof_128x128*$23,	sizeof_128x128*$24,	sizeof_128x128*$25,	sizeof_128x128*$26,	sizeof_128x128*$27
		dc.w sizeof_128x128*$28,	sizeof_128x128*$29,	sizeof_128x128*$2A,	sizeof_128x128*$2B,	sizeof_128x128*$2C,	sizeof_128x128*$32
		dc.w sizeof_128x128*$28,	sizeof_128x128*$29,	sizeof_128x128*$2A,	sizeof_128x128*$2B,	sizeof_128x128*$2C,	sizeof_128x128*$32
		dc.w sizeof_128x128*$3A,	sizeof_128x128*$3B,	sizeof_128x128*$3C,	sizeof_128x128*$3F,	sizeof_128x128*$48,	sizeof_128x128*$4B
		dc.w sizeof_128x128*$3A,	sizeof_128x128*$3B,	sizeof_128x128*$3C,	sizeof_128x128*$3F,	sizeof_128x128*$48,	sizeof_128x128*$4B
		dc.w sizeof_128x128*$4C,	sizeof_128x128*$4D,	sizeof_128x128*$4F,	sizeof_128x128*$56,	sizeof_128x128*$5E,	sizeof_128x128*$65
		dc.w sizeof_128x128*$4C,	sizeof_128x128*$4D,	sizeof_128x128*$4F,	sizeof_128x128*$56,	sizeof_128x128*$5E,	sizeof_128x128*$65
		dc.w sizeof_128x128*$6C,	sizeof_128x128*$6D,	sizeof_128x128*$6F,	sizeof_128x128*$79,	sizeof_128x128*$7A,	sizeof_128x128*$7E
		dc.w sizeof_128x128*$6C,	sizeof_128x128*$6D,	sizeof_128x128*$6F,	sizeof_128x128*$79,	sizeof_128x128*$7A,	sizeof_128x128*$7E
		dc.w sizeof_128x128*$7F,	sizeof_128x128*$81,	sizeof_128x128*$89,	sizeof_128x128*$8B,	sizeof_128x128*$91,	sizeof_128x128*$92
		dc.w sizeof_128x128*$7F,	sizeof_128x128*$81,	sizeof_128x128*$89,	sizeof_128x128*$8B,	sizeof_128x128*$91,	sizeof_128x128*$92
		arraysize	HTZ_CliffTiles

; ---------------------------------------------------------------------------
; Builds the HTZ clouds from individual 1*8 pixel primitives
; ---------------------------------------------------------------------------

Dynamic_HTZ_Clouds:
		lea	(v_bgscroll_buffer).w,a1
		move.w	(v_camera_x_pos).w,d2			; get camera x pos
		neg.w	d2					; negate
		asr.w	#3,d2					; divide by 8
		pushr.l	a2					; back up dynamic script pointer
		lea	(Art_HTZClouds).l,a0			; uncompressed cloud graphics (set of 1x8 pixel primitives)
		lea	(v_128x128_tiles+(sizeof_128x128*$F8)).l,a2 ; buffer for cloud GFX
		moveq	#(8*2)-1,d1				; build 16 tiles total; first 8 loops build 4, next 8 remaining 4

	.cloud_loop:
		move.w	(a1)+,d0				; get value generated by Deform_HTZ
		neg.w	d0					; negate
		add.w	d2,d0					; add negated x pos (overflows to positive)
		andi.w	#$1F,d0					; only first five bits
		lsr.w	#1,d0					; divide by 2
		bcc.s	.even					; branch if index is even
		addi.w	#$200,d0				; adjust index

	.even:
		lea	(a0,d0.w),a4				; a4 = location in uncompressed tiles to start copy
		lsr.w	#1,d0
		bcs.s	.odd					; branch if start location is odd

		rept 3
		move.l	(a4)+,(a2)+				; copy one line of tile (8 pixels)
		adda.w	#(sizeof_cell*2)-4,a2			; skip ahead two tiles
		endr

		move.l	(a4)+,(a2)+				; copy one line of tile
		suba.w	#sizeof_cell*6,a2			; start building next line of each tile
		adda.w	#sizeof_cell,a0				; increment base address for calculating copy start by one tile
		dbf	d1,.cloud_loop
		bra.s	.add_dma
; ===========================================================================

	.odd:
		rept 3
		rept 4
		move.b	(a4)+,(a2)+				; copy two pixels
		endr						; repeat until full line of tile is copied (note that they could have used a word move bracketed by two byte moves)
		adda.w	#(sizeof_cell*2)-4,a2			; skip ahead two tiles
		endr
		rept 4
		move.b	(a4)+,(a2)+				; copy two pixels
		endr						; repeat until full line is copied
		suba.w	#sizeof_cell*6,a2			; start building next line of each tile
		adda.w	#sizeof_cell,a0				; increment base address for calculating copy start by one tile
		dbf	d1,.cloud_loop

	.add_dma:
		move.l	#(v_128x128_tiles+(sizeof_128x128*$F8))&$FFFFFF,d1 ; DMA source
		move.w	#vram_HTZClouds,d2			; DMA destination
		move.w	#(sizeof_cell*8)/2,d3			; DMA length
		jsr	(AddDMA).l
		popr.l	a2					; back up dynamic script pointer
		addq.w	#2,a3					; a3 = animation frame counters for HTZ's standard scripts
		bra.w	Dynamic_Normal2				; all done with custom animations; run HTZ's standard dynamic scripts
; ===========================================================================

Dynamic_CNZ:
		tst.b	(v_current_boss).w
		beq.s	.chk_2p					; skip animations if boss fight is in progress
		rts
; ===========================================================================

	.chk_2p:
		lea	(Animated_CNZ).l,a2			; unnecessary as a2 already points to this
		tst.w	(f_two_player).w
		beq.s	Dynamic_Normal				; branch if we're not in 2P mode
		lea	(Animated_CNZ_2P).l,a2			; use 2p-mode specific scripts
		bra.s	Dynamic_Normal
; ===========================================================================

Dynamic_ARZ:
		tst.b	(v_current_boss).w
		beq.s	Dynamic_Normal				; skip animations if boss fight is in progress
		rts

; ---------------------------------------------------------------------------
; Zone animation script header structure
; ---------------------------------------------------------------------------
		rsreset
aniscrpt_globaldur:	rs.l 1					; 0; global duration value in highest byte
aniscrpt_source:	equ aniscrpt_globaldur			; 0; source address in lower three bytes
aniscrpt_dest:		rs.w 1					; 4; VRAM destination
aniscrpt_size:		rs.b 1					; 6; count of individual elements in script
aniscrpt_tilecnt:	rs.b 1					; 7; count of tiles to copy in this script
aniscrpt_start:		rs.b 1					; 8; start of actual script
aniscrpt_tileid:	equ aniscrpt_start			; 8; ID of first tile in source to copy
aniscrpt_perframedur: rs.b 1					; 9; per frame duration of first tile if applicable

; ---------------------------------------------------------------------------
; Subroutine to process dynamic zone animation scripts

; input:
;	a2 = pointer to script list

; uses d0.l, d1.l, d2.w, d3.w, d6.w, a3
; ---------------------------------------------------------------------------

Dynamic_Normal:
		lea	(v_anim_counters).w,a3			; a3 = animation frame counters

Dynamic_Normal2:
		move.w	(a2)+,d6				; get count of scripts in list

	.loop:
		subq.b	#1,zoneanim_duration(a3)		; decrement duration counter
		bcc.s	.nextscript				; skip to next script if frames remains

	;.next_frame:
		moveq	#0,d0
		move.b	zoneanim_frames(a3),d0			; get current frame
		cmp.b	aniscrpt_size(a2),d0			; have we processed the last frame in the script?
		bcs.s	.not_last_frame				; branch if not
		moveq	#0,d0
		move.b	d0,zoneanim_frames(a3)			; reset to first frame (could be clr.b)

	.not_last_frame:
		addq.b	#1,zoneanim_frames(a3)			; increment frame ID
		move.b	aniscrpt_globaldur(a2),zoneanim_duration(a3) ; get global duration value
		bpl.s	.global_duration			; branch if this script uses a global duration
		add.w	d0,d0					; d0 = index to per-frame duration
		move.b	aniscrpt_perframedur(a2,d0.w),zoneanim_duration(a3) ; get per-frame duration

	.global_duration:
		move.b	aniscrpt_tileid(a2,d0.w),d0		; get tile id
		lsl.w	#5,d0					; turn into offset within uncompressed source
		move.w	aniscrpt_dest(a2),d2			; get VRAM destination
		move.l	aniscrpt_source(a2),d1			; get start address of uncompressed source
		andi.l	#$FFFFFF,d1				; remove global duration in high byte
		add.l	d0,d1					; add offset to make source address
		moveq	#0,d3
		move.b	aniscrpt_tilecnt(a2),d3			; get count of tiles to copy
		lsl.w	#4,d3					; make into DMA length
		jsr	(AddDMA).l

	.nextscript:
		move.b	aniscrpt_size(a2),d0			; get total size of script
		tst.b	aniscrpt_globaldur(a2)
		bpl.s	.global_duration2			; branch if we're using a global duration
		add.b	d0,d0					; double size to account for additional duration byte in each script element

	.global_duration2:
		addq.b	#1,d0
		andi.w	#$FE,d0					; round to even address
		lea	aniscrpt_start(a2,d0.w),a2		; advance to next script in list
		addq.w	#2,a3					; advance to next script's counters
		dbf	d6,.loop				; repeat for all scripts
		rts

; ---------------------------------------------------------------------------
; Start an animation script list
; ---------------------------------------------------------------------------

zoneanimstart: macro *
		\*: equ *
		zoneanimcount: = 0				; initialize counter
		zoneanimcur: equs "\*"
		dc.w zoneanimcount_\*				; count of scripts-1
   		endm

; ---------------------------------------------------------------------------
; Terminate an animation script list
; ---------------------------------------------------------------------------

zoneanimend: macro
		zoneanimcount_\zoneanimcur: equ zoneanimcount-1	; count of scripts-1
    	endm

; ---------------------------------------------------------------------------
; Start an animation script

; input: global frame duration, or -1 if per-frame durations are used, source
; art address, destination VRAM address, count of tiles to update each frame
; ---------------------------------------------------------------------------

zoneanimdecl: macro *,duration,artaddr,vramaddr,numvramtiles
		\*: equ *
		zoneanimcurdecl:	equs "\*_ani"		; label used to calculate size of script

		dc.l (\duration&$FF)<<24|\artaddr		; global script duration and source art address
		dc.w \vramaddr					; destination VRAM address

	if \duration=-1
		dc.b sizeof_\zoneanimcurdecl/2			; size of script with custom durations
	else
		dc.b sizeof_\zoneanimcurdecl			; size of script without custom durations
	endc

		dc.b \numvramtiles				; number of tiles to load for each frame
		zoneanimcount: = zoneanimcount+1		; increment counter

	\zoneanimcurdecl:					; start of script proper
    	endm

; ---------------------------------------------------------------------------
; Terminate an animation script
; ---------------------------------------------------------------------------

zoneanimdeclend:	macro
		arraysize	\zoneanimcurdecl		; make size constant for script
		even						; align to even address
		endm

; ---------------------------------------------------------------------------
; Dynamic reloading scripts for background and foreground animations.

; First byte of each script element is the index of the first tile in the
; source art to transfer; second byte, if present, is a custom duration for
; the frame.
; ---------------------------------------------------------------------------

Animated_EHZ:	zoneanimstart
Animated_EHZ_Flowers1:	zoneanimdecl -1,Art_Flowers1,vram_Flowers1,2
		dc.b   0,$7F
		dc.b   2,$13
		dc.b   0,  7
		dc.b   2,  7
		dc.b   0,  7
		dc.b   2,  7
		zoneanimdeclend

Animated_EHZ_Flowers2:	zoneanimdecl -1,Art_Flowers2,vram_Flowers2,2
		dc.b   2,$7F
		dc.b   0, $B
		dc.b   2, $B
		dc.b   0, $B
		dc.b   2,  5
		dc.b   0,  5
		dc.b   2,  5
		dc.b   0,  5
		zoneanimdeclend

Animated_EHZ_Flowers3:	zoneanimdecl 7,Art_Flowers3,vram_Flowers3,2
		dc.b   0
		dc.b   2
		zoneanimdeclend

Animated_EHZ_Flowers4:	zoneanimdecl -1,Art_Flowers4,vram_Flowers4,2
		dc.b   0,$7F
		dc.b   2,  7
		dc.b   0,  7
		dc.b   2,  7
		dc.b   0,  7
		dc.b   2, $B
		dc.b   0, $B
		dc.b   2, $B
		zoneanimdeclend

Animated_EHZ_PulseBall: zoneanimdecl -1,Art_EHZPulseBall,vram_EHZPulseBall,2
		dc.b   0,$17
		dc.b   2,  9
		dc.b   4, $B
		dc.b   6,$17
		dc.b   4, $B
		dc.b   2,  9
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_MTZ:	zoneanimstart
Animated_MTZ_Cylinder:	zoneanimdecl 0,Art_MTZCylinder,vram_MTZCylinder,$10
		dc.b   0
		dc.b $10
		dc.b $20
		dc.b $30
		dc.b $40
		dc.b $50
		dc.b $60
		dc.b $70
		zoneanimdeclend

Animated_MTZ_Lava:	zoneanimdecl $D,Art_Lava,vram_Lava,$C
		dc.b   0
		dc.b  $C
		dc.b $18
		dc.b $24
		dc.b $18
		dc.b  $C
		zoneanimdeclend

Animated_MTZ_AnimBack1:	zoneanimdecl -1,Art_MTZAnimBack,vram_MTZAnimBack1,6
		dc.b   0,$13
		dc.b   6,  7
		dc.b  $C,$13
		dc.b   6,  7
		zoneanimdeclend

Animated_MTZ_AnimBack2:	zoneanimdecl -1,Art_MTZAnimBack,vram_MTZAnimBack2,6
		dc.b  $C,$13
		dc.b   6,  7
		dc.b   0,$13
		dc.b   6,  7
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_HTZ:	zoneanimstart
Animated_HTZ_Flowers1:	zoneanimdecl -1,Art_Flowers1,vram_Flowers1,2
		dc.b   0,$7F
		dc.b   2,$13
		dc.b   0,  7
		dc.b   2,  7
		dc.b   0,  7
		dc.b   2,  7
		zoneanimdeclend

Animated_HTZ_Flowers2:	zoneanimdecl -1,Art_Flowers2,vram_Flowers2,2
		dc.b   2,$7F
		dc.b   0, $B
		dc.b   2, $B
		dc.b   0, $B
		dc.b   2,  5
		dc.b   0,  5
		dc.b   2,  5
		dc.b   0,  5
		zoneanimdeclend

Animated_HTZ_Flowers3:	zoneanimdecl 7,Art_Flowers3,vram_Flowers3,2
		dc.b   0
		dc.b   2
		zoneanimdeclend

Animated_HTZ_Flowers4:	zoneanimdecl -1,Art_Flowers4,vram_Flowers4,2
		dc.b   0,$7F
		dc.b   2,  7
		dc.b   0,  7
		dc.b   2,  7
		dc.b   0,  7
		dc.b   2, $B
		dc.b   0, $B
		dc.b   2, $B
		zoneanimdeclend

Animated_HTZ_PulseBall:	zoneanimdecl -1,Art_EHZPulseBall,vram_EHZPulseBall,2
		dc.b   0,$17
		dc.b   2,  9
		dc.b   4, $B
		dc.b   6,$17
		dc.b   4, $B
		dc.b   2,  9
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_HPZ:	zoneanimstart
Animated_HPZ_PulseBall1: zoneanimdecl 8,Art_OOZPulseBall,vram_HPZPulseOrb1,8
		dc.b   0
		dc.b   0
		dc.b   8
		dc.b $10
		dc.b $10
		dc.b   8
		zoneanimdeclend

Animated_HPZ_PulseBall2: zoneanimdecl 8,Art_OOZPulseBall,vram_HPZPulseOrb2,8
		dc.b   8
		dc.b $10
		dc.b $10
		dc.b   8
		dc.b   0
		dc.b   0
		zoneanimdeclend

Animated_HPZ_PulseBall3: zoneanimdecl 8,Art_OOZPulseBall,vram_HPZPulseOrb3,8
		dc.b $10
		dc.b   8
		dc.b   0
		dc.b   0
		dc.b   8
		dc.b $10
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_OOZ:	zoneanimstart
Animated_OOZ_PulseBall:	zoneanimdecl	-1,Art_OOZPulseBall,vram_OOZPulseBall,4
		dc.b   0
		dc.b  $B
		dc.b   4
		dc.b   5
		dc.b   8
		dc.b   9
		dc.b   4
		dc.b   3
		zoneanimdeclend

Animated_OOZ_SquareBall1:	zoneanimdecl 6,Art_OOZSquareBall1,vram_OOZSquareBall1,4
		dc.b   0
		dc.b   4
		dc.b   8
		dc.b  $C
		zoneanimdeclend

Animated_OOZ_SquareBall2:	zoneanimdecl 6,Art_OOZSquareBall2,vram_OOZSquareBall2,4
		dc.b   0
		dc.b   4
		dc.b   8
		dc.b  $C
		zoneanimdeclend

Animated_OOZ_Oil1:	zoneanimdecl $11,Art_Oil1,vram_Oil1,$10
		dc.b   0
		dc.b $10
		dc.b $20
		dc.b $30
		dc.b $20
		dc.b $10
		zoneanimdeclend

Animated_OOZ_Oil2:	zoneanimdecl $11,Art_Oil2,vram_Oil2,$10
		dc.b   0
		dc.b $10
		dc.b $20
		dc.b $30
		dc.b $20
		dc.b $10
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_CNZ:	zoneanimstart
Animated_CNZ_FlipTiles2:	zoneanimdecl -1,Art_CNZFlipPanels,vram_CNZFlipPanels2,$10
		dc.b   0,$C7
		dc.b $10,  5
		dc.b $20,  5
		dc.b $30,  5
		dc.b $40,$C7
		dc.b $50,  5
		dc.b $20,  5
		dc.b $60,  5
		dc.b   0,  5
		dc.b $10,  5
		dc.b $20,  5
		dc.b $30,  5
		dc.b $40,  5
		dc.b $50,  5
		dc.b $20,  5
		dc.b $60,  5
		zoneanimdeclend

Animated_CNZ_FlipTiles1:	zoneanimdecl -1,Art_CNZFlipPanels,vram_CNZFlipPanels1,$10
		dc.b $70,  5
		dc.b $80,  5
		dc.b $20,  5
		dc.b $90,  5
		dc.b $A0,  5
		dc.b $B0,  5
		dc.b $20,  5
		dc.b $C0,  5
		dc.b $70,$C7
		dc.b $80,  5
		dc.b $20,  5
		dc.b $90,  5
		dc.b $A0,$C7
		dc.b $B0,  5
		dc.b $20,  5
		dc.b $C0,  5
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_CNZ_2P:	zoneanimstart
Animated_CNZ_2P_FlipTiles2:	zoneanimdecl -1,Art_CNZFlipPanels,vram_CNZFlipPanels2_2p,$10
		dc.b   0,$C7
		dc.b $10,  5
		dc.b $20,  5
		dc.b $30,  5
		dc.b $40,$C7
		dc.b $50,  5
		dc.b $20,  5
		dc.b $60,  5
		dc.b   0,  5
		dc.b $10,  5
		dc.b $20,  5
		dc.b $30,  5
		dc.b $40,  5
		dc.b $50,  5
		dc.b $20,  5
		dc.b $60,  5
		zoneanimdeclend

Animated_CNZ_2P_FlipTiles1:	zoneanimdecl -1,Art_CNZFlipPanels,vram_CNZFlipPanels1_2p,$10
		dc.b $70,  5
		dc.b $80,  5
		dc.b $20,  5
		dc.b $90,  5
		dc.b $A0,  5
		dc.b $B0,  5
		dc.b $20,  5
		dc.b $C0,  5
		dc.b $70,$C7
		dc.b $80,  5
		dc.b $20,  5
		dc.b $90,  5
		dc.b $A0,$C7
		dc.b $B0,  5
		dc.b $20,  5
		dc.b $C0,  5
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_CPZ:	zoneanimstart
Animated_CPZ_AniBack:	zoneanimdecl 4,Art_CPZAnimBack,vram_CPZAnimBack,2
		dc.b   0
		dc.b   2
		dc.b   4
		dc.b   6
		dc.b   8
		dc.b  $A
		dc.b  $C
		dc.b  $E
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_DEZ:	zoneanimstart
Animated_DEZ_Aniback:	zoneanimdecl	4,Art_CPZAnimBack,vram_DEZAnimBack,2
		dc.b   0
		dc.b   2
		dc.b   4
		dc.b   6
		dc.b   8
		dc.b  $A
		dc.b  $C
		dc.b  $E
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_ARZ:	zoneanimstart
Animated_ARZ_WaterFall1_2:	zoneanimdecl 5,Art_Waterfall1,vram_WaterFall1_2,4
		dc.b   0
		dc.b   4
		zoneanimdeclend

Animated_ARZ_WaterFall1_1:	zoneanimdecl 5,Art_Waterfall1,vram_WaterFall1_1,4
		dc.b   4
		dc.b   0
		zoneanimdeclend

Animated_ARZ_WaterFall2:	zoneanimdecl 5,Art_Waterfall2,vram_WaterFall2,4
		dc.b   0
		dc.b   4
		zoneanimdeclend

Animated_ARZ_WaterFall3:	zoneanimdecl 5,Art_Waterfall3,vram_WaterFall3,4
		dc.b   0
		dc.b   4
		zoneanimdeclend
		zoneanimend
; ===========================================================================

Animated_Null:

; ---------------------------------------------------------------------------
; Unused custom background animation routine for CPZ

; In CPZ, if the camera x pos is within the range of $1940-$1F80 (exactly two
; screen widths wide), rotate 128x128 tiles $EA-$ED and $FA-$FD to the left
; by shifting all 16x16 block indicies to the left by one, moving the first
; index of each line into the end of the corresponding line in the previous
; chunk, and shifting the first index of the first tile to the very end.
; ---------------------------------------------------------------------------

Unused_CPZAnim:
		cmpi.b	#id_CPZ,(v_zone).w
		beq.s	.doanim					; branch if it's CPZ

	.noanim:
		rts
; ===========================================================================

.doanim:
		move.w	(v_camera_x_pos).w,d0			; d0 - camera x pos
		cmpi.w	#$1940,d0
		bcs.s	.noanim					; branch if camera is left of $1940
		cmpi.w	#$1F80,d0
		bcc.s	.noanim					; branch if camera is right of $1F80
		subq.b	#1,(v_unused_cpz_scroll_timer).w	; decrement timer
		bpl.s	.noanim					; branch if time remains
		move.b	#7,(v_unused_cpz_scroll_timer).w	; reset timer
		move.b	#1,(f_screen_redraw).w			; force redraw of entire screen
		lea	(v_128x128_tiles+(sizeof_128x128*$EA)).l,a1 ; 128x128 tiles $EA-$ED
		bsr.s	.chunkshift
		lea	(v_128x128_tiles+(sizeof_128x128*$FA)).l,a1 ; 128x128 tiles $FA-$FD

.chunkshift:
		move.w	#8-1,d1					; 8 lines per tile

	.loop:
		move.w	(a1),d0					; first word of first line will be shifted into end

    	rept 3

     	rept 7							; 7 blocks to shift within tile
		move.w	2(a1),(a1)+				; shift one line of 128x128 tile by 1 block to the left
      	endr

		move.w	sizeof_128x128-$E(a1),(a1)+		; shift first 16x16 index of corresponding line in next 128x128 tile to the left into end of previous tile
		adda.w	#sizeof_128x128-$10,a1			; advance to corresponding line of next tile
   		endr						; repeat for first three tiles

     	rept 7							; 7 blocks to shift within chunk
		move.w	2(a1),(a1)+				; shift line of fourth and final 128x128 tile by 1 block to the left
      	endr

		move.w	d0,(a1)+				; shift first word of line in first tile to the end
		suba.w	#sizeof_128x128*3,a1			; advance to next line in all tiles
		dbf	d1,.loop				; repeat for all lines of each tile
		rts

; ---------------------------------------------------------------------------
; Subroutine to load animated blocks
; ---------------------------------------------------------------------------

AnimatedBlocksLoad:
		cmpi.b	#id_HTZ,(v_zone).w			; is it HTZ?
		bne.s	.notHTZ					; branch if not
		bsr.w	LoadHTZCliffArt				; load art for HTZ's distant background cliffs
		move.b	#-1,(v_anim_counters+1).w
		move.w	#-1,(v_bgscroll_buffer+$20).w		; set otherwise unused flag in BG scroll buffer

	.notHTZ:
		cmpi.b	#id_CPZ,(v_zone).w			; is it CPZ?
		bne.s	.notCPZ					; branch if not
		move.b	#-1,(v_anim_counters+1).w

	.notCPZ:
		moveq	#0,d0
		move.b	(v_zone).w,d0
		add.w	d0,d0					; zone ID is index
		move.w	AniPatMap_Index(pc,d0.w),d0
		lea	AniPatMap_Index(pc,d0.w),a0		; a0 = animated block list for current zone
		tst.w	(f_two_player).w
		beq.s	.notCNZ2P				; branch if we're not in 2P mode
		cmpi.b	#id_CNZ,(v_zone).w
		bne.s	.notCNZ2P				; branch if it's not CNZ
		lea	(APM_CNZ_2P).l,a0			; use the 2P-mode specific list for CNZ

	.notCNZ2P:
		tst.w	(a0)
		beq.s	.done					; branch if no animated blocks are defined for current zone
		lea	(v_16x16_tiles).w,a1
		adda.w	(a0)+,a1				; a1 = start of animated blocks in v_16x16_tiles
		move.w	(a0)+,d1				; d1 = loop counter
		tst.w	(f_two_player).w			; is it 2P mode?
		bne.s	.loop_2P				; if so,  use the 2p-mode specific copy code

	.loop:
		move.w	(a0)+,(a1)+				; copy to block table
		dbf	d1,.loop

	.done:
		rts

; ---------------------------------------------------------------------------
; Same as above, but adjusts the tile offset for 2P mode
; ---------------------------------------------------------------------------

.loop_2P:
		move.w	(a0)+,d0				; get tile word

	if FixBugs
		move.w	d0,d2					; should be using a different register
		andi.w	#tile_settings,d0			; strip tile index
		andi.w	#tile_vram,d2				; strip tile settings
		lsr.w	#1,d2					; adjust tile index for 2P mode
		or.w	d2,d0					; or them back together
	else
		; This overwrites the loop counter with VRAM data!
		move.w	d0,d1					; should be using a different register
		andi.w	#tile_settings,d0			; strip tile index
		andi.w	#tile_vram,d1				; strip tile settings
		lsr.w	#1,d1					; adjust tile index for 2P mode
		or.w	d1,d0					; or them back together
	endc

		move.w	d0,(a1)+				; write to block table
		dbf	d1,.loop_2P
		rts

; ---------------------------------------------------------------------------
; Start an animated block list
; ---------------------------------------------------------------------------

anipat:	macro *
		\*: equ *
		current_anipat:	equs "\*"
		dc.w ((sizeof_16x16_all*2)-sizeof_\*_Blocks)	; start offset of animated blocks in v_16x16_tiles
		dc.w (sizeof_\*_Blocks/2)-1			; loops to copy blocks in word-length moves
	\*_Blocks:
		endm

; ---------------------------------------------------------------------------
; Terminate an animated block list
; ---------------------------------------------------------------------------

anipat_end:	macros
		arraysize	\current_anipat\_Blocks

; ---------------------------------------------------------------------------
; Animated 16x16 block lists
; ---------------------------------------------------------------------------

AniPatMap_Index:	index offset(*),,1
		ptr APM_EHZ_HTZ					; EHZ
		ptr APM_Null					; unused
		ptr APM_Null					; unused
		ptr APM_Null					; unused
		ptr APM_MTZ					; MTZ 1 and 2
		ptr APM_MTZ					; MTZ 3
		ptr APM_Null					; unused
		ptr APM_EHZ_HTZ					; HTZ
		ptr APM_HPZ					; HPZ (unused beta leftover)
		ptr APM_Null					; unused
		ptr APM_OOZ					; OOZ
		ptr APM_Null					; unused
		ptr APM_CNZ					; CNZ
		ptr APM_CPZ					; CPZ
		ptr APM_DEZ					; DEZ
		ptr APM_ARZ					; ARZ
		ptr APM_Null					; unused
		zonewarning	AniPatMap_Index,2

APM_EHZ_HTZ:	anipat
		dc.w tile_Art_EHZMountains+tile_pal3,		tile_Art_EHZMountains+4+tile_pal3
		dc.w tile_Art_EHZMountains+1+tile_pal3,		tile_Art_EHZMountains+5+tile_pal3

		dc.w tile_Art_EHZMountains+8+tile_pal3,		tile_Art_EHZMountains+$C+tile_pal3
		dc.w tile_Art_EHZMountains+9+tile_pal3,		tile_Art_EHZMountains+$D+tile_pal3

		dc.w tile_Art_EHZMountains+$10+tile_pal3,	tile_Art_EHZMountains+$14+tile_pal3
		dc.w tile_Art_EHZMountains+$11+tile_pal3,	tile_Art_EHZMountains+$15+tile_pal3

		dc.w tile_Art_EHZMountains+2+tile_pal3,		tile_Art_EHZMountains+6+tile_pal3
		dc.w tile_Art_EHZMountains+3+tile_pal3,		tile_Art_EHZMountains+7+tile_pal3

		dc.w tile_Art_EHZMountains+$A+tile_pal3,	tile_Art_EHZMountains+$E+tile_pal3
		dc.w tile_Art_EHZMountains+$B+tile_pal3,	tile_Art_EHZMountains+$F+tile_pal3

		dc.w tile_Art_EHZMountains+$12+tile_pal3,	tile_Art_EHZMountains+$16+tile_pal3
		dc.w tile_Art_EHZMountains+$13+tile_pal3,	tile_Art_EHZMountains+$17+tile_pal3

		dc.w tile_Art_EHZMountains+$18+tile_pal4,	tile_Art_EHZMountains+$1A+tile_pal4
		dc.w tile_Art_EHZMountains+$19+tile_pal4,	tile_Art_EHZMountains+$1B+tile_pal4

		dc.w tile_Art_EHZMountains+$1C+tile_pal4,	tile_Art_EHZMountains+$1E+tile_pal4
		dc.w tile_Art_EHZMountains+$1D+tile_pal4,	tile_Art_EHZMountains+$1F+tile_pal4

		dc.w tile_Art_EHZPulseBall+tile_pal3,		tile_Art_EHZPulseBall+blockmap_xflip+tile_pal3
		dc.w tile_Art_EHZPulseBall+1+tile_pal3,		tile_Art_EHZPulseBall+1+blockmap_xflip+tile_pal3

		dc.w tile_Kos_Checkers+tile_pal3,			tile_Art_EHZPulseBall+tile_pal3
		dc.w tile_Kos_Checkers+1+tile_pal3,			tile_Art_EHZPulseBall+1+tile_pal3

		dc.w tile_Art_EHZPulseBall+blockmap_xflip+tile_pal3,		tile_Kos_Checkers+blockmap_xflip+tile_pal3
		dc.w tile_Art_EHZPulseBall+1+blockmap_xflip+tile_pal3,	tile_Kos_Checkers+1+blockmap_xflip+tile_pal3

		dc.w tile_Art_Flowers1+tile_pal4,						tile_Art_Flowers1+blockmap_xflip+tile_pal4
		dc.w tile_Art_Flowers1+1+tile_pal4,						tile_Art_Flowers1+1+blockmap_xflip+tile_pal4

		dc.w tile_Art_Flowers2+tile_pal4+blockmap_hi,			tile_Art_Flowers2+blockmap_xflip+tile_pal4+blockmap_hi
		dc.w tile_Art_Flowers2+1+tile_pal4+blockmap_hi,			tile_Art_Flowers2+1+blockmap_xflip+tile_pal4+blockmap_hi

		dc.w tile_Art_Flowers3+tile_pal4,						tile_Art_Flowers3+blockmap_xflip+tile_pal4
		dc.w tile_Art_Flowers3+1+tile_pal4,						tile_Art_Flowers3+1+blockmap_xflip+tile_pal4

		dc.w tile_Art_Flowers4+tile_pal4+blockmap_hi,			tile_Art_Flowers4+blockmap_xflip+tile_pal4+blockmap_hi
		dc.w tile_Art_Flowers4+1+tile_pal4+blockmap_hi,			tile_Art_Flowers4+1+blockmap_xflip+tile_pal4+blockmap_hi
		anipat_end
; ===========================================================================

APM_MTZ:	anipat
		dc.w tile_Art_MTZAnimBack1+tile_pal2,		tile_Art_MTZAnimBack1+blockmap_xflip+tile_pal2
		dc.w tile_Art_MTZAnimBack1+1+tile_pal2,		tile_Art_MTZAnimBack1+1+blockmap_xflip+tile_pal2

		dc.w tile_Art_MTZAnimBack1+2+tile_pal2,		tile_Art_MTZAnimBack1+2+blockmap_xflip+tile_pal2
		dc.w tile_Art_MTZAnimBack1+3+tile_pal2,		tile_Art_MTZAnimBack1+3+blockmap_xflip+tile_pal2

		dc.w tile_Art_MTZCylinder+$E+tile_pal4,		tile_Art_MTZCylinder+$E+tile_pal4
		dc.w tile_Art_MTZCylinder+$F+tile_pal4,		tile_Art_MTZCylinder+$F+tile_pal4

		dc.w tile_Art_MTZCylinder+$C+tile_pal4,		tile_Art_MTZCylinder+$C+tile_pal4
		dc.w tile_Art_MTZCylinder+$D+tile_pal4,		tile_Art_MTZCylinder+$D+tile_pal4

		dc.w tile_Art_MTZCylinder+$A+tile_pal4,		tile_Art_MTZCylinder+$A+tile_pal4
		dc.w tile_Art_MTZCylinder+$B+tile_pal4,		tile_Art_MTZCylinder+$B+tile_pal4

		dc.w tile_Art_MTZCylinder+8+tile_pal4,		tile_Art_MTZCylinder+8+tile_pal4
		dc.w tile_Art_MTZCylinder+9+tile_pal4,		tile_Art_MTZCylinder+9+tile_pal4

		dc.w tile_Art_MTZCylinder+6+tile_pal4,		tile_Art_MTZCylinder+6+tile_pal4
		dc.w tile_Art_MTZCylinder+7+tile_pal4,		tile_Art_MTZCylinder+7+tile_pal4

		dc.w tile_Art_MTZCylinder+4+tile_pal4,		tile_Art_MTZCylinder+4+tile_pal4
		dc.w tile_Art_MTZCylinder+5+tile_pal4,		tile_Art_MTZCylinder+5+tile_pal4

		dc.w tile_Art_MTZCylinder+2+tile_pal4,		tile_Art_MTZCylinder+2+tile_pal4
		dc.w tile_Art_MTZCylinder+3+tile_pal4,		tile_Art_MTZCylinder+3+tile_pal4

		dc.w tile_Art_MTZCylinder+tile_pal4,		tile_Art_MTZCylinder+tile_pal4
		dc.w tile_Art_MTZCylinder+1+tile_pal4,		tile_Art_MTZCylinder+1+tile_pal4

		dc.w tile_Art_MTZAnimBack1+4+tile_pal2,		tile_Art_MTZAnimBack1+4+blockmap_xflip+tile_pal2
		dc.w tile_Art_MTZAnimBack1+5+tile_pal2,		tile_Art_MTZAnimBack1+5+blockmap_xflip+tile_pal2

		dc.w tile_Art_MTZAnimBack2+tile_pal2,		tile_Art_MTZAnimBack2+blockmap_xflip+tile_pal2
		dc.w tile_Art_MTZAnimBack2+1+tile_pal2,		tile_Art_MTZAnimBack2+1+blockmap_xflip+tile_pal2

		dc.w tile_Art_MTZAnimBack2+2+tile_pal2,		tile_Art_MTZAnimBack2+2+blockmap_xflip+tile_pal2
		dc.w tile_Art_MTZAnimBack2+3+tile_pal2,		tile_Art_MTZAnimBack2+3+blockmap_xflip+tile_pal2

		dc.w tile_Art_MTZAnimBack2+4+tile_pal2,		tile_Art_MTZAnimBack2+4+blockmap_xflip+tile_pal2
		dc.w tile_Art_MTZAnimBack2+5+tile_pal2,		tile_Art_MTZAnimBack2+5+blockmap_xflip+tile_pal2

		dc.w tile_LevelArt+tile_pal3+blockmap_hi,	tile_LevelArt+tile_pal3+blockmap_hi
		dc.w tile_Art_Lava+tile_pal3+blockmap_hi,	tile_Art_Lava+1+tile_pal3+blockmap_hi

		dc.w tile_LevelArt+tile_pal3+blockmap_hi,	tile_LevelArt+tile_pal3+blockmap_hi
		dc.w tile_Art_Lava+2+tile_pal3+blockmap_hi,	tile_Art_Lava+3+tile_pal3+blockmap_hi

		dc.w tile_Art_Lava+4+tile_pal3+blockmap_hi,	tile_Art_Lava+5+tile_pal3+blockmap_hi
		dc.w tile_Art_Lava+8+tile_pal3+blockmap_hi,	tile_Art_Lava+9+tile_pal3+blockmap_hi

		dc.w tile_Art_Lava+6+tile_pal3+blockmap_hi,	tile_Art_Lava+7+tile_pal3+blockmap_hi
		dc.w tile_Art_Lava+$A+tile_pal3+blockmap_hi,	tile_Art_Lava+$B+tile_pal3+blockmap_hi

		dc.w tile_Art_MTZCylinder+$E+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+$E+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+$F+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+$F+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+$C+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+$C+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+$D+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+$D+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+$A+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+$A+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+$B+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+$B+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+8+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+8+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+9+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+9+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+6+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+6+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+7+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+7+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+4+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+4+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+5+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+5+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+2+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+2+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+3+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+3+tile_pal4+blockmap_hi

		dc.w tile_Art_MTZCylinder+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+tile_pal4+blockmap_hi
		dc.w tile_Art_MTZCylinder+1+tile_pal4+blockmap_hi,		tile_Art_MTZCylinder+1+tile_pal4+blockmap_hi
		anipat_end
; ===========================================================================

APM_HPZ:	anipat
		dc.w tile_Art_HPZPulseOrb1+tile_pal4,	tile_Art_HPZPulseOrb1+1+tile_pal4
		dc.w tile_Art_HPZPulseOrb1+2+tile_pal4,	tile_Art_HPZPulseOrb1+3+tile_pal4

		dc.w tile_Art_HPZPulseOrb1+4+tile_pal4,	tile_Art_HPZPulseOrb1+5+tile_pal4
		dc.w tile_Art_HPZPulseOrb1+6+tile_pal4,	tile_Art_HPZPulseOrb1+7+tile_pal4

		dc.w tile_Art_HPZPulseOrb2+tile_pal4,	tile_Art_HPZPulseOrb2+1+tile_pal4
		dc.w tile_Art_HPZPulseOrb2+2+tile_pal4,	tile_Art_HPZPulseOrb2+3+tile_pal4

		dc.w tile_Art_HPZPulseOrb2+4+tile_pal4,	tile_Art_HPZPulseOrb2+5+tile_pal4
		dc.w tile_Art_HPZPulseOrb2+6+tile_pal4,	tile_Art_HPZPulseOrb2+7+tile_pal4

		dc.w tile_Art_HPZPulseOrb3+tile_pal4,	tile_Art_HPZPulseOrb3+1+tile_pal4
		dc.w tile_Art_HPZPulseOrb3+2+tile_pal4,	tile_Art_HPZPulseOrb3+3+tile_pal4

		dc.w tile_Art_HPZPulseOrb3+4+tile_pal4,	tile_Art_HPZPulseOrb3+5+tile_pal4
		dc.w tile_Art_HPZPulseOrb3+6+tile_pal4,	tile_Art_HPZPulseOrb3+7+tile_pal4

		dc.w tile_Art_HPZPulseOrb1+tile_pal3,	tile_Art_HPZPulseOrb1+1+tile_pal3
		dc.w tile_Art_HPZPulseOrb1+2+tile_pal3,	tile_Art_HPZPulseOrb1+3+tile_pal3

		dc.w tile_Art_HPZPulseOrb1+4+tile_pal3,	tile_Art_HPZPulseOrb1+5+tile_pal3
		dc.w tile_Art_HPZPulseOrb1+6+tile_pal3,	tile_Art_HPZPulseOrb1+7+tile_pal3

		dc.w tile_Art_HPZPulseOrb2+tile_pal3,	tile_Art_HPZPulseOrb2+1+tile_pal3
		dc.w tile_Art_HPZPulseOrb2+2+tile_pal3,	tile_Art_HPZPulseOrb2+3+tile_pal3

		dc.w tile_Art_HPZPulseOrb2+4+tile_pal3,	tile_Art_HPZPulseOrb2+5+tile_pal3
		dc.w tile_Art_HPZPulseOrb2+6+tile_pal3,	tile_Art_HPZPulseOrb2+7+tile_pal3

		dc.w tile_Art_HPZPulseOrb3+tile_pal3,	tile_Art_HPZPulseOrb3+1+tile_pal3
		dc.w tile_Art_HPZPulseOrb3+2+tile_pal3,	tile_Art_HPZPulseOrb3+3+tile_pal3

		dc.w tile_Art_HPZPulseOrb3+4+tile_pal3,	tile_Art_HPZPulseOrb3+5+tile_pal3
		dc.w tile_Art_HPZPulseOrb3+6+tile_pal3,	tile_Art_HPZPulseOrb3+7+tile_pal3

	if Revision=2
		; In Revision 2,the palette lines of HPZ's blank tiles were, for some reason,
		; changed to line 4. This is consistent with MTZ's blank tiles. Notably, the new
		; palette lines' first entry always happens to match the current VDP background
		; color.
		dc.w tile_LevelArt+tile_pal4, 			tile_Art_HPZPulseOrb1+tile_pal4
		dc.w tile_LevelArt+tile_pal4, 			tile_Art_HPZPulseOrb1+2+tile_pal4
	else
		dc.w tile_LevelArt, 					tile_Art_HPZPulseOrb1+tile_pal4
		dc.w tile_LevelArt, 					tile_Art_HPZPulseOrb1+2+tile_pal4
	endc

		dc.w tile_Art_HPZPulseOrb1+1+tile_pal4, tile_Art_HPZPulseOrb1+4+tile_pal4
		dc.w tile_Art_HPZPulseOrb1+3+tile_pal4, tile_Art_HPZPulseOrb1+6+tile_pal4

	if Revision=2
		dc.w tile_Art_HPZPulseOrb1+5+tile_pal4, tile_LevelArt+tile_pal4
		dc.w tile_Art_HPZPulseOrb1+7+tile_pal4, tile_LevelArt+tile_pal4

		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb2+tile_pal4
		dc.w tile_LevelArt+tile_pal4, 			tile_Art_HPZPulseOrb2+2+tile_pal4
	else
		dc.w tile_Art_HPZPulseOrb1+5+tile_pal4, tile_LevelArt
		dc.w tile_Art_HPZPulseOrb1+7+tile_pal4, tile_LevelArt

		dc.w tile_LevelArt, 					tile_Art_HPZPulseOrb2+tile_pal4
		dc.w tile_LevelArt, 					tile_Art_HPZPulseOrb2+2+tile_pal4
	endc

		dc.w tile_Art_HPZPulseOrb2+1+tile_pal4, tile_Art_HPZPulseOrb2+4+tile_pal4
		dc.w tile_Art_HPZPulseOrb2+3+tile_pal4, tile_Art_HPZPulseOrb2+6+tile_pal4

	if Revision=2
		dc.w tile_Art_HPZPulseOrb2+5+tile_pal4, tile_LevelArt+tile_pal4
		dc.w tile_Art_HPZPulseOrb2+7+tile_pal4, tile_LevelArt+tile_pal4

		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb3+tile_pal4
		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb3+2+tile_pal4
	else
		dc.w tile_Art_HPZPulseOrb2+5+tile_pal4, tile_LevelArt
		dc.w tile_Art_HPZPulseOrb2+7+tile_pal4, tile_LevelArt

		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb3+tile_pal4
		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb3+2+tile_pal4
	endc

		dc.w tile_Art_HPZPulseOrb3+1+tile_pal4, tile_Art_HPZPulseOrb3+4+tile_pal4
		dc.w tile_Art_HPZPulseOrb3+3+tile_pal4, tile_Art_HPZPulseOrb3+6+tile_pal4

	if Revision=2
		dc.w tile_Art_HPZPulseOrb3+5+tile_pal4, tile_LevelArt+tile_pal4
		dc.w tile_Art_HPZPulseOrb3+7+tile_pal4, tile_LevelArt+tile_pal4

		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb1+tile_pal3
		dc.w tile_LevelArt+tile_pal4, 			tile_Art_HPZPulseOrb1+2+tile_pal3
	else
		dc.w tile_Art_HPZPulseOrb3+5+tile_pal4, tile_LevelArt
		dc.w tile_Art_HPZPulseOrb3+7+tile_pal4, tile_LevelArt

		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb1+tile_pal3
		dc.w tile_LevelArt, 					tile_Art_HPZPulseOrb1+2+tile_pal3
	endc

		dc.w tile_Art_HPZPulseOrb1+1+tile_pal3, tile_Art_HPZPulseOrb1+4+tile_pal3
		dc.w tile_Art_HPZPulseOrb1+3+tile_pal3, tile_Art_HPZPulseOrb1+6+tile_pal3

	if Revision=2
		dc.w tile_Art_HPZPulseOrb1+5+tile_pal3, tile_LevelArt+tile_pal4
		dc.w tile_Art_HPZPulseOrb1+7+tile_pal3, tile_LevelArt+tile_pal4

		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb2+tile_pal3
		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb2+2+tile_pal3
	else
		dc.w tile_Art_HPZPulseOrb1+5+tile_pal3,	tile_LevelArt
		dc.w tile_Art_HPZPulseOrb1+7+tile_pal3, tile_LevelArt

		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb2+tile_pal3
		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb2+2+tile_pal3
	endc

		dc.w tile_Art_HPZPulseOrb2+1+tile_pal3, tile_Art_HPZPulseOrb2+4+tile_pal3
		dc.w tile_Art_HPZPulseOrb2+3+tile_pal3, tile_Art_HPZPulseOrb2+6+tile_pal3

	if Revision=2
		dc.w tile_Art_HPZPulseOrb2+5+tile_pal3, tile_LevelArt+tile_pal4
		dc.w tile_Art_HPZPulseOrb2+7+tile_pal3, tile_LevelArt+tile_pal4

		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb3+tile_pal3
		dc.w tile_LevelArt+tile_pal4,			tile_Art_HPZPulseOrb3+2+tile_pal3
	else
		dc.w tile_Art_HPZPulseOrb2+5+tile_pal3, tile_LevelArt
		dc.w tile_Art_HPZPulseOrb2+7+tile_pal3, tile_LevelArt

		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb3+tile_pal3
		dc.w tile_LevelArt,						tile_Art_HPZPulseOrb3+2+tile_pal3
	endc

		dc.w tile_Art_HPZPulseOrb3+1+tile_pal3, tile_Art_HPZPulseOrb3+4+tile_pal3
		dc.w tile_Art_HPZPulseOrb3+3+tile_pal3, tile_Art_HPZPulseOrb3+6+tile_pal3

	if Revision=2
		dc.w tile_Art_HPZPulseOrb3+5+tile_pal3, tile_LevelArt+tile_pal4
		dc.w tile_Art_HPZPulseOrb3+7+tile_pal3, tile_LevelArt+tile_pal4
	else
		dc.w tile_Art_HPZPulseOrb3+5+tile_pal3, tile_LevelArt
		dc.w tile_Art_HPZPulseOrb3+7+tile_pal3, tile_LevelArt
	endc
		anipat_end
; ===========================================================================

APM_OOZ:	anipat
		dc.w tile_Art_OOZPulseBall+blockmap_hi, 					tile_Art_OOZPulseBall+2+blockmap_hi
		dc.w tile_Art_OOZPulseBall+1+blockmap_hi, 				tile_Art_OOZPulseBall+3+blockmap_hi

		dc.w tile_Art_OOZSquareBall1+tile_pal4+blockmap_hi,		tile_Art_OOZSquareBall1+1+tile_pal4+blockmap_hi
		dc.w tile_Art_OOZSquareBall1+2+tile_pal4+blockmap_hi, 	tile_Art_OOZSquareBall1+3+tile_pal4+blockmap_hi

	if Revision=2
		; Same deal as with HPZ's blocks, except they were changed to use palette line 3.
		dc.w tile_LevelArt+tile_pal3, 					tile_Art_OOZSquareBall2+tile_pal4
		dc.w tile_LevelArt+tile_pal3, 					tile_Art_OOZSquareBall2+2+tile_pal4

		dc.w tile_Art_OOZSquareBall2+1+tile_pal4,		tile_LevelArt+tile_pal3
		dc.w tile_Art_OOZSquareBall2+3+tile_pal4,		tile_LevelArt+tile_pal3
	else
		dc.w tile_LevelArt,								tile_Art_OOZSquareBall2+tile_pal4
		dc.w tile_LevelArt,								tile_Art_OOZSquareBall2+2+tile_pal4

		dc.w tile_Art_OOZSquareBall2+1+tile_pal4,		tile_LevelArt
		dc.w tile_Art_OOZSquareBall2+3+tile_pal4,		tile_LevelArt
	endc

		dc.w tile_Art_Oil1+tile_pal3+blockmap_hi,		tile_Art_Oil1+tile_pal3+1+blockmap_hi
		dc.w tile_Art_Oil1+8+tile_pal3+blockmap_hi, 		tile_Art_Oil1+tile_pal3+9+blockmap_hi

		dc.w tile_Art_Oil1+2+tile_pal3+blockmap_hi,		tile_Art_Oil1+tile_pal3+3+blockmap_hi
		dc.w tile_Art_Oil1+$A+tile_pal3+blockmap_hi, 	tile_Art_Oil1+tile_pal3+$B+blockmap_hi

		dc.w tile_Art_Oil1+4+tile_pal3+blockmap_hi,		tile_Art_Oil1+tile_pal3+5+blockmap_hi
		dc.w tile_Art_Oil1+$C+tile_pal3+blockmap_hi, 	tile_Art_Oil1+tile_pal3+$D+blockmap_hi

		dc.w tile_Art_Oil1+6+tile_pal3+blockmap_hi,		tile_Art_Oil1+tile_pal3+7+blockmap_hi
		dc.w tile_Art_Oil1+$E+tile_pal3+blockmap_hi, 	tile_Art_Oil1+tile_pal3+$F+blockmap_hi

		dc.w tile_Art_Oil2+tile_pal3+blockmap_hi,		tile_Art_Oil2+tile_pal3+1+blockmap_hi
		dc.w tile_Art_Oil2+8+tile_pal3+blockmap_hi, 		tile_Art_Oil2+tile_pal3+9+blockmap_hi

		dc.w tile_Art_Oil2+2+tile_pal3+blockmap_hi,		tile_Art_Oil2+tile_pal3+3+blockmap_hi
		dc.w tile_Art_Oil2+$A+tile_pal3+blockmap_hi, 	tile_Art_Oil2+tile_pal3+$B+blockmap_hi

		dc.w tile_Art_Oil2+4+tile_pal3+blockmap_hi,		tile_Art_Oil2+tile_pal3+5+blockmap_hi
		dc.w tile_Art_Oil2+$C+tile_pal3+blockmap_hi, 	tile_Art_Oil2+tile_pal3+$D+blockmap_hi

		dc.w tile_Art_Oil2+6+tile_pal3+blockmap_hi,		tile_Art_Oil2+tile_pal3+7+blockmap_hi
		dc.w tile_Art_Oil2+$E+tile_pal3+blockmap_hi, 	tile_Art_Oil2+tile_pal3+$F+blockmap_hi
		anipat_end
; ===========================================================================

APM_CNZ:	anipat
		dc.w tile_Art_SlotPics1,	tile_Art_SlotPics1+4
		dc.w tile_Art_SlotPics1+1,	tile_Art_SlotPics1+5

		dc.w tile_Art_SlotPics1+8,	tile_Art_SlotPics1+$C
		dc.w tile_Art_SlotPics1+9,	tile_Art_SlotPics1+$D

		dc.w tile_Art_SlotPics1+2,	tile_Art_SlotPics1+6
		dc.w tile_Art_SlotPics1+3,	tile_Art_SlotPics1+7

		dc.w tile_Art_SlotPics1+$A,	tile_Art_SlotPics1+$E
		dc.w tile_Art_SlotPics1+$B,	tile_Art_SlotPics1+$F

		dc.w tile_Art_SlotPics2,	tile_Art_SlotPics2+4
		dc.w tile_Art_SlotPics2+1,	tile_Art_SlotPics2+5

		dc.w tile_Art_SlotPics2+8,	tile_Art_SlotPics2+$C
		dc.w tile_Art_SlotPics2+9,	tile_Art_SlotPics2+$D

		dc.w tile_Art_SlotPics2+2,	tile_Art_SlotPics2+6
		dc.w tile_Art_SlotPics2+3,	tile_Art_SlotPics2+7

		dc.w tile_Art_SlotPics2+$A,	tile_Art_SlotPics2+$E
		dc.w tile_Art_SlotPics2+$B,	tile_Art_SlotPics2+$F

		dc.w tile_Art_SlotPics3,	tile_Art_SlotPics3+4
		dc.w tile_Art_SlotPics3+1,	tile_Art_SlotPics3+5

		dc.w tile_Art_SlotPics3+8,	tile_Art_SlotPics3+$C
		dc.w tile_Art_SlotPics3+9,	tile_Art_SlotPics3+$D

		dc.w tile_Art_SlotPics3+2,	tile_Art_SlotPics3+6
		dc.w tile_Art_SlotPics3+3,	tile_Art_SlotPics3+7

		dc.w tile_Art_SlotPics3+$A,	tile_Art_SlotPics3+$E
		dc.w tile_Art_SlotPics3+$B,	tile_Art_SlotPics3+$F

		dc.w tile_Art_CNZFlipPanels2+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2+4+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2+1+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+5+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels2+8+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+$C+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2+9+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+$D+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels2+2+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+6+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2+3+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+7+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels2+$A+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+$E+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2+$B+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2+$F+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1+4+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1+1+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+5+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1+8+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+$C+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1+9+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+$D+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1+2+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+6+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1+3+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+7+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1+$A+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+$E+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1+$B+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1+$F+tile_pal4+blockmap_hi
		anipat_end
; ===========================================================================

APM_CNZ_2P:	anipat
		dc.w tile_Art_SlotPics1_2p,	tile_Art_SlotPics1_2p+4
		dc.w tile_Art_SlotPics1_2p+1,	tile_Art_SlotPics1_2p+5

		dc.w tile_Art_SlotPics1_2p+8,	tile_Art_SlotPics1_2p+$C
		dc.w tile_Art_SlotPics1_2p+9,	tile_Art_SlotPics1_2p+$D

		dc.w tile_Art_SlotPics1_2p+2,	tile_Art_SlotPics1_2p+6
		dc.w tile_Art_SlotPics1_2p+3,	tile_Art_SlotPics1_2p+7

		dc.w tile_Art_SlotPics1_2p+$A,	tile_Art_SlotPics1_2p+$E
		dc.w tile_Art_SlotPics1_2p+$B,	tile_Art_SlotPics1_2p+$F

		dc.w tile_Art_SlotPics2_2p,	tile_Art_SlotPics2_2p+4
		dc.w tile_Art_SlotPics2_2p+1,	tile_Art_SlotPics2_2p+5

		dc.w tile_Art_SlotPics2_2p+8,	tile_Art_SlotPics2_2p+$C
		dc.w tile_Art_SlotPics2_2p+9,	tile_Art_SlotPics2_2p+$D

		dc.w tile_Art_SlotPics2_2p+2,	tile_Art_SlotPics2_2p+6
		dc.w tile_Art_SlotPics2_2p+3,	tile_Art_SlotPics2_2p+7

		dc.w tile_Art_SlotPics2_2p+$A,	tile_Art_SlotPics2_2p+$E
		dc.w tile_Art_SlotPics2_2p+$B,	tile_Art_SlotPics2_2p+$F

		dc.w tile_Art_SlotPics3_2p,	tile_Art_SlotPics3_2p+4
		dc.w tile_Art_SlotPics3_2p+1,	tile_Art_SlotPics3_2p+5

		dc.w tile_Art_SlotPics3_2p+8,	tile_Art_SlotPics3_2p+$C
		dc.w tile_Art_SlotPics3_2p+9,	tile_Art_SlotPics3_2p+$D

		dc.w tile_Art_SlotPics3_2p+2,	tile_Art_SlotPics3_2p+6
		dc.w tile_Art_SlotPics3_2p+3,	tile_Art_SlotPics3_2p+7

		dc.w tile_Art_SlotPics3_2p+$A,	tile_Art_SlotPics3_2p+$E
		dc.w tile_Art_SlotPics3_2p+$B,	tile_Art_SlotPics3_2p+$F

		dc.w tile_Art_CNZFlipPanels2_2p+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2_2p+4+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2_2p+1+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2_2p+5+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels2_2p+8+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2_2p+$C+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2_2p+9+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2_2p+$D+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels2_2p+2+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2_2p+6+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2_2p+3+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels2_2p+7+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels2_2p+$A+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2_2p+$E+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels2_2p+$B+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels2_2p+$F+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1_2p+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1_2p+4+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1_2p+1+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1_2p+5+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1_2p+8+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1_2p+$C+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1_2p+9+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1_2p+$D+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1_2p+2+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1_2p+6+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1_2p+3+tile_pal4+blockmap_hi,		tile_Art_CNZFlipPanels1_2p+7+tile_pal4+blockmap_hi

		dc.w tile_Art_CNZFlipPanels1_2p+$A+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1_2p+$E+tile_pal4+blockmap_hi
		dc.w tile_Art_CNZFlipPanels1_2p+$B+tile_pal4+blockmap_hi,	tile_Art_CNZFlipPanels1_2p+$F+tile_pal4+blockmap_hi
		anipat_end
; ===========================================================================

APM_CPZ:	anipat
		dc.w tile_Art_CPZAnimBack+tile_pal3, tile_Art_CPZAnimBack+1+tile_pal3
		dc.w tile_Art_CPZAnimBack+tile_pal3, tile_Art_CPZAnimBack+1+tile_pal3
		anipat_end
; ===========================================================================

APM_DEZ:	anipat
		dc.w tile_Art_DEZAnimBack+tile_pal3, tile_Art_DEZAnimBack+1+tile_pal3
		dc.w tile_Art_DEZAnimBack+tile_pal3, tile_Art_DEZAnimBack+1+tile_pal3
		anipat_end
; ===========================================================================

APM_ARZ:	anipat
		dc.w tile_Art_Waterfall3+tile_pal3+blockmap_hi,		tile_Art_Waterfall3+1+tile_pal3+blockmap_hi
		dc.w tile_Art_Waterfall3+2+tile_pal3+blockmap_hi,	tile_Art_Waterfall3+3+tile_pal3+blockmap_hi

		dc.w tile_Art_Waterfall2+tile_pal3+blockmap_hi,		tile_Art_Waterfall2+1+tile_pal3+blockmap_hi
		dc.w tile_Art_Waterfall2+2+tile_pal3+blockmap_hi,	tile_Art_Waterfall2+3+tile_pal3+blockmap_hi

		dc.w tile_Art_Waterfall1_1+tile_pal3+blockmap_hi,	tile_Art_Waterfall1_1+1+tile_pal3+blockmap_hi
		dc.w tile_Art_Waterfall1_1+2+tile_pal3+blockmap_hi,	tile_Art_Waterfall1_1+3+tile_pal3+blockmap_hi

	if FixBugs
		dc.w tile_Art_Waterfall1_2+tile_pal3+blockmap_hi,		tile_Art_Waterfall1_2+1+tile_pal3+blockmap_hi
		dc.w tile_Art_Waterfall1_2+2+tile_pal3+blockmap_hi,		tile_Art_Waterfall1_2+3+tile_pal3+blockmap_hi
	else
		; Those '+$C's shouldn't be here; these are invalid animation entries for waterfalls.
		dc.w tile_Art_Waterfall1_2+tile_pal3+blockmap_hi+$C,		tile_Art_Waterfall1_2+1+tile_pal3+blockmap_hi+$C
		dc.w tile_Art_Waterfall1_2+2+tile_pal3+blockmap_hi+$C,	tile_Art_Waterfall1_2+3+tile_pal3+blockmap_hi+$C
	endc

		dc.w tile_Art_Waterfall3+tile_pal3,			tile_Art_Waterfall3+1+tile_pal3
		dc.w tile_Art_Waterfall3+2+tile_pal3,		tile_Art_Waterfall3+3+tile_pal3

		dc.w tile_Art_Waterfall2+tile_pal3,			tile_Art_Waterfall2+1+tile_pal3
		dc.w tile_Art_Waterfall2+2+tile_pal3,		tile_Art_Waterfall2+3+tile_pal3

		dc.w tile_Art_Waterfall1_1+tile_pal3,		tile_Art_Waterfall1_1+1+tile_pal3
		dc.w tile_Art_Waterfall1_1+2+tile_pal3,		tile_Art_Waterfall1_1+3+tile_pal3

	if FixBugs
		dc.w tile_Art_Waterfall1_2+tile_pal3,		tile_Art_Waterfall1_2+1+tile_pal3
		dc.w tile_Art_Waterfall1_2+2+tile_pal3,		tile_Art_Waterfall1_2+3+tile_pal3
	else
		; Those '+$C's shouldn't be here; these are invalid animation entries for waterfalls.
		dc.w tile_Art_Waterfall1_2+tile_pal3+$C,	tile_Art_Waterfall1_2+1+tile_pal3+$C
		dc.w tile_Art_Waterfall1_2+2+tile_pal3+$C,	tile_Art_Waterfall1_2+3+tile_pal3+$C
	endc

		anipat_end
; ===========================================================================

APM_Null:
		dc.w   0

; ---------------------------------------------------------------------------
; Subroutine to load the tiles for HTZ's distant blue background cliffs

; These tiles are loaded in RAM in groups of four within HTZ's 128x128 maps,
; replacing unused 128x128 tiles.
; ---------------------------------------------------------------------------

LoadHTZCliffArt:
		lea	(Nem_HTZCliffs).l,a0
		lea	(v_ost_dynamic_end-$1800).w,a4		; part of the OST is used as a decompression buffer
		jsrto	NemDecToRAM,JmpTo2_NemDecToRAM
		lea	(v_ost_dynamic_end-$1800).w,a1
		lea_	HTZ_CliffTiles,a4			; table of addresses within 128x128 chunk maps where tiles are copied
		moveq	#0,d2
		moveq	#(sizeof_HTZ_CliffTiles/(2*6*2))-1,d4	; 8 unique rows in table; 2 as each row is duplicated, 6 for number of entries in each row, 2 as each entry is a word

	.loop1:
		moveq	#6-1,d3					; six entries in each row of table

	.loop2:
		moveq	#-1,d0					; $FFFF in high word
		move.w	(a4)+,d0				; move offset from table into low word to make destination address
		movea.l	d0,a2
		moveq	#(sizeof_cell*4)/4-1,d1			; copy 4 tiles

	.loop3:
		move.l	(a1),(a2)+				; copy 8 pixels
		move.l	d2,(a1)+				; clear OST RAM that was used as decomp buffer
		dbf	d1,.loop3				; repeat for four tile
		dbf	d3,.loop2				; repeat for entire row of table
		adda.w	#6*2,a4					; skip duplicated row in HTZ_CliffTiles
		dbf	d4,.loop1				; repeat for entire table
		rts
; ===========================================================================

	if Revision<2
		nop
	endc

	if RemoveJmpTos=0
JmpTo2_NemDecToRAM:
		jmp	(NemDecToRAM).l
		align 4
	endc

; ---------------------------------------------------------------------------
; Subroutine to draw the HUD in one-player mode
; ---------------------------------------------------------------------------

BuildHUD:
		tst.w	(v_rings).w
		beq.s	.norings				; branch if player has no rings
		moveq	#id_Frame_HUD1_AllYellow,d1		; frame if neither 'RINGS' nor 'TIME' are red
		btst	#3,(v_frame_counter_low).w		; check bit that changes every 8 frames
		bne.s	.notimeflash				; branch if set (only flash HUD every 8 frames)
		cmpi.b	#9,(v_time_min).w			; have 9 minutes elapsed?
		bne.s	.notimeflash				; branch if not
		addq.w	#id_Frame_HUD1_TimeRed-id_Frame_HUD1_AllYellow,d1 ; 'TIME' is red

	.notimeflash:
		bra.s	.display
; ===========================================================================

	.norings:
		moveq	#id_Frame_HUD1_AllYellow,d1		; frame if neither 'RINGS' nor 'TIME' are red
		btst	#3,(v_frame_counter_low).w		; check bit that changes every 8 frames
		bne.s	.display				; branch if set (only flash HUD every 8 frames)
		addq.w	#id_Frame_HUD1_RingRed-id_Frame_HUD1_AllYellow,d1 ; 'RINGS' is red
		cmpi.b	#9,(v_time_min).w			; have 9 minutes elapsed?
		bne.s	.display				; branch if not
		addq.w	#id_Frame_HUD1_AllRed-id_Frame_HUD1_RingRed,d1 ; both 'RINGS' and 'TIME' are red

	.display:
		move.w	#screen_left+16,d3			; set x pos
		move.w	#screen_top+136,d2			; set y pos
		lea	(Map_HUD1).l,a1
		movea.w	#tile_Nem_HUD+tile_hi,a3		; set art tile
		add.w	d1,d1
		adda.w	(a1,d1.w),a1				; a1 = mappings for current HUD frame
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		bmi.s	.skipdraw				; branch if it underflows for some reason
		jsrto	BuildSpr_Normal,JmpTo_BuildSpr_DrawLoop	; draw the HUD (could be jmpto)

	.skipdraw:
		rts

; ---------------------------------------------------------------------------
; Subroutine to draw player 1's HUD in two-player mode
; ---------------------------------------------------------------------------

BuildHUD_P1:
		tst.w	(v_rings).w
		beq.s	.norings				; branch if player has no rings
		moveq	#id_Frame_HUD2_AllYellow,d1		; frame if neither 'RINGS' nor 'TIME' are red
		btst	#3,(v_frame_counter_low).w		; check bit that changes every 8 frames
		bne.s	.noflash				; branch if set (only flash HUD every 8 frames)
		cmpi.b	#9,(v_time_min).w			; have 9 minutes elapsed?
		bne.s	.noflash				; branch if not
		addq.w	#id_Frame_HUD2_TimeRed-id_Frame_HUD2_AllYellow,d1 ; 'TIME' is red

	.noflash:
		bra.s	.drawlabels
; ===========================================================================

	.norings:
		moveq	#id_Frame_HUD2_AllYellow,d1		; frame if neither 'RINGS' nor 'TIME' are red
		btst	#3,(v_frame_counter_low).w		; check bit that changes every 8 frames
		bne.s	.drawlabels				; branch if set (only flash HUD every 8 frames)
		addq.w	#id_Frame_HUD2_RingRed-id_Frame_HUD2_AllYellow,d1 ; 'RINGS' is red
		cmpi.b	#9,(v_time_min).w			; have 9 minutes elapsed?
		bne.s	.drawlabels				; branch if not
		addq.w	#id_Frame_HUD2_AllRed-id_Frame_HUD2_RingRed,d1 ; both 'RINGS' and 'TIME' are red

	.drawlabels:
		move.w	#screen_left+16,d3			; set x pos
		move.w	#screen_top+264,d2			; set y pos
		lea	(Map_HUD2).l,a1
		movea.w	#(vram_HUD/sizeof_cell)>>1+tile_hi,a3	; set art tile
		add.w	d1,d1
		adda.w	(a1,d1.w),a1				; a1 = mappings for current HUD frame
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw the 'RINGS' and 'TIME' text

	;.drawtime:
		move.w	#screen_left+56,d3			; set x pos of time
		move.w	#screen_top+136,d2			; same for y pos
		movea.w	#((vram_HUD2P_Numbers/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		moveq	#0,d7
		move.b	(v_time_min).w,d7			; get minutes elapsed
		bsr.w	HUD_2P_Mins				; draw the minute digit
		bsr.w	HUD_2P_Colon				; draw the colon
		moveq	#0,d7
		move.b	(v_time_sec).w,d7			; get seconds elapsed
		bsr.w	HUD_2P_Secs				; draw the seconds

	;.drawrings:
		move.w	#screen_left+64,d3			; set x pos of ring count
		move.w	#screen_top+152,d2			; same for y pos
		movea.w	#((vram_HUD2P_Numbers/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		moveq	#0,d7
		move.w	(v_rings).w,d7				; get player 1's ring count
		bsr.w	HUD_2P_Rings				; draw the ring count

	;.draw_loser_time:
		tst.b	(f_hud_time_update_p2).w
		bne.s	.drawlives				; branch if player 2 isn't finished
		tst.b	(f_hud_time_update).w
		beq.s	.drawlives				; branch if player 1 is finished
		move.w	#screen_left+144,d3			; set x pos
		move.w	#screen_top+312,d2			; set y pos
		movea.w	#((vram_HUD2P_Numbers/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		moveq	#0,d7
		move.b	(v_loser_time_left).w,d7		; get time remaining
		bsr.w	HUD_2P_Secs				; draw loser time remaining

	.drawlives:
		moveq	#id_Frame_HUD2_SonicLives,d1		; Sonic life counter
		move.w	#screen_left+16,d3			; set x pos
		move.w	#screen_top+264,d2			; set y pos
		lea	(Map_HUD2).l,a1
		movea.w	#((vram_HUD2P_Text/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		add.w	d1,d1					; d1 = index
		adda.w	(a1,d1.w),a1				; a1 = mappings for current HUD frame
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw player 1's life counter
		moveq	#0,d4					; no clue what this is for
		rts

; ---------------------------------------------------------------------------
; Subroutine to	draw time numbers in 2P mode

; input:
; 	d7.w = number on time counter

;	uses d1.l, d3.w, d4.l, d6.l, a1, a4
; ---------------------------------------------------------------------------

HUD_2P_Mins:
		lea	(HUD_1).l,a4				; multiples of 1
		moveq	#1-1,d6					; number of digits
		bra.s	HUD_2P_DrawDigit
; ===========================================================================

HUD_2P_Secs:
		lea	(HUD_10).l,a4				; multiples of 10
		moveq	#2-1,d6					; number of digits

HUD_2P_DrawDigit:
		moveq	#id_Frame_HUD3_0,d1			; first frame of HUD_3 mappings
		move.l	(a4)+,d4				; d4 = subtrahend for finding digit (10 or 1)

	.find_digit:
		sub.l	d4,d7
		bcs.s	.digit_found				; branch if time is less than the value in d3
		addq.w	#1,d1					; increment frame ID
		bra.s	.find_digit				; loop until digit is found
; ===========================================================================

.digit_found:
		add.l	d4,d7					; undo previous subtraction
		lea	(Map_HUD3).l,a1
		add.w	d1,d1					; d1 = index
		adda.w	(a1,d1.w),a1				; a1 = mappings for digit
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw the digit
		addq.w	#8,d3					; advance x pos
		dbf	d6,HUD_2P_DrawDigit			; repeat for number of digits
		rts

; ---------------------------------------------------------------------------
; Subroutine to	draw the time colon in 2P mode

;	uses d1.l, d3.w, a1
; ---------------------------------------------------------------------------

HUD_2P_Colon:
		moveq	#id_Frame_HUD3_Colon,d1			; frame ID for colon
		lea	(Map_HUD3).l,a1
		add.w	d1,d1					; d1 = index
		adda.w	(a1,d1.w),a1				; a1 = mappings for digit
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw the colon
		addq.w	#8,d3					; advance x pos
		rts

; ---------------------------------------------------------------------------
; Subroutine to	draw the ring count in 2P mode

; input:
; 	d7.w = number of rings

;	uses d1.l, d3.w, d4.l, d6.l, a1, a4
; ---------------------------------------------------------------------------

HUD_2P_Rings:
		lea	(HUD_100).l,a4				; multiples of 100
		moveq	#3-1,d6					; 3 digits to draw

.loop:
		moveq	#id_Frame_HUD3_0,d1			; first frame of HUD_3 mappings
		move.l	(a4)+,d4				; d4 = multiples of 100, 10, and 1 for each successive loop

	.find_digit:
		sub.l	d4,d7
		bcs.s	.digit_found				; branch if ring count is less than the value in d3
		addq.w	#1,d1					; increment frame ID
		bra.s	.find_digit				; loop until digit is found
; ===========================================================================

.digit_found:
		add.l	d4,d7					; undo previous subtraction
		tst.w	d6
		beq.s	.draw_digit				; branch if this is the ones digit (always drawn even if 0)
		tst.w	d1
		beq.s	.digit_0				; branch if this digit is 0
		bset	#$1F,d6					; set flag to draw digits

	.digit_0:
		tst.l	d6
		bpl.s	.skip_digit				; branch if digit is not to be drawn

	.draw_digit:
		lea	(Map_HUD3).l,a1
		add.w	d1,d1					; d1 = index
		adda.w	(a1,d1.w),a1				; a1 = mappings for digit
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw the digit

	.skip_digit:
		addq.w	#8,d3					; advance x pos
		dbf	d6,.loop				; repeat for all digits
		rts

; ---------------------------------------------------------------------------
; Subroutine to draw player 2's HUD in two-player mode

; Almost identical to player 1's version except for different y coordinates
; and using player 2's ring and timer variables.
; ---------------------------------------------------------------------------

BuildHUD_P2:
		tst.w	(v_rings_p2).w
		beq.s	.norings				; branch if player has no rings
		moveq	#id_Frame_HUD2_AllYellow,d1		; frame if neither 'RINGS' nor 'TIME' are red
		btst	#3,(v_frame_counter_low).w		; check bit that changes every 8 frames
		bne.s	.noflash				; branch if set (only flash HUD every 8 frames)
		cmpi.b	#9,(v_time_min_p2).w			; have 9 minutes elapsed?
		bne.s	.noflash				; branch if not
		addq.w	#id_Frame_HUD2_TimeRed-id_Frame_HUD2_AllYellow,d1 ; 'TIME' is red

	.noflash:
		bra.s	.drawlabels
; ===========================================================================

	.norings:
		moveq	#id_Frame_HUD2_AllYellow,d1		; frame if neither 'RINGS' nor 'TIME' are red
		btst	#3,(v_frame_counter_low).w		; check bit that changes every 8 frames
		bne.s	.drawlabels				; branch if set (only flash HUD every 8 frames)
		addq.w	#id_Frame_HUD2_RingRed-id_Frame_HUD2_AllYellow,d1 ; 'RINGS' is red
		cmpi.b	#9,(v_time_min_p2).w			; have 9 minutes elapsed?
		bne.s	.drawlabels				; branch if not
		addq.w	#id_Frame_HUD2_AllRed-id_Frame_HUD2_RingRed,d1 ; both 'RINGS' and 'TIME' are red

	.drawlabels:
		move.w	#screen_left+16,d3			; set x pos
		move.w	#screen_top+488,d2			; set y pos
		lea	(Map_HUD2).l,a1
		movea.w	#((vram_HUD2P_Text/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		add.w	d1,d1
		adda.w	(a1,d1.w),a1				; a1 = mappings for current HUD frame
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw the 'RINGS' and 'TIME' text

	;.drawtime:
		move.w	#screen_left+56,d3			; set x pos of time
		move.w	#screen_top+360,d2			; same for y pos
		movea.w	#((vram_HUD2P_Numbers/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		moveq	#0,d7
		move.b	(v_time_min_p2).w,d7			; get minutes elapsed
		bsr.w	HUD_2P_Mins				; draw the minute digit
		bsr.w	HUD_2P_Colon				; draw the colon
		moveq	#0,d7
		move.b	(v_time_sec_p2).w,d7			; get seconds elapsed
		bsr.w	HUD_2P_Secs				; draw the seconds

	;.drawrings:
		move.w	#screen_left+64,d3			; set x pos of ring count
		move.w	#screen_top+376,d2			; same for y pos
		movea.w	#((vram_HUD2P_Numbers/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		moveq	#0,d7
		move.w	(v_rings_p2).w,d7			; get player 2's ring count
		bsr.w	HUD_2P_Rings				; draw the ring count

	;.draw_loser_time:
		tst.b	(f_hud_time_update).w
		bne.s	.drawlives				; branch if player 1 isn't finished
		tst.b	(f_hud_time_update_p2).w
		beq.s	.drawlives				; branch if player 2 is finished
		move.w	#screen_left+144,d3			; set x pos
		move.w	#screen_top+536,d2			; set y pos
		movea.w	#((vram_HUD2P_Numbers/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		moveq	#0,d7
		move.b	(v_loser_time_left).w,d7		; get time remaining
		bsr.w	HUD_2P_Secs				; draw loser time remaining

	.drawlives:
		moveq	#id_Frame_HUD2_TailsLives,d1
		move.w	#screen_left+16,d3			; set x pos
		move.w	#screen_top+488,d2			; set y pos
		lea	(Map_HUD2).l,a1
		movea.w	#((vram_Monitors/sizeof_cell)>>1)+tile_hi,a3 ; set art tile
		add.w	d1,d1					; d1 = index
		adda.w	(a1,d1.w),a1				; a1 = mappings for current HUD frame
		move.w	(a1)+,d1				; d1 = total sprite pieces
		subq.w	#1,d1					; adjust for loop counter
		jsrto	BuildSpr_DrawLoop_2P,JmpTo_BuildSpr_DrawLoop_2P ; draw player 1's life counter
		moveq	#0,d4					; no clue what this is for
		rts
; ===========================================================================

		include "mappings/sprite/HUD.asm"

; ---------------------------------------------------------------------------
; Subroutine to add points to player 1's score
;
; input:
;	d0.l = points to add (appears as *10 larger on the HUD)

; output:
;	d0.l = score
;	(a3).l = score

;	uses d1.l

; usage:
;		moveq	#100,d0
;		bsr.w	AddPoints				; give 1000 points
; ---------------------------------------------------------------------------

AddPoints:
		move.b	#1,(f_hud_score_update).w		; set score counter to update
		lea	(v_score).w,a3
		add.l	d0,(a3)					; add d0*10 to the score
		move.l	#999999,d1
		cmp.l   (a3),d1					; is score below 999999?
		bhi.s   .belowmax				; if yes, branch
		move.l  d1,(a3)					; reset score to 999999

	.belowmax:
		move.l	(a3),d0
		cmp.l   (v_score_next_life).w,d0		; has player got 50000+ points?
		bcs.s   .noextralife				; if not, branch

		addi.l	#points_for_life,(v_score_next_life).w	; increase requirement by 50000
		addq.b  #1,(v_lives).w				; give extra life
		addq.b  #1,(f_hud_lives_update).w		; set life counter in HUD to update
		move.w	#mus_ExtraLife,d0
		jmp	(PlayMusic).l				; play extra life music

	.noextralife:
		rts

; ---------------------------------------------------------------------------
; Subroutine to add points to player 1's score
; Used by objects in 2P mode; goes to AddPoints to add to Player 1's score
; instead if this is not Player 2
;
; input:
;	d0.l = points to add (appears as *10 larger on the HUD)

; output:
;	d0.l = score
;	(a3).l = score

;	uses d1.l

; usage:
;		moveq	#100,d0
;		bsr.w	AddPoints2				; give 1000 points
; ---------------------------------------------------------------------------

AddPoints2:
		tst.w	(f_two_player).w
		beq.s	AddPoints				; branch if we're in 1P mode
		cmpa.w	#v_ost_player1,a3
		beq.s	AddPoints				; branch if points are for player 1
		move.b	#1,(f_hud_score_update_p2).w		; set score counter to update
		lea	(v_score_p2).w,a3
		add.l	d0,(a3)
		move.l	#999999,d1
		cmp.l   (a3),d1					; is score below 999999?
		bhi.s   .belowmax				; if yes, branch
		move.l  d1,(a3)					; reset score to 999999

	.belowmax:
		move.l	(a3),d0
		cmp.l   (v_score_next_life_p2).w,d0		; has player got 50000+ points?
		bcs.s   .noextralife				; if not, branch
		addi.l	#points_for_life,(v_score_next_life_p2).w ; increase requirement by 50000
		addq.b  #1,(v_lives_p2).w			; give extra life
		addq.b  #1,(f_hud_lives_update_p2).w		; set life counter in HUD to update
		move.w	#mus_ExtraLife,d0
		jmp	(PlayMusic).l				; play extra life music

.noextralife:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	update the 1P mode HUD and end-of-level bonus counters

;	uses d0.l, d1.l, d2.l, d3.l, d4.l, d6.l, a0, a1, a2, a3, a6
; ---------------------------------------------------------------------------

HUD_Update:
		nop
		lea	(vdp_data_port).l,a6
		tst.w	(f_two_player).w
		bne.w	HUD_Update_2P				; branch if we're in 2P mode
		tst.w	(f_debug_enable).w
		bne.w	HUD_Debug				; branch if debug mode is enabled
		tst.b	(f_hud_score_update).w
		beq.s	.chkrings				; branch if we don't need to update the score
		clr.b	(f_hud_score_update).w
		vdp_comm.l	move,vram_HUD_Score,vram,write,d0 ; set VRAM address
		move.l	(v_score).w,d1				; load score
		bsr.w	HUD_Score

	.chkrings:
		tst.b	(v_hud_rings_update).w
		beq.s	.chktime				; branch if we don't need to update the ring counter
		bpl.s	.drawrings				; branch if ring count doesn't need to be reset to 0
		bsr.w	HUD_InitRings				; reset ring count

	.drawrings:
		clr.b	(v_hud_rings_update).w
		vdp_comm.l	move,vram_HUD_Rings,vram,write,d0 ; set VRAM address
		moveq	#0,d1
		move.w	(v_rings).w,d1				; load number of rings
		bsr.w	HUD_Rings

	.chktime:
		tst.b	(f_hud_time_update).w
		beq.s	.chklives				; branch if we don't need to update time
		tst.w	(f_pause).w
		bne.s	.chklives				; branch if the game is paused
		lea	(v_time).w,a1
		cmpi.l	#(9*$10000)+(59*$100)+59,(a1)+		; is the time 9:59:99?
		beq.w	TimeOver				; branch if so

		addq.b	#1,-(a1)				; increment 1/60s counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.chklives
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment second counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.updatetime
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment minute counter
		cmpi.b	#9,(a1)					; check if passed 9
		bcs.s	.updatetime
		move.b	#9,(a1)					; keep as 9

	.updatetime:
		vdp_comm.l	move,vram_HUD_Minutes,vram,write,d0 ; set VRAM address
		moveq	#0,d1
		move.b	(v_time_min).w,d1			; load	minutes
		bsr.w	HUD_Mins
		vdp_comm.l	move,vram_HUD_Seconds,vram,write,d0 ; set VRAM address
		moveq	#0,d1
		move.b	(v_time_sec).w,d1			; load	seconds
		bsr.w	HUD_Secs

	.chklives:
		tst.b	(f_hud_lives_update).w
		beq.s	.chkbonus				; branch if we don't need to update the life counter
		clr.b	(f_hud_lives_update).w
		bsr.w	HUD_Lives

	.chkbonus:
		tst.b	(f_pass_bonus_update).w
		beq.s	.finish					; branch if time/ring bonus countdowns don't need updating
		clr.b	(f_pass_bonus_update).w
		vdp_comm.l	move,vram_Bonus_Score,vram,write,(vdp_control_port).l ; set VRAM address
		moveq	#0,d1
		move.w	(v_total_bonus_countdown).w,d1
		bsr.w	HUD_Bonus
		moveq	#0,d1
		move.w	(v_bonus_count_1).w,d1
		bsr.w	HUD_Bonus
		moveq	#0,d1
		move.w	(v_bonus_count_2).w,d1
		bsr.w	HUD_Bonus
		moveq	#0,d1
		move.w	(v_bonus_count_3).w,d1
		bsr.w	HUD_Bonus

	.finish:
		rts
; ===========================================================================

TimeOver:
		clr.b	(f_hud_time_update).w
		lea	(v_ost_player1).w,a0
		movea.l	a0,a2					; the player is killing themselves
		bsr.w	KillCharacter				; kill the player
		move.b	#1,(f_time_over).w			; flag for GAME OVER / TIME OVER object to use correct frame
		rts
; ===========================================================================

HUD_Debug:
		bsr.w	HUD_DebugXY				; draw x and y coordinates of player and camera
		tst.b	(v_hud_rings_update).w
		beq.s	.spritecounter				; branch if ring counter doens't need updating
		bpl.s	.notzero				; branch if does not need to be reset to 0
		bsr.w	HUD_InitRings				; reset rings to 0 if required

	.notzero:
		clr.b	(v_hud_rings_update).w
		vdp_comm.l	move,vram_HUD_Rings,vram,write,d0 ; set VRAM address
		moveq	#0,d1
		move.w	(v_rings).w,d1				; load number of rings
		bsr.w	HUD_Rings

	.spritecounter:
		vdp_comm.l	move,vram_HUD_Seconds,vram,write,d0 ; drawn in place of the seconds counter
		moveq	#0,d1
		move.b	(v_spritecount).w,d1			; load count of sprites rendered on current frame
		bsr.w	HUD_Secs

		tst.b	(f_hud_lives_update).w
		beq.s	.chkbonus				; branch if lives counter doesn't need updating
		clr.b	(f_hud_lives_update).w
		bsr.w	HUD_Lives

	.chkbonus:
		tst.b	(f_pass_bonus_update).w			; do time/ring bonus counters need updating?
		beq.s	.chktime				; branch if not
		clr.b	(f_pass_bonus_update).w
		vdp_comm.l	move,vram_Bonus_Score,vram,write,(vdp_control_port).l ; set VRAM address
		moveq	#0,d1
		move.w	(v_total_bonus_countdown).w,d1
		bsr.w	HUD_Bonus
		moveq	#0,d1
		move.w	(v_bonus_count_1).w,d1
		bsr.w	HUD_Bonus
		moveq	#0,d1
		move.w	(v_bonus_count_2).w,d1
		bsr.w	HUD_Bonus
		moveq	#0,d1
		move.w	(v_bonus_count_3).w,d1
		bsr.w	HUD_Bonus

	.chktime:
		; Unlike Sonic 1, Sonic 2 continues to run the timer in debug mode.
		tst.w	(f_pause).w
		bne.s	.finish					; branch if the game is paused
		lea	(v_time).w,a1
		cmpi.l	#(9*$10000)+(59*$100)+59,(a1)+		; is the time 9:59:99? (could be deleted along with below instruction)
		nop						; (no time overs in debug mode)
		addq.b	#1,-(a1)				; increment 1/60s counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.finish
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment second counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.finish
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment minute counter
		cmpi.b	#9,(a1)					; check if passed 9
		bcs.s	.finish
		move.b	#9,(a1)					; keep as 9


	.finish:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	update the 2P mode HUDs

;	uses d0.l, d1.l, d2.l, d3.l, d4.l, d6.l, a0, a1, a2, a3, a6
; ---------------------------------------------------------------------------

HUD_Update_2P:
		tst.w	(f_pause).w
		bne.w	.finish					; branch if game is paused

	;.chktime_p1:
		tst.b	(f_hud_time_update).w
		beq.s	.chktime_p2				; branch if we don't need to update player 1's time
		lea	(v_time).w,a1
		cmpi.l	#(9*$10000)+(59*$100)+59,(a1)+		; is the time 9:59:59?
		beq.w	TimeOver_P1				; branch if so

		addq.b	#1,-(a1)				; increment 1/60s counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.chktime_p2
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment second counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.chktime_p2
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment minute counter
		cmpi.b	#9,(a1)					; check if passed 9
		bcs.s	.chktime_p2
		move.b	#9,(a1)					; keep as 9

	.chktime_p2:
		tst.b	(f_hud_time_update_p2).w
		beq.s	.chklives_p1				; branch if we don't need to update player 2's time
		lea	(v_time_p2).w,a1
		cmpi.l	#(9*$10000)+(59*$100)+59,(a1)+		; is the time 9:59:59?
		beq.w	TimeOver_P2				; branch if so

		addq.b	#1,-(a1)				; increment 1/60s counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.chklives_p1
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment second counter
		cmpi.b	#60,(a1)				; check if passed 60
		bcs.s	.chklives_p1
		move.b	#0,(a1)
		addq.b	#1,-(a1)				; increment minute counter
		cmpi.b	#9,(a1)					; check if passed 9
		bcs.s	.chklives_p1
		move.b	#9,(a1)					; keep as 9

	.chklives_p1:
		tst.b	(f_hud_lives_update).w
		beq.s	.chklives_p2				; branch if we don't need to update player 1's life counter
		clr.b	(f_hud_lives_update).w
		bsr.w	HUD_Lives

	.chklives_p2:
		tst.b	(f_hud_lives_update_p2).w
		beq.s	.chklosertime				; branch if we don't need to update player 2's life counter
		clr.b	(f_hud_lives_update_p2).w
		bsr.w	HUD_Lives_P2

	.chklosertime:
		move.b	(f_hud_time_update).w,d0
		or.b	(f_hud_time_update_p2).w,d0
		beq.s	.finish					; branch if both players are finished
		lea	(v_loser_time_left).w,a1		; get loser timer (will be nonzero if at least one player has finished)
		tst.w	(a1)+
		beq.s	.finish					; branch if neither player has finished
		subq.b	#1,-(a1)				; decrement frame counter
		bhi.s	.finish					; branch if time remains
		move.b	#60,(a1)				; reset frame counter
		cmpi.b	#time_warning_2P,-1(a1)			; has seconds timer reached 12?
		bne.s	.skipmusic				; branch if not
		move.w	#mus_Drowning,d0
		jsr	(PlayMusic).l				; play drowning music

	.skipmusic:
		subq.b	#1,-(a1)				; decrement seconds timer
		bcc.s	.finish					; branch if time remains
		move.w	#0,(a1)					; clear loser time
		bsr.s	TimeOver_2P

	.finish:
		rts

; ===========================================================================

TimeOver_2P:
		tst.b	(f_hud_time_update).w
		bne.s	TimeOver_P1				; branch if player 1 ran out of time
		tst.b	(f_hud_time_update_p2).w
		bne.s	TimeOver_P2				; branch if player 2 ran out of time
		rts
; ===========================================================================

TimeOver_P1:
		clr.b	(f_hud_time_update).w
		lea	(v_ost_player1).w,a0
		movea.l	a0,a2					; the player is killing themselves
		bsr.w	KillCharacter				; kill the player
		move.b	#1,(f_time_over).w			; flag for GAME OVER / TIME OVER object to use correct frame
		tst.b	(f_hud_time_update_p2).w
		beq.s	TimeOver_2P_Done			; branch if player 2 has time left

TimeOver_P2:
		clr.b	(f_hud_time_update_p2).w
		lea	(v_ost_player2).w,a0
		movea.l	a0,a2					; the player is killing themselves
		bsr.w	KillCharacter				; kill the player
		move.b	#1,(f_time_over_p2).w			; flag for GAME OVER / TIME OVER object to use correct frame

TimeOver_2P_Done:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	set rings counter to 0 on HUD

; input:
;	a6 = vdp_data_port

;	uses d0.w, d1.w, d2.w, a1, a2, a3
; ---------------------------------------------------------------------------

HUD_InitRings:
		vdp_comm.l	move,vram_HUD_Rings,vram,write,(vdp_control_port).l ; rings counter VRAM address
		lea	HUD_TilesRings(pc),a2			; tile list
		move.w	#sizeof_HUD_TilesRings-1,d2		; number of characters
		bra.s	HUD_Base_Load

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed HUD patterns ("E", "0", colon)

; output:
;	a6 = vdp_data_port ($C00000)

;	uses d0.l, d1.l, d2.l, d3.l, d4.l, d5.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

HUD_Base:
		lea	(vdp_data_port).l,a6
		bsr.w	HUD_Lives				; initialize lives counter
		tst.w	(f_two_player).w
		bne.s	HUD_Base_2P				; branch if we're in 2P mode
		vdp_comm.l	move,vram_HUD_Score_E,vram,write,(vdp_control_port).l ; VRAM address
		lea	HUD_TilesBase(pc),a2			; tile list
		move.w	#sizeof_HUD_TilesBase-1,d2		; number of characters

HUD_Base_Load:
		lea	Art_HUD(pc),a1				; address of HUD GFx

.loop_chars:
		move.w	#((sizeof_cell/4)*2)-1,d1		; each character consist of 2 cells
		move.b	(a2)+,d0				; get tile ID
		bmi.s	.blank_char				; branch if $FF
		ext.w	d0
		lsl.w	#5,d0					; multiply ID by 20
		lea	(a1,d0.w),a3				; jump to relevant GFX

	.loop_gfx:
		move.l	(a3)+,(a6)				; copy two tiles to VRAM
		dbf	d1,.loop_gfx

.next_char:
		dbf	d2,.loop_chars				; repeat for all characters
		rts
; ===========================================================================

.blank_char:
		move.l	#0,(a6)					; erase character
		dbf	d1,.blank_char

		bra.s	.next_char

; ---------------------------------------------------------------------------
; In 2P mode, we simply DMA these graphics to VRAM.
; ---------------------------------------------------------------------------

HUD_Base_2P:
		bsr.w	HUD_Lives_P2				; initialize player 2's life counter
		move.l	#Art_HUD,d1				; DMA source
		move.w	#vram_HUD_Score_E,d2			; VRAM destination
		move.w	#(sizeof_Art_HUD-(sizeof_cell*2))/2,d3	; DMA everything except the 'E' (the final two tiles)
		jmp	(AddDMA).l
; ===========================================================================

HUD_TilesBase:
		charset	hud,"E      0"
		charset	hud,"0:00"

HUD_TilesRings:
		charset hud,"  0"
		arraysize	HUD_TilesBase
		arraysize 	HUD_TilesRings
		even

; ---------------------------------------------------------------------------
; Subroutine to	load debug mode	numbers	patterns

; input:
;	a6 = vdp_data_port

;	uses d1.l, d2.w, d6.l, a1, a3
; ---------------------------------------------------------------------------

HUD_DebugXY:
		vdp_comm.l	move,vram_HUD_Score_E,vram,write,(vdp_control_port).l ; VRAM address, starts at "E" in score
		move.w	(v_camera_x_pos).w,d1
		swap	d1					; camera x pos in high word
		move.w	(v_ost_player1+ost_x_pos).w,d1		; player x pos in low word
		bsr.s	.draw
		move.w	(v_camera_y_pos).w,d1
		swap	d1					; camera y pos in high word
		move.w	(v_ost_player1+ost_y_pos).w,d1		; player y pos in low word

.draw:
		moveq	#8-1,d6					; number of digits
		lea	(Art_HUDText).l,a1			; debug number gfx

	.loop:
		rol.w	#4,d1
		move.w	d1,d2					; copy nybble to d2
		andi.w	#$F,d2
		cmpi.w	#$A,d2
		bcs.s	.is_0to9				; branch if 0-9
		addi_.w	#7,d2					; use later tile for A-F

	.is_0to9:
		lsl.w	#5,d2					; multiply by $20
		lea	(a1,d2.w),a3				; jump to relevant tile in gfx
		rept sizeof_cell/4
		move.l	(a3)+,(a6)				; copy tile to VRAM
		endr
		swap	d1
		dbf	d6,.loop				; repeat for all digits stored in d1

		rts

; ---------------------------------------------------------------------------
; Subroutine to	load rings numbers patterns

; input:
;	d0.l = VDP instruction for VRAM address
;	d1.l = number of rings
;	a6 = vdp_data_port ($C00000)

;	uses d1.l, d2.l, d3.l, d4.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

HUD_Rings:
		lea	(HUD_100).l,a2				; multiples of 100
		moveq	#3-1,d6					; number of digits
		bra.s	HUD_LoadArt

; ---------------------------------------------------------------------------
; As above, but for the score
; ---------------------------------------------------------------------------

HUD_Score:
		lea	(HUD_100000).l,a2			; multiples of 100000
		moveq	#6-1,d6					; number of digits

HUD_LoadArt:
		moveq	#0,d4
		lea	Art_HUD(pc),a1				; address of HUD number gfx

.loop:
		moveq	#0,d2					; digits start a 0
		move.l	(a2)+,d3				; d3 = multiple of 10

	.find_digit:
		sub.l	d3,d1
		bcs.s	.digit_found				; branch if score is less than the value in d3
		addq.w	#1,d2					; increment digit counter
		bra.s	.find_digit				; repeat until d2 = digit
; ===========================================================================

.digit_found:
		add.l	d3,d1
		tst.w	d2
		beq.s	.digit_0				; branch if digit is 0
		move.w	#1,d4					; set flag to load gfx for digit

	.digit_0:
		tst.w	d4
		beq.s	.skip_digit				; branch if digit was 0
		lsl.w	#6,d2					; multiply by $40 (size of 2 tiles per digit)
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; set target VRAM address
		lea	(a1,d2.w),a3				; jump to relevant gfx source
		rept (sizeof_cell/4)*2
		move.l	(a3)+,(a6)				; copy 2 tiles to VRAM
		endr

	.skip_digit:
		addi.l	#(sizeof_cell*2)<<16,d0			; next VRAM address, 2 tiles ahead
		dbf	d6,.loop				; repeat for number of digits

		rts

; ---------------------------------------------------------------------------
; Subroutine to	load countdown numbers on the continue screen

; input:
;	d1.l = number on countdown

; output:
;	a6 = vdp_data_port ($C00000)

;	uses d1.l, d2.l, d3.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

ContScrCounter:
		vdp_comm.l	move,vram_ContinueCountdown,vram,write,(vdp_control_port).l
		lea	(vdp_data_port).l,a6
		lea	(HUD_10).l,a2
		moveq	#2-1,d6					; number of digits
		moveq	#0,d4					; pointless
		lea	Art_Hud(pc),a1				; address of number gfx

.loop:
		moveq	#0,d2
		move.l	(a2)+,d3				; d3 = current multiple to search for

	.find_digit:
		sub.l	d3,d1
		bcs.s	.digit_found				; branch if number is less than the value in d3
		addq.w	#1,d2					; increment digit counter
		bra.s	.find_digit				; repeat until d2 = digit
; ===========================================================================

.digit_found:
		add.l	d3,d1
		lsl.w	#6,d2					; multiply by $40 (size of 2 tiles per digit)
		lea	(a1,d2.w),a3				; jump to relevant gfx source
		rept (sizeof_cell/4)*2
		move.l	(a3)+,(a6)				; copy 2 tiles to VRAM
		endr
		dbf	d6,.loop				; repeat 1 more	time

		rts

; ---------------------------------------------------------------------------
; HUD counter sizes
; ---------------------------------------------------------------------------

HUD_100000:	dc.l 100000
			dc.l 10000				; unused
HUD_1000:	dc.l 1000
HUD_100:	dc.l 100
HUD_10:		dc.l 10
HUD_1:		dc.l 1

; ---------------------------------------------------------------------------
; Subroutine to	load time numbers patterns

; input:
;	d0.l = VDP instruction for VRAM address
;	d1.l = number on time counter
;	a6 = vdp_data_port ($C00000)

;	uses d1.l, d2.l, d3.l, d4.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

HUD_Mins:
		lea_	HUD_1,a2				; multiples of 1
		moveq	#1-1,d6					; number of digits
		bra.s	HUD_Time_Load

HUD_Secs:
		lea_	HUD_10,a2				; multiples of 10
		moveq	#2-1,d6					; number of digits

HUD_Time_Load:
		moveq	#0,d4
		lea	Art_HUD(pc),a1				; address of HUD number gfx

.loop:
		moveq	#0,d2
		move.l	(a2)+,d3				; d3 = current multiple to search for

	.find_digit:
		sub.l	d3,d1
		bcs.s	.digit_found				; branch if time is less than the value in d3
		addq.w	#1,d2					; increment digit counter
		bra.s	.find_digit				; repeat until d2 = digit
; ===========================================================================

.digit_found:
		add.l	d3,d1
		tst.w	d2
		beq.s	.digit_0				; branch if digit is 0
		move.w	#1,d4					; unused flag

	.digit_0:
		lsl.w	#6,d2					; multiply by $40 (size of 2 tiles per digit)
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; set target VRAM address
		lea	(a1,d2.w),a3				; jump to relevant gfx source
		rept (sizeof_cell/4)*2
		move.l	(a3)+,(a6)				; copy 2 tiles to VRAM
		endr
		addi.l	#(sizeof_cell*2)<<16,d0			; next VRAM address, 2 tiles ahead
		dbf	d6,.loop				; repeat for number of digits

		rts

; ---------------------------------------------------------------------------
; Subroutine to	load time/ring bonus numbers patterns

; input:
;	d0.l = VDP instruction for VRAM address
;	d1.l = number on bonus counter
;	a6 = vdp_data_port

;	uses d1.l, d2.l, d3.l, d4.l, d5.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

HUD_Bonus:
		lea_	HUD_1000,a2				; multiples of 1000
		moveq	#4-1,d6					; number of digits
		moveq	#0,d4
		lea	Art_HUD(pc),a1				; address of HUD number gfx

.loop:
		moveq	#0,d2
		move.l	(a2)+,d3				; d3 = multiple of 10

	.find_digit:
		sub.l	d3,d1
		bcs.s	.digit_found				; branch if bonus is less than the value in d3
		addq.w	#1,d2					; increment digit counter
		bra.s	.find_digit				; repeat until d2 = digit
; ===========================================================================

.digit_found:
		add.l	d3,d1
		tst.w	d2
		beq.s	.digit_0				; branch if digit is 0
		move.w	#1,d4					; set flag to load gfx for digit

	.digit_0:
		tst.w	d4
		beq.s	.skip_digit				; branch if digit was 0
		lsl.w	#6,d2					; multiply by $40 (size of 2 tiles per digit)
		lea	(a1,d2.w),a3				; jump to relevant gfx source
		rept (sizeof_cell/4)*2
		move.l	(a3)+,(a6)				; copy 2 tiles to VRAM
		endr

.next:
		dbf	d6,.loop				; repeat for number of digits
		rts
; ===========================================================================

.skip_digit:
		moveq	#((sizeof_cell/4)*2)-1,d5

	.loop_erase:
		move.l	#0,(a6)					; write blank digit to VRAM
		dbf	d5,.loop_erase

		bra.s	.next

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed lives	counter	patterns

; input:
;	a6 = vdp_data_port ($C00000)

;	uses d0.l, d1.l, d2.l, d3.l, d4.l, d5.l, d6.l, a1, a2, a3
; ---------------------------------------------------------------------------

HUD_Lives_P2:
		vdp_comm.l	move,vram_LifeCounter2_Lives,vram,write,d0 ; VRAM address of lives counter
		moveq	#0,d1
		move.b	(v_lives_p2).w,d1			; load number of lives
		bra.s	HUD_Lives_Load

HUD_Lives:
		vdp_comm.l	move,vram_LifeCounter_Lives,vram,write,d0
		moveq	#0,d1
		move.b	(v_lives).w,d1				; load number of lives

HUD_Lives_Load:
		lea_	HUD_10,a2				; multiples of 10
		moveq	#2-1,d6					; number of digits
		moveq	#0,d4
		lea	Art_LivesNums(pc),a1			; address of lives counter GFX

.loop:
		move.l	d0,vdp_control_port-vdp_data_port(a6)	; set VRAM address
		moveq	#0,d2
		move.l	(a2)+,d3				; d3 = multiples of 10 or 1

	.find_digit:
		sub.l	d3,d1
		bcs.s	.digit_found				; branch if lives is less than the value in d3
		addq.w	#1,d2					; increment digit counter
		bra.s	.find_digit				; repeat until d2 = digit
; ===========================================================================

.digit_found:
		add.l	d3,d1
		tst.w	d2
		beq.s	.digit_0				; branch if digit is 0
		move.w	#1,d4					; set flag to load gfx for digit

	.digit_0:
		tst.w	d4
		beq.s	.skip_digit				; branch if digit was 0

.show_digit:
		lsl.w	#5,d2					; multiply by $20 (size of cell)
		lea	(a1,d2.w),a3				; jump to relevant gfx source
		rept sizeof_cell/4
		move.l	(a3)+,(a6)				; copy tile to VRAM
		endr

.next:
		addi.l	#(sizeof_cell*2)<<16,d0			; next VRAM address, 2 tiles ahead (1st & 2nd digits are not adjacent)
		dbf	d6,.loop				; repeat 1 more time

		rts
; ===========================================================================

.skip_digit:
		tst.w	d6
		beq.s	.show_digit				; branch if this is the 2nd digit
		moveq	#(sizeof_cell/4)-1,d5

	.loop_erase:
		move.l	#0,(a6)					; write blank digit to VRAM
		dbf	d5,.loop_erase
		bra.s	.next

; ===========================================================================

		incfile Art_HUD
		incfile	Art_LivesNums
		incfile	Art_HUDText

; ===========================================================================

	if RemoveJmpTos=0
JmpTo_BuildSpr_DrawLoop_2P:
		jmp	(BuildSpr_DrawLoop_2P).l
JmpTo_BuildSpr_DrawLoop:
		jmp	(BuildSpr_Normal).l

		align 4
	endc

; ---------------------------------------------------------------------------
; Psuedoobject that runs debug placement mode
; ---------------------------------------------------------------------------
; loc_41A78:
DebugMode:
		moveq	#0,d0
		move.b	(v_debug_active).w,d0
		move.w	Debug_Index(pc,d0.w),d1
		jmp	Debug_Index(pc,d1.w)
; ===========================================================================
; off_41A86:
Debug_Index:	index offset(*),,2
		ptr loc_41A8A					; 0
		ptr loc_41B0C					; 2
; ===========================================================================

loc_41A8A:
		addq.b	#2,(v_debug_active).w
		move.w	(v_boundary_top).w,(v_boundary_top_next_debug).w
		move.w	(v_boundary_bottom_next).w,(v_boundary_bottom_next_debug).w
		cmpi.b	#id_SCZ,(v_zone).w
		bne.s	loc_41AAE
		move.w	#0,(v_boundary_left).w
		move.w	#$3FFF,(v_boundary_right).w

	loc_41AAE:
		andi.w	#$7FF,(v_ost_player1+ost_y_pos).w
		andi.w	#$7FF,(v_camera_y_pos).w
		andi.w	#$7FF,(v_bg1_y_pos).w
		clr.b	(f_disable_scroll_p1).w
		move.b	#0,ost_frame(a0)
		move.b	#0,ost_anim(a0)
		cmpi.b	#$10,(v_gamemode).w
		bne.s	loc_41ADC
		moveq	#6,d0
		bra.s	loc_41AE2
; ===========================================================================

loc_41ADC:
		moveq	#0,d0
		move.b	(v_zone).w,d0

loc_41AE2:
		lea	(off_41D0C).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d6
		cmp.b	(v_debug_item_index).w,d6
		bhi.s	loc_41AFC
		move.b	#0,(v_debug_item_index).w

loc_41AFC:
		bsr.w	sub_41CEC
		move.b	#$C,(v_debug_move_delay).w
		move.b	#1,(v_debug_move_speed).w

loc_41B0C:
		moveq	#6,d0
		cmpi.b	#$10,(v_gamemode).w
		beq.s	loc_41B1C
		moveq	#0,d0
		move.b	(v_zone).w,d0

loc_41B1C:
		lea	(off_41D0C).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d6
		bsr.w	sub_41B34
		jmp	(DisplaySprite).l

; ===========================================================================


sub_41B34:
		moveq	#0,d4
		move.w	#1,d1
		move.b	(v_joypad_press_actual).w,d4
		andi.w	#$F,d4
		bne.s	loc_41B76
		move.b	(v_joypad_hold_actual).w,d0
		andi.w	#$F,d0
		bne.s	loc_41B5E
		move.b	#$C,(v_debug_move_delay).w
		move.b	#$F,(v_debug_move_speed).w
		bra.w	loc_41BDA
; ===========================================================================

loc_41B5E:
		subq.b	#1,(v_debug_move_delay).w
		bne.s	loc_41B7A
		move.b	#1,(v_debug_move_delay).w
		addq.b	#1,(v_debug_move_speed).w
		bne.s	loc_41B76
		move.b	#-1,(v_debug_move_speed).w

loc_41B76:
		move.b	(v_joypad_hold_actual).w,d4

loc_41B7A:
		moveq	#0,d1
		move.b	(v_debug_move_speed).w,d1
		addq.w	#1,d1
		swap	d1
		asr.l	#4,d1
		move.l	ost_y_pos(a0),d2
		move.l	ost_x_pos(a0),d3
		btst	#0,d4
		beq.s	loc_41BA4
		sub.l	d1,d2
		moveq	#0,d0
		move.w	(v_boundary_top).w,d0
		swap	d0
		cmp.l	d0,d2
		bge.s	loc_41BA4
		move.l	d0,d2

loc_41BA4:
		btst	#1,d4
		beq.s	loc_41BBE
		add.l	d1,d2
		moveq	#0,d0
		move.w	(v_boundary_bottom_next).w,d0
		addi.w	#$DF,d0
		swap	d0
		cmp.l	d0,d2
		blt.s	loc_41BBE
		move.l	d0,d2

loc_41BBE:
		btst	#2,d4
		beq.s	loc_41BCA
		sub.l	d1,d3
		bcc.s	loc_41BCA
		moveq	#0,d3

loc_41BCA:
		btst	#3,d4
		beq.s	loc_41BD2
		add.l	d1,d3

loc_41BD2:
		move.l	d2,ost_y_pos(a0)
		move.l	d3,ost_x_pos(a0)

loc_41BDA:
		btst	#6,(v_joypad_hold_actual).w
		beq.s	loc_41C12
		btst	#5,(v_joypad_press_actual).w
		beq.s	loc_41BF6
		subq.b	#1,(v_debug_item_index).w
		bcc.s	loc_41C0E
		add.b	d6,(v_debug_item_index).w
		bra.s	loc_41C0E
; ===========================================================================

loc_41BF6:
		btst	#6,(v_joypad_press_actual).w
		beq.s	loc_41C12
		addq.b	#1,(v_debug_item_index).w
		cmp.b	(v_debug_item_index).w,d6
		bhi.s	loc_41C0E
		move.b	#0,(v_debug_item_index).w

loc_41C0E:
		bra.w	sub_41CEC
; ===========================================================================

loc_41C12:
		btst	#5,(v_joypad_press_actual).w
		beq.s	loc_41C56
		jsr	(FindFreeObj).l
		bne.s	loc_41C56
		move.w	ost_x_pos(a0),ost_x_pos(a1)
		move.w	ost_y_pos(a0),ost_y_pos(a1)
		_move.b	ost_mappings(a0),ost_id(a1)
		move.b	ost_render(a0),ost_render(a1)
    if FixBugs
		; 'render_onscreen is not cleared here. This causes
		; 'RunObjectDisplayOnly' to display the object even when it isn't
		; fully initialized. This causes the crash that occurs when you
		; attempt to spawn an object in Debug Mode while dead.
		andi.b	#(~render_onscreen)&$FF,ost_render(a1)
    endc
		move.b	ost_render(a0),ost_primary_status(a1)
		andi.b	#(~status_broken)&$FF,ost_primary_status(a1)
		moveq	#0,d0
		move.b	(v_debug_item_index).w,d0
		lsl.w	#3,d0
		move.b	4(a2,d0.w),ost_subtype(a1)
		rts
; ===========================================================================

loc_41C56:
		btst	#4,(v_joypad_press_actual).w
		beq.s	locret_41CB6
		moveq	#0,d0
		move.w	d0,(v_debug_active).w
		lea	(v_ost_player1).w,a1
		move.l	#Map_Sonic,ost_mappings(a1)
		move.w	#tile_Sonic,ost_tile(a1)
		tst.w	(f_two_player).w
		beq.s	loc_41C82
		move.w	#tile_Sonic>>1,ost_tile(a1)

loc_41C82:
		bsr.s	sub_41CB8
		move.b	#$13,ost_height(a1)
		move.b	#9,ost_width(a1)
		move.w	(v_boundary_top_next_debug).w,(v_boundary_top).w
		move.w	(v_boundary_bottom_next_debug).w,(v_boundary_bottom_next).w

		; Following four lines are unused Sonic 1 leftover, used when exiting debug mode
		; while in a Special Stage.
		cmpi.b	#$10,(v_gamemode).w
		bne.s	locret_41CB6
		move.b	#2,(v_ost_player1+ost_anim).w
		bset	#2,(v_ost_player1+ost_primary_status).w
		bset	#1,(v_ost_player1+ost_primary_status).w

locret_41CB6:
		rts

; ===========================================================================


sub_41CB8:
		move.b	d0,ost_anim(a1)
		move.w	d0,ost_x_sub(a1)
		move.w	d0,ost_y_sub(a1)
		move.b	d0,$2A(a1)
		move.b	d0,$39(a1)
		move.w	d0,ost_x_vel(a1)
		move.w	d0,ost_y_vel(a1)
		move.w	d0,ost_inertia(a1)
		move.b	#2,ost_primary_status(a1)
		move.b	#2,ost_primary_routine(a1)
		move.b	#0,ost_secondary_routine(a1)
		rts

; ===========================================================================


sub_41CEC:
		moveq	#0,d0
		move.b	(v_debug_item_index).w,d0
		lsl.w	#3,d0
		move.l	(a2,d0.w),ost_mappings(a0)
		move.w	6(a2,d0.w),ost_tile(a0)
		move.b	5(a2,d0.w),ost_frame(a0)
		jsrto	AdjustVRAM2P,JmpTo66_AdjustVRAM2P
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Debug mode item lists
; ---------------------------------------------------------------------------
off_41D0C:	index offset(*),,1
		ptr DbgEHZ_41D40				; 0
		ptr DbgDef_41D2E				; 1
		ptr DbgDef_41D2E				; 2
		ptr DbgDef_41D2E				; 3
		ptr DbgMTZ_41DDA				; 4
		ptr DbgMTZ_41DDA				; 5
		ptr DbgWFZ_41EEC				; 6
		ptr DbgHTZ_41FEE				; 7
		ptr DbgOOZ_420E8				; 8
		ptr DbgDef_41D2E				; 9
		ptr DbgOOZ_420E8				; 10
		ptr DbgMCZ_421F2				; 11
		ptr DbgCNZ_422B4				; 12
		ptr DbgCPZ_42376				; 13
		ptr DbgDef_41D2E				; 14
		ptr DbgARZ_42438				; 15
		ptr DbgSCZ_42522				; 16

;dbugheader:	macro *
;\* equ *
;		dc.w	(sizeof_\*-2)/8
;		endm
;dbug:		macro object,map,subtype,frame,vram
;		dc.l map+(id_\object<<24)
;		dc.b subtype,frame
;		dc.w vram
;		endm

DbgDef_41D2E:	dc.w 2
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
DbgEHZ_41D40:	dc.w $13
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $3000000+Map_PSwitch
		dc.w $901
		dc.w $26BC
		dc.l $49000000+Map_EHZWFall
		dc.w 0
		dc.w $239E
		dc.l $49000000+Map_EHZWFall
		dc.w $203
		dc.w $239E
		dc.l $49000000+Map_EHZWFall
		dc.w $405
		dc.w $239E
		dc.l $18000000+Map_Plat_EHZ_HTZ
		dc.w $100
		dc.w $4000
		dc.l $18000000+Map_Plat_EHZ_HTZ
		dc.w $9A01
		dc.w $4000
		dc.l $36000000+Map_Spike
		dc.w 0
		dc.w $2434
		dc.l $41000000+Map_RedSpring
		dc.w $8100
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $9003
		dc.w $470
		dc.l $41000000+Map_RedSpring
		dc.w $A006
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $3007
		dc.w $43C
		dc.l $41000000+Map_RedSpring
		dc.w $400A
		dc.w $43C
		dc.l $4B000000+Map_Buzz
		dc.w 0
		dc.w $3D2
		dc.l $5C000000+Map_Mash
		dc.w 0
		dc.w $414
		dc.l $9D000000+Map_Coco
		dc.w $1E00
		dc.w $3EE
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgMTZ_41DDA:	dc.w $22
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $3000000+Map_PSwitch
		dc.w $901
		dc.w $26BC
		dc.l $42000000+Map_SteamSpring
		dc.w $107
		dc.w $6000
		dc.l $64000000+Map_Stomp
		dc.w $100
		dc.w $2000
		dc.l $64000000+Map_Stomp
		dc.w $1101
		dc.w $2000
		dc.l $65000000+Map_MTZPlats
		dc.w $8000
		dc.w $6000
		dc.l $65000000+Map_MTZPlats
		dc.w $1301
		dc.w $6000
		dc.l $47000000+Map_But
		dc.w 2
		dc.w $424
		dc.l $2D000000+Map_Barrier
		dc.w $101
		dc.w $6000
		dc.l $66000000+Map_SpringWall
		dc.w $100
		dc.w $8680
		dc.l $66000000+Map_SpringWall
		dc.w $1101
		dc.w $8680
		dc.l $68000000+Map_SpkBlk
		dc.w 4
		dc.w $6414
		dc.l $69000000+Map_Nut
		dc.w $400
		dc.w $2500
		dc.l $6A000000+Map_MTZPlats
		dc.w 1
		dc.w $6000
		dc.l $6B000000+Map_MTZPlats
		dc.w $701
		dc.w $6000
		dc.l $6D000000+Map_SpkBlk
		dc.w 0
		dc.w $241C
		dc.l $6E000000+Map_CirclePlat
		dc.w 0
		dc.w $6000
		dc.l $6E000000+Map_CirclePlat
		dc.w $1001
		dc.w $6000
		dc.l $6E000000+Map_CirclePlat
		dc.w $2002
		dc.w $6000
		dc.l $70000000+Map_CogTeeth
		dc.w $1000
		dc.w $E378
		dc.l $71000000+Map_LavaBubble
		dc.w $2205
		dc.w $4536
		dc.l $1C000000+Map_BoltEnd_Rope
		dc.w 0
		dc.w $43FD
		dc.l $1C000000+Map_BoltEnd_Rope
		dc.w $101
		dc.w $43FD
		dc.l $1C000000+Map_BoltEnd_Rope
		dc.w $302
		dc.w $23FD
		dc.l $65000000+Map_MTZPlats
		dc.w $B000
		dc.w $6000
		dc.l $9F000000+Map_Shelcrk
		dc.w $2400
		dc.w $31C
		dc.l $A4000000+Map_Ast
		dc.w $2E00
		dc.w $8368
		dc.l $A1000000+Map_Slice
		dc.w $2800
		dc.w $243C
		dc.l $31000000+Map_LTag
		dc.w 0
		dc.w $8680
		dc.l $31000000+Map_LTag
		dc.w $101
		dc.w $8680
		dc.l $31000000+Map_LTag
		dc.w $202
		dc.w $8680
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgWFZ_41EEC:	dc.w $20
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $8B000000+Map_PSwitch
		dc.w 0
		dc.w $6BC
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $B3000000+Map_Cloud
		dc.w $5E00
		dc.w $454F
		dc.l $B3000000+Map_Cloud
		dc.w $6001
		dc.w $454F
		dc.l $B3000000+Map_Cloud
		dc.w $6202
		dc.w $454F
		dc.l $B4000000+Map_VertProp
		dc.w $6400
		dc.w $A561
		dc.l $B5000000+Map_HorizProp
		dc.w $6600
		dc.w $A3CD
		dc.l $B5000000+Map_HorizProp
		dc.w $6800
		dc.w $A3CD
		dc.l $AD000000+Map_Clucker
		dc.w $420C
		dc.w $379
		dc.l $AE000000+Map_Clucker
		dc.w $440B
		dc.w $379
		dc.l $B6000000+Map_TiltPlat
		dc.w $6A00
		dc.w $A393
		dc.l $B6000000+Map_TiltPlat
		dc.w $6C00
		dc.w $A393
		dc.l $B6000000+Map_TiltPlat
		dc.w $6E00
		dc.w $A393
		dc.l $B6000000+Map_TiltPlat
		dc.w $7000
		dc.w $A393
		dc.l $B7000000+Map_VertLaser
		dc.w $7200
		dc.w $C39F
		dc.l $B8000000+Map_WallTurr
		dc.w $7400
		dc.w $3AB
		dc.l $B9000000+Map_HorizLaser
		dc.w $7600
		dc.w $C3C3
		dc.l $BA000000+Map_ConvPulley
		dc.w $7800
		dc.w $C3EA
		dc.l $BC000000+Map_ShipExh
		dc.w $7C00
		dc.w $4465
		dc.l $BD000000+Map_ConvPlat
		dc.w $7E00
		dc.w $E40E
		dc.l $BD000000+Map_ConvPlat
		dc.w $8000
		dc.w $E40E
		dc.l $BE000000+Map_GunPlat
		dc.w $8200
		dc.w $E41A
		dc.l $BF000000+Map_PropShaft
		dc.w $8400
		dc.w $E450
		dc.l $C0000000+Map_CPult
		dc.w $800
		dc.w $245C
		dc.l $C1000000+Map_BreakPlate
		dc.w $8800
		dc.w $E48C
		dc.l $C2000000+Map_Rivet
		dc.w $8A00
		dc.w $A461
		dc.l $19000000+Map_Plat2
		dc.w $3803
		dc.w $A46D
		dc.l $D9000000+Map_Ring
		dc.w 0
		dc.w $26BC
		dc.l $80000000+Map_Hook
		dc.w 0
		dc.w $23FE
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgHTZ_41FEE:	dc.w $1F
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $84000000+Map_PSwitch
		dc.w 0
		dc.w $6BC
		dc.l $84000000+Map_PSwitch
		dc.w $404
		dc.w $6BC
		dc.l $3000000+Map_PSwitch
		dc.w $901
		dc.w $26BC
		dc.l $18000000+Map_Plat_EHZ_HTZ
		dc.w $100
		dc.w $4000
		dc.l $18000000+Map_Plat_EHZ_HTZ
		dc.w $9A01
		dc.w $4000
		dc.l $36000000+Map_Spike
		dc.w 0
		dc.w $2434
		dc.l $14000000+Map_Seesaw
		dc.w 0
		dc.w $3C6
		dc.l $2D000000+Map_Barrier
		dc.w 0
		dc.w $2426
		dc.l $2F000000+Map_SmashGround
		dc.w 0
		dc.w $C000
		dc.l $20000000+Map_Fireball2
		dc.w $4402
		dc.w $8416
		dc.l $41000000+Map_RedSpring
		dc.w $8100
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $9003
		dc.w $470
		dc.l $41000000+Map_RedSpring
		dc.w $A006
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $3007
		dc.w $43C
		dc.l $41000000+Map_RedSpring
		dc.w $400A
		dc.w $43C
		dc.l $16000000+Map_Tram
		dc.w 0
		dc.w $43E6
		dc.l $1C000000+Map_Tram
		dc.w $403
		dc.w $43E6
		dc.l $1C000000+Map_Tram
		dc.w $504
		dc.w $43E6
		dc.l $1C000000+Map_TramStake
		dc.w $700
		dc.w $4000
		dc.l $1C000000+Map_TramStake
		dc.w $801
		dc.w $4000
		dc.l $32000000+Map_BreakRock
		dc.w 0
		dc.w $43B2
		dc.l $31000000+Map_LTag
		dc.w 0
		dc.w $8680
		dc.l $31000000+Map_LTag
		dc.w $101
		dc.w $8680
		dc.l $31000000+Map_LTag
		dc.w $202
		dc.w $8680
		dc.l $96000000+Map_Rex
		dc.w $E02
		dc.w $637E
		dc.l $92000000+Map_Spiker
		dc.w $A00
		dc.w 0
		dc.l $95000000+Map_Sol
		dc.w 0
		dc.w 0
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgOOZ_420E8:	dc.w $21
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $33000000+Map_BurnPlat
		dc.w $100
		dc.w $632C
		dc.l $43000000+Map_RailSpikes
		dc.w 0
		dc.w $C30C
		dc.l $19000000+Map_Plat2
		dc.w $2302
		dc.w $62F4
		dc.l $45000000+Map_PSpring
		dc.w $200
		dc.w $43C5
		dc.l $45000000+Map_PSpring
		dc.w $120A
		dc.w $43C5
		dc.l $46000000+Map_OOZBetaBall
		dc.w 1
		dc.w $6354
		dc.l $47000000+Map_But
		dc.w 2
		dc.w $424
		dc.l $15000000+Map_Swing_OOZ
		dc.w $8801
		dc.w $43E3
		dc.l $3D000000+Map_LaunchBlock
		dc.w 0
		dc.w $6332
		dc.l $48000000+Map_TransBall
		dc.w $8000
		dc.w $6368
		dc.l $48000000+Map_TransBall
		dc.w $8101
		dc.w $6368
		dc.l $48000000+Map_TransBall
		dc.w $8202
		dc.w $6368
		dc.l $48000000+Map_TransBall
		dc.w $8303
		dc.w $6368
		dc.l $1F000000+Map_CFlo_OOZ
		dc.w 0
		dc.w $639D
		dc.l $3F000000+Map_HorizFan
		dc.w 0
		dc.w $6403
		dc.l $3F000000+Map_VertFan
		dc.w $8000
		dc.w $6403
		dc.l $50000000+Map_Aquis
		dc.w 0
		dc.w $2500
		dc.l $4A000000+Map_Octus
		dc.w 0
		dc.w $2538
		dc.l $1C000000+Map_NarrowFallingOil
		dc.w $A00
		dc.w $4346
		dc.l $1C000000+Map_NarrowFallingOil
		dc.w $B01
		dc.w $4346
		dc.l $1C000000+Map_NarrowFallingOil
		dc.w $C02
		dc.w $4346
		dc.l $1C000000+Map_NarrowFallingOil
		dc.w $D03
		dc.w $4346
		dc.l $1C000000+Map_NarrowFallingOil
		dc.w $E04
		dc.w $4346
		dc.l $1C000000+Map_NarrowFallingOil
		dc.w $F05
		dc.w $4346
		dc.l $1C000000+Map_WideFallingOil
		dc.w $1000
		dc.w $4346
		dc.l $1C000000+Map_WideFallingOil
		dc.w $1101
		dc.w $4346
		dc.l $1C000000+Map_WideFallingOil
		dc.w $1202
		dc.w $4346
		dc.l $1C000000+Map_WideFallingOil
		dc.w $1303
		dc.w $4346
		dc.l $1C000000+Map_WideFallingOil
		dc.w $1404
		dc.w $4346
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgMCZ_421F2:	dc.w $18
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $15000000+Map_Swing_Track_CPZ_MCZ
		dc.w $4802
		dc.w 0
		dc.l $1F000000+Map_CFlo_MCZ
		dc.w 0
		dc.w $63F4
		dc.l $73000000+Map_MCZRotRings
		dc.w $F500
		dc.w $26BC
		dc.l $6A000000+Map_Crate
		dc.w $1800
		dc.w $63D4
		dc.l $2A000000+Map_Stomper
		dc.w 0
		dc.w $4000
		dc.l $36000000+Map_Spike
		dc.w 0
		dc.w $2434
		dc.l $36000000+Map_Spike
		dc.w $4004
		dc.w $242C
		dc.l $41000000+Map_RedSpring
		dc.w $8100
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $9003
		dc.w $470
		dc.l $40000000+Map_SprngBrd
		dc.w $100
		dc.w $440
		dc.l $74000000+Map_Invis
		dc.w $1100
		dc.w $8680
		dc.l $75000000+Map_BrckSpkChn
		dc.w $1802
		dc.w $2000
		dc.l $76000000+Map_SlidSpks
		dc.w 0
		dc.w 0
		dc.l $77000000+Map_DBridge
		dc.w $100
		dc.w $643C
		dc.l $7F000000+Map_VineSwitch
		dc.w 0
		dc.w $640E
		dc.l $80000000+Map_VinePulley
		dc.w 0
		dc.w $641E
		dc.l $81000000+Map_SBridge
		dc.w 1
		dc.w $643C
		dc.l $7A000000+Map_Swing_Track_CPZ_MCZ
		dc.w $1200
		dc.w 0
		dc.l $A3000000+Map_Flash
		dc.w $2C00
		dc.w $83A8
		dc.l $9E000000+Map_CrawlT
		dc.w $2200
		dc.w $23C0
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgCNZ_422B4:	dc.w $18
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $84000000+Map_PSwitch
		dc.w 0
		dc.w $6BC
		dc.l $84000000+Map_PSwitch
		dc.w $404
		dc.w $6BC
		dc.l $3000000+Map_PSwitch
		dc.w $901
		dc.w $26BC
		dc.l $3000000+Map_PSwitch
		dc.w $D05
		dc.w $26BC
		dc.l $44000000+Map_RoundBump
		dc.w 0
		dc.w $439A
		dc.l $85000000+Map_VertLauncher
		dc.w 0
		dc.w $422
		dc.l $85000000+Map_DiagLauncher
		dc.w $8100
		dc.w $402
		dc.l $86000000+Map_Flip
		dc.w 0
		dc.w $43B2
		dc.l $86000000+Map_Flip
		dc.w $104
		dc.w $43B2
		dc.l $D2000000+Map_Snake
		dc.w $100
		dc.w $437C
		dc.l $D3000000+Map_BombPenalty
		dc.w 0
		dc.w $380
		dc.l $D4000000+Map_LrgMovBlock
		dc.w 0
		dc.w $436C
		dc.l $D4000000+Map_LrgMovBlock
		dc.w $200
		dc.w $436C
		dc.l $D5000000+Map_Elevator
		dc.w $1800
		dc.w $4384
		dc.l $D6000000+Map_Cage
		dc.w $100
		dc.w $388
		dc.l $D7000000+Map_HexBump
		dc.w 0
		dc.w $4394
		dc.l $D8000000+Map_SauceBump
		dc.w 0
		dc.w $43E6
		dc.l $D8000000+Map_SauceBump
		dc.w $4001
		dc.w $43E6
		dc.l $D8000000+Map_SauceBump
		dc.w $8002
		dc.w $43E6
		dc.l $C8000000+Map_Crawl
		dc.w $AC00
		dc.w $8340
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgCPZ_42376:	dc.w $18
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $B000000+Map_obj0B
		dc.w $7000
		dc.w $E3B0
		dc.l $1B000000+Map_Bstr
		dc.w 0
		dc.w $E39C
		dc.l $1D000000+Map_BBalls
		dc.w $500
		dc.w $E43C
		dc.l $19000000+Map_Plat2
		dc.w $600
		dc.w $63A0
		dc.l $2D000000+Map_Barrier
		dc.w $202
		dc.w $2394
		dc.l $32000000+Map_SpinTubeBlock
		dc.w 0
		dc.w $6430
		dc.l $6B000000+Map_StairBlock
		dc.w $1000
		dc.w $6418
		dc.l $78000000+Map_StairBlock
		dc.w 0
		dc.w $6418
		dc.l $7A000000+Map_TrackPlat
		dc.w 0
		dc.w $E418
		dc.l $7B000000+Map_TubeLid
		dc.w $200
		dc.w $3E0
		dc.l $3000000+Map_PSwitch
		dc.w $901
		dc.w $26BC
		dc.l $3000000+Map_PSwitch
		dc.w $D05
		dc.w $26BC
		dc.l $36000000+Map_Spike
		dc.w 0
		dc.w $2434
		dc.l $41000000+Map_RedSpring
		dc.w $8100
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $9003
		dc.w $470
		dc.l $41000000+Map_RedSpring
		dc.w $A006
		dc.w $45C
		dc.l $40000000+Map_SprngBrd
		dc.w $100
		dc.w $440
		dc.l $A5000000+Map_Spiny
		dc.w $3200
		dc.w $252D
		dc.l $A6000000+Map_Spiny
		dc.w $3203
		dc.w $252D
		dc.l $A7000000+Map_Grab
		dc.w $3600
		dc.w $A500
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgARZ_42438:	dc.w $1D
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $79000000+Map_Starpost
		dc.w $100
		dc.w $47C
		dc.l $15000000+Map_ARZPlats
		dc.w $8802
		dc.w 0
		dc.l $18000000+Map_Plat_ARZ
		dc.w $100
		dc.w $4000
		dc.l $18000000+Map_Plat_ARZ
		dc.w $9A01
		dc.w $4000
		dc.l $22000000+Map_ArrowShoot
		dc.w 1
		dc.w $417
		dc.l $23000000+Map_FallPillar
		dc.w 0
		dc.w $2000
		dc.l $2B000000+Map_RisePillar
		dc.w 0
		dc.w $2000
		dc.l $2C000000+Map_LTag
		dc.w 0
		dc.w $8680
		dc.l $2C000000+Map_LTag
		dc.w $101
		dc.w $8680
		dc.l $2C000000+Map_LTag
		dc.w $202
		dc.w $8680
		dc.l $40000000+Map_SprngBrd
		dc.w $100
		dc.w $440
		dc.l $41000000+Map_RedSpring
		dc.w $8100
		dc.w $45C
		dc.l $41000000+Map_RedSpring
		dc.w $9003
		dc.w $470
		dc.l $41000000+Map_RedSpring
		dc.w $A006
		dc.w $45C
		dc.l $3000000+Map_PSwitch
		dc.w $901
		dc.w $26BC
		dc.l $36000000+Map_Spike
		dc.w 0
		dc.w $2434
		dc.l $2D000000+Map_Barrier
		dc.w $303
		dc.w $23F8
		dc.l $1F000000+Map_CFlo_ARZ
		dc.w 0
		dc.w $4000
		dc.l $82000000+Map_PillPlat
		dc.w $300
		dc.w 0
		dc.l $82000000+Map_PillPlat
		dc.w $1101
		dc.w 0
		dc.l $83000000+Map_ARZPlats
		dc.w $1001
		dc.w 0
		dc.l $24000000+Map_Bub_Player1
		dc.w $810E
		dc.w $855B
		dc.l $91000000+Map_Chop
		dc.w $800
		dc.w $253B
		dc.l $8C000000+Map_Whisp
		dc.w 0
		dc.w $A500
		dc.l $8D000000+Map_Ground
		dc.w $200
		dc.w $A509
		dc.l $8E000000+Map_Ground
		dc.w $200
		dc.w $A509
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680
DbgSCZ_42522:	dc.w $D
		dc.l $25000000+Map_Ring				; 0
		dc.w 0
		dc.w $26BC
		dc.l $26000000+Map_Monitor
		dc.w $800
		dc.w $680
		dc.l $8B000000+Map_PSwitch
		dc.w 0
		dc.w $6BC
		dc.l $B3000000+Map_Cloud
		dc.w $5E00
		dc.w $454F
		dc.l $B3000000+Map_Cloud
		dc.w $6001
		dc.w $454F
		dc.l $B3000000+Map_Cloud
		dc.w $6202
		dc.w $454F
		dc.l $B4000000+Map_VertProp
		dc.w $6400
		dc.w $A561
		dc.l $B5000000+Map_HorizProp
		dc.w $6600
		dc.w $A3CD
		dc.l $B5000000+Map_HorizProp
		dc.w $6800
		dc.w $A3CD
		dc.l $9A000000+Map_Turt
		dc.w $1600
		dc.w $38A
		dc.l $AC000000+Map_Balkiry
		dc.w $4000
		dc.w $565
		dc.l $99000000+Map_Neb
		dc.w $1200
		dc.w $A36E
		dc.l $3E000000+Map_Pri
		dc.w 0
		dc.w $2680

; ===========================================================================

    if RemoveJmpTos=0
JmpTo66_AdjustVRAM2P:
		jmp	(AdjustVRAM2P).l

		align 4
	endc

; ===========================================================================
; ---------------------------------------------------------------------------
; Level Headers

; This struct array tells the engine where to find all the art associated with
; a particular zone. Each zone gets three longwords, in which it stores three
; pointers (in the lower 24 bits) and three jump table indeces (in the upper eight
; bits). The assembled data looks something like this:

; aaBBBBBB
; ccDDDDDD
; eeFFFFFF

; aa = index for primary pattern load request list
; BBBBBB = pointer to level art
; cc = index for secondary pattern load request list
; DDDDDD = pointer to 16x16 block mappings
; ee = index for palette
; FFFFFF = pointer to 128x128 block mappings

; Nemesis refers to this as the "main level load block". However, that name implies
; that this is code (obviously, it isn't), or at least that it points to the level's
; collision, object and ring placement arrays (it only points to art...
; although the 128x128 mappings do affect the actual level layout and collision)
; ---------------------------------------------------------------------------

lhead:	macro plc1,plc2,palette,art,map16x16,map128x128
		dc.l (plc1<<24)+art
		dc.l (plc2<<24)+map16x16
		dc.l (palette<<24)|map128x128
		endm

; LevelArtPointers:
LevelHeaders:

		lhead id_PLC_EHZ1,		id_PLC_EHZ2,		id_Pal_EHZ,		Kos_EHZ,	BM16_EHZ,	BM128_EHZ ;   0 ; Emerald Hill
		lhead id_PLC_Miles1Up,	id_PLC_MilesLife,	id_Pal_EHZ2,	Kos_EHZ,	BM16_EHZ,	BM128_EHZ ;   1 ; Level 1; unused
		lhead id_PLC_Tails1Up,	id_PLC_TailsLife,	id_Pal_WZ,		Kos_EHZ,	BM16_EHZ,	BM128_EHZ ;   2 ; Level 2; unused
		lhead id_PLC_Unused1,	id_PLC_Unused2,		id_Pal_EHZ3,	Kos_EHZ,	BM16_EHZ,	BM128_EHZ ;   3 ; Level 3; unused
		lhead id_PLC_MTZ1,		id_PLC_MTZ2,		id_Pal_MTZ,		Kos_MTZ,	BM16_MTZ,	BM128_MTZ ;   4 ; Metropolis Acts 1 & 2
		lhead id_PLC_MTZ1,		id_PLC_MTZ2,		id_Pal_MTZ,		Kos_MTZ,	BM16_MTZ,	BM128_MTZ ;   5 ; Metropolis Act 3
		lhead id_PLC_WFZ1,		id_PLC_WFZ2,		id_Pal_WFZ,		Kos_SCZ,	BM16_WFZ,	BM128_WFZ ;   6 ; Wing Fortress
		lhead id_PLC_HTZ1,		id_PLC_HTZ2,		id_Pal_HTZ,		Kos_EHZ,	BM16_EHZ,	BM128_EHZ ;   7 ; Hill Top; art is patched later by LoadZoneTiles
		lhead id_PLC_HPZ1,		id_PLC_HPZ2,		id_Pal_HPZ,		Kos_HPZ,	BM16_HPZ,	BM128_HPZ ;   8 ; Hidden Palace; unused
		lhead id_PLC_Unused5,	id_PLC_Unused6,		id_Pal_EHZ4,	Kos_EHZ,	BM16_EHZ,	BM128_EHZ ;   9 ; Level 9; unused
		lhead id_PLC_OOZ1,		id_PLC_OOZ2,		id_Pal_OOZ,		Kos_OOZ,	BM16_OOZ,	BM128_OOZ ;  $A ; Oil Ocean
		lhead id_PLC_MCZ1,		id_PLC_MCZ2,		id_Pal_MCZ,		Kos_MCZ,	BM16_MCZ,	BM128_MCZ ;  $B ; Mystic Cave
		lhead id_PLC_CNZ1,		id_PLC_CNZ2,		id_Pal_CNZ,		Kos_CNZ,	BM16_CNZ,	BM128_CNZ ;  $C ; Casino Night
		lhead id_PLC_CPZ1,		id_PLC_CPZ2,		id_Pal_CPZ,		Kos_CPZ,	BM16_CPZ,	BM128_CPZ ;  $D ; Chemical Plant
		lhead id_PLC_DEZ1,		id_PLC_DEZ2,		id_Pal_DEZ,		Kos_CPZ,	BM16_CPZ,	BM128_CPZ ;  $E ; Death Egg;  art is patched later by LoadZoneTiles
		lhead id_PLC_ARZ1,		id_PLC_ARZ2,		id_Pal_ARZ,		Kos_ARZ,	BM16_ARZ,	BM128_ARZ ;  $F ; Aquatic Ruin
		lhead id_PLC_SCZ1,		id_PLC_SCZ2,		id_Pal_SCZ,		Kos_SCZ,	BM16_WFZ,	BM128_WFZ ; $10 ; Sky Chase

;---------------------------------------------------------------------------------------
; Macro to make PLC pointers and generate symbolic constants
; (modification of standard ptr macro)
;---------------------------------------------------------------------------------------

plcp:	macro plcaddress,altid,alias1,alias2

		nolist
		pusho
		opt	m-

		dc.\index_width \plcaddress-index_start		; make pointer

		ifarg \altid
			\prefix_id\\altid: equ ptr_id		; generate an alternate ID constant for duplicate pointers
		else
			\prefix_id\\plcaddress:	equ ptr_id	; generate ID constant
		endc

		ifarg \alias1
			\prefix_id\\alias1:	equ ptr_id	; make aliased ID constant
		endc

		ifarg \alias2
			\prefix_id\\alias2:	equ ptr_id	; make aliased ID constant
		endc
		ptr_id: = ptr_id+ptr_id_inc			; increment ptr_id

		popo
		list
		endm

PatternLoadCues:
		index offset(*)
		plcp 	PLC_Main				; 0
		plcp 	PLC_Main2				; 1
		plcp	PLC_Water				; 2
		plcp 	PLC_GameOver				; 3
		plcp 	PLC_EHZ1				; 4
		plcp 	PLC_EHZ2				; 5
		plcp 	PLC_Miles1Up				; 6
		plcp 	PLC_MilesLife				; 7
		plcp 	PLC_Tails1Up				; 8
		plcp	PLC_TailsLife				; 9
		plcp	PLC_MTZ1,PLC_Unused1			; 10 - unused, but referenced in LevelHeaders array
		plcp	PLC_MTZ1,PLC_Unused2			; 11 - unused, but referenced in LevelHeaders array
		plcp	PLC_MTZ1				; 12
		plcp	PLC_MTZ2				; 13
		plcp	PLC_WFZ1,PLC_Unused3			; 14 - unused, never referenced
		plcp	PLC_WFZ1,PLC_Unused4			; 15 - unused, never referenced
		plcp	PLC_WFZ1				; 16
		plcp	PLC_WFZ2				; 17
		plcp	PLC_HTZ1				; 18
		plcp	PLC_HTZ2				; 19
		plcp	PLC_HPZ1				; 20
		plcp	PLC_HPZ2				; 21
		plcp	PLC_OOZ1,PLC_Unused5			; 22 - unused, but referenced in LevelHeaders array
		plcp	PLC_OOZ1,PLC_Unused6			; 23 - unused, but referenced in LevelHeaders array
		plcp	PLC_OOZ1				; 24
		plcp	PLC_OOZ2				; 25
		plcp	PLC_MCZ1				; 26
		plcp	PLC_MCZ2				; 27
		plcp	PLC_CNZ1				; 28
		plcp	PLC_CNZ2				; 29
		plcp	PLC_CPZ1				; 30
		plcp	PLC_CPZ2				; 31
		plcp	PLC_DEZ1				; 32
		plcp	PLC_DEZ2				; 33
		plcp	PLC_ARZ1				; 34
		plcp	PLC_ARZ2				; 35
		plcp	PLC_SCZ1				; 36
		plcp	PLC_SCZ2				; 37
		plcp	PLC_ResultsSonic			; 38
		plcp	PLC_Signpost				; 39
		plcp	PLC_CPZBoss				; 40
		plcp	PLC_EHZBoss				; 41
		plcp	PLC_HTZBoss				; 42
		plcp	PLC_ARZBoss				; 43
		plcp	PLC_MCZBoss				; 44
		plcp	PLC_CNZBoss				; 45
		plcp	PLC_MTZBoss				; 46
		plcp	PLC_OOZBoss				; 47
		plcp	PLC_FieryExplosion			; 48
		plcp	PLC_DEZBoss				; 49
		plcp	PLC_EHZAnimals				; 50
		plcp	PLC_MCZAnimals				; 51
		plcp	PLC_WFZAnimals,,PLC_HTZAnimals,PLC_MTZAnimals ; 52, these zones share the same list
		plcp	PLC_DEZAnimals				; 53
		plcp	PLC_HPZAnimals				; 54
		plcp	PLC_OOZAnimals				; 55
		plcp	PLC_SCZAnimals				; 56
		plcp	PLC_CNZAnimals				; 57
		plcp	PLC_CPZAnimals				; 58
		plcp	PLC_ARZAnimals				; 59
		plcp	PLC_SpecialStage			; 60
		plcp	PLC_SpecialStageBombs			; 61
		plcp	PLC_WFZBoss				; 62
		plcp	PLC_Tornado				; 63
		plcp	PLC_Capsule				; 64
		plcp	PLC_Explosion				; 65
		plcp	PLC_ResultsTails			; 66

plcm:		macro gfx,vram,suffix
		dc.l gfx
		ifarg \vram
			plcm_vram: = \vram
		else
			plcm_vram: = last_vram
		endc
		last_vram: = plcm_vram+sizeof_\gfx
		dc.w plcm_vram
		ifarg \suffix
			tile_\gfx\_\suffix: equ plcm_vram/sizeof_cell
		else
			if ~def(tile_\gfx)
			tile_\gfx: equ plcm_vram/sizeof_cell
			endc
		endc
		endm

plcheader:	macro *
		\*: equ *
		plc_count\@: equ (sizeof_\*-2)/sizeof_plc
		dc.w plc_count\@-1
		endm

;---------------------------------------------------------------------------------------
; Pattern load cues - standard block 1
;---------------------------------------------------------------------------------------

PLC_Main:	plcheader
		plcm 	Nem_HUD,vram_HUD
		plcm 	Nem_Sonic_Life_Counter,vram_LifeCounter
		plcm	Nem_Ring,vram_Ring
		plcm	Nem_Numbers,vram_Numbers
		arraysize PLC_Main

;---------------------------------------------------------------------------------------
; Pattern load cues - standard block 2
;---------------------------------------------------------------------------------------

PLC_Main2:	plcheader
		plcm	Nem_Checkpoint,vram_Checkpoint
		plcm	Nem_Monitors,vram_Monitors
		plcm 	Nem_Shield, vram_Shield
		plcm	Nem_Invinciblity_Stars,vram_Invinciblity_Stars
		arraysize PLC_Main2

;---------------------------------------------------------------------------------------
; Pattern load cues - water level standard block
;---------------------------------------------------------------------------------------

PLC_Water:		plcheader
		plcm	Nem_Explosion,vram_Explosion
		plcm	Nem_SuperSonic_Stars,vram_SuperSonic_stars
		plcm	Nem_Bubbles,vram_Bubbles
		arraysize PLC_Water

;---------------------------------------------------------------------------------------
; Pattern load cue - Game/Time over
;---------------------------------------------------------------------------------------

PLC_GameOver:	plcheader
		plcm Nem_Game_Over,vram_Game_Over
		arraysize PLC_GameOver

;---------------------------------------------------------------------------------------
; Pattern load cues - Emerald Hill Primary
;---------------------------------------------------------------------------------------

PLC_EHZ1:		plcheader
		plcm	Nem_Waterfall,vram_Waterfall
		plcm	Nem_EHZBridge,vram_Bridge
		plcm	Nem_Fireball1,vram_Buzzer_Fireball,Buzzer ; loaded but never used
		plcm	Nem_Buzzer,vram_Buzzer
		plcm	Nem_Coconuts,vram_Coconuts
		plcm	Nem_Masher,vram_Masher
		arraysize PLC_EHZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Emerald Hill Secondary
;---------------------------------------------------------------------------------------

PLC_EHZ2:		plcheader
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_DignlSprng,vram_DignlSprng
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_EHZ2

;---------------------------------------------------------------------------------------
; Pattern load cue - Miles 1-UP patch
;---------------------------------------------------------------------------------------

PLC_Miles1Up:	plcheader
		plcm	Nem_MilesLife,vram_LifeCounter2
		arraysize PLC_Miles1Up

;---------------------------------------------------------------------------------------
; Pattern load cue - Miles life counter
;---------------------------------------------------------------------------------------

PLC_MilesLife:	plcheader
		plcm	Nem_MilesLife,vram_LifeCounter
		arraysize PLC_MilesLife

;---------------------------------------------------------------------------------------
; Pattern load cue - Tails 1-UP patch
;---------------------------------------------------------------------------------------

PLC_Tails1Up:	plcheader
		plcm	Nem_TailsLife,vram_LifeCounter2
		arraysize PLC_Tails1Up

;---------------------------------------------------------------------------------------
; Pattern load cue - Tails life counter
;---------------------------------------------------------------------------------------

PLC_TailsLife:	plcheader
		plcm	Nem_TailsLife,vram_LifeCounter
		arraysize PLC_TailsLife

;---------------------------------------------------------------------------------------
; Pattern load cues - Metropolis Primary
;---------------------------------------------------------------------------------------

PLC_MTZ1:		plcheader
		plcm	Nem_GiantCog,vram_GiantCog
		plcm	Nem_WheelIndent,vram_WheelIndent
		plcm	Nem_RopePlat,vram_RopePlat
		plcm	Nem_BoltEnd_Rope,vram_BoltEnd_Rope
		plcm	Nem_SteamSpring,vram_SteamSpring
		plcm	Nem_SpikeBlock,vram_SpikeBlock
		plcm	Nem_MTZSpike,vram_MTZSpike
		plcm	Nem_Shellcracker,vram_Shellcracker
		plcm	Nem_Asteron,vram_Asteron
		arraysize PLC_MTZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Metropolis Secondary
;---------------------------------------------------------------------------------------

PLC_MTZ2:		plcheader
		plcm	Nem_Button,vram_Button
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_Slicer,vram_Slicer
		plcm	 Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		plcm	Nem_Nut,vram_Nut
		plcm	Nem_LavaBubble,vram_LavaBubble
		plcm	Nem_Cog,vram_Cog
		plcm	Nem_TeleportFlash,vram_TeleportFlash
		arraysize PLC_MTZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Wing Fortress Primary
;---------------------------------------------------------------------------------------

PLC_WFZ1:		plcheader
		plcm	Nem_Tornado,vram_Tornado
		plcm	Nem_Clouds,vram_Clouds
		plcm	Nem_VertProp,vram_VertProp
		plcm	Nem_HorizProp,vram_HorizProp
		plcm	Nem_Balkiry,vram_Balkriy
		plcm	Nem_BreakPanels,vram_BreakPanels
		plcm	Nem_Clucker,vram_Clucker
		plcm	Nem_WFZTiltPlatforms,vram_WFZTiltPlatforms
		; Redundant entries.
		plcm	Nem_Tornado,vram_Tornado
		plcm	Nem_Clouds,vram_Clouds
		arraysize PLC_WFZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Wing Fortress Secondary
;---------------------------------------------------------------------------------------

PLC_WFZ2:	plcheader
		; Redundant: these first two are also loaded by the first cue.
		plcm	Nem_VertProp,vram_VertProp
		plcm	Nem_HorizProp,vram_HorizProp
		plcm	Nem_WFZVrtclLaser,vram_WFZVrtclLaser
		plcm	Nem_WFZWallTurret,vram_WFZWallTurret
		plcm	Nem_WFZHrzntlLaser,vram_WFZHrzntlLaser
		plcm	Nem_ConvPulley,vram_ConvPulley
		plcm	Nem_Hook,vram_Hook
		plcm	Nem_WFZThrust,vram_WFZThrust
		plcm	Nem_WFZBeltPlatform,vram_WFZBeltPlatform
		plcm	Nem_WFZGunPlatform,vram_WFZGunPlatform
		plcm	Nem_WFZUnusedBadnik,vram_WfzUnusedBadnik
		plcm	Nem_WFZLaunchCatapult,vram_WFZLaunchCatapult
		plcm	Nem_WFZSwitch,vram_WFZSwitch
		plcm	Nem_WFZFloatingPlatform,vram_WFZFloatingPlatform
		arraysize PLC_WFZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Hill Top Primary
;---------------------------------------------------------------------------------------
PLC_HTZ1:	plcheader
		plcm	Nem_Fireball1,vram_HTZFireball1
		plcm	Nem_HTZRock,vram_HTZRock
		plcm	Nem_SeeSaw,vram_SeeSaw
		plcm	Nem_Sol,vram_Sol
		plcm	Nem_Rexon,vram_Rexon
		plcm	Nem_Spiker,vram_Spiker
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_DignlSprng,vram_DignlSprng
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_HTZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Hill Top Secondary
;---------------------------------------------------------------------------------------
PLC_HTZ2:	plcheader
		plcm	Nem_Tram,vram_Tram
		plcm	Nem_HTZFireball2,vram_HTZFireball2
		plcm	Nem_HTZOneWayBarrier,vram_HTZOneWayBarrier
		arraysize PLC_HTZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Oil Ocean Primary (also pointed to by unused HPZ entries)
;---------------------------------------------------------------------------------------

PLC_HPZ1:
PLC_HPZ2:

PLC_OOZ1:	plcheader
		plcm	Nem_Burner,vram_Burner
		plcm	Nem_OOZElevator,vram_OOZElevator
		plcm	Nem_SlidingSpikes,vram_SlidingSpikes
		plcm	Nem_BurnerLid,vram_BurnerLid
		plcm	Nem_StripedBlocksVert,vram_StripedBlocksVert
		plcm	Nem_Oilfall,vram_Oilfall
		plcm	Nem_Oilfall2,vram_Oilfall2
		plcm	Nem_SpringBall,vram_SpringBall
		plcm	Nem_LaunchBall,vram_LaunchBall
		arraysize PLC_OOZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Oil Ocean Secondary
;---------------------------------------------------------------------------------------

PLC_OOZ2:	plcheader
		plcm	Nem_OOZPlatform,vram_OOZPlatform
		plcm	Nem_PushSpring,vram_PushSpring
		plcm	Nem_OOZSwingPlat,vram_OOZSwingPlat
		plcm	Nem_StripedBlocksHoriz,vram_StripedBlocksHoriz
		plcm	Nem_Fan,vram_Fan
		plcm	Nem_Button,vram_Button
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_DignlSprng,vram_DignlSprng
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		plcm	Nem_Aquis,vram_Aquis
		plcm	Nem_Octus,vram_Octus
		arraysize PLC_OOZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Mystic Cave Primary
;---------------------------------------------------------------------------------------

PLC_MCZ1:	plcheader
		plcm	Nem_Crate,vram_Crate
		plcm	Nem_MCZCollapsingPlat,vram_MCZCollapsingPlat
		plcm 	Nem_VineSwitch,vram_VineSwitch
		plcm	Nem_VinePulley,vram_VinePulley
		plcm 	Nem_Flasher,vram_Flasher
		plcm 	Nem_Crawlton,vram_Crawlton
		arraysize PLC_MCZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Mystic Cave Secondary
;---------------------------------------------------------------------------------------

PLC_MCZ2:	plcheader
		plcm	Nem_HorizSpike,vram_HorizSpike
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_DrawbridgeLogs,vram_DrawbridgeLogs
		plcm	Nem_LeverSpring,vram_LeverSpring
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_MCZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Casino Night Primary
;---------------------------------------------------------------------------------------

PLC_CNZ1:	plcheader
		plcm 	Nem_Crawl,vram_Crawl
		plcm	Nem_LargeMovingBlock,vram_LargeMovingBlock
		plcm	Nem_SnakePlats,vram_SnakePlats
		plcm	Nem_BombPenalty,vram_BombPenalty
		plcm	Nem_CNZElevator,vram_CNZElevator
		plcm	Nem_Cage,vram_Cage
		plcm	Nem_HexBumper,vram_HexBumper
		plcm	Nem_RoundBumper,vram_RoundBumper
		plcm 	Nem_Flipper,vram_Flipper
		plcm	Nem_SaucerBumper,vram_SaucerBumper
		arraysize PLC_CNZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Casino Night Secondary
;---------------------------------------------------------------------------------------

PLC_CNZ2:	plcheader
		plcm	Nem_DiagLauncher,vram_DiagLauncher
		plcm	Nem_VertLauncher,vram_VertLauncher
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_DignlSprng,vram_DignlSprng
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_CNZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Chemical Plant Primary
;---------------------------------------------------------------------------------------

PLC_CPZ1:	plcheader
		plcm	Nem_Pylon,vram_Pylon
		plcm	Nem_ConstructionStripes,vram_CPZConstructionStripes,CPZ
		plcm	Nem_Booster,vram_Booster
		plcm	Nem_CPZElevator,vram_CPZElevator
		plcm	Nem_CPZDumpingPipePlat,vram_CPZDumpingPipePlat
		plcm	Nem_TubeLid,vram_TubeLid
		plcm 	Nem_WaterSurface1,vram_WaterSurface
		plcm	Nem_StairBlock,vram_StairBlock
		plcm	Nem_CPZMetalBlock,vram_CPZMetalBlock
		arraysize PLC_CPZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Chemical Plant Secondary
;---------------------------------------------------------------------------------------

PLC_CPZ2:	plcheader
		plcm	Nem_Grabber,vram_Grabber
		plcm	Nem_Spiny,vram_Spiny
		plcm	Nem_Spikes,vram_Spikes
		plcm	Nem_Droplet,vram_Droplet
		plcm	Nem_LeverSpring,vram_LeverSpring
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_CPZ2

;---------------------------------------------------------------------------------------
; Pattern load cue - Death Egg Primary
;---------------------------------------------------------------------------------------

PLC_DEZ1:	plcheader
		plcm	Nem_ConstructionStripes,vram_DEZConstructionStripes,DEZ
		arraysize PLC_DEZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Death Egg Secondary
;---------------------------------------------------------------------------------------

PLC_DEZ2:	plcheader
		plcm 	Nem_MechaSonic,vram_MechaSonic
		plcm	Nem_DEZWindow,vram_DEZWindow
		plcm	Nem_RobotnikRunning,vram_RobotnikRunning
		plcm	Nem_RobotnikUpper,vram_RobotnikUpper
		plcm	Nem_RobotnikLower,vram_RobotnikLower
		arraysize PLC_DEZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Aquatic Ruin Primary
;---------------------------------------------------------------------------------------

PLC_ARZ1:	plcheader
		plcm 	Nem_ARZBarrier,vram_ARZBarrier
		plcm 	Nem_WaterSurface2,vram_WaterSurface
		plcm 	Nem_Leaves,vram_Leaves
		plcm	Nem_ArrowAndShooter,vram_ArrowAndShooter
		arraysize PLC_ARZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Aquatic Ruin Secondary
;---------------------------------------------------------------------------------------

PLC_ARZ2:	plcheader
		plcm	Nem_ChopChop,vram_ChopChop
		plcm	Nem_Whisp,vram_Whisp
		plcm	Nem_Grounder,vram_Grounder
		plcm	Nem_BubbleGenerator,vram_BubbleGenerator
		plcm	Nem_Spikes,vram_Spikes
		plcm 	Nem_LeverSpring,vram_LeverSpring
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_ARZ2

;---------------------------------------------------------------------------------------
; Pattern load cue - Sky Chase Primary
;---------------------------------------------------------------------------------------

PLC_SCZ1:	plcheader
		plcm	Nem_Tornado,vram_Tornado
		arraysize PLC_SCZ1

;---------------------------------------------------------------------------------------
; Pattern load cues - Sky Chase Secondary
;---------------------------------------------------------------------------------------

PLC_SCZ2:	plcheader
		plcm	Nem_Clouds,vram_Clouds
		plcm	Nem_VertProp,vram_VertProp
		plcm	Nem_HorizProp,vram_HorizProp
		plcm	Nem_Balkiry,vram_Balkriy
		plcm	Nem_Turtloid,vram_Turtloid
		plcm	Nem_Nebula,vram_Nebula
		arraysize PLC_SCZ2

;---------------------------------------------------------------------------------------
; Pattern load cues - Sonic end of level results screen
;---------------------------------------------------------------------------------------

PLC_ResultsSonic:	plcheader
		plcm	Nem_TitleCard,vram_TitleCard
		plcm	Nem_ResultsText,vram_ResultsText
		plcm 	Nem_MiniSonic,vram_MiniCharacter
		plcm 	Nem_Perfect,vram_Perfect
		arraysize PLC_ResultsSonic

;---------------------------------------------------------------------------------------
; Pattern load cue - End of	level signpost
;---------------------------------------------------------------------------------------

PLC_Signpost:	plcheader
		plcm	Nem_Signpost,vram_Signpost
		arraysize PLC_Signpost

;---------------------------------------------------------------------------------------
; Pattern load cues - Chemical Plant Boss
;---------------------------------------------------------------------------------------

PLC_CPZBoss:	plcheader
		plcm	Nem_Eggpod,vram_CPZEggpod,CPZ
		plcm	Nem_CPZBoss,vram_CPZBoss
		plcm	Nem_EggpodJets,vram_CPZEggpodJets,CPZ
		plcm	Nem_BossSmoke,vram_CPZBossSmoke,CPZ	; unused due to a bug in loc_2E9B6; see there for a fix
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_CPZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Emerald Hill Boss
;---------------------------------------------------------------------------------------

PLC_EHZBoss:	plcheader
		plcm	Nem_Eggpod,vram_EHZEggpod,EHZ
		plcm	Nem_EHZBoss,vram_EHZBoss
		plcm	Nem_EggChopperBlades,vram_EggChopperBlades
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_EHZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Hill Top Boss
;---------------------------------------------------------------------------------------

PLC_HTZBoss:	plcheader
		plcm	Nem_Eggpod,vram_HTZEggpod,HTZ
		plcm	Nem_HTZBoss,vram_HTZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		plcm	Nem_BossSmoke,vram_HTZBossSmoke,HTZ
		arraysize PLC_HTZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Aquatic Ruin Boss
;---------------------------------------------------------------------------------------

PLC_ARZBoss:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_ARZBoss,vram_ARZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_ARZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Mystic Cave Boss
;---------------------------------------------------------------------------------------

PLC_MCZBoss:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_MCZBoss,vram_MCZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_MCZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Casino Night Boss
;---------------------------------------------------------------------------------------

PLC_CNZBoss:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_CNZBoss,vram_CNZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_CNZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Metropolis Boss
;---------------------------------------------------------------------------------------

PLC_MTZBoss:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_MTZBoss,vram_MTZBoss
		plcm	Nem_EggpodJets,vram_MTZEggpodJets
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_MTZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Oil Ocean Boss
;---------------------------------------------------------------------------------------

PLC_OOZBoss:	plcheader
		plcm	Nem_OOZBoss,vram_OOZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_OOZBoss

;---------------------------------------------------------------------------------------
; Pattern load cue - Fiery Explosion
;---------------------------------------------------------------------------------------

PLC_FieryExplosion:	plcheader
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_FieryExplosion

;---------------------------------------------------------------------------------------
; Pattern load cue - Final Boss
;---------------------------------------------------------------------------------------

PLC_DEZBoss:	plcheader
		plcm	Nem_DEZBoss,vram_DEZBoss
		arraysize PLC_DEZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - EHZ Animals
;---------------------------------------------------------------------------------------

PLC_EHZAnimals:		plcheader
		plcm	Nem_Squirrel,vram_animal_1
		plcm	Nem_Flicky,vram_animal_2
		arraysize PLC_EHZAnimals

;---------------------------------------------------------------------------------------
;Pattern load cues - MCZ Animals
;---------------------------------------------------------------------------------------

PLC_MCZAnimals:		plcheader
		plcm	Nem_Mouse,vram_animal_1
		plcm	Nem_Chicken,vram_animal_2
		arraysize PLC_MCZAnimals

;---------------------------------------------------------------------------------------
;Pattern load cues - HTZ/MTZ/WFZ animals
;---------------------------------------------------------------------------------------

PLC_WFZAnimals:		plcheader
		plcm Nem_Beaver,vram_animal_1
		plcm Nem_Eagle,vram_animal_2
		arraysize PLC_WFZAnimals

;---------------------------------------------------------------------------------------
;Pattern load cues - DEZ Animals
;---------------------------------------------------------------------------------------

PLC_DEZAnimals:		plcheader
		plcm Nem_Pig,vram_animal_1
		plcm Nem_Chicken,vram_animal_2
		arraysize PLC_DEZAnimals

;---------------------------------------------------------------------------------------
;Pattern load cues - HPZ animals
;---------------------------------------------------------------------------------------

PLC_HPZAnimals:		plcheader
		plcm Nem_Mouse,vram_animal_1
		plcm Nem_Seal,vram_animal_2
		arraysize PLC_HPZAnimals

;---------------------------------------------------------------------------------------
;Pattern load cues - OOZ Animals
;---------------------------------------------------------------------------------------

PLC_OOZAnimals:		plcheader
		plcm Nem_Penguin,vram_animal_1
		plcm Nem_Seal,vram_animal_2
		arraysize PLC_OOZAnimals

;---------------------------------------------------------------------------------------
; Pattern load cues - SCZ Animals
;---------------------------------------------------------------------------------------

PLC_SCZAnimals:		plcheader
		plcm Nem_Turtle,vram_animal_1
		plcm Nem_Chicken,vram_animal_2
		arraysize PLC_SCZAnimals

;---------------------------------------------------------------------------------------
; Pattern load cues - CNZ Animals
;---------------------------------------------------------------------------------------

PLC_CNZAnimals:		plcheader
		plcm Nem_Bear,vram_animal_1
		plcm Nem_Flicky,vram_animal_2
		arraysize PLC_CNZAnimals

;---------------------------------------------------------------------------------------
; Pattern load cues - CPZ Animals
;---------------------------------------------------------------------------------------

PLC_CPZAnimals:		plcheader
		plcm Nem_Rabbit,vram_animal_1
		plcm Nem_Eagle,vram_animal_2
		arraysize PLC_CPZAnimals

;---------------------------------------------------------------------------------------
; Pattern load cues - ARZ Animals
;---------------------------------------------------------------------------------------

PLC_ARZAnimals:		plcheader
		plcm Nem_Penguin,vram_animal_1
		plcm Nem_Flicky,vram_animal_2
		arraysize PLC_ARZAnimals

;---------------------------------------------------------------------------------------
; Pattern load cues - Special Stage
;---------------------------------------------------------------------------------------

PLC_SpecialStage:	plcheader
		plcm	Nem_SpecialEmerald,vram_SpecialEmerald
		plcm	Nem_SpecialMessages,vram_SpecialMessages
		plcm	Nem_SpecialHUD,vram_SpecialHUD
		plcm	Nem_SpecialHorizShadow,vram_SpecialHorizShadow
		plcm	Nem_SpecialDiagShadow,vram_SpecialDiagShadow
		plcm	Nem_SpecialVertShadow,vram_SpecialVertShadow
		plcm	Nem_SpecialExplosion,vram_SpecialExplosion
		plcm	Nem_SpecialRings,vram_SpecialRings
		plcm	Nem_SpecialStart,vram_SpecialStart
		plcm	Nem_SpecialPlayerVSPlayer,vram_SpecialPlayerVSPlayer
		plcm	Nem_SpecialBack,vram_SpecialBack
		plcm	Nem_SpecialStars,vram_SpecialStars
		plcm	Nem_SpecialTailsText,vram_SpecialTailsText
		arraysize PLC_SpecialStage

;---------------------------------------------------------------------------------------
; Pattern load cue - Special Stage Bombs
;---------------------------------------------------------------------------------------

PLC_SpecialStageBombs:	plcheader
		plcm	Nem_SpecialBomb,vram_SpecialBomb
		arraysize PLC_SpecialStageBombs

;---------------------------------------------------------------------------------------
; Pattern load cues - WFZ Boss
;---------------------------------------------------------------------------------------

PLC_WFZBoss:	plcheader
		plcm	Nem_WFZBoss,vram_WFZBoss
		plcm	Nem_RobotnikRunning,vram_RobotnikRunning
		plcm	Nem_RobotnikUpper,vram_RobotnikUpper
		plcm	Nem_RobotnikLower,vram_RobotnikLower
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_WFZBoss

;---------------------------------------------------------------------------------------
; Pattern load cues - Tornado
;---------------------------------------------------------------------------------------

PLC_Tornado:	plcheader
		plcm	Nem_Tornado,vram_Tornado
		plcm	Nem_TornadoThruster,vram_TornadoThruster
		plcm	Nem_Clouds,vram_Clouds
		arraysize PLC_Tornado

;---------------------------------------------------------------------------------------
; Pattern load cue - Egg Prison
;---------------------------------------------------------------------------------------

PLC_Capsule:	plcheader
		plcm 	Nem_Capsule,vram_Capsule
		arraysize PLC_Capsule

;---------------------------------------------------------------------------------------
; Pattern load cue - Explosion
;---------------------------------------------------------------------------------------

PLC_Explosion:	plcheader
		plcm 	Nem_Explosion,vram_Explosion
		arraysize PLC_Explosion

;---------------------------------------------------------------------------------------
; Pattern load cue - Tails end of level results screen
;---------------------------------------------------------------------------------------

PLC_ResultsTails:	plcheader
		plcm	Nem_TitleCard,vram_TitleCard
		plcm 	Nem_ResultsText,vram_ResultsText
		plcm 	Nem_MiniTails,vram_MiniCharacter
		plcm	Nem_Perfect,vram_Perfect
		arraysize PLC_ResultsTails

;---------------------------------------------------------------------------------------
; Unused duplicates of some of the PLC lists found only in Revisions 0 and 2
; (possibly used as padding?)
;---------------------------------------------------------------------------------------

	if Revision=0
		; second half of PLC_ResultsTails
		plcm 	Nem_MiniTails,vram_MiniCharacter
		plcm	Nem_Perfect,vram_Perfect
		arraysize PLC_ResultsTails_dup

	elseif Revision=2
		; half of PLC_ARZ2 and everything from there to the end of the PLC lists!
		plcm	Nem_Grounder,vram_Grounder
		plcm	Nem_BubbleGenerator,vram_BubbleGenerator
		plcm	Nem_Spikes,vram_Spikes
		plcm 	Nem_LeverSpring,vram_LeverSpring
		plcm	Nem_VrtclSprng,vram_VrtclSprng
		plcm	Nem_HrzntlSprng,vram_HrzntlSprng
		arraysize PLC_ARZ2_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - Sky Chase Primary
;---------------------------------------------------------------------------------------

PLC_SCZ1_dup:	plcheader
		plcm	Nem_Tornado,vram_Tornado
		arraysize PLC_SCZ1_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Sky Chase Secondary
;---------------------------------------------------------------------------------------

PLC_SCZ2_dup:	plcheader
		plcm	Nem_Clouds,vram_Clouds
		plcm	Nem_VertProp,vram_VertProp
		plcm	Nem_HorizProp,vram_HorizProp
		plcm	Nem_Balkiry,vram_Balkriy
		plcm	Nem_Turtloid,vram_Turtloid
		plcm	Nem_Nebula,vram_Nebula
		arraysize PLC_SCZ2_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Sonic end of level results screen
;---------------------------------------------------------------------------------------

PLC_ResultsSonic_dup:	plcheader
		plcm	Nem_TitleCard,vram_TitleCard
		plcm	Nem_ResultsText,vram_ResultsText
		plcm 	Nem_MiniSonic,vram_MiniCharacter
		plcm 	Nem_Perfect,vram_Perfect
		arraysize PLC_ResultsSonic_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - End of	level signpost
;---------------------------------------------------------------------------------------

PLC_Signpost_dup:	plcheader
		plcm	Nem_Signpost,vram_Signpost
		arraysize PLC_Signpost_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Chemical Plant Boss
;---------------------------------------------------------------------------------------
PLC_CPZBoss_dup:	plcheader

		plcm	Nem_Eggpod,vram_CPZEggpod
		plcm	Nem_CPZBoss,vram_CPZBoss
		plcm	Nem_EggpodJets,vram_CPZEggpodJets
		plcm	Nem_BossSmoke,vram_CPZBossSmoke
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_CPZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Emerald Hill Boss
;---------------------------------------------------------------------------------------

PLC_EHZBoss_dup:	plcheader
		plcm	Nem_Eggpod,vram_EHZEggpod
		plcm	Nem_EHZBoss,vram_EHZBoss
		plcm	Nem_EggChopperBlades,vram_EggChopperBlades
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_EHZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Hill Top Boss
;---------------------------------------------------------------------------------------

PLC_HTZBoss_dup:	plcheader
		plcm	Nem_Eggpod,vram_HTZEggpod
		plcm	Nem_HTZBoss,vram_HTZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		plcm	Nem_BossSmoke,vram_HTZBossSmoke
		arraysize PLC_HTZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Aquatic Ruin Boss
;---------------------------------------------------------------------------------------

PLC_ARZBoss_dup:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_ARZBoss,vram_ARZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_ARZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Mystic Cave Boss
;---------------------------------------------------------------------------------------

PLC_MCZBoss_dup:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_MCZBoss,vram_MCZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_MCZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Casino Night Boss
;---------------------------------------------------------------------------------------

PLC_CNZBoss_dup:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_CNZBoss,vram_CNZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_CNZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Metropolis Boss
;---------------------------------------------------------------------------------------

PLC_MTZBoss_dup:	plcheader
		plcm	Nem_Eggpod,vram_Eggpod_common
		plcm	Nem_MTZBoss,vram_MTZBoss
		plcm	Nem_EggpodJets,vram_MTZEggpodJets
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_MTZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Oil Ocean Boss
;---------------------------------------------------------------------------------------

PLC_OOZBoss_dup:	plcheader
		plcm	Nem_OOZBoss,vram_OOZBoss
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_OOZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - Fiery Explosion
;---------------------------------------------------------------------------------------

PLC_FieryExplosion_dup:	plcheader
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_FieryExplosion_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - Final Boss
;---------------------------------------------------------------------------------------

PLC_DEZBoss_dup:	plcheader
		plcm	Nem_DEZBoss,vram_DEZBoss
		arraysize PLC_DEZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - EHZ Animals
;---------------------------------------------------------------------------------------

PLC_EHZAnimals_dup:		plcheader
		plcm	Nem_Squirrel,vram_animal_1
		plcm	Nem_Flicky,vram_animal_2
		arraysize PLC_EHZAnimals_dup

;---------------------------------------------------------------------------------------
;Pattern load cues (duplicate) - MCZ Animals
;---------------------------------------------------------------------------------------

PLC_MCZAnimals_dup:		plcheader
		plcm	Nem_Mouse,vram_animal_1
		plcm	Nem_Chicken,vram_animal_2
		arraysize PLC_MCZAnimals_dup

;---------------------------------------------------------------------------------------
;Pattern load cues (duplicate) - HTZ/MTZ/WFZ animals
;---------------------------------------------------------------------------------------

PLC_WFZAnimals_dup:		plcheader
		plcm Nem_Beaver,vram_animal_1
		plcm Nem_Eagle,vram_animal_2
		arraysize PLC_WFZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - DEZ Animals
;---------------------------------------------------------------------------------------

PLC_DEZAnimals_dup:		plcheader
		plcm Nem_Pig,vram_animal_1
		plcm Nem_Chicken,vram_animal_2
		arraysize PLC_DEZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - HPZ animals
;---------------------------------------------------------------------------------------

PLC_HPZAnimals_dup:		plcheader
		plcm Nem_Mouse,vram_animal_1
		plcm Nem_Seal,vram_animal_2
		arraysize PLC_HPZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - OOZ Animals
;---------------------------------------------------------------------------------------

PLC_OOZAnimals_dup:		plcheader
		plcm Nem_Penguin,vram_animal_1
		plcm Nem_Seal,vram_animal_2
		arraysize PLC_OOZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - SCZ Animals
;---------------------------------------------------------------------------------------

PLC_SCZAnimals_dup:		plcheader
		plcm Nem_Turtle,vram_animal_1
		plcm Nem_Chicken,vram_animal_2
		arraysize PLC_SCZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - CNZ Animals
;---------------------------------------------------------------------------------------

PLC_CNZAnimals_dup:		plcheader
		plcm Nem_Bear,vram_animal_1
		plcm Nem_Flicky,vram_animal_2
		arraysize PLC_CNZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - CPZ Animals
;---------------------------------------------------------------------------------------

PLC_CPZAnimals_dup:		plcheader
		plcm Nem_Rabbit,vram_animal_1
		plcm Nem_Eagle,vram_animal_2
		arraysize PLC_CPZAnimals_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - ARZ Animals
;---------------------------------------------------------------------------------------

PLC_ARZAnimals_dup:		plcheader
		plcm Nem_Penguin,vram_animal_1
		plcm Nem_Flicky,vram_animal_2
		arraysize PLC_ARZAnimals_dup

;---------------------------------------------------------------------------------------
;Pattern load cues (duplicate) - Special Stage
;---------------------------------------------------------------------------------------
PLC_SpecialStage_dup:	plcheader
		plcm	Nem_SpecialEmerald,vram_SpecialEmerald
		plcm	Nem_SpecialMessages,vram_SpecialMessages
		plcm	Nem_SpecialHUD,vram_SpecialHUD
		plcm	Nem_SpecialHorizShadow,vram_SpecialHorizShadow
		plcm	Nem_SpecialDiagShadow,vram_SpecialDiagShadow
		plcm	Nem_SpecialVertShadow,vram_SpecialVertShadow
		plcm	Nem_SpecialExplosion,vram_SpecialExplosion
		plcm	Nem_SpecialRings,vram_SpecialRings
		plcm	Nem_SpecialStart,vram_SpecialStart
		plcm	Nem_SpecialPlayerVSPlayer,vram_SpecialPlayerVSPlayer
		plcm	Nem_SpecialBack,vram_SpecialBack
		plcm	Nem_SpecialStars,vram_SpecialStars
		plcm	Nem_SpecialTailsText,vram_SpecialTailsText
		arraysize PLC_SpecialStage_dup

;---------------------------------------------------------------------------------------
;Pattern load cue (duplicate) - Special Stage Bombs
;---------------------------------------------------------------------------------------

PLC_SpecialStageBombs_dup:	plcheader
		plcm	Nem_SpecialBomb,vram_SpecialBomb
		arraysize PLC_SpecialStageBombs_dup

;---------------------------------------------------------------------------------------
;Pattern load cues (duplicate) - WFZ Boss
;---------------------------------------------------------------------------------------

PLC_WFZBoss_dup:	plcheader
		plcm	Nem_WFZBoss,vram_WFZBoss
		plcm	Nem_RobotnikRunning,vram_RobotnikRunning
		plcm	Nem_RobotnikUpper,vram_RobotnikUpper
		plcm	Nem_RobotnikLower,vram_RobotnikLower
		plcm	Nem_FieryExplosion,vram_FieryExplosion
		arraysize PLC_WFZBoss_dup

;---------------------------------------------------------------------------------------
; Pattern load cues (duplicate) - Tornado
;---------------------------------------------------------------------------------------

PLC_Tornado_dup:	plcheader
		plcm	Nem_Tornado,vram_Tornado
		plcm	Nem_TornadoThruster,vram_TornadoThruster
		plcm	Nem_Clouds,vram_Clouds
		arraysize PLC_Tornado_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - Egg Prison
;---------------------------------------------------------------------------------------

PLC_Capsule_dup:	plcheader
		plcm 	Nem_Capsule,vram_Capsule
		arraysize PLC_Capsule_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - Explosion
;---------------------------------------------------------------------------------------

PLC_Explosion_dup:	plcheader
		plcm 	Nem_Explosion,vram_Explosion
		arraysize PLC_Explosion_dup

;---------------------------------------------------------------------------------------
; Pattern load cue (duplicate) - Tails end of level results screen
;---------------------------------------------------------------------------------------

PLC_ResultsTails_dup:	plcheader
		plcm	Nem_TitleCard,vram_TitleCard
		plcm 	Nem_ResultsText,vram_ResultsText
		plcm 	Nem_MiniTails,vram_MiniCharacter
		plcm	Nem_Perfect,vram_Perfect
		arraysize PLC_ResultsTails_dup
	endc

;---------------------------------------------------------------------------------------
; Collision data
;---------------------------------------------------------------------------------------

		incfile AngleMap
		incfile CollArray1
		incfile CollArray2

;---------------------------------------------------------------------------------------
; 16x16 collision indices (Kosinski compression)
;---------------------------------------------------------------------------------------

		incfile	ColP_EHZHTZ
		incfile	ColS_EHZHTZ
		incfile	ColP_MTZ
;		incfile	ColP_HPZ
;		incfile	ColS_HPZ
		incfile	ColP_OOZ
		incfile	ColP_MCZ
		incfile	ColP_CNZ
		incfile	ColS_CNZ
		incfile	ColP_CPZDEZ
		incfile	ColS_CPZDEZ
		incfile	ColP_ARZ
		incfile	ColS_ARZ
		incfile	ColP_WFZSCZ
		incfile	ColS_WFZSCZ

;---------------------------------------------------------------------------------------
; Level layout pointers
; Two entries per act, pointing to the level layouts for acts 1 and 2 of each level
; respectively.
;---------------------------------------------------------------------------------------
LevelIndex:		index offset(*)

		ptr Level_EHZ1					; EHZ 1
		ptr Level_EHZ2					; EHZ 2
		ptr Level_EHZ1					; unused
		ptr Level_EHZ1					; unused
		ptr Level_EHZ1					; unused
		ptr Level_EHZ1					; unused
		ptr Level_EHZ1					; unused
		ptr Level_EHZ1					; unused
		ptr Level_MTZ1					; MTZ 1
		ptr Level_MTZ2					; MTZ 2
		ptr Level_MTZ3					; MTZ 3
		ptr Level_MTZ3					; unused
		ptr Level_WFZ					; WFZ
		ptr Level_WFZ					; unused
		ptr Level_HTZ1					; HTZ 1
		ptr Level_HTZ2					; HTZ 2
		ptr Level_OOZ1					; unused (HPZ 1)
		ptr Level_OOZ1					; unused (HPZ 2)
		ptr Level_EHZ1					; unused
		ptr Level_EHZ1					; unused
		ptr Level_OOZ1					; OOZ 1
		ptr Level_OOZ2					; OOZ 2
		ptr Level_MCZ1					; MCZ 1
		ptr Level_MCZ2					; MCZ 2
		ptr Level_CNZ1					; CNZ 1
		ptr Level_CNZ2					; CNZ 2
		ptr Level_CPZ1					; CPZ 1
		ptr Level_CPZ2					; CPZ 2
		ptr Level_DEZ					; DEZ
		ptr Level_DEZ					; unused
		ptr Level_ARZ1					; ARZ 1
		ptr Level_ARZ2					; ARZ 2
		ptr Level_SCZ					; SCZ
		ptr Level_SCZ					; unused

; ---------------------------------------------------------------------------
; Level	layouts (Kosinski Compression)
; ---------------------------------------------------------------------------

		incfile	Level_EHZ1
		incfile	Level_EHZ2
		incfile	Level_MTZ1
		incfile	Level_MTZ2
		incfile	Level_MTZ3
		incfile	Level_WFZ
		incfile	Level_HTZ1
		incfile	Level_HTZ2
		incfile	Level_OOZ1
		incfile	Level_OOZ2
		incfile	Level_MCZ1
		incfile	Level_MCZ2
		incfile	Level_CNZ1
		incfile	Level_CNZ2
		incfile	Level_CPZ1
		incfile	Level_CPZ2
		incfile	Level_DEZ
		incfile	Level_ARZ1
		incfile	Level_ARZ2
		incfile	Level_SCZ

;---------------------------------------------------------------------------------------
; Animated level art
;---------------------------------------------------------------------------------------

		incfile	Art_Flowers1				; ArtUnc_49714:
		incfile	Art_Flowers2				; ArtUnc_49794:
		incfile	Art_Flowers3				; ArtUnc_49814:
		incfile	Art_Flowers4				; ArtUnc_49894:
		incfile	Art_EHZPulseBall			; ArtUnc_49914:
		incfile	Nem_HTZCliffs				; ArtNem_49A14: ArtUnc_HTZCliffs:
		incfile	Art_HTZClouds				; ArtUnc_4A33E:
		incfile	Art_MTZCylinder				; ArtUnc_4A73E:
		incfile	Art_Lava				; ArtUnc_4B73E:
		incfile	Art_MTZAnimBack				; ArtUnc_4BD3E:
;		incfile Art_HPZPulseOrb
		incfile	Art_OOZPulseBall			; ArtUnc_4BF7E:
		incfile	Art_OOZSquareBall1			; ArtUnc_4C0FE:
		incfile	Art_OOZSquareBall2			; ArtUnc_4C2FE:
		incfile	Art_Oil1				; ArtUnc_4C4FE:
		incfile	Art_Oil2				; ArtUnc_4CCFE:
		incfile	Art_CNZFlipPanels			; ArtUnc_4D4FE:
		incfile	Art_CNZSlotPics				; ArtUnc_4EEFE:
		incfile	Art_CPZAnimBack				; ArtUnc_4FAFE:
		incfile	Art_Waterfall1				; ArtUnc_4FAFE:
		incfile	Art_Waterfall2
		incfile	Art_Waterfall3

;---------------------------------------------------------------------------------------
; Player art and mappings
;---------------------------------------------------------------------------------------

		align $20
		incfile	Art_Sonic				; ArtUnc_50000:

		align $20
		incfile	Art_Tails				; ArtUnc_64320:

		include	"mappings/sprite/Sonic.asm"		; MapUnc_6FBE0: SprTbl_Sonic: Map_Sonic:
		include	"mappings/spriteDPLC/Sonic.asm"		; MapRUnc_714E0:
		even

		incfile	Nem_Shield				; ArtNem_71D8E:
		incfile	Nem_Invinciblity_Stars			; ArtNem_71F14:
		incfile	Art_SplashAndDust			; ArtUnc_71FFC:
		incfile Nem_SuperSonic_Stars			; ArtNem_7393C:

		include	"mappings/sprite/Tails.asm"		; MapUnc_739E2: ; Map_Tails
		include	"mappings/spriteDPLC/Tails.asm"		; MapRUnc_7446C:
		even

;---------------------------------------------------------------------------------------
; Sega screen
;---------------------------------------------------------------------------------------

		incfile	Nem_SEGA				; ArtNem_74876:
		incfile Nem_IntroTrails				; ArtNem_74CF6:
		incfile Eni_SEGA				; MapEng_74D0E:

;---------------------------------------------------------------------------------------
; Title screen
;---------------------------------------------------------------------------------------

		incfile Eni_TitleScreen				; ArtNem_74DC6:
		incfile Eni_TitleBack				; MapEng_74E86:
		incfile	Eni_TitleLogo
		incfile Nem_Title				; ArtNem_74F6C:
		incfile	Nem_TitleSprites			; ArtNem_7667A:
		incfile	Nem_MenuJunk				; ArtNem_78CBC:

;---------------------------------------------------------------------------------------
; Global level objects and HUD
;---------------------------------------------------------------------------------------

		incfile	Nem_Button				; ArtNem_78DAC:
		incfile	Nem_VrtclSprng				; ArtNem_78E84:
		incfile	Nem_HrzntlSprng				; ArtNem_78FA0:
		incfile Nem_DignlSprng				; ArtNem_7906A:
		incfile	Nem_HUD					; ArtNem_7923E:
		incfile	Nem_Sonic_Life_Counter			; ArtNem_79346:
		incfile	Nem_Ring				; ArtNem_7945C:
		incfile	Nem_Monitors				; ArtNem_79550:
		incfile Nem_Spikes				; ArtNem_7995C:
		incfile	Nem_Numbers				; ArtNem_799AC:
		incfile	Nem_Checkpoint				; ArtNem_79A86:
		incfile Nem_Signpost				; ArtNem_79BDE:
		incfile	Art_Signpost				; ArtUnc_7A18A:	; Yep, it's in the ROM twice: once compressed and once uncompressed
		incfile	Nem_LeverSpring				; ArtNem_7AB4A:
		incfile	Nem_HorizSpike				; ArtNem_7AC9A:

		incfile	Nem_BubbleGenerator			; ArtNem_7AD16: ArtNem_BigBubbles:
		incfile	Nem_Bubbles				; ArtNem_7AEE2:
		incfile	Art_Countdown				; ArtUnc_7AF80:
		incfile	Nem_Game_Over				; ArtNem_7B400:
		incfile	Nem_Explosion				; ArtNem_7B592:
		incfile	Nem_MilesLife				; ArtNem_7B946:
		incfile	Nem_Capsule				; ArtNem_7BA32:
		incfile	Nem_ContinueTails			; ArtNem_7BDBE:
		incfile	Nem_MiniSonic				; ArtNem_7C0AA:
		incfile	Nem_TailsLife				; ArtNem_7C20C:
		incfile	Nem_MiniTails				; ArtNem_7C2F2:

;---------------------------------------------------------------------------------------
; Menu, stage result, and title cards
;---------------------------------------------------------------------------------------

		incfile	Nem_StandardFont			; ArtNem_7C43A:
		incfile	Nem_1P2PWins				; ArtNem_7C9AE:
		incfile	Eni_MenuBack				; MapEng_7CB80:
		incfile	Art_MenuBack				; ArtUnc_7CD2C:
		incfile	Nem_TitleCard				; ArtNem_7D22C:
		incfile	Nem_TitleCardFont			; ArtNem_7D58A:
		incfile	Nem_MenuBox				; ArtNem_7D990:
		incfile	Nem_LevelSelectPics			; ArtNem_7DA10:
		incfile	Nem_ResultsText				; ArtNem_7E86A:
		incfile	Nem_SpecialStageResults			; ArtNem_7EB58:
		incfile	Nem_Perfect				; ArtNem_7EEBE:

;---------------------------------------------------------------------------------------
; Small animals
;---------------------------------------------------------------------------------------

		incfile	Nem_Flicky				; ArtNem_7EF60: ; ArtNem_Bird:
		incfile	Nem_Squirrel				; ArtNem_7F0A2:
		incfile	Nem_Mouse				; ArtNem_7F206
		incfile	Nem_Chicken				; ArtNem_7F340:
		incfile	Nem_Beaver				; ArtNem_7F4A2:
		incfile	Nem_Eagle				; ArtNem_7F5E2:
		incfile	Nem_Pig					; ArtNem_7F710:
		incfile	Nem_Seal				; ArtNem_7F846:
		incfile	Nem_Penguin				; ArtNem_7F962:
		incfile	Nem_Turtle				; ArtNem_7FADE:
		incfile	Nem_Bear				; ArtNem_7FC90:
		incfile	Nem_Rabbit				; ArtNem_7FDD2:

;---------------------------------------------------------------------------------------
; WFZ objects
;---------------------------------------------------------------------------------------

		incfile	Nem_WFZSwitch				; ArtNem_7FF2A:
		incfile	Nem_BreakPanels				; ArtNem_7FF98:

;---------------------------------------------------------------------------------------
; OOZ objects
;---------------------------------------------------------------------------------------

		incfile	Nem_SlidingSpikes			; ArtNem_8007C:
		incfile	Nem_BurnerLid				; ArtNem_80274:
		incfile	Nem_StripedBlocksVert			; ArtNem_8030A:
		incfile	Nem_Oilfall				; ArtNem_80376:
		incfile	Nem_Oilfall2				; ArtNem_804F2:
		incfile	Nem_SpringBall				; ArtNem_805C0:
		incfile	Nem_LaunchBall				; ArtNem_806E0:
		incfile	Nem_OOZPlatform				; ArtNem_806E0:
		incfile	Nem_PushSpring				; ArtNem_80C64:
		incfile	Nem_OOZSwingPlat			; ArtNem_80E26:
		incfile	Nem_StripedBlocksHoriz			; ArtNem_81048:
		incfile	Nem_OOZElevator				; ArtNem_810B8:
		incfile	Nem_Fan					; ArtNem_81254:
		incfile	Nem_Burner				; ArtNem_81514:

;---------------------------------------------------------------------------------------
; CNZ objects
;---------------------------------------------------------------------------------------

		incfile	Nem_SnakePlats				; ArtNem_81600: ; ArtNem_CNZSnake:
		incfile	Nem_BombPenalty				; ArtNem_81668:
		incfile	Nem_LargeMovingBlock			; ArtNem_816C8:
		incfile	Nem_CNZElevator				; ArtNem_817B4:
		incfile	Nem_Cage				; ArtNem_81826:
		incfile	Nem_HexBumper				; ArtNem_81894:
		incfile	Nem_RoundBumper				; ArtNem_8191E:
		incfile	Nem_DiagLauncher			; ArtNem_81AB0:
		incfile	Nem_VertLauncher			; ArtNem_81C96:
		incfile	Nem_SaucerBumper			; ArtNem_81DCC: ; ArtNem_CNZMiniBumper
		incfile	Nem_Flipper				; ArtNem_81EF2:

;---------------------------------------------------------------------------------------
; CPZ object art
;---------------------------------------------------------------------------------------

		incfile	Nem_CPZElevator				; ArtNem_82216:
		incfile	Nem_WaterSurface1			; ArtNem_82364:
		incfile	Nem_Booster				; ArtNem_824D4:
		incfile	Nem_Droplet				; ArtNem_8253C:
		incfile	Nem_Pylon				; ArtNem_825AE:
		incfile	Nem_CPZMetalBlock			; ArtNem_827B8:
		incfile	Nem_ConstructionStripes			; ArtNem_827F8:
		incfile	Nem_CPZDumpingPipePlat			; ArtNem_82864: ; ArtNem_CPZAnimatedBits
		incfile	Nem_StairBlock				; ArtNem_82A46:
		incfile	Nem_TubeLid				; ArtNem_82C06:

;---------------------------------------------------------------------------------------
; ARZ objects
;---------------------------------------------------------------------------------------

		incfile	Nem_WaterSurface2			; ArtNem_82E02:
		incfile	Nem_Leaves				; ArtNem_82EE8:
		incfile	Nem_ArrowAndShooter			; ArtNem_82F74:
		incfile	Nem_ARZBarrier				; ArtNem_830D2: ; ArtNem_ARZBarrierThing

;---------------------------------------------------------------------------------------
; One EHZ badnik (why is it separate?)
;---------------------------------------------------------------------------------------

		incfile	Nem_Buzzer				; ArtNem_8316A:

;---------------------------------------------------------------------------------------
; OOZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Octus				; ArtNem_8336A:
		incfile	Nem_Aquis				; ArtNem_8368A:

;---------------------------------------------------------------------------------------
; Another EHZ badnik (why?)
;---------------------------------------------------------------------------------------

		incfile	Nem_Masher				; ArtNem_839EA:	ArtNem_Pirahna:

;---------------------------------------------------------------------------------------
; Bosses
;---------------------------------------------------------------------------------------

		incfile	Nem_Eggpod				; ArtNem_83BF6:
		incfile	Nem_CPZBoss				; ArtNem_84332:
		incfile	Nem_FieryExplosion			; ArtNem_84890:
		incfile	Nem_EggpodJets				; ArtNem_84F18:
		incfile	Nem_BossSmoke				; ArtNem_84F96:
		incfile	Nem_EHZBoss				; ArtNem_8507C:
		incfile	Nem_EggChopperBlades			; ArtNem_85868:  ; ArtNem_EggChoppers:
		incfile	Nem_HTZBoss				; ArtNem_8595C:
		incfile	Nem_ARZBoss				; ArtNem_86128:
		incfile	Nem_MCZBoss				; ArtNem_86B6E:
		incfile	Nem_CNZBoss				; ArtNem_87AAC:
		incfile	Nem_OOZBoss				; ArtNem_882D6:
		incfile	Nem_MTZBoss				; ArtNem_88DA6:
		incfile	Art_FallingRocks			; Art_FallingRocks:

;---------------------------------------------------------------------------------------
; ARZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Whisp				; ArtNem_895E4:
		incfile	Nem_Grounder				; ArtNem_8970E:
		incfile	Nem_ChopChop				; ArtNem_89B9A:
;---------------------------------------------------------------------------------------
; HTZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Rexon				;	ArtNem_89DEC: ArtNem_HtzRexxon:
		incfile	Nem_Spiker				;	ArtNem_89FAA:	ArtNem_HtzDriller:

;---------------------------------------------------------------------------------------
; SCZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Nebula				; ArtNem_8A142:
		incfile	Nem_Turtloid				; ArtNem_8A362:

;---------------------------------------------------------------------------------------
; ANOTHER EHZ badnik (WHY?)
;---------------------------------------------------------------------------------------

		incfile	Nem_Coconuts

;---------------------------------------------------------------------------------------
; MCZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Crawlton				; ArtNem_8AB36:
		incfile	Nem_Flasher				; ArtNem_8AC5E:

;---------------------------------------------------------------------------------------
; MTZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Slicer				; ArtNem_8AD80: ; ArtNem_MtzMantis
		incfile	Nem_Shellcracker			; ArtNem_8B058:
		incfile	Nem_Asteron				; ArtNem_8B300: ArtNem_MtzSupernova

;---------------------------------------------------------------------------------------
; CPZ badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Spiny				; ArtNem_8B430:
		incfile	Nem_Grabber				; ArtNem_8B6B4:

;---------------------------------------------------------------------------------------
; A haphazard mess of SCZ, WFZ, and DEZ objects and badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Clucker				; ArtNem_8B9DC:
		incfile	Nem_Balkiry				; ArtNem_8BC16:

		incfile	Nem_MechaSonic				; ArtNem_8BE12:
		incfile	Nem_Tornado				; ArtNem_8CC44:

		incfile	Nem_WFZWallTurret			; ArtNem_8D1A0:
		incfile	Nem_Hook				; ArtNem_8D388:
		incfile	Nem_WFZGunPlatform			; ArtNem_8D540:
		incfile	Nem_ConvPulley				; ArtNem_8D7D8:
		incfile	Nem_WFZFloatingPlatform
		incfile	Nem_WFZVrtclLaser			; ArtNem_8DA6E:
		incfile	Nem_Clouds				; ArtNem_8DAFC:
		incfile	Nem_WFZHrzntlLaser			; ArtNem_8DC42:
		incfile	Nem_WFZLaunchCatapult			; ArtNem_8DCA2:
		incfile	Nem_WFZBeltPlatform			; ArtNem_8DD0C:
		incfile	Nem_WFZUnusedBadnik			; ArtNem_8DDF6:
		incfile	Nem_VertProp				; ArtNem_8DEB8:
		incfile	Nem_HorizProp				; ArtNem_8DEE8:
		incfile	Nem_WFZTiltPlatforms			; ArtNem_8E010:
		incfile	Nem_WFZThrust				; ArtNem_8E0C4:
		incfile	Nem_WFZBoss

		incfile	Nem_RobotnikUpper
		incfile	Nem_RobotnikRunning
		incfile	Nem_RobotnikLower
		incfile	Nem_DEZWindow
		incfile	Nem_DEZBoss
		incfile	Nem_Crawl
		incfile	Nem_TornadoThruster

;---------------------------------------------------------------------------------------
; Ending
;---------------------------------------------------------------------------------------

		incfile	Eni_Ending1				; MapEng_906E0:
		incfile	Eni_Ending2				; MapEng_906F8:
		incfile	Eni_Ending3				; MapEng_90722:
		incfile	Eni_Ending4				; MapEng_9073C:
		incfile	Eni_EndingTailsPlane			; MapEng_9076E:
		incfile	Eni_EndingSonicPlane			; MapEng_907C0:


		rept 9
		incbin	"mappings/planes/Sonic 2 Ending Logo.eni" ; 9 unused duplicates of Eni_EndGameLogo (used as padding?)
		even
		endr


		incfile	Nem_EndingStills			; ArtNem_EndingPics:
		incfile	Nem_EndingFinalTornado			; ArtNem_EndingFinalTornado:
		incfile	Nem_EndingMiniTornado			; ArtNem_EndingMiniTornado:
		incfile	Nem_EndingSonic
		incfile	Nem_EndingSuperSonic			; ArtNem_EndingSuperSonic:
		incfile	Nem_EndingTails				; ArtNem_93F3C:
		incfile	Nem_EndingLogo				; ArtNem_94B28:

; ----------------------------------------------------------------------------------
; Level art and block mappings
; ----------------------------------------------------------------------------------

		incfile	BM16_EHZ
		incfile	Kos_EHZ
		incfile	BM16_HTZ
		incfile	Kos_HTZ
		incfile	BM128_EHZ

		incfile	BM16_MTZ
		incfile	Kos_MTZ
		incfile	BM128_MTZ

;		incfile	BM16_HPZ
;		incfile	Kos_HPZ
;		incfile	BM128_HPZ

BM16_HPZ:							; While HPZ's graphics and mappings were removed, labels that reference them
Kos_HPZ:							; remain, which now point to OOZ's 16x16 mappings data instead.
BM128_HPZ:

		incfile	BM16_OOZ
		incfile	Kos_OOZ
		incfile	BM128_OOZ

		incfile	BM16_MCZ
		incfile	Kos_MCZ
		incfile	BM128_MCZ

		incfile	BM16_CNZ
		incfile	Kos_CNZ
		incfile	BM128_CNZ

		incfile	BM16_CPZ
		incfile	Kos_CPZ
		incfile	BM128_CPZ

		incfile	BM16_ARZ				; See warning in File Definitions.asm
		incfile	Kos_ARZ
		incfile	BM128_ARZ

		incfile	BM16_WFZ
		incfile	Kos_SCZ
		incfile	Kos_WFZ
		incfile	BM128_WFZ

; ----------------------------------------------------------------------------------
; Special Stage track mappings
; ----------------------------------------------------------------------------------

; End curve right, slope up, slope down, begin curve right
MapSpec_Rise1:		incbin	"mappings/special stage/Slope Up 1.bin"
MapSpec_Rise2:		incbin	"mappings/special stage/Slope Up 2.bin"
MapSpec_Rise3:		incbin	"mappings/special stage/Slope Up 3.bin"
MapSpec_Rise4:		incbin	"mappings/special stage/Slope Up 4.bin"
MapSpec_Rise5:		incbin	"mappings/special stage/Slope Up 5.bin"
MapSpec_Rise6:		incbin	"mappings/special stage/Slope Up 6.bin"
MapSpec_Rise7:		incbin	"mappings/special stage/Slope Up 7.bin"
MapSpec_Rise8:		incbin	"mappings/special stage/Slope Up 8.bin"
MapSpec_Rise9:		incbin	"mappings/special stage/Slope Up 9.bin"
MapSpec_Rise10:		incbin	"mappings/special stage/Slope Up 10.bin"
MapSpec_Rise11:		incbin	"mappings/special stage/Slope Up 11.bin"
MapSpec_Rise12:		incbin	"mappings/special stage/Slope Up 12.bin"
MapSpec_Rise13:		incbin	"mappings/special stage/Slope Up 13.bin"
MapSpec_Rise14:		incbin	"mappings/special stage/Slope Up 14.bin"
MapSpec_Rise15:		incbin	"mappings/special stage/Slope Up 15.bin"
MapSpec_Rise16:		incbin	"mappings/special stage/Slope Up 16.bin"
MapSpec_Rise17:		incbin	"mappings/special stage/Slope Up 17.bin"

; Straight path
MapSpec_Straight1:	incbin	"mappings/special stage/Straight Path 1.bin"
MapSpec_Straight2:	incbin	"mappings/special stage/Straight Path 2.bin"
MapSpec_Straight3:	incbin	"mappings/special stage/Straight Path 3.bin"
MapSpec_Straight4:	incbin	"mappings/special stage/Straight Path 4.bin"

; Exit curve & slope down
MapSpec_Drop1:		incbin	"mappings/special stage/Slope Down 1.bin"
MapSpec_Drop2:		incbin	"mappings/special stage/Slope Down 2.bin"
MapSpec_Drop3:		incbin	"mappings/special stage/Slope Down 3.bin"
MapSpec_Drop4:		incbin	"mappings/special stage/Slope Down 4.bin"
MapSpec_Drop5:		incbin	"mappings/special stage/Slope Down 5.bin"
MapSpec_Drop6:		incbin	"mappings/special stage/Slope Down 6.bin"
MapSpec_Drop7:		incbin	"mappings/special stage/Slope Down 7.bin"
MapSpec_Drop8:		incbin	"mappings/special stage/Slope Down 8.bin"
MapSpec_Drop9:		incbin	"mappings/special stage/Slope Down 9.bin"
MapSpec_Drop10:		incbin	"mappings/special stage/Slope Down 10.bin"
MapSpec_Drop11:		incbin	"mappings/special stage/Slope Down 11.bin"
MapSpec_Drop12:		incbin	"mappings/special stage/Slope Down 12.bin"
MapSpec_Drop13:		incbin	"mappings/special stage/Slope Down 13.bin"
MapSpec_Drop14:		incbin	"mappings/special stage/Slope Down 14.bin"
MapSpec_Drop15:		incbin	"mappings/special stage/Slope Down 15.bin"
MapSpec_Drop16:		incbin	"mappings/special stage/Slope Down 16.bin"
MapSpec_Drop17:		incbin	"mappings/special stage/Slope Down 17.bin"

; Curve
MapSpec_Turning1:	incbin	"mappings/special stage/Curve 1.bin"
MapSpec_Turning2:	incbin	"mappings/special stage/Curve 2.bin"
MapSpec_Turning3:	incbin	"mappings/special stage/Curve 3.bin"
MapSpec_Turning4:	incbin	"mappings/special stage/Curve 4.bin"
MapSpec_Turning5:	incbin	"mappings/special stage/Curve 5.bin"
MapSpec_Turning6:	incbin	"mappings/special stage/Curve 6.bin"

; Exit curve
MapSpec_Unturn1:	incbin "mappings/special stage/Exit Curve 1.bin"
MapSpec_Unturn2:	incbin "mappings/special stage/Exit Curve 2.bin"
MapSpec_Unturn3:	incbin "mappings/special stage/Exit Curve 3.bin"
MapSpec_Unturn4:	incbin "mappings/special stage/Exit Curve 4.bin"
MapSpec_Unturn5:	incbin "mappings/special stage/Exit Curve 5.bin"

; Begin curve right
MapSpec_Turn1:		incbin "mappings/special stage/Curve Right 1.bin"
MapSpec_Turn2:		incbin "mappings/special stage/Curve Right 2.bin"
MapSpec_Turn3:		incbin "mappings/special stage/Curve Right 3.bin"
MapSpec_Turn4:		incbin "mappings/special stage/Curve Right 4.bin"
MapSpec_Turn5:		incbin "mappings/special stage/Curve Right 5.bin"
MapSpec_Turn6:		incbin "mappings/special stage/Curve Right 6.bin"
MapSpec_Turn7:		incbin "mappings/special stage/Curve Right 7.bin"

; ----------------------------------------------------------------------------------
; Special Stage graphics, plane mappings, and layout data
; ----------------------------------------------------------------------------------

		incfile	Kos_Special				; Koz_DCA38
		incfile	Nem_SpecialBack				; ArtNem_DCD68:
		incfile	Eni_SpecialBack				; MapEng_SpecialBack: ; MapEng_DD1DE:
		incfile	Eni_SpecialBackBottom			; MapEng_DD30C:
		incfile	Nem_SpecialHUD				; ArtNem_DD48A:
		incfile	Nem_SpecialStart			; ArtNem_DD790:
		incfile	Nem_SpecialStars			; ArtNem_DD8CE:
		incfile	Nem_SpecialPlayerVSPlayer		; ArtNem_DD9C8:
		incfile	Nem_SpecialRings			; ArtNem_DDA7E:
		incfile	Nem_SpecialHorizShadow			; ArtNem_DDFA4: ; ArtNem_SpecialFlatShadow
		incfile	Nem_SpecialDiagShadow			; ArtNem_DE05A:
		incfile	Nem_SpecialVertShadow			; ArtNem_DE120: ; ArtNem_SpecialSideShadow
		incfile	Nem_SpecialExplosion			; ArtNem_DE188:
		incfile	Nem_SpecialBomb				; ArtNem_DE4BC:
		incfile	Nem_SpecialEmerald			; ArtNem_DE8AC:
		incfile	Nem_SpecialMessages			; ArtNem_DEAF4:
		incfile	Nem_SpecialSonicAndTails		; Nem_DEEAE
		incfile	Nem_SpecialTailsText			; ArtNem_E247E:
		incfile	Kos_SpecialPerspective			; MiscKoz_SpecialPerspective:
		incfile	Nem_SpecialLevelLayouts
		incfile	Koz_SpecialObjectLocations		; MiscKoz_SpecialObjectLocations:

		align $100					; (unnecessary; could be replaced with "even")

; --------------------------------------------------------------------------------------
; Ring position index
; --------------------------------------------------------------------------------------

levringnull:	macros
		dc.w $FFFF

RingPos_Index:	index offset(*)

		ptr Rings_EHZ_1					; 0
		ptr Rings_EHZ_2					; 1
		ptr Rings_Lev1_1				; 2
		ptr Rings_Lev1_2				; 3
		ptr Rings_Lev2_1				; 4
		ptr Rings_Lev2_2				; 5
		ptr Rings_Lev3_1				; 6
		ptr Rings_Lev3_2				; 7
		ptr Rings_MTZ_1					; 8
		ptr Rings_MTZ_2					; 9
		ptr Rings_MTZ_3					; 10
		ptr Rings_MTZ_4					; 11
		ptr Rings_WFZ_1					; 12
		ptr Rings_WFZ_2					; 13
		ptr Rings_HTZ_1					; 14
		ptr Rings_HTZ_2					; 15
		ptr Rings_HPZ_1					; 16
		ptr Rings_HPZ_2					; 17
		ptr Rings_Lev9_1				; 18
		ptr Rings_Lev9_2				; 19
		ptr Rings_OOZ_1					; 20
		ptr Rings_OOZ_2					; 21
		ptr Rings_MCZ_1					; 22
		ptr Rings_MCZ_2					; 23
		ptr Rings_CNZ_1					; 24
		ptr Rings_CNZ_2					; 25
		ptr Rings_CPZ_1					; 26
		ptr Rings_CPZ_2					; 27
		ptr Rings_DEZ_1					; 28
		ptr Rings_DEZ_2					; 29
		ptr Rings_ARZ_1					; 30
		ptr Rings_ARZ_2					; 31
		ptr Rings_SCZ_1					; 32
		ptr Rings_SCZ_2					; 33

Rings_EHZ_1:	incbin	"level/rings/EHZ 1.bin"
Rings_EHZ_2:	incbin	"level/rings/EHZ 2.bin"
Rings_Lev1_1:	levringnull					; null
Rings_Lev1_2:	levringnull					; null
Rings_Lev2_1:	levringnull					; null
Rings_Lev2_2:	levringnull					; null
Rings_Lev3_1:	levringnull					; null
Rings_Lev3_2:	levringnull					; null
Rings_MTZ_1:	incbin	"level/rings/MTZ 1.bin"
Rings_MTZ_2:	incbin	"level/rings/MTZ 2.bin"
Rings_MTZ_3:	incbin	"level/rings/MTZ 3.bin"
Rings_MTZ_4:	levringnull					; null
Rings_HTZ_1:	incbin	"level/rings/HTZ 1.bin"
Rings_HTZ_2:	incbin	"level/rings/HTZ 2.bin"
Rings_HPZ_1:	incbin	"level/rings/HPZ 1.bin"
Rings_HPZ_2:	levringnull					; null
Rings_Lev9_1:	levringnull					; null
Rings_Lev9_2:	levringnull					; null
Rings_OOZ_1:	incbin	"level/rings/OOZ 1.bin"
Rings_OOZ_2:	incbin	"level/rings/OOZ 2.bin"
Rings_MCZ_1:	incbin	"level/rings/MCZ 1.bin"
Rings_MCZ_2:	incbin	"level/rings/MCZ 2.bin"
Rings_CNZ_1:	incbin	"level/rings/CNZ 1.bin"
Rings_CNZ_2:	incbin	"level/rings/CNZ 2.bin"
Rings_CPZ_1:	incbin	"level/rings/CPZ 1.bin"
Rings_CPZ_2:	incbin	"level/rings/CPZ 2.bin"
Rings_DEZ_1:	levringnull					; null
Rings_DEZ_2:	levringnull					; null
Rings_WFZ_1:	incbin	"level/rings/WFZ 1.bin"
Rings_WFZ_2:	incbin	"level/rings/WFZ 2.bin"
Rings_ARZ_1:	incbin	"level/rings/ARZ 1.bin"
Rings_ARZ_2:	incbin	"level/rings/ARZ 2.bin"
Rings_SCZ_1:	incbin	"level/rings/SCZ 1.bin"
Rings_SCZ_2:	levringnull					; null

		align $200					; (unnecessary; could be replaced with "even")

; --------------------------------------------------------------------------------------
; Object position index
; --------------------------------------------------------------------------------------

ObjPos_Index:	index offset(*)

		ptr ObjPos_EHZ_1				;	0
		ptr ObjPos_EHZ_2				;	1
		ptr ObjPos_Null					;	2
		ptr ObjPos_Null					;	3
		ptr ObjPos_Null					;	4
		ptr ObjPos_Null					;	5
		ptr ObjPos_Null					;	6
		ptr ObjPos_Null					;	7
		ptr ObjPos_MTZ_1				;	8
		ptr ObjPos_MTZ_2				;	9
		ptr ObjPos_MTZ_3				;	10
		ptr ObjPos_MTZ_3				;	11
		ptr ObjPos_WFZ_1				;	12
		ptr ObjPos_WFZ_2				;	13
		ptr ObjPos_HTZ_1				;	14
		ptr ObjPos_HTZ_2				;	15
		ptr ObjPos_HPZ_1				;	16
		ptr ObjPos_HPZ_2				;	17
		ptr ObjPos_Null					;	18
		ptr ObjPos_Null					;	19
		ptr ObjPos_OOZ_1				;	20
		ptr ObjPos_OOZ_2				;	21
		ptr ObjPos_MCZ_1				;	22
		ptr ObjPos_MCZ_2				;	23
		ptr ObjPos_CNZ_1				;	24
		ptr ObjPos_CNZ_2				;	25
		ptr ObjPos_CPZ_1				;	26
		ptr ObjPos_CPZ_2				;	27
		ptr ObjPos_DEZ_1				;	28
		ptr ObjPos_DEZ_2				;	29
		ptr ObjPos_ARZ_1				;	30
		ptr ObjPos_ARZ_2				;	31
		ptr ObjPos_SCZ_1				;	32
		ptr ObjPos_SCZ_2				;	33

		endobj

		include "level/objects/EHZ_1.asm"

	if Revision=0
		include "level/objects/EHZ_2_(REV00).asm"
	else
		; fixes a pair of incorrectly placed plane switchers
		include	"level/objects/EHZ_2.asm"
	endc

		include	"level/objects/MTZ_1.asm"
		include	"level/objects/MTZ_2.asm"
		include	"level/objects/MTZ_3.asm"

	if Revision=0
		; all starposts are misconfigured: none of them have the 'remember state' flag set
		include	"level/objects/WFZ_1_(REV00).asm"
	else
		include	"level/objects/WFZ_1.asm"
	endc

ObjPos_WFZ_2:
		endobj
		include	"level/objects/HTZ_1.asm"
		include	"level/objects/HTZ_2.asm"
		include	"level/objects/HPZ_1.asm"
ObjPos_HPZ_2:	;include	"level/objects/HPZ_2.asm"
		endobj
		endobj

		include	"level/objects/OOZ_1.asm"
		include	"level/objects/OOZ_2.asm"
		include	"level/objects/MCZ_1.asm"
		include	"level/objects/MCZ_2.asm"

	if Revision=0
		; the signposts are too low, causing them to poke out the bottom of the ground
		include	"level/objects/CNZ_1_(REV00).asm"
		include	"level/objects/CNZ_2_(REV00).asm"
	else
		include	"level/objects/CNZ_1.asm"
		include	"level/objects/CNZ_2.asm"
	endc

		include	"level/objects/CPZ_1.asm"
		include	"level/objects/CPZ_2.asm"
		include	"level/objects/DEZ_1.asm"

ObjPos_DEZ_2:
		endobj

		include	"level/objects/ARZ_1.asm"
		include	"level/objects/ARZ_2.asm"
		include	"level/objects/SCZ_1.asm"

ObjPos_SCZ_2:
		endobj

ObjPos_Null:
		endobj
		endobj
		endobj
		endobj
ObjPos_End:

		align $1000					; (unnecessary; could be replaced with "even")

; ---------------------------------------------------------------------------
; Subroutine to load the sound driver
; This routine is a LOT more cautious than it really needs to be.
; ---------------------------------------------------------------------------

SoundDriverLoad:
		move	sr,-(sp)
		pushr.l	d0-a6
		disable_ints
		lea	(z80_bus_request).l,a3
		lea	(z80_reset).l,a2
		moveq	#0,d2
		move.w	#$100,d1
		move.w	d1,(a3)					; stop the Z80
		move.w	d1,(a2)					; ensure Z80 reset is not asserted

	.waitforZ80:
		btst	d2,(a3)
		bne.s	.waitforZ80

		jsr	DecompressSoundDriver(pc)		; could be bsr.s
		btst	#video_mode_bit,(vdp_control_port+1).l	; check video mode (why do it this way?)
		sne	(z80_ram+f_pal).l			; set if PAL
		move.w	d2,(a2)					; assert Z80 reset
		move.w	d2,(a3)					; start the Z80
		moveq_	$E6,d0					; $FFE6

	.wait:
		dbf	d0,.wait				; wait for 2,314 cycles to reset the YM2612/3438 (pointless, as they are reset on both cold boot and soft reset by the behavior of the ZRES line)
		move.w	d1,(a2)					; release Z80 reset
		popr.l	d0-a6
		move	(sp)+,sr
		rts
; ===========================================================================

DecompressSoundDriver:
		lea	SoundDriver(pc),a6
	; WARNING: you must edit MergeCode if you rename this label
	movewZ80CompSize:
		move.w	#Z80_space,d7				; size of compressed data; patched if necessary by SndDriverCompress.exe
		moveq	#0,d6					; make the decompressor fetch the first byte of descriptor bits
		lea	(z80_ram).l,a5
		moveq	#0,d5
		lea	(z80_ram).l,a4

; ---------------------------------------------------------------------------
; Saxman Decompression algorithm
; Requires size of compressed data as input in d7

; input:
;	d7.w = size of compressed data
; 	a4 = destination address (used for dictionary matches)
;	a5 = destination address
;	a6 = source address

;	uses d0,w, d3.w, d4.w, d5.w, d6.w, d7.w, a5, a6

; See http://www.segaretro.org/Saxman_compression for format description
; ---------------------------------------------------------------------------

SaxDec:
		lsr.w	#1,d6					; shift to next descriptor bit (if we've run out, bit 8 will be zero)
		btst	#8,d6					; have we run out of bits?
		bne.s	.bitsremaining				; branch if not
		jsr	SaxDec_GetByte(pc)			; get next byte of descriptor bits
		move.b	d0,d6
		ori.w	#$FF00,d6				; set all bits of high byte; when these are fully shifted into low byte, it's time to get another byte of descriptor bits

	.bitsremaining:
		btst	#0,d6					; is the next byte compressed?
		beq.s	SaxDec_ReadCompressed			; branch if so

	;read_uncompressed:
		jsr	SaxDec_GetByte(pc)			; get uncompressed byte
		move.b	d0,(a5)+				; write to destination
		addq.w	#1,d5					; increment relative pointer to destination
		bra.w	SaxDec
; ===========================================================================

SaxDec_ReadCompressed:
		jsr	SaxDec_GetByte(pc)			; get low byte of target address of match
		moveq	#0,d4
		move.b	d0,d4
		jsr	SaxDec_GetByte(pc)			; get high byte of target address and length of match
		move.b	d0,d3
		andi.w	#$F,d3
		addq.w	#2,d3					; d3 = length of the match minus 1
		andi.w	#$F0,d0
		lsl.w	#4,d0
		add.w	d0,d4					; combine high and low nybbles of target address
		addi.w	#$12,d4
		andi.w	#$FFF,d4				; d4 = offset into the current $1000 byte window of decompressed data
		move.w	d5,d0					; get relative pointer to destination
		andi.w	#$F000,d0
		add.w	d0,d4					; add offset in d4
		cmp.w	d4,d5					; is result greater than offset in d5?
		bcc.s	SaxDec_IsMatch				; if not, d4 is index to the match
		subi.w	#$1000,d4				; else, subtract $1000
		bcc.s	SaxDec_IsMatch				; if result is negative, this is a zero-fill match, otherwise d4 is index to match

;is_zeros:
		add.w	d3,d5					; add length of zero-fill match to offset pointer (d3+1)
		addq.w	#1,d5

	.fillzeros:
		move.b	#0,(a5)+				; write zeros for length of match
		dbf	d3,.fillzeros

		bra.w	SaxDec
; ===========================================================================

SaxDec_IsMatch:
		add.w	d3,d5					; add length of match to offset pointer (d3 + 1)
		addq.w	#1,d5

	.loop:
		move.b	(a4,d4.w),(a5)+				; copy matched byte
		addq.w	#1,d4					; increment index
		dbf	d3,.loop				; repeat for length of match

		bra.w	SaxDec
; ===========================================================================

SaxDec_GetByte:
		move.b	(a6)+,d0				; get next byte in compressed data
		subq.w	#1,d7					; decrement remaining number of bytes
		bne.s	.exit					; branch if bytes remain
		addq.w	#4,sp					; if here, we are done; exit the decompressor

	.exit:
		rts
; ===========================================================================

SoundDriver:
		pushs						; save current section info

Z80_Code:	section	org(0),file("sound/Sound Driver.unc"),over(Main) ; new section for the sound driver
		cpu Z80

		include "sound/Sound Driver.asm"		; include the actual Z80 sound driver code

		cpu 68000
		pops						; return to main section...
		pushs						; ...and save section info again

MergeCode: section org(0), file("sound/MergeData.dat"),over(Main) ; make data file for S2 Sound Driver Compress
		dc.l offset(SoundDriver),Z80_Space,offset(movewZ80CompSize)+2 ; start location of compressed sound driver; space reserved for sound driver; location to patch in the Saxman decompressor
		pops						; return to main section for good
		ds.b Z80_Space					; reserve space for the compressed sound driver
		even

; ---------------------------------------------------------------------------
; DAC samples
; ---------------------------------------------------------------------------

		align_to_end	sizeof_DAC_samples		; replaces cnop -$2F00,$8000

; Macro to include DAC samples, and generate bank pointer constants
; for them.
incdac:	macro name
		filename: equs file_\name			; get file name
		zbankptr_DAC_\name:	equ	z_rom_window+(offset(*)&7FFFh) ; make pointer constant
	DAC_\name:	incbin	"\filename"			; write file to ROM

		endm

DAC_Start: bnkswtch_vals

		incdac	Kick
		incdac	Snare
		incdac	Timpani
		incdac	Tom
		incdac	Clap
		incdac	Scratch
		incdac	Bongo

; ------------------------------------------------------------------------------
; One music track
; ------------------------------------------------------------------------------

MusicPoint1:		startbank
		sndbank_ptr	MusFile_Continue

MusFile_Continue:		incbin	"sound/music/compressed/Continue.sax"
		finishbank
		align $20

;---------------------------------------------------------------------------------------
; EHZ & HTZ objects/badniks
;---------------------------------------------------------------------------------------

		incfile	Nem_Fireball1
		incfile	Nem_Waterfall
		incfile	Nem_HTZFireball2
		incfile	Nem_EHZBridge
		incfile	Nem_Tram
		incfile	Nem_HTZOneWayBarrier			;ArtNem_HtzValveBarrier:
		incfile	Nem_SeeSaw
		incfile	Nem_UnusedFireball
		incfile	Nem_HTZRock
		incfile	Nem_Sol					; ArtNem_HtzSol:

;---------------------------------------------------------------------------------------
; MTZ objects
;---------------------------------------------------------------------------------------

		incfile	Nem_GiantCog
		incfile	Nem_WheelIndent
		incfile	Nem_SpikeBlock
		incfile	Nem_SteamSpring
		incfile	Nem_MTZSpike
		incfile	Nem_Nut
		incfile	Nem_LavaBubble
		incfile	Nem_RopePlat
		incfile	Nem_BoltEnd_Rope
		incfile	Nem_Cog
		incfile	Nem_TeleportFlash

;---------------------------------------------------------------------------------------
; MCZ objects
;---------------------------------------------------------------------------------------

		incfile	Nem_Crate
		incfile	Nem_MCZCollapsingPlat			; ArtNem_F1ABA:
		incfile	Nem_VineSwitch				; ArtNem_F1C64:
		incfile	Nem_VinePulley				; ArtNem_F1D5C:
		incfile	Nem_DrawbridgeLogs

; -------------------------------------------------------------------------------
; Sega Sound
; 8-bit	unsigned PCM at 16Khz
; -------------------------------------------------------------------------------

		align_to_end	sizeof_SegaPCM			; replaces cnop -$6714,$8000
SegaPCM:	bnkswtch_vals
		incbin	"sound/PCM/SEGA.pcm"

; ------------------------------------------------------------------------------
; Music
; ------------------------------------------------------------------------------

MusicPoint2:		startbank
		sndbank_ptr	MusFile_CNZ_2P
		sndbank_ptr	MusFile_EHZ
		sndbank_ptr	MusFile_MTZ
		sndbank_ptr	MusFile_CNZ
		sndbank_ptr	MusFile_MCZ
		sndbank_ptr	MusFile_MCZ_2P
		sndbank_ptr	MusFile_ARZ
		sndbank_ptr	MusFile_DEZ
		sndbank_ptr	MusFile_SpecialStage
		sndbank_ptr	MusFile_Options
		sndbank_ptr	MusFile_Ending
		sndbank_ptr	MusFile_FinalBoss
		sndbank_ptr	MusFile_CPZ
		sndbank_ptr	MusFile_Boss
		sndbank_ptr	MusFile_SCZ
		sndbank_ptr	MusFile_OOZ
		sndbank_ptr	MusFile_WFZ
		sndbank_ptr	MusFile_EHZ_2P
		sndbank_ptr	MusFile_2PResults
		sndbank_ptr	MusFile_SuperSonic
		sndbank_ptr	MusFile_HTZ
		sndbank_ptr	MusFile_ExtraLife
		sndbank_ptr	MusFile_Title
		sndbank_ptr	MusFile_EndLevel
		sndbank_ptr	MusFile_GameOver
		sndbank_ptr	MusFile_Invincible
		sndbank_ptr	MusFile_Emerald
		sndbank_ptr	MusFile_HPZ
		sndbank_ptr	MusFile_Drowning
		sndbank_ptr	MusFile_Credits

MusFile_HPZ:			incbin	"sound/music/compressed/HPZ.sax"
MusFile_Drowning:		incbin	"sound/music/compressed/Drowning.sax"
MusFile_Invincible:		incbin	"sound/music/compressed/Invincible.sax"
MusFile_CNZ_2P:			incbin	"sound/music/compressed/CNZ2P.sax"
MusFile_EHZ:			incbin	"sound/music/compressed/EHZ.sax"
MusFile_MTZ:			incbin	"sound/music/compressed/MTZ.sax"
MusFile_CNZ:			incbin	"sound/music/compressed/CNZ.sax"
MusFile_MCZ:			incbin	"sound/music/compressed/MCZ.sax"
MusFile_MCZ_2P:			incbin	"sound/music/compressed/MCZ2P.sax"
MusFile_ARZ:			incbin	"sound/music/compressed/ARZ.sax"
MusFile_DEZ:			incbin	"sound/music/compressed/DEZ.sax"
MusFile_SpecialStage:	incbin	"sound/music/compressed/SpecialStage.sax"
MusFile_Options:		incbin	"sound/music/compressed/Options.sax"
MusFile_Ending:			incbin	"sound/music/compressed/Ending.sax"
MusFile_FinalBoss:		incbin	"sound/music/compressed/FinalBoss.sax"
MusFile_CPZ:			incbin	"sound/music/compressed/CPZ.sax"
MusFile_Boss:			incbin	"sound/music/compressed/Boss.sax"
MusFile_SCZ:			incbin	"sound/music/compressed/SCZ.sax"
MusFile_OOZ:			incbin	"sound/music/compressed/OOZ.sax"
MusFile_WFZ:			incbin	"sound/music/compressed/WFZ.sax"
MusFile_EHZ_2P:			incbin	"sound/music/compressed/EHZ2P.sax"
MusFile_2PResults:		incbin	"sound/music/compressed/2PResult.sax"
MusFile_SuperSonic:		incbin	"sound/music/compressed/SuperSonic.sax"
MusFile_HTZ:			incbin	"sound/music/compressed/HTZ.sax"
MusFile_Title:			incbin	"sound/music/compressed/TitleScreen.sax"
MusFile_EndLevel:		incbin	"sound/music/compressed/EndLevel.sax"

MusFile_ExtraLife:		include	"sound/music/ExtraLife.asm"
MusFile_GameOver:		include	"sound/music/GameOver.asm"
MusFile_Emerald:		include	"sound/music/GotEmerald.asm"
MusFile_Credits:		include	"sound/music/Credits.asm"


; ------------------------------------------------------------------------------------------
; Sound	effects
; ------------------------------------------------------------------------------------------

SFXPointers:	macro	name
		sndbank_ptr	SFXFile_\name
		endm

SoundIndex:		bnkswtch_vals
		SFXFiles	SFXPointers			; generate little endian pointers and constants for SFX

IncludeSFX:	macro	name
SFXFile_\name:	include	"sound/sfx/\name\.asm"
		endm

		SFXFiles	IncludeSFX			; generate includes for the SFX files

		finishbank
		align $FFFFF

ROM_End:
		end
